


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > POJOPropertyBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind.introspect</a>
</div>

<h1>Coverage Summary for Class: POJOPropertyBuilder (com.fasterxml.jackson.databind.introspect)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">POJOPropertyBuilder</td>
<td class="coverageStat">
  <span class="percent">
    97.2%
  </span>
  <span class="absValue">
    (69/71)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91%
  </span>
  <span class="absValue">
    (352/387)
  </span>
</td>
</tr>
  <tr>
    <td class="name">POJOPropertyBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$Linked</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.6%
  </span>
  <span class="absValue">
    (38/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$MemberIterator</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">POJOPropertyBuilder$WithMember</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.1%
  </span>
  <span class="absValue">
    (99/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.9%
  </span>
  <span class="absValue">
    (419/466)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind.introspect;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.JsonInclude;
&nbsp;import com.fasterxml.jackson.annotation.JsonProperty;
&nbsp;import com.fasterxml.jackson.databind.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.MapperConfig;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;
&nbsp;/**
&nbsp; * Helper class used for aggregating information about a single
&nbsp; * potential POJO property.
&nbsp; */
&nbsp;public class POJOPropertyBuilder
&nbsp;    extends BeanPropertyDefinition
&nbsp;    implements Comparable&lt;POJOPropertyBuilder&gt;
&nbsp;{
&nbsp;    /**
&nbsp;     * Whether property is being composed for serialization
&nbsp;     * (true) or deserialization (false)
&nbsp;     */
&nbsp;    protected final boolean _forSerialization;
&nbsp;
&nbsp;    protected final MapperConfig&lt;?&gt; _config;
&nbsp;
&nbsp;    protected final AnnotationIntrospector _annotationIntrospector;
&nbsp;
&nbsp;    /**
&nbsp;     * External name of logical property; may change with
&nbsp;     * renaming (by new instance being constructed using
&nbsp;     * a new name)
&nbsp;     */
&nbsp;    protected final PropertyName _name;
&nbsp;
&nbsp;    /**
&nbsp;     * Original internal name, derived from accessor, of this
&nbsp;     * property. Will not be changed by renaming.
&nbsp;     */
&nbsp;    protected final PropertyName _internalName;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedField&gt; _fields;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedParameter&gt; _ctorParameters;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedMethod&gt; _getters;
&nbsp;
&nbsp;    protected Linked&lt;AnnotatedMethod&gt; _setters;
&nbsp;
&nbsp;    public POJOPropertyBuilder(MapperConfig&lt;?&gt; config, AnnotationIntrospector ai,
&nbsp;            boolean forSerialization, PropertyName internalName) {
<b class="fc">&nbsp;        this(config, ai, forSerialization, internalName, internalName);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected POJOPropertyBuilder(MapperConfig&lt;?&gt; config, AnnotationIntrospector ai,
&nbsp;            boolean forSerialization, PropertyName internalName, PropertyName name)
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        _config = config;</b>
<b class="fc">&nbsp;        _annotationIntrospector = ai;</b>
<b class="fc">&nbsp;        _internalName = internalName;</b>
<b class="fc">&nbsp;        _name = name;</b>
<b class="fc">&nbsp;        _forSerialization = forSerialization;</b>
&nbsp;    }
&nbsp;
&nbsp;    public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)
<b class="fc">&nbsp;    {</b>
<b class="fc">&nbsp;        _config = src._config;</b>
<b class="fc">&nbsp;        _annotationIntrospector = src._annotationIntrospector;</b>
<b class="fc">&nbsp;        _internalName = src._internalName;</b>
<b class="fc">&nbsp;        _name = newName;</b>
<b class="fc">&nbsp;        _fields = src._fields;</b>
<b class="fc">&nbsp;        _ctorParameters = src._ctorParameters;</b>
<b class="fc">&nbsp;        _getters = src._getters;</b>
<b class="fc">&nbsp;        _setters = src._setters;</b>
<b class="fc">&nbsp;        _forSerialization = src._forSerialization;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Fluent factory methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public POJOPropertyBuilder withName(PropertyName newName) {
<b class="fc">&nbsp;        return new POJOPropertyBuilder(this, newName);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public POJOPropertyBuilder withSimpleName(String newSimpleName)
&nbsp;    {
<b class="fc">&nbsp;        PropertyName newName = _name.withSimpleName(newSimpleName);</b>
<b class="fc">&nbsp;        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Comparable implementation: sort alphabetically, except
&nbsp;    /* that properties with constructor parameters sorted
&nbsp;    /* before other properties
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public int compareTo(POJOPropertyBuilder other)
&nbsp;    {
&nbsp;        // first, if one has ctor params, that should come first:
<b class="nc">&nbsp;        if (_ctorParameters != null) {</b>
<b class="nc">&nbsp;            if (other._ctorParameters == null) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (other._ctorParameters != null) {</b>
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
&nbsp;        /* otherwise sort by external name (including sorting of
&nbsp;         * ctor parameters)
&nbsp;         */
<b class="nc">&nbsp;        return getName().compareTo(other.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* BeanPropertyDefinition implementation, name/type
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public String getName() {
<b class="fc">&nbsp;        return (_name == null) ? null : _name.getSimpleName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PropertyName getFullName() {
<b class="fc">&nbsp;        return _name;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasName(PropertyName name) {
<b class="fc">&nbsp;        return _name.equals(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
<b class="fc">&nbsp;    public String getInternalName() { return _internalName.getSimpleName(); }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public PropertyName getWrapperName() {
&nbsp;        /* 13-Mar-2013, tatu: Accessing via primary member SHOULD work,
&nbsp;         *   due to annotation merging. However, I have seen some problems
&nbsp;         *   with this access (for other annotations)... so if this should
&nbsp;         *   occur, try commenting out full traversal code
&nbsp;         */
<b class="fc">&nbsp;        AnnotatedMember member = getPrimaryMember();</b>
<b class="fc">&nbsp;        return (member == null || _annotationIntrospector == null) ? null</b>
<b class="fc">&nbsp;                : _annotationIntrospector.findWrapperName(member);</b>
&nbsp;    	/*
&nbsp;        return fromMemberAnnotations(new WithMember&lt;PropertyName&gt;() {
&nbsp;            @Override
&nbsp;            public PropertyName withMember(AnnotatedMember member) {
&nbsp;                return _annotationIntrospector.findWrapperName(member);
&nbsp;            }
&nbsp;        });
&nbsp;        */
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isExplicitlyIncluded() {
<b class="fc">&nbsp;        return _anyExplicits(_fields)</b>
<b class="fc">&nbsp;                || _anyExplicits(_getters)</b>
<b class="fc">&nbsp;                || _anyExplicits(_setters)</b>
&nbsp;                // 16-Jan-2016, tatu: Creator names are special, in that name should exist too;
&nbsp;                //   reason for this is [databind#1317]. Let&#39;s hope this works well, may need
&nbsp;                //   to tweak further if this lowers visibility
&nbsp;//                || _anyExplicits(_ctorParameters)
<b class="fc">&nbsp;                || _anyExplicitNames(_ctorParameters)</b>
&nbsp;                ;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isExplicitlyNamed() {
<b class="fc">&nbsp;        return _anyExplicitNames(_fields)</b>
<b class="fc">&nbsp;                || _anyExplicitNames(_getters)</b>
<b class="fc">&nbsp;                || _anyExplicitNames(_setters)</b>
<b class="fc">&nbsp;                || _anyExplicitNames(_ctorParameters)</b>
&nbsp;                ;
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* BeanPropertyDefinition implementation, accessor access
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
<b class="fc">&nbsp;    public boolean hasGetter() { return _getters != null; }</b>
&nbsp;
&nbsp;    @Override
<b class="fc">&nbsp;    public boolean hasSetter() { return _setters != null; }</b>
&nbsp;
&nbsp;    @Override
<b class="fc">&nbsp;    public boolean hasField() { return _fields != null; }</b>
&nbsp;
&nbsp;    @Override
<b class="fc">&nbsp;    public boolean hasConstructorParameter() { return _ctorParameters != null; }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean couldDeserialize() {
<b class="fc">&nbsp;        return (_ctorParameters != null) || (_setters != null) || (_fields != null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean couldSerialize() {
<b class="fc">&nbsp;        return (_getters != null) || (_fields != null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMethod getGetter()
&nbsp;    {
&nbsp;        // Easy with zero or one getters...
<b class="fc">&nbsp;        Linked&lt;AnnotatedMethod&gt; curr = _getters;</b>
<b class="fc">&nbsp;        if (curr == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        Linked&lt;AnnotatedMethod&gt; next = curr.next;</b>
<b class="fc">&nbsp;        if (next == null) {</b>
<b class="fc">&nbsp;            return curr.value;</b>
&nbsp;        }
&nbsp;        // But if multiple, verify that they do not conflict...
<b class="fc">&nbsp;        for (; next != null; next = next.next) {</b>
&nbsp;            /* [JACKSON-255] Allow masking, i.e. do not report exception if one
&nbsp;             *   is in super-class from the other
&nbsp;             */
<b class="fc">&nbsp;            Class&lt;?&gt; currClass = curr.value.getDeclaringClass();</b>
<b class="fc">&nbsp;            Class&lt;?&gt; nextClass = next.value.getDeclaringClass();</b>
<b class="fc">&nbsp;            if (currClass != nextClass) {</b>
<b class="nc">&nbsp;                if (currClass.isAssignableFrom(nextClass)) { // next is more specific</b>
<b class="nc">&nbsp;                    curr = next;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (nextClass.isAssignableFrom(currClass)) { // current more specific</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            /* 30-May-2014, tatu: Three levels of precedence:
&nbsp;             * 
&nbsp;             * 1. Regular getters (&quot;getX&quot;)
&nbsp;             * 2. Is-getters (&quot;isX&quot;)
&nbsp;             * 3. Implicit, possible getters (&quot;x&quot;)
&nbsp;             */
<b class="fc">&nbsp;            int priNext = _getterPriority(next.value);</b>
<b class="fc">&nbsp;            int priCurr = _getterPriority(curr.value);</b>
&nbsp;
<b class="fc">&nbsp;            if (priNext != priCurr) {</b>
<b class="fc">&nbsp;                if (priNext &lt; priCurr) {</b>
<b class="fc">&nbsp;                    curr = next;</b>
&nbsp;                }
&nbsp;                continue;
&nbsp;            }
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Conflicting getter definitions for property \&quot;&quot;+getName()+&quot;\&quot;: &quot;</b>
<b class="fc">&nbsp;                    +curr.value.getFullName()+&quot; vs &quot;+next.value.getFullName());</b>
&nbsp;        }
&nbsp;        // One more thing; to avoid having to do it again...
<b class="fc">&nbsp;        _getters = curr.withoutNext();</b>
<b class="fc">&nbsp;        return curr.value;</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public AnnotatedMethod getSetter()
&nbsp;    {
&nbsp;        // Easy with zero or one getters...
<b class="fc">&nbsp;        Linked&lt;AnnotatedMethod&gt; curr = _setters;</b>
<b class="fc">&nbsp;        if (curr == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        Linked&lt;AnnotatedMethod&gt; next = curr.next;</b>
<b class="fc">&nbsp;        if (next == null) {</b>
<b class="fc">&nbsp;            return curr.value;</b>
&nbsp;        }
&nbsp;        // But if multiple, verify that they do not conflict...
<b class="fc">&nbsp;        for (; next != null; next = next.next) {</b>
&nbsp;            // Allow masking, i.e. do not fail if one is in super-class from the other
<b class="fc">&nbsp;            Class&lt;?&gt; currClass = curr.value.getDeclaringClass();</b>
<b class="fc">&nbsp;            Class&lt;?&gt; nextClass = next.value.getDeclaringClass();</b>
<b class="fc">&nbsp;            if (currClass != nextClass) {</b>
<b class="fc">&nbsp;                if (currClass.isAssignableFrom(nextClass)) { // next is more specific</b>
<b class="fc">&nbsp;                    curr = next;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (nextClass.isAssignableFrom(currClass)) { // current more specific</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            AnnotatedMethod nextM = next.value;</b>
<b class="fc">&nbsp;            AnnotatedMethod currM = curr.value;</b>
&nbsp;
&nbsp;            /* 30-May-2014, tatu: Two levels of precedence:
&nbsp;             * 
&nbsp;             * 1. Regular setters (&quot;setX(...)&quot;)
&nbsp;             * 2. Implicit, possible setters (&quot;x(...)&quot;)
&nbsp;             */
<b class="fc">&nbsp;            int priNext = _setterPriority(nextM);</b>
<b class="fc">&nbsp;            int priCurr = _setterPriority(currM);</b>
&nbsp;
<b class="fc">&nbsp;            if (priNext != priCurr) {</b>
<b class="fc">&nbsp;                if (priNext &lt; priCurr) {</b>
<b class="fc">&nbsp;                    curr = next;</b>
&nbsp;                }
&nbsp;                continue;
&nbsp;            }
&nbsp;            // 11-Dec-2015, tatu: As per [databind#1033] allow pluggable conflict resolution
<b class="fc">&nbsp;            if (_annotationIntrospector != null) {</b>
<b class="fc">&nbsp;                AnnotatedMethod pref = _annotationIntrospector.resolveSetterConflict(_config,</b>
&nbsp;                        currM, nextM);
&nbsp;                
&nbsp;                // note: should be one of nextM/currM; but no need to check
<b class="fc">&nbsp;                if (pref == currM) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (pref == nextM) {</b>
<b class="fc">&nbsp;                    curr = next;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            throw new IllegalArgumentException(String.format(</b>
&nbsp; &quot;Conflicting setter definitions for property \&quot;%s\&quot;: %s vs %s&quot;,
<b class="fc">&nbsp; getName(), curr.value.getFullName(), next.value.getFullName()));</b>
&nbsp;        }
&nbsp;        // One more thing; to avoid having to do it again...
<b class="fc">&nbsp;        _setters = curr.withoutNext();</b>
<b class="fc">&nbsp;        return curr.value;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedField getField()
&nbsp;    {
<b class="fc">&nbsp;        if (_fields == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // If multiple, verify that they do not conflict...
<b class="fc">&nbsp;        AnnotatedField field = _fields.value;</b>
<b class="fc">&nbsp;        Linked&lt;AnnotatedField&gt; next = _fields.next;</b>
<b class="fc">&nbsp;        for (; next != null; next = next.next) {</b>
<b class="fc">&nbsp;            AnnotatedField nextField = next.value;</b>
<b class="fc">&nbsp;            Class&lt;?&gt; fieldClass = field.getDeclaringClass();</b>
<b class="fc">&nbsp;            Class&lt;?&gt; nextClass = nextField.getDeclaringClass();</b>
<b class="fc">&nbsp;            if (fieldClass != nextClass) {</b>
<b class="nc">&nbsp;                if (fieldClass.isAssignableFrom(nextClass)) { // next is more specific</b>
<b class="nc">&nbsp;                    field = nextField;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (nextClass.isAssignableFrom(fieldClass)) { // getter more specific</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Multiple fields representing property \&quot;&quot;+getName()+&quot;\&quot;: &quot;</b>
<b class="fc">&nbsp;                    +field.getFullName()+&quot; vs &quot;+nextField.getFullName());</b>
&nbsp;        }
<b class="fc">&nbsp;        return field;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedParameter getConstructorParameter()
&nbsp;    {
<b class="fc">&nbsp;        if (_ctorParameters == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        /* Hmmh. Checking for constructor parameters is trickier; for one,
&nbsp;         * we must allow creator and factory method annotations.
&nbsp;         * If this is the case, constructor parameter has the precedence.
&nbsp;         * 
&nbsp;         * So, for now, just try finding the first constructor parameter;
&nbsp;         * if none, first factory method. And don&#39;t check for dups, if we must,
&nbsp;         * can start checking for them later on.
&nbsp;         */
<b class="fc">&nbsp;        Linked&lt;AnnotatedParameter&gt; curr = _ctorParameters;</b>
&nbsp;        do {
<b class="fc">&nbsp;            if (curr.value.getOwner() instanceof AnnotatedConstructor) {</b>
<b class="fc">&nbsp;                return curr.value;</b>
&nbsp;            }
<b class="fc">&nbsp;            curr = curr.next;</b>
<b class="fc">&nbsp;        } while (curr != null);</b>
<b class="fc">&nbsp;        return _ctorParameters.value;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Iterator&lt;AnnotatedParameter&gt; getConstructorParameters() {
<b class="fc">&nbsp;        if (_ctorParameters == null) {</b>
<b class="fc">&nbsp;            return ClassUtil.emptyIterator();</b>
&nbsp;        }
<b class="fc">&nbsp;        return new MemberIterator&lt;AnnotatedParameter&gt;(_ctorParameters);</b>
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public AnnotatedMember getAccessor()
&nbsp;    {
<b class="fc">&nbsp;        AnnotatedMember m = getGetter();</b>
<b class="fc">&nbsp;        if (m == null) {</b>
<b class="fc">&nbsp;            m = getField();</b>
&nbsp;        }
<b class="fc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMember getMutator()
&nbsp;    {
<b class="fc">&nbsp;        AnnotatedMember m = getConstructorParameter();</b>
<b class="fc">&nbsp;        if (m == null) {</b>
<b class="fc">&nbsp;            m = getSetter();</b>
<b class="fc">&nbsp;            if (m == null) {</b>
<b class="fc">&nbsp;                m = getField();</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMember getNonConstructorMutator() {
<b class="fc">&nbsp;        AnnotatedMember m = getSetter();</b>
<b class="fc">&nbsp;        if (m == null) {</b>
<b class="fc">&nbsp;            m = getField();</b>
&nbsp;        }
<b class="fc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotatedMember getPrimaryMember() {
<b class="fc">&nbsp;        if (_forSerialization) {</b>
<b class="fc">&nbsp;            return getAccessor();</b>
&nbsp;        }
<b class="fc">&nbsp;        return getMutator();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int _getterPriority(AnnotatedMethod m)
&nbsp;    {
<b class="fc">&nbsp;        final String name = m.getName();</b>
&nbsp;        // [databind#238]: Also, regular getters have precedence over &quot;is-getters&quot;
<b class="fc">&nbsp;        if (name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) {</b>
&nbsp;            // should we check capitalization?
<b class="fc">&nbsp;            return 1;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2) {</b>
<b class="fc">&nbsp;            return 2;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int _setterPriority(AnnotatedMethod m)
&nbsp;    {
<b class="fc">&nbsp;        final String name = m.getName();</b>
<b class="fc">&nbsp;        if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {</b>
&nbsp;            // should we check capitalization?
<b class="fc">&nbsp;            return 1;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Implementations of refinement accessors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public Class&lt;?&gt;[] findViews() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;Class&lt;?&gt;[]&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Class&lt;?&gt;[] withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findViews(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AnnotationIntrospector.ReferenceProperty findReferenceType() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;AnnotationIntrospector.ReferenceProperty&gt;() {</b>
&nbsp;            @Override
&nbsp;            public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findReferenceType(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isTypeId() {
<b class="fc">&nbsp;        Boolean b = fromMemberAnnotations(new WithMember&lt;Boolean&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Boolean withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.isTypeId(member);</b>
&nbsp;            }
&nbsp;        });
<b class="fc">&nbsp;        return (b != null) &amp;&amp; b.booleanValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PropertyMetadata getMetadata() {
<b class="fc">&nbsp;        final Boolean b = _findRequired();</b>
<b class="fc">&nbsp;        final String desc = _findDescription();</b>
<b class="fc">&nbsp;        final Integer idx = _findIndex();</b>
<b class="fc">&nbsp;        final String def = _findDefaultValue();</b>
<b class="fc">&nbsp;        if (b == null &amp;&amp; idx == null &amp;&amp; def == null) {</b>
<b class="fc">&nbsp;            return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL</b>
<b class="fc">&nbsp;                    : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);</b>
&nbsp;        }
<b class="fc">&nbsp;        return PropertyMetadata.construct(b, desc, idx, def);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Boolean _findRequired() {
<b class="fc">&nbsp;       return fromMemberAnnotations(new WithMember&lt;Boolean&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Boolean withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.hasRequiredMarker(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;    
&nbsp;    protected String _findDescription() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;String&gt;() {</b>
&nbsp;            @Override
&nbsp;            public String withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findPropertyDescription(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    protected Integer _findIndex() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;Integer&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Integer withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findPropertyIndex(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    protected String _findDefaultValue() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;String&gt;() {</b>
&nbsp;            @Override
&nbsp;            public String withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findPropertyDefaultValue(member);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;    
&nbsp;    @Override
&nbsp;    public ObjectIdInfo findObjectIdInfo() {
<b class="fc">&nbsp;        return fromMemberAnnotations(new WithMember&lt;ObjectIdInfo&gt;() {</b>
&nbsp;            @Override
&nbsp;            public ObjectIdInfo withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(member);</b>
<b class="fc">&nbsp;                if (info != null) {</b>
<b class="fc">&nbsp;                    info = _annotationIntrospector.findObjectReferenceInfo(member, info);</b>
&nbsp;                }
<b class="fc">&nbsp;                return info;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JsonInclude.Value findInclusion() {
<b class="fc">&nbsp;        AnnotatedMember a = getAccessor();</b>
&nbsp;        // 16-Apr-2106, tatu: Let&#39;s include per-type default inclusion too
&nbsp;        // 17-Aug-2016, tatu: Do NOT include global, or per-type defaults, because
&nbsp;        //    not all of this information (specifically, enclosing type&#39;s settings)
&nbsp;        //    is available here
<b class="fc">&nbsp;        JsonInclude.Value v = (_annotationIntrospector == null) ?</b>
<b class="fc">&nbsp;                null : _annotationIntrospector.findPropertyInclusion(a);</b>
<b class="fc">&nbsp;        return (v == null) ? JsonInclude.Value.empty() : v;</b>
&nbsp;    }
&nbsp;
&nbsp;    public JsonProperty.Access findAccess() {
<b class="fc">&nbsp;        return fromMemberAnnotationsExcept(new WithMember&lt;JsonProperty.Access&gt;() {</b>
&nbsp;            @Override
&nbsp;            public JsonProperty.Access withMember(AnnotatedMember member) {
<b class="fc">&nbsp;                return _annotationIntrospector.findPropertyAccess(member);</b>
&nbsp;            }
&nbsp;        }, JsonProperty.Access.AUTO);
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Data aggregation
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
<b class="fc">&nbsp;        _fields = new Linked&lt;AnnotatedField&gt;(a, _fields, name, explName, visible, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addCtor(AnnotatedParameter a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
<b class="fc">&nbsp;        _ctorParameters = new Linked&lt;AnnotatedParameter&gt;(a, _ctorParameters, name, explName, visible, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addGetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
<b class="fc">&nbsp;        _getters = new Linked&lt;AnnotatedMethod&gt;(a, _getters, name, explName, visible, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addSetter(AnnotatedMethod a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
<b class="fc">&nbsp;        _setters = new Linked&lt;AnnotatedMethod&gt;(a, _setters, name, explName, visible, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for adding all property members from specified collector into
&nbsp;     * this collector.
&nbsp;     */
&nbsp;    public void addAll(POJOPropertyBuilder src)
&nbsp;    {
<b class="fc">&nbsp;        _fields = merge(_fields, src._fields);</b>
<b class="fc">&nbsp;        _ctorParameters = merge(_ctorParameters, src._ctorParameters);</b>
<b class="fc">&nbsp;        _getters= merge(_getters, src._getters);</b>
<b class="fc">&nbsp;        _setters = merge(_setters, src._setters);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; Linked&lt;T&gt; merge(Linked&lt;T&gt; chain1, Linked&lt;T&gt; chain2)
&nbsp;    {
<b class="fc">&nbsp;        if (chain1 == null) {</b>
<b class="fc">&nbsp;            return chain2;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (chain2 == null) {</b>
<b class="fc">&nbsp;            return chain1;</b>
&nbsp;        }
<b class="fc">&nbsp;        return chain1.append(chain2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Modifications
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to remove all entries that are marked as
&nbsp;     * ignored.
&nbsp;     */
&nbsp;    public void removeIgnored()
&nbsp;    {
<b class="fc">&nbsp;        _fields = _removeIgnored(_fields);</b>
<b class="fc">&nbsp;        _getters = _removeIgnored(_getters);</b>
<b class="fc">&nbsp;        _setters = _removeIgnored(_setters);</b>
<b class="fc">&nbsp;        _ctorParameters = _removeIgnored(_ctorParameters);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param inferMutators Whether mutators can be &quot;pulled in&quot; by visible
&nbsp;     *    accessors or not. 
&nbsp;     */
&nbsp;    public JsonProperty.Access removeNonVisible(boolean inferMutators)
&nbsp;    {
&nbsp;        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition
&nbsp;         *  of explicit access type for property; if not &quot;AUTO&quot;, it will
&nbsp;         *  dictate how visibility checks are applied.
&nbsp;         */
<b class="fc">&nbsp;        JsonProperty.Access acc = findAccess();</b>
<b class="fc">&nbsp;        if (acc == null) {</b>
<b class="fc">&nbsp;            acc = JsonProperty.Access.AUTO;</b>
&nbsp;        }
<b class="fc">&nbsp;        switch (acc) {</b>
&nbsp;        case READ_ONLY:
&nbsp;            // Remove setters, creators for sure, but fields too if deserializing
<b class="fc">&nbsp;            _setters = null;</b>
<b class="fc">&nbsp;            _ctorParameters = null;</b>
<b class="fc">&nbsp;            if (!_forSerialization) {</b>
<b class="fc">&nbsp;                _fields = null;</b>
&nbsp;            }
&nbsp;            break;
&nbsp;        case READ_WRITE:
&nbsp;            // no trimming whatsoever?
<b class="fc">&nbsp;            break;</b>
&nbsp;        case WRITE_ONLY:
&nbsp;            // remove getters, definitely, but also fields if serializing
<b class="fc">&nbsp;            _getters = null;</b>
<b class="fc">&nbsp;            if (_forSerialization) {</b>
<b class="fc">&nbsp;                _fields = null;</b>
&nbsp;            }
&nbsp;            break;
&nbsp;        default:
&nbsp;        case AUTO: // the default case: base it on visibility
<b class="fc">&nbsp;            _getters = _removeNonVisible(_getters);</b>
<b class="fc">&nbsp;            _ctorParameters = _removeNonVisible(_ctorParameters);</b>
&nbsp;    
<b class="fc">&nbsp;            if (!inferMutators || (_getters == null)) {</b>
<b class="fc">&nbsp;                _fields = _removeNonVisible(_fields);</b>
<b class="fc">&nbsp;                _setters = _removeNonVisible(_setters);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return acc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mutator that will simply drop any constructor parameters property may have.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public void removeConstructors() {
<b class="fc">&nbsp;        _ctorParameters = null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method called to trim unnecessary entries, such as implicit
&nbsp;     * getter if there is an explict one available. This is important
&nbsp;     * for later stages, to avoid unnecessary conflicts.
&nbsp;     */
&nbsp;    public void trimByVisibility()
&nbsp;    {
<b class="fc">&nbsp;        _fields = _trimByVisibility(_fields);</b>
<b class="fc">&nbsp;        _getters = _trimByVisibility(_getters);</b>
<b class="fc">&nbsp;        _setters = _trimByVisibility(_setters);</b>
<b class="fc">&nbsp;        _ctorParameters = _trimByVisibility(_ctorParameters);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public void mergeAnnotations(boolean forSerialization)
&nbsp;    {
<b class="fc">&nbsp;        if (forSerialization) {</b>
<b class="fc">&nbsp;            if (_getters != null) {</b>
<b class="fc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters);</b>
<b class="fc">&nbsp;                _getters = _applyAnnotations(_getters, ann);</b>
<b class="fc">&nbsp;            } else if (_fields != null) {</b>
<b class="fc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);</b>
<b class="fc">&nbsp;                _fields = _applyAnnotations(_fields, ann);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        } else { // for deserialization
<b class="fc">&nbsp;            if (_ctorParameters != null) {</b>
<b class="fc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);</b>
<b class="fc">&nbsp;                _ctorParameters = _applyAnnotations(_ctorParameters, ann);</b>
<b class="fc">&nbsp;            } else if (_setters != null) {</b>
<b class="fc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters);</b>
<b class="fc">&nbsp;                _setters = _applyAnnotations(_setters, ann);</b>
<b class="fc">&nbsp;            } else if (_fields != null) {</b>
<b class="fc">&nbsp;                AnnotationMap ann = _mergeAnnotations(0, _fields, _getters);</b>
<b class="fc">&nbsp;                _fields = _applyAnnotations(_fields, ann);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private AnnotationMap _mergeAnnotations(int index,
&nbsp;            Linked&lt;? extends AnnotatedMember&gt;... nodes)
&nbsp;    {
<b class="fc">&nbsp;        AnnotationMap ann = _getAllAnnotations(nodes[index]);</b>
<b class="fc">&nbsp;        while (++index &lt; nodes.length) {</b>
<b class="fc">&nbsp;            if (nodes[index] != null) {</b>
<b class="fc">&nbsp;              return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return ann;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Replacement, as per [databind#868], of simple access to annotations, which
&nbsp;     * does &quot;deep merge&quot; if an as necessary.
&nbsp;     *&lt;pre&gt;
&nbsp;     * nodes[index].value.getAllAnnotations()
&nbsp;     *&lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    private &lt;T extends AnnotatedMember&gt; AnnotationMap _getAllAnnotations(Linked&lt;T&gt; node) {
<b class="fc">&nbsp;        AnnotationMap ann = node.value.getAllAnnotations();</b>
<b class="fc">&nbsp;        if (node.next != null) {</b>
<b class="fc">&nbsp;            ann = AnnotationMap.merge(ann, _getAllAnnotations(node.next));</b>
&nbsp;        }
<b class="fc">&nbsp;        return ann;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method to handle recursive merging of annotations within accessor class,
&nbsp;     * to ensure no annotations are accidentally dropped within chain when non-visible
&nbsp;     * and secondary accessors are pruned later on.
&nbsp;     *&lt;p&gt;
&nbsp;     * See [databind#868] for more information.
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    private &lt;T extends AnnotatedMember&gt; Linked&lt;T&gt; _applyAnnotations(Linked&lt;T&gt; node, AnnotationMap ann) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;        T value = (T) node.value.withAnnotations(ann);</b>
<b class="fc">&nbsp;        if (node.next != null) {</b>
<b class="fc">&nbsp;            node = node.withNext(_applyAnnotations(node.next, ann));</b>
&nbsp;        }
<b class="fc">&nbsp;        return node.withValue(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _removeIgnored(Linked&lt;T&gt; node)
&nbsp;    {
<b class="fc">&nbsp;        if (node == null) {</b>
<b class="fc">&nbsp;            return node;</b>
&nbsp;        }
<b class="fc">&nbsp;        return node.withoutIgnored();</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _removeNonVisible(Linked&lt;T&gt; node)
&nbsp;    {
<b class="fc">&nbsp;        if (node == null) {</b>
<b class="fc">&nbsp;            return node;</b>
&nbsp;        }
<b class="fc">&nbsp;        return node.withoutNonVisible();</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; Linked&lt;T&gt; _trimByVisibility(Linked&lt;T&gt; node)
&nbsp;    {
<b class="fc">&nbsp;        if (node == null) {</b>
<b class="fc">&nbsp;            return node;</b>
&nbsp;        }
<b class="fc">&nbsp;        return node.trimByVisibility();</b>
&nbsp;    }
&nbsp;        
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Accessors for aggregate information
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    private &lt;T&gt; boolean _anyExplicits(Linked&lt;T&gt; n)
&nbsp;    {
<b class="fc">&nbsp;        for (; n != null; n = n.next) {</b>
<b class="fc">&nbsp;            if (n.name != null &amp;&amp; n.name.hasSimpleName()) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; boolean _anyExplicitNames(Linked&lt;T&gt; n)
&nbsp;    {
<b class="fc">&nbsp;        for (; n != null; n = n.next) {</b>
<b class="fc">&nbsp;            if (n.name != null &amp;&amp; n.isNameExplicit) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean anyVisible() {
<b class="fc">&nbsp;        return _anyVisible(_fields)</b>
<b class="fc">&nbsp;            || _anyVisible(_getters)</b>
<b class="fc">&nbsp;            || _anyVisible(_setters)</b>
<b class="fc">&nbsp;            || _anyVisible(_ctorParameters)</b>
&nbsp;        ;
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; boolean _anyVisible(Linked&lt;T&gt; n)
&nbsp;    {
<b class="fc">&nbsp;        for (; n != null; n = n.next) {</b>
<b class="fc">&nbsp;            if (n.isVisible) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public boolean anyIgnorals() {
<b class="fc">&nbsp;        return _anyIgnorals(_fields)</b>
<b class="fc">&nbsp;            || _anyIgnorals(_getters)</b>
<b class="fc">&nbsp;            || _anyIgnorals(_setters)</b>
<b class="fc">&nbsp;            || _anyIgnorals(_ctorParameters)</b>
&nbsp;        ;
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; boolean _anyIgnorals(Linked&lt;T&gt; n)
&nbsp;    {
<b class="fc">&nbsp;        for (; n != null; n = n.next) {</b>
<b class="fc">&nbsp;            if (n.isMarkedIgnored) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to find out set of explicit names for accessors
&nbsp;     * bound together due to implicit name.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public Set&lt;PropertyName&gt; findExplicitNames()
&nbsp;    {
<b class="fc">&nbsp;        Set&lt;PropertyName&gt; renamed = null;</b>
<b class="fc">&nbsp;        renamed = _findExplicitNames(_fields, renamed);</b>
<b class="fc">&nbsp;        renamed = _findExplicitNames(_getters, renamed);</b>
<b class="fc">&nbsp;        renamed = _findExplicitNames(_setters, renamed);</b>
<b class="fc">&nbsp;        renamed = _findExplicitNames(_ctorParameters, renamed);</b>
<b class="fc">&nbsp;        if (renamed == null) {</b>
<b class="fc">&nbsp;            return Collections.emptySet();</b>
&nbsp;        }
<b class="fc">&nbsp;        return renamed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called when a previous call to {@link #findExplicitNames} found
&nbsp;     * multiple distinct explicit names, and the property this builder represents
&nbsp;     * basically needs to be broken apart and replaced by a set of more than
&nbsp;     * one properties.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public Collection&lt;POJOPropertyBuilder&gt; explode(Collection&lt;PropertyName&gt; newNames)
&nbsp;    {
<b class="fc">&nbsp;        HashMap&lt;PropertyName,POJOPropertyBuilder&gt; props = new HashMap&lt;PropertyName,POJOPropertyBuilder&gt;();</b>
<b class="fc">&nbsp;        _explode(newNames, props, _fields);</b>
<b class="fc">&nbsp;        _explode(newNames, props, _getters);</b>
<b class="fc">&nbsp;        _explode(newNames, props, _setters);</b>
<b class="fc">&nbsp;        _explode(newNames, props, _ctorParameters);</b>
<b class="fc">&nbsp;        return props.values();</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private void _explode(Collection&lt;PropertyName&gt; newNames,
&nbsp;            Map&lt;PropertyName,POJOPropertyBuilder&gt; props,
&nbsp;            Linked&lt;?&gt; accessors)
&nbsp;    {
<b class="fc">&nbsp;        final Linked&lt;?&gt; firstAcc = accessors; // clumsy, part 1</b>
<b class="fc">&nbsp;        for (Linked&lt;?&gt; node = accessors; node != null; node = node.next) {</b>
<b class="fc">&nbsp;            PropertyName name = node.name;</b>
<b class="fc">&nbsp;            if (!node.isNameExplicit || name == null) { // no explicit name -- problem!</b>
&nbsp;                // [databind#541] ... but only as long as it&#39;s visible
<b class="fc">&nbsp;                if (!node.isVisible) {</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;                
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Conflicting/ambiguous property name definitions (implicit name &#39;&quot;</b>
&nbsp;                        +_name+&quot;&#39;): found multiple explicit names: &quot;
&nbsp;                        +newNames+&quot;, but also implicit accessor: &quot;+node);
&nbsp;            }
<b class="fc">&nbsp;            POJOPropertyBuilder prop = props.get(name);</b>
<b class="fc">&nbsp;            if (prop == null) {</b>
<b class="fc">&nbsp;                prop = new POJOPropertyBuilder(_config, _annotationIntrospector, _forSerialization,</b>
&nbsp;                        _internalName, name);
<b class="fc">&nbsp;                props.put(name, prop);</b>
&nbsp;            }
&nbsp;            // ultra-clumsy, part 2 -- lambdas would be nice here
<b class="fc">&nbsp;            if (firstAcc == _fields) {</b>
<b class="fc">&nbsp;                Linked&lt;AnnotatedField&gt; n2 = (Linked&lt;AnnotatedField&gt;) node;</b>
<b class="fc">&nbsp;                prop._fields = n2.withNext(prop._fields);</b>
<b class="fc">&nbsp;            } else if (firstAcc == _getters) {</b>
<b class="fc">&nbsp;                Linked&lt;AnnotatedMethod&gt; n2 = (Linked&lt;AnnotatedMethod&gt;) node;</b>
<b class="fc">&nbsp;                prop._getters = n2.withNext(prop._getters);</b>
<b class="fc">&nbsp;            } else if (firstAcc == _setters) {</b>
<b class="nc">&nbsp;                Linked&lt;AnnotatedMethod&gt; n2 = (Linked&lt;AnnotatedMethod&gt;) node;</b>
<b class="nc">&nbsp;                prop._setters = n2.withNext(prop._setters);</b>
<b class="nc">&nbsp;            } else if (firstAcc == _ctorParameters) {</b>
<b class="fc">&nbsp;                Linked&lt;AnnotatedParameter&gt; n2 = (Linked&lt;AnnotatedParameter&gt;) node;</b>
<b class="fc">&nbsp;                prop._ctorParameters = n2.withNext(prop._ctorParameters);</b>
<b class="fc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Internal error: mismatched accessors, property: &quot;+this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    private Set&lt;PropertyName&gt; _findExplicitNames(Linked&lt;? extends AnnotatedMember&gt; node,
&nbsp;            Set&lt;PropertyName&gt; renamed)
&nbsp;    {
<b class="fc">&nbsp;        for (; node != null; node = node.next) {</b>
&nbsp;            /* 30-Mar-2014, tatu: Second check should not be needed, but seems like
&nbsp;             *   removing it can cause nasty exceptions with certain version
&nbsp;             *   combinations (2.4 databind, an older module).
&nbsp;             *   So leaving it in for now until this is resolved
&nbsp;             *   (or version beyond 2.4)
&nbsp;             */
<b class="fc">&nbsp;            if (!node.isNameExplicit || node.name == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (renamed == null) {</b>
<b class="fc">&nbsp;                renamed = new HashSet&lt;PropertyName&gt;();</b>
&nbsp;            }
<b class="fc">&nbsp;            renamed.add(node.name);</b>
&nbsp;        }
<b class="fc">&nbsp;        return renamed;</b>
&nbsp;    }
&nbsp;    
&nbsp;    // For trouble-shooting
&nbsp;    @Override
&nbsp;    public String toString()
&nbsp;    {
<b class="nc">&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc">&nbsp;        sb.append(&quot;[Property &#39;&quot;).append(_name)</b>
<b class="nc">&nbsp;          .append(&quot;&#39;; ctors: &quot;).append(_ctorParameters)</b>
<b class="nc">&nbsp;          .append(&quot;, field(s): &quot;).append(_fields)</b>
<b class="nc">&nbsp;          .append(&quot;, getter(s): &quot;).append(_getters)</b>
<b class="nc">&nbsp;          .append(&quot;, setter(s): &quot;).append(_setters)</b>
&nbsp;          ;
<b class="nc">&nbsp;        sb.append(&quot;]&quot;);</b>
<b class="nc">&nbsp;        return sb.toString();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method used for finding annotation values, from accessors
&nbsp;     * relevant to current usage (deserialization, serialization)
&nbsp;     */
&nbsp;    protected &lt;T&gt; T fromMemberAnnotations(WithMember&lt;T&gt; func)
&nbsp;    {
<b class="fc">&nbsp;        T result = null;</b>
<b class="fc">&nbsp;        if (_annotationIntrospector != null) {</b>
<b class="fc">&nbsp;            if (_forSerialization) {</b>
<b class="fc">&nbsp;                if (_getters != null) {</b>
<b class="fc">&nbsp;                    result = func.withMember(_getters.value);</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                if (_ctorParameters != null) {</b>
<b class="fc">&nbsp;                    result = func.withMember(_ctorParameters.value);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (result == null &amp;&amp; _setters != null) {</b>
<b class="fc">&nbsp;                    result = func.withMember(_setters.value);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (result == null &amp;&amp; _fields != null) {</b>
<b class="fc">&nbsp;                result = func.withMember(_fields.value);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected &lt;T&gt; T fromMemberAnnotationsExcept(WithMember&lt;T&gt; func, T defaultValue)
&nbsp;    {
<b class="fc">&nbsp;        if (_annotationIntrospector == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // NOTE: here we must ask ALL accessors, but the order varies between
&nbsp;        // serialization, deserialization
<b class="fc">&nbsp;        if (_forSerialization) {</b>
<b class="fc">&nbsp;            if (_getters != null) {</b>
<b class="fc">&nbsp;                T result = func.withMember(_getters.value);</b>
<b class="fc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (_fields != null) {</b>
<b class="fc">&nbsp;                T result = func.withMember(_fields.value);</b>
<b class="fc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (_ctorParameters != null) {</b>
<b class="fc">&nbsp;                T result = func.withMember(_ctorParameters.value);</b>
<b class="fc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (_setters != null) {</b>
<b class="fc">&nbsp;                T result = func.withMember(_setters.value);</b>
<b class="fc">&nbsp;                if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (_ctorParameters != null) {</b>
<b class="fc">&nbsp;            T result = func.withMember(_ctorParameters.value);</b>
<b class="fc">&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (_setters != null) {</b>
<b class="fc">&nbsp;            T result = func.withMember(_setters.value);</b>
<b class="fc">&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (_fields != null) {</b>
<b class="fc">&nbsp;            T result = func.withMember(_fields.value);</b>
<b class="fc">&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (_getters != null) {</b>
<b class="fc">&nbsp;            T result = func.withMember(_getters.value);</b>
<b class="fc">&nbsp;            if ((result != null) &amp;&amp; (result != defaultValue)) {</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper classes
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    private interface WithMember&lt;T&gt; {
&nbsp;        public T withMember(AnnotatedMember member);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected static class MemberIterator&lt;T extends AnnotatedMember&gt;
&nbsp;        implements Iterator&lt;T&gt;
&nbsp;    {
&nbsp;        private Linked&lt;T&gt; next;
&nbsp;        
<b class="fc">&nbsp;        public MemberIterator(Linked&lt;T&gt; first) {</b>
<b class="fc">&nbsp;            next = first;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public boolean hasNext() {
<b class="fc">&nbsp;            return (next != null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public T next() {
<b class="fc">&nbsp;            if (next == null) throw new NoSuchElementException();</b>
<b class="fc">&nbsp;            T result = next.value;</b>
<b class="fc">&nbsp;            next = next.next;</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void remove() {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;        
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Node used for creating simple linked lists to efficiently store small sets
&nbsp;     * of things.
&nbsp;     */
&nbsp;    protected final static class Linked&lt;T&gt;
&nbsp;    {
&nbsp;        public final T value;
&nbsp;        public final Linked&lt;T&gt; next;
&nbsp;
&nbsp;        public final PropertyName name;
&nbsp;        public final boolean isNameExplicit;
&nbsp;        public final boolean isVisible;
&nbsp;        public final boolean isMarkedIgnored;
&nbsp;        
&nbsp;        public Linked(T v, Linked&lt;T&gt; n,
&nbsp;                PropertyName name, boolean explName, boolean visible, boolean ignored)
<b class="fc">&nbsp;        {</b>
<b class="fc">&nbsp;            value = v;</b>
<b class="fc">&nbsp;            next = n;</b>
&nbsp;            // ensure that we&#39;ll never have missing names
<b class="fc">&nbsp;            this.name = (name == null || name.isEmpty()) ? null : name;</b>
&nbsp;
<b class="fc">&nbsp;            if (explName) {</b>
<b class="fc">&nbsp;                if (this.name == null) { // sanity check to catch internal problems</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Can not pass true for &#39;explName&#39; if name is null/empty&quot;);</b>
&nbsp;                }
&nbsp;                // 03-Apr-2014, tatu: But how about name-space only override?
&nbsp;                //   Probably should not be explicit? Or, need to merge somehow?
<b class="fc">&nbsp;                if (!name.hasSimpleName()) {</b>
<b class="nc">&nbsp;                    explName = false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            isNameExplicit = explName;</b>
<b class="fc">&nbsp;            isVisible = visible;</b>
<b class="fc">&nbsp;            isMarkedIgnored = ignored;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Linked&lt;T&gt; withoutNext() {
<b class="fc">&nbsp;            if (next == null) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Linked&lt;T&gt;(value, null, name, isNameExplicit, isVisible, isMarkedIgnored);</b>
&nbsp;        }
&nbsp;        
&nbsp;        public Linked&lt;T&gt; withValue(T newValue) {
<b class="fc">&nbsp;            if (newValue == value) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Linked&lt;T&gt;(newValue, next, name, isNameExplicit, isVisible, isMarkedIgnored);</b>
&nbsp;        }
&nbsp;        
&nbsp;        public Linked&lt;T&gt; withNext(Linked&lt;T&gt; newNext) {
<b class="fc">&nbsp;            if (newNext == next) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Linked&lt;T&gt;(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);</b>
&nbsp;        }
&nbsp;        
&nbsp;        public Linked&lt;T&gt; withoutIgnored() {
<b class="fc">&nbsp;            if (isMarkedIgnored) {</b>
<b class="fc">&nbsp;                return (next == null) ? null : next.withoutIgnored();</b>
&nbsp;            }
<b class="fc">&nbsp;            if (next != null) {</b>
<b class="nc">&nbsp;                Linked&lt;T&gt; newNext = next.withoutIgnored();</b>
<b class="nc">&nbsp;                if (newNext != next) {</b>
<b class="nc">&nbsp;                    return withNext(newNext);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;        
&nbsp;        public Linked&lt;T&gt; withoutNonVisible() {
<b class="fc">&nbsp;            Linked&lt;T&gt; newNext = (next == null) ? null : next.withoutNonVisible();</b>
<b class="fc">&nbsp;            return isVisible ? withNext(newNext) : newNext;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Method called to append given node(s) at the end of this
&nbsp;         * node chain.
&nbsp;         */
&nbsp;        protected Linked&lt;T&gt; append(Linked&lt;T&gt; appendable) {
<b class="fc">&nbsp;            if (next == null) {</b>
<b class="fc">&nbsp;                return withNext(appendable);</b>
&nbsp;            }
<b class="nc">&nbsp;            return withNext(next.append(appendable));</b>
&nbsp;        }
&nbsp;
&nbsp;        public Linked&lt;T&gt; trimByVisibility() {
<b class="fc">&nbsp;            if (next == null) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;            Linked&lt;T&gt; newNext = next.trimByVisibility();</b>
<b class="fc">&nbsp;            if (name != null) { // this already has highest; how about next one?</b>
<b class="fc">&nbsp;                if (newNext.name == null) { // next one not, drop it</b>
<b class="fc">&nbsp;                    return withNext(null);</b>
&nbsp;                }
&nbsp;                //  both have it, keep
<b class="fc">&nbsp;                return withNext(newNext);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (newNext.name != null) { // next one has higher, return it...</b>
<b class="fc">&nbsp;                return newNext;</b>
&nbsp;            }
&nbsp;            // neither has explicit name; how about visibility?
<b class="fc">&nbsp;            if (isVisible == newNext.isVisible) { // same; keep both in current order</b>
<b class="fc">&nbsp;                return withNext(newNext);</b>
&nbsp;            }
<b class="nc">&nbsp;            return isVisible ? withNext(null) : newNext;</b>
&nbsp;        }
&nbsp;        
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            String msg = value.toString()+&quot;[visible=&quot;+isVisible+&quot;,ignore=&quot;+isMarkedIgnored</b>
&nbsp;                    +&quot;,explicitName=&quot;+isNameExplicit+&quot;]&quot;;
<b class="nc">&nbsp;            if (next != null) {</b>
<b class="nc">&nbsp;                msg = msg + &quot;, &quot;+next.toString();</b>
&nbsp;            }
<b class="nc">&nbsp;            return msg;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 11:11</div>
</div>
</body>
</html>
