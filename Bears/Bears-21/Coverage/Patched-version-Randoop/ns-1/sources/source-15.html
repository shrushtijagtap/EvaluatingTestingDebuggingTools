


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ObjectMapper</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.fasterxml.jackson.databind</a>
</div>

<h1>Coverage Summary for Class: ObjectMapper (com.fasterxml.jackson.databind)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ObjectMapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/212)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/573)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ObjectMapper$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectMapper$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectMapper$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectMapper$DefaultTypeResolverBuilder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectMapper$DefaultTyping</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/248)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/640)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.fasterxml.jackson.databind;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.net.URL;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.text.DateFormat;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;
&nbsp;import com.fasterxml.jackson.annotation.*;
&nbsp;import com.fasterxml.jackson.core.*;
&nbsp;import com.fasterxml.jackson.core.io.CharacterEscapes;
&nbsp;import com.fasterxml.jackson.core.io.SegmentedStringWriter;
&nbsp;import com.fasterxml.jackson.core.type.ResolvedType;
&nbsp;import com.fasterxml.jackson.core.type.TypeReference;
&nbsp;import com.fasterxml.jackson.core.util.*;
&nbsp;import com.fasterxml.jackson.databind.cfg.BaseSettings;
&nbsp;import com.fasterxml.jackson.databind.cfg.ContextAttributes;
&nbsp;import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;
&nbsp;import com.fasterxml.jackson.databind.cfg.MapperConfig;
&nbsp;import com.fasterxml.jackson.databind.cfg.MutableConfigOverride;
&nbsp;import com.fasterxml.jackson.databind.cfg.ConfigOverrides;
&nbsp;import com.fasterxml.jackson.databind.deser.*;
&nbsp;import com.fasterxml.jackson.databind.introspect.*;
&nbsp;import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
&nbsp;import com.fasterxml.jackson.databind.jsontype.*;
&nbsp;import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;
&nbsp;import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;
&nbsp;import com.fasterxml.jackson.databind.node.*;
&nbsp;import com.fasterxml.jackson.databind.ser.*;
&nbsp;import com.fasterxml.jackson.databind.type.*;
&nbsp;import com.fasterxml.jackson.databind.util.ClassUtil;
&nbsp;import com.fasterxml.jackson.databind.util.RootNameLookup;
&nbsp;import com.fasterxml.jackson.databind.util.StdDateFormat;
&nbsp;import com.fasterxml.jackson.databind.util.TokenBuffer;
&nbsp;
&nbsp;/**
&nbsp; * ObjectMapper provides functionality for reading and writing JSON,
&nbsp; * either to and from basic POJOs (Plain Old Java Objects), or to and from
&nbsp; * a general-purpose JSON Tree Model ({@link JsonNode}), as well as
&nbsp; * related functionality for performing conversions.
&nbsp; * It is also highly customizable to work both with different styles of JSON
&nbsp; * content, and to support more advanced Object concepts such as
&nbsp; * polymorphism and Object identity.
&nbsp; * &lt;code&gt;ObjectMapper&lt;/code&gt; also acts as a factory for more advanced {@link ObjectReader}
&nbsp; * and {@link ObjectWriter} classes.
&nbsp; * Mapper (and {@link ObjectReader}s, {@link ObjectWriter}s it constructs) will
&nbsp; * use instances of {@link JsonParser} and {@link JsonGenerator}
&nbsp; * for implementing actual reading/writing of JSON.
&nbsp; * Note that although most read and write methods are exposed through this class,
&nbsp; * some of the functionality is only exposed via {@link ObjectReader} and
&nbsp; * {@link ObjectWriter}: specifically, reading/writing of longer sequences of
&nbsp; * values is only available through {@link ObjectReader#readValues(InputStream)}
&nbsp; * and {@link ObjectWriter#writeValues(OutputStream)}.
&nbsp; *&lt;p&gt;
&nbsp;Simplest usage is of form:
&nbsp;&lt;pre&gt;
&nbsp;  final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!
&nbsp;  MyValue value = new MyValue();
&nbsp;  // ... and configure
&nbsp;  File newState = new File(&quot;my-stuff.json&quot;);
&nbsp;  mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance
&nbsp;  // or, read
&nbsp;  MyValue older = mapper.readValue(new File(&quot;my-older-stuff.json&quot;), MyValue.class);
&nbsp;
&nbsp;  // Or if you prefer JSON Tree representation:
&nbsp;  JsonNode root = mapper.readTree(newState);
&nbsp;  // and find values by, for example, using a {@link com.fasterxml.jackson.core.JsonPointer} expression:
&nbsp;  int age = root.at(&quot;/personal/age&quot;).getValueAsInt(); 
&nbsp;&lt;/pre&gt;
&nbsp; *&lt;p&gt;
&nbsp; * The main conversion API is defined in {@link ObjectCodec}, so that
&nbsp; * implementation details of this class need not be exposed to
&nbsp; * streaming parser and generator classes. Usage via {@link ObjectCodec} is,
&nbsp; * however, usually only for cases where dependency to {@link ObjectMapper} is
&nbsp; * either not possible (from Streaming API), or undesireable (when only relying
&nbsp; * on Streaming API).
&nbsp; *&lt;p&gt; 
&nbsp; * Mapper instances are fully thread-safe provided that ALL configuration of the
&nbsp; * instance occurs before ANY read or write calls. If configuration of a mapper
&nbsp; * is modified after first usage, changes may or may not take effect, and configuration
&nbsp; * calls themselves may fail.
&nbsp; * If you need to use different configuration, you have two main possibilities:
&nbsp; *&lt;ul&gt;
&nbsp; * &lt;li&gt;Construct and use {@link ObjectReader} for reading, {@link ObjectWriter} for writing.
&nbsp; *    Both types are fully immutable and you can freely create new instances with different
&nbsp; *    configuration using either factory methods of {@link ObjectMapper}, or readers/writers
&nbsp; *    themselves. Construction of new {@link ObjectReader}s and {@link ObjectWriter}s is
&nbsp; *    a very light-weight operation so it is usually appropriate to create these on per-call
&nbsp; *    basis, as needed, for configuring things like optional indentation of JSON.
&nbsp; *  &lt;/li&gt;
&nbsp; * &lt;li&gt;If the specific kind of configurability is not available via {@link ObjectReader} and
&nbsp; *   {@link ObjectWriter}, you may need to use multiple {@link ObjectMapper} instead (for example:
&nbsp; *   you can not change mix-in annotations on-the-fly; or, set of custom (de)serializers).
&nbsp; *   To help with this usage, you may want to use method {@link #copy()} which creates a clone
&nbsp; *   of the mapper with specific configuration, and allows configuration of the copied instance
&nbsp; *   before it gets used. Note that {@link #copy} operation is as expensive as constructing
&nbsp; *   a new {@link ObjectMapper} instance: if possible, you should still pool and reuse mappers
&nbsp; *   if you intend to use them for multiple operations.
&nbsp; *  &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *&lt;p&gt;
&nbsp; * Note on caching: root-level deserializers are always cached, and accessed
&nbsp; * using full (generics-aware) type information. This is different from
&nbsp; * caching of referenced types, which is more limited and is done only
&nbsp; * for a subset of all deserializer types. The main reason for difference
&nbsp; * is that at root-level there is no incoming reference (and hence no
&nbsp; * referencing property, no referral information or annotations to
&nbsp; * produce differing deserializers), and that the performance impact
&nbsp; * greatest at root level (since it&#39;ll essentially cache the full
&nbsp; * graph of deserializers involved).
&nbsp; */
&nbsp;public class ObjectMapper
&nbsp;    extends ObjectCodec
&nbsp;    implements Versioned,
&nbsp;        java.io.Serializable // as of 2.1
&nbsp;{
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Helper classes, enums
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}
&nbsp;     * to specify what kind of types (classes) default typing should
&nbsp;     * be used for. It will only be used if no explicit type information
&nbsp;     * is found, but this enumeration further limits subset of those types.
&nbsp;     *&lt;p&gt;
&nbsp;     * Since 2.4 there are special exceptions for JSON Tree model
&nbsp;     * types (sub-types of {@link TreeNode}: default typing is never
&nbsp;     * applied to them
&nbsp;     * (see &lt;a href=&quot;https://github.com/FasterXML/jackson-databind/issues/88&quot;&gt;databind#88&lt;/a&gt; for details)
&nbsp;     *&lt;p&gt;
&nbsp;     * Since 2.8(.4) additional checks are made to avoid attempts at default
&nbsp;     * typing primitive-valued properties.
&nbsp;     */
<b class="nc">&nbsp;    public enum DefaultTyping {</b>
&nbsp;        /**
&nbsp;         * This value means that only properties that have
&nbsp;         * {@link java.lang.Object} as declared type (including
&nbsp;         * generic types without explicit type) will use default
&nbsp;         * typing.
&nbsp;         */
<b class="nc">&nbsp;        JAVA_LANG_OBJECT,</b>
&nbsp;        
&nbsp;        /**
&nbsp;         * Value that means that default typing will be used for
&nbsp;         * properties with declared type of {@link java.lang.Object}
&nbsp;         * or an abstract type (abstract class or interface).
&nbsp;         * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.
&nbsp;         *&lt;p&gt;
&nbsp;         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.
&nbsp;         */
<b class="nc">&nbsp;        OBJECT_AND_NON_CONCRETE,</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Value that means that default typing will be used for
&nbsp;         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}
&nbsp;         * plus all array types for them.
&nbsp;         *&lt;p&gt;
&nbsp;         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.
&nbsp;         */
<b class="nc">&nbsp;        NON_CONCRETE_AND_ARRAYS,</b>
&nbsp;        
&nbsp;        /**
&nbsp;         * Value that means that default typing will be used for
&nbsp;         * all non-final types, with exception of small number of
&nbsp;         * &quot;natural&quot; types (String, Boolean, Integer, Double), which
&nbsp;         * can be correctly inferred from JSON; as well as for
&nbsp;         * all arrays of non-final types.
&nbsp;         *&lt;p&gt;
&nbsp;         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.
&nbsp;         */
<b class="nc">&nbsp;        NON_FINAL</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Customized {@link TypeResolverBuilder} that provides type resolver builders
&nbsp;     * used with so-called &quot;default typing&quot;
&nbsp;     * (see {@link ObjectMapper#enableDefaultTyping()} for details).
&nbsp;     *&lt;p&gt;
&nbsp;     * Type resolver construction is based on configuration: implementation takes care
&nbsp;     * of only providing builders in cases where type information should be applied.
&nbsp;     * This is important since build calls may be sent for any and all types, and
&nbsp;     * type information should NOT be applied to all of them.
&nbsp;     */
&nbsp;    public static class DefaultTypeResolverBuilder
&nbsp;        extends StdTypeResolverBuilder
&nbsp;        implements java.io.Serializable
&nbsp;    {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        /**
&nbsp;         * Definition of what types is this default typer valid for.
&nbsp;         */
&nbsp;        protected final DefaultTyping _appliesFor;
&nbsp;
<b class="nc">&nbsp;        public DefaultTypeResolverBuilder(DefaultTyping t) {</b>
<b class="nc">&nbsp;            _appliesFor = t;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,
&nbsp;                JavaType baseType, Collection&lt;NamedType&gt; subtypes)
&nbsp;        {
<b class="nc">&nbsp;            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeSerializer buildTypeSerializer(SerializationConfig config,
&nbsp;                JavaType baseType, Collection&lt;NamedType&gt; subtypes)
&nbsp;        {
<b class="nc">&nbsp;            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            </b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Method called to check if the default type handler should be
&nbsp;         * used for given type.
&nbsp;         * Note: &quot;natural types&quot; (String, Boolean, Integer, Double) will never
&nbsp;         * use typing; that is both due to them being concrete and final,
&nbsp;         * and since actual serializers and deserializers will also ignore any
&nbsp;         * attempts to enforce typing.
&nbsp;         */
&nbsp;        public boolean useForType(JavaType t)
&nbsp;        {
&nbsp;            // 03-Oct-2016, tatu: As per [databind#1395], need to skip
&nbsp;            //  primitive types too, regardless
<b class="nc">&nbsp;            if (t.isPrimitive()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            switch (_appliesFor) {</b>
&nbsp;            case NON_CONCRETE_AND_ARRAYS:
<b class="nc">&nbsp;                while (t.isArrayType()) {</b>
<b class="nc">&nbsp;                    t = t.getContentType();</b>
&nbsp;                }
&nbsp;                // fall through
&nbsp;            case OBJECT_AND_NON_CONCRETE:
&nbsp;                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
<b class="nc">&nbsp;                while (t.isReferenceType()) {</b>
<b class="nc">&nbsp;                    t = t.getReferencedType();</b>
&nbsp;                }
<b class="nc">&nbsp;                return t.isJavaLangObject()</b>
<b class="nc">&nbsp;                        || (!t.isConcrete()</b>
&nbsp;                                // [databind#88] Should not apply to JSON tree models:
<b class="nc">&nbsp;                                &amp;&amp; !TreeNode.class.isAssignableFrom(t.getRawClass()));</b>
&nbsp;
&nbsp;            case NON_FINAL:
<b class="nc">&nbsp;                while (t.isArrayType()) {</b>
<b class="nc">&nbsp;                    t = t.getContentType();</b>
&nbsp;                }
&nbsp;                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
<b class="nc">&nbsp;                while (t.isReferenceType()) {</b>
<b class="nc">&nbsp;                    t = t.getReferencedType();</b>
&nbsp;                }
&nbsp;                // [databind#88] Should not apply to JSON tree models:
<b class="nc">&nbsp;                return !t.isFinal() &amp;&amp; !TreeNode.class.isAssignableFrom(t.getRawClass());</b>
&nbsp;            default:
&nbsp;            //case JAVA_LANG_OBJECT:
<b class="nc">&nbsp;                return t.isJavaLangObject();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Internal constants, singletons
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    // Quick little shortcut, to avoid having to use global TypeFactory instance...
&nbsp;    // 19-Oct-2015, tatu: Not sure if this is really safe to do; let&#39;s at least allow
&nbsp;    //   some amount of introspection
<b class="nc">&nbsp;    private final static JavaType JSON_NODE_TYPE =</b>
<b class="nc">&nbsp;            SimpleType.constructUnsafe(JsonNode.class);</b>
&nbsp;//            TypeFactory.defaultInstance().constructType(JsonNode.class);
&nbsp;
&nbsp;    // 16-May-2009, tatu: Ditto ^^^
<b class="nc">&nbsp;    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();</b>
&nbsp;
<b class="nc">&nbsp;    protected final static VisibilityChecker&lt;?&gt; STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Base settings contain defaults used for all {@link ObjectMapper}
&nbsp;     * instances.
&nbsp;     */
<b class="nc">&nbsp;    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(</b>
&nbsp;            null, // can not share global ClassIntrospector any more (2.5+)
&nbsp;            DEFAULT_ANNOTATION_INTROSPECTOR,
<b class="nc">&nbsp;            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),</b>
&nbsp;            null, StdDateFormat.instance, null,
<b class="nc">&nbsp;            Locale.getDefault(),</b>
&nbsp;            null, // to indicate &quot;use Jackson default TimeZone&quot; (UTC since Jackson 2.7)
<b class="nc">&nbsp;            Base64Variants.getDefaultVariant() // 2.1</b>
&nbsp;    );
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration settings, shared
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Factory used to create {@link JsonParser} and {@link JsonGenerator}
&nbsp;     * instances as necessary.
&nbsp;     */
&nbsp;    protected final JsonFactory _jsonFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * Specific factory used for creating {@link JavaType} instances;
&nbsp;     * needed to allow modules to add more custom type handling
&nbsp;     * (mostly to support types of non-Java JVM languages)
&nbsp;     */
&nbsp;    protected TypeFactory _typeFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * Provider for values to inject in deserialized POJOs.
&nbsp;     */
&nbsp;    protected InjectableValues _injectableValues;
&nbsp;
&nbsp;    /**
&nbsp;     * Thing used for registering sub-types, resolving them to
&nbsp;     * super/sub-types as needed.
&nbsp;     */
&nbsp;    protected SubtypeResolver _subtypeResolver;
&nbsp;
&nbsp;    /**
&nbsp;     * Currently active per-type configuration overrides, accessed by
&nbsp;     * declared type of property.
&nbsp;     *
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    protected ConfigOverrides _propertyOverrides;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration settings: mix-in annotations
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Mapping that defines how to apply mix-in annotations: key is
&nbsp;     * the type to received additional annotations, and value is the
&nbsp;     * type that has annotations to &quot;mix in&quot;.
&nbsp;     *&lt;p&gt;
&nbsp;     * Annotations associated with the value classes will be used to
&nbsp;     * override annotations of the key class, associated with the
&nbsp;     * same field or method. They can be further masked by sub-classes:
&nbsp;     * you can think of it as injecting annotations between the target
&nbsp;     * class and its sub-classes (or interfaces)
&nbsp;     * 
&nbsp;     * @since 2.6 (earlier was a simple {@link java.util.Map}
&nbsp;     */
&nbsp;    protected SimpleMixInResolver _mixIns;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration settings, serialization
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Configuration object that defines basic global
&nbsp;     * settings for the serialization process
&nbsp;     */
&nbsp;    protected SerializationConfig _serializationConfig;
&nbsp;
&nbsp;    /**
&nbsp;     * Object that manages access to serializers used for serialization,
&nbsp;     * including caching.
&nbsp;     * It is configured with {@link #_serializerFactory} to allow
&nbsp;     * for constructing custom serializers.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: while serializers are only exposed {@link SerializerProvider},
&nbsp;     * mappers and readers need to access additional API defined by
&nbsp;     * {@link DefaultSerializerProvider}
&nbsp;     */
&nbsp;    protected DefaultSerializerProvider _serializerProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * Serializer factory used for constructing serializers.
&nbsp;     */
&nbsp;    protected SerializerFactory _serializerFactory;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration settings, deserialization
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Configuration object that defines basic global
&nbsp;     * settings for the serialization process
&nbsp;     */
&nbsp;    protected DeserializationConfig _deserializationConfig;
&nbsp;
&nbsp;    /**
&nbsp;     * Blueprint context object; stored here to allow custom
&nbsp;     * sub-classes. Contains references to objects needed for
&nbsp;     * deserialization construction (cache, factory).
&nbsp;     */
&nbsp;    protected DefaultDeserializationContext _deserializationContext;
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Module-related
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Set of module types (as per {@link Module#getTypeId()} that have been
&nbsp;     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}
&nbsp;     * is enabled, so that duplicate registration calls can be ignored
&nbsp;     * (to avoid adding same handlers multiple times, mostly).
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected Set&lt;Object&gt; _registeredModuleTypes;
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Caching
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /* Note: handling of serializers and deserializers is not symmetric;
&nbsp;     * and as a result, only root-level deserializers can be cached here.
&nbsp;     * This is mostly because typing and resolution for deserializers is
&nbsp;     * fully static; whereas it is quite dynamic for serialization.
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * We will use a separate main-level Map for keeping track
&nbsp;     * of root-level deserializers. This is where most successful
&nbsp;     * cache lookups get resolved.
&nbsp;     * Map will contain resolvers for all kinds of types, including
&nbsp;     * container types: this is different from the component cache
&nbsp;     * which will only cache bean deserializers.
&nbsp;     *&lt;p&gt;
&nbsp;     * Given that we don&#39;t expect much concurrency for additions
&nbsp;     * (should very quickly converge to zero after startup), let&#39;s
&nbsp;     * explicitly define a low concurrency setting.
&nbsp;     *&lt;p&gt;
&nbsp;     * Since version 1.5, these may are either &quot;raw&quot; deserializers (when
&nbsp;     * no type information is needed for base type), or type-wrapped
&nbsp;     * deserializers (if it is needed)
&nbsp;     */
<b class="nc">&nbsp;    final protected ConcurrentHashMap&lt;JavaType, JsonDeserializer&lt;Object&gt;&gt; _rootDeserializers</b>
&nbsp;        = new ConcurrentHashMap&lt;JavaType, JsonDeserializer&lt;Object&gt;&gt;(64, 0.6f, 2);
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Life-cycle: constructing instance
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Default constructor, which will construct the default
&nbsp;     * {@link JsonFactory} as necessary, use
&nbsp;     * {@link SerializerProvider} as its
&nbsp;     * {@link SerializerProvider}, and
&nbsp;     * {@link BeanSerializerFactory} as its
&nbsp;     * {@link SerializerFactory}.
&nbsp;     * This means that it
&nbsp;     * can serialize all standard JDK types, as well as regular
&nbsp;     * Java Beans (based on method names and Jackson-specific annotations),
&nbsp;     * but does not support JAXB annotations.
&nbsp;     */
&nbsp;    public ObjectMapper() {
<b class="nc">&nbsp;        this(null, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs instance that uses specified {@link JsonFactory}
&nbsp;     * for constructing necessary {@link JsonParser}s and/or
&nbsp;     * {@link JsonGenerator}s.
&nbsp;     */
&nbsp;    public ObjectMapper(JsonFactory jf) {
<b class="nc">&nbsp;        this(jf, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy-constructor, mostly used to support {@link #copy}.
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    protected ObjectMapper(ObjectMapper src)
<b class="nc">&nbsp;    {</b>
<b class="nc">&nbsp;        _jsonFactory = src._jsonFactory.copy();</b>
<b class="nc">&nbsp;        _jsonFactory.setCodec(this);</b>
<b class="nc">&nbsp;        _subtypeResolver = src._subtypeResolver;</b>
<b class="nc">&nbsp;        _typeFactory = src._typeFactory;</b>
<b class="nc">&nbsp;        _injectableValues = src._injectableValues;</b>
<b class="nc">&nbsp;        _propertyOverrides = src._propertyOverrides.copy();</b>
<b class="nc">&nbsp;        _mixIns = src._mixIns.copy();</b>
&nbsp;
<b class="nc">&nbsp;        RootNameLookup rootNames = new RootNameLookup();</b>
<b class="nc">&nbsp;        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixIns, rootNames, _propertyOverrides);</b>
<b class="nc">&nbsp;        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixIns, rootNames, _propertyOverrides);</b>
<b class="nc">&nbsp;        _serializerProvider = src._serializerProvider.copy();</b>
<b class="nc">&nbsp;        _deserializationContext = src._deserializationContext.copy();</b>
&nbsp;
&nbsp;        // Default serializer factory is stateless, can just assign
<b class="nc">&nbsp;        _serializerFactory = src._serializerFactory;</b>
&nbsp;
&nbsp;        // as per [databind#922], [databind#1078] make sure to copy registered modules as appropriate
<b class="nc">&nbsp;        Set&lt;Object&gt; reg = src._registeredModuleTypes;</b>
<b class="nc">&nbsp;        if (reg == null) {</b>
<b class="nc">&nbsp;            _registeredModuleTypes = null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            _registeredModuleTypes = new LinkedHashSet&lt;Object&gt;(reg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs instance that uses specified {@link JsonFactory}
&nbsp;     * for constructing necessary {@link JsonParser}s and/or
&nbsp;     * {@link JsonGenerator}s, and uses given providers for accessing
&nbsp;     * serializers and deserializers.
&nbsp;     * 
&nbsp;     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed
&nbsp;     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed
&nbsp;     * @param dc Blueprint deserialization context instance to use for creating
&nbsp;     *    actual context objects; if null, will construct standard
&nbsp;     *    {@link DeserializationContext}
&nbsp;     */
&nbsp;    public ObjectMapper(JsonFactory jf,
&nbsp;            DefaultSerializerProvider sp, DefaultDeserializationContext dc)
<b class="nc">&nbsp;    {</b>
&nbsp;        /* 02-Mar-2009, tatu: Important: we MUST default to using
&nbsp;         *   the mapping factory, otherwise tree serialization will
&nbsp;         *   have problems with POJONodes.
&nbsp;         * 03-Jan-2010, tatu: and obviously we also must pass &#39;this&#39;,
&nbsp;         *    to create actual linking.
&nbsp;         */
<b class="nc">&nbsp;        if (jf == null) {</b>
<b class="nc">&nbsp;            _jsonFactory = new MappingJsonFactory(this);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            _jsonFactory = jf;</b>
<b class="nc">&nbsp;            if (jf.getCodec() == null) { // as per [JACKSON-741]</b>
<b class="nc">&nbsp;                _jsonFactory.setCodec(this);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        _subtypeResolver = new StdSubtypeResolver();</b>
<b class="nc">&nbsp;        RootNameLookup rootNames = new RootNameLookup();</b>
&nbsp;        // and default type factory is shared one
<b class="nc">&nbsp;        _typeFactory = TypeFactory.defaultInstance();</b>
&nbsp;
<b class="nc">&nbsp;        SimpleMixInResolver mixins = new SimpleMixInResolver(null);</b>
<b class="nc">&nbsp;        _mixIns = mixins;</b>
<b class="nc">&nbsp;        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());</b>
<b class="nc">&nbsp;        ConfigOverrides propOverrides = new ConfigOverrides();</b>
<b class="nc">&nbsp;        _propertyOverrides = propOverrides;</b>
<b class="nc">&nbsp;        _serializationConfig = new SerializationConfig(base,</b>
&nbsp;                    _subtypeResolver, mixins, rootNames, propOverrides);
<b class="nc">&nbsp;        _deserializationConfig = new DeserializationConfig(base,</b>
&nbsp;                    _subtypeResolver, mixins, rootNames, propOverrides);
&nbsp;
&nbsp;        // Some overrides we may need
<b class="nc">&nbsp;        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();</b>
<b class="nc">&nbsp;        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {</b>
<b class="nc">&nbsp;            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;</b>
<b class="nc">&nbsp;        _deserializationContext = (dc == null) ?</b>
&nbsp;                new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;
&nbsp;
&nbsp;        // Default serializer factory is stateless, can just assign
<b class="nc">&nbsp;        _serializerFactory = BeanSerializerFactory.instance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overridable helper method used to construct default {@link ClassIntrospector}
&nbsp;     * to use.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ClassIntrospector defaultClassIntrospector() {
<b class="nc">&nbsp;        return new BasicClassIntrospector();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Methods sub-classes MUST override
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for creating a new {@link ObjectMapper} instance that
&nbsp;     * has same initial configuration as this instance. Note that this
&nbsp;     * also requires making a copy of the underlying {@link JsonFactory}
&nbsp;     * instance.
&nbsp;     *&lt;p&gt;
&nbsp;     * Method is typically
&nbsp;     * used when multiple, differently configured mappers are needed.
&nbsp;     * Although configuration is shared, cached serializers and deserializers
&nbsp;     * are NOT shared, which means that the new instance may be re-configured
&nbsp;     * before use; meaning that it behaves the same way as if an instance
&nbsp;     * was constructed from scratch.
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public ObjectMapper copy() {
<b class="nc">&nbsp;        _checkInvalidCopy(ObjectMapper.class);</b>
<b class="nc">&nbsp;        return new ObjectMapper(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    protected void _checkInvalidCopy(Class&lt;?&gt; exp)
&nbsp;    {
<b class="nc">&nbsp;        if (getClass() != exp) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Failed copy(): &quot;+getClass().getName()</b>
<b class="nc">&nbsp;                    +&quot; (version: &quot;+version()+&quot;) does not override copy(); it has to&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Methods sub-classes MUST override if providing custom
&nbsp;    /* ObjectReader/ObjectWriter implementations
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method sub-classes must override, to produce {@link ObjectReader}
&nbsp;     * instances of proper sub-type
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ObjectReader _newReader(DeserializationConfig config) {
<b class="nc">&nbsp;        return new ObjectReader(this, config);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method sub-classes must override, to produce {@link ObjectReader}
&nbsp;     * instances of proper sub-type
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ObjectReader _newReader(DeserializationConfig config,
&nbsp;            JavaType valueType, Object valueToUpdate,
&nbsp;            FormatSchema schema, InjectableValues injectableValues) {
<b class="nc">&nbsp;        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method sub-classes must override, to produce {@link ObjectWriter}
&nbsp;     * instances of proper sub-type
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ObjectWriter _newWriter(SerializationConfig config) {
<b class="nc">&nbsp;        return new ObjectWriter(this, config);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method sub-classes must override, to produce {@link ObjectWriter}
&nbsp;     * instances of proper sub-type
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {
<b class="nc">&nbsp;        return new ObjectWriter(this, config, schema);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method sub-classes must override, to produce {@link ObjectWriter}
&nbsp;     * instances of proper sub-type
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    protected ObjectWriter _newWriter(SerializationConfig config,
&nbsp;            JavaType rootType, PrettyPrinter pp) {
<b class="nc">&nbsp;        return new ObjectWriter(this, config, rootType, pp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Versioned impl
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that will return version information stored in and read from jar
&nbsp;     * that contains this class.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Version version() {
<b class="nc">&nbsp;        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Module registration, discovery
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for registering a module that can extend functionality
&nbsp;     * provided by this mapper; for example, by adding providers for
&nbsp;     * custom serializers and deserializers.
&nbsp;     * 
&nbsp;     * @param module Module to register
&nbsp;     */
&nbsp;    public ObjectMapper registerModule(Module module)
&nbsp;    {
<b class="nc">&nbsp;        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {</b>
<b class="nc">&nbsp;            Object typeId = module.getTypeId();</b>
<b class="nc">&nbsp;            if (typeId != null) {</b>
<b class="nc">&nbsp;                if (_registeredModuleTypes == null) {</b>
&nbsp;                    // plus let&#39;s keep them in order too, easier to debug or expose
&nbsp;                    // in registration order if that matter
<b class="nc">&nbsp;                    _registeredModuleTypes = new LinkedHashSet&lt;Object&gt;();</b>
&nbsp;                }
&nbsp;                // try adding; if already had it, should skip
<b class="nc">&nbsp;                if (!_registeredModuleTypes.add(typeId)) {</b>
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        /* Let&#39;s ensure we have access to name and version information, 
&nbsp;         * even if we do not have immediate use for either. This way we know
&nbsp;         * that they will be available from beginning
&nbsp;         */
<b class="nc">&nbsp;        String name = module.getModuleName();</b>
<b class="nc">&nbsp;        if (name == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Module without defined name&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        Version version = module.version();</b>
<b class="nc">&nbsp;        if (version == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Module without defined version&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final ObjectMapper mapper = this;</b>
&nbsp;        
&nbsp;        // And then call registration
<b class="nc">&nbsp;        module.setupModule(new Module.SetupContext()</b>
<b class="nc">&nbsp;        {</b>
&nbsp;            // // // Accessors
&nbsp;
&nbsp;            @Override
&nbsp;            public Version getMapperVersion() {
<b class="nc">&nbsp;                return version();</b>
&nbsp;            }
&nbsp;
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            @Override
&nbsp;            public &lt;C extends ObjectCodec&gt; C getOwner() {
&nbsp;                // why do we need the cast here?!?
<b class="nc">&nbsp;                return (C) mapper;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeFactory getTypeFactory() {
<b class="nc">&nbsp;                return _typeFactory;</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public boolean isEnabled(MapperFeature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled(DeserializationFeature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public boolean isEnabled(SerializationFeature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled(JsonFactory.Feature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled(JsonParser.Feature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled(JsonGenerator.Feature f) {
<b class="nc">&nbsp;                return mapper.isEnabled(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            // // // Mutant accessors
&nbsp;
&nbsp;            @Override
&nbsp;            public MutableConfigOverride configOverride(Class&lt;?&gt; type) {
<b class="nc">&nbsp;                return mapper.configOverride(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            // // // Methods for registering handlers: deserializers
&nbsp;
&nbsp;            @Override
&nbsp;            public void addDeserializers(Deserializers d) {
<b class="nc">&nbsp;                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);</b>
<b class="nc">&nbsp;                mapper._deserializationContext = mapper._deserializationContext.with(df);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void addKeyDeserializers(KeyDeserializers d) {
<b class="nc">&nbsp;                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);</b>
<b class="nc">&nbsp;                mapper._deserializationContext = mapper._deserializationContext.with(df);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
<b class="nc">&nbsp;                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);</b>
<b class="nc">&nbsp;                mapper._deserializationContext = mapper._deserializationContext.with(df);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // // // Methods for registering handlers: serializers
&nbsp;            
&nbsp;            @Override
&nbsp;            public void addSerializers(Serializers s) {
<b class="nc">&nbsp;                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void addKeySerializers(Serializers s) {
<b class="nc">&nbsp;                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
<b class="nc">&nbsp;                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);</b>
&nbsp;            }
&nbsp;
&nbsp;            // // // Methods for registering handlers: other
&nbsp;            
&nbsp;            @Override
&nbsp;            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
<b class="nc">&nbsp;                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);</b>
<b class="nc">&nbsp;                mapper._deserializationContext = mapper._deserializationContext.with(df);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void addTypeModifier(TypeModifier modifier) {
<b class="nc">&nbsp;                TypeFactory f = mapper._typeFactory;</b>
<b class="nc">&nbsp;                f = f.withModifier(modifier);</b>
<b class="nc">&nbsp;                mapper.setTypeFactory(f);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void addValueInstantiators(ValueInstantiators instantiators) {
<b class="nc">&nbsp;                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);</b>
<b class="nc">&nbsp;                mapper._deserializationContext = mapper._deserializationContext.with(df);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void setClassIntrospector(ClassIntrospector ci) {
<b class="nc">&nbsp;                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);</b>
<b class="nc">&nbsp;                mapper._serializationConfig = mapper._serializationConfig.with(ci);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
<b class="nc">&nbsp;                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);</b>
<b class="nc">&nbsp;                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
<b class="nc">&nbsp;                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);</b>
<b class="nc">&nbsp;                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void registerSubtypes(Class&lt;?&gt;... subtypes) {
<b class="nc">&nbsp;                mapper.registerSubtypes(subtypes);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void registerSubtypes(NamedType... subtypes) {
<b class="nc">&nbsp;                mapper.registerSubtypes(subtypes);</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public void setMixInAnnotations(Class&lt;?&gt; target, Class&lt;?&gt; mixinSource) {
<b class="nc">&nbsp;                mapper.addMixIn(target, mixinSource);</b>
&nbsp;            }
&nbsp;            
&nbsp;            @Override
&nbsp;            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
<b class="nc">&nbsp;                mapper.addHandler(handler);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void setNamingStrategy(PropertyNamingStrategy naming) {
<b class="nc">&nbsp;                mapper.setPropertyNamingStrategy(naming);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for registering specified modules in order;
&nbsp;     * functionally equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   for (Module module : modules) {
&nbsp;     *      registerModule(module);
&nbsp;     *   }
&nbsp;     *&lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    public ObjectMapper registerModules(Module... modules)
&nbsp;    {
<b class="nc">&nbsp;        for (Module module : modules) {</b>
<b class="nc">&nbsp;            registerModule(module);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for registering specified modules in order;
&nbsp;     * functionally equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   for (Module module : modules) {
&nbsp;     *      registerModule(module);
&nbsp;     *   }
&nbsp;     *&lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    public ObjectMapper registerModules(Iterable&lt;Module&gt; modules)
&nbsp;    {
<b class="nc">&nbsp;        for (Module module : modules) {</b>
<b class="nc">&nbsp;            registerModule(module);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for locating available methods, using JDK {@link ServiceLoader}
&nbsp;     * facility, along with module-provided SPI.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that method does not do any caching, so calls should be considered
&nbsp;     * potentially expensive.
&nbsp;     * 
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    public static List&lt;Module&gt; findModules() {
<b class="nc">&nbsp;        return findModules(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for locating available methods, using JDK {@link ServiceLoader}
&nbsp;     * facility, along with module-provided SPI.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that method does not do any caching, so calls should be considered
&nbsp;     * potentially expensive.
&nbsp;     * 
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    public static List&lt;Module&gt; findModules(ClassLoader classLoader)
&nbsp;    {
<b class="nc">&nbsp;        ArrayList&lt;Module&gt; modules = new ArrayList&lt;Module&gt;();</b>
<b class="nc">&nbsp;        ServiceLoader&lt;Module&gt; loader = secureGetServiceLoader(Module.class, classLoader);</b>
<b class="nc">&nbsp;        for (Module module : loader) {</b>
<b class="nc">&nbsp;            modules.add(module);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return modules;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; ServiceLoader&lt;T&gt; secureGetServiceLoader(final Class&lt;T&gt; clazz, final ClassLoader classLoader) {
<b class="nc">&nbsp;        final SecurityManager sm = System.getSecurityManager();</b>
<b class="nc">&nbsp;        if (sm == null) {</b>
<b class="nc">&nbsp;            return (classLoader == null) ?</b>
<b class="nc">&nbsp;                    ServiceLoader.load(clazz) : ServiceLoader.load(clazz, classLoader);</b>
&nbsp;        }
<b class="nc">&nbsp;        return AccessController.doPrivileged(new PrivilegedAction&lt;ServiceLoader&lt;T&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public ServiceLoader&lt;T&gt; run() {
<b class="nc">&nbsp;                return (classLoader == null) ?</b>
<b class="nc">&nbsp;                        ServiceLoader.load(clazz) : ServiceLoader.load(clazz, classLoader);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that is functionally equivalent to:
&nbsp;     *&lt;code&gt;
&nbsp;     *   mapper.registerModules(mapper.findModules());
&nbsp;     *&lt;/code&gt;
&nbsp;     *&lt;p&gt;
&nbsp;     * As with {@link #findModules()}, no caching is done for modules, so care
&nbsp;     * needs to be taken to either create and share a single mapper instance;
&nbsp;     * or to cache introspected set of modules.
&nbsp;     *
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    public ObjectMapper findAndRegisterModules() {
<b class="nc">&nbsp;        return registerModules(findModules());</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration: main config object access
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that returns the shared default {@link SerializationConfig}
&nbsp;     * object that defines configuration settings for serialization.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that since instances are immutable, you can NOT change settings
&nbsp;     * by accessing an instance and calling methods: this will simply create
&nbsp;     * new instance of config object.
&nbsp;     */
&nbsp;    public SerializationConfig getSerializationConfig() {
<b class="nc">&nbsp;        return _serializationConfig;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that returns
&nbsp;     * the shared default {@link DeserializationConfig} object
&nbsp;     * that defines configuration settings for deserialization.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that since instances are immutable, you can NOT change settings
&nbsp;     * by accessing an instance and calling methods: this will simply create
&nbsp;     * new instance of config object.
&nbsp;     */
&nbsp;    public DeserializationConfig getDeserializationConfig() {
<b class="nc">&nbsp;        return _deserializationConfig;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for getting current {@link DeserializationContext}.
&nbsp;      *&lt;p&gt;
&nbsp;     * Note that since instances are immutable, you can NOT change settings
&nbsp;     * by accessing an instance and calling methods: this will simply create
&nbsp;     * new instance of context object.
&nbsp;    */
&nbsp;    public DeserializationContext getDeserializationContext() {
<b class="nc">&nbsp;        return _deserializationContext;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration: ser/deser factory, provider access
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for setting specific {@link SerializerFactory} to use
&nbsp;     * for constructing (bean) serializers.
&nbsp;     */
&nbsp;    public ObjectMapper setSerializerFactory(SerializerFactory f) {
<b class="nc">&nbsp;        _serializerFactory = f;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for getting current {@link SerializerFactory}.
&nbsp;      *&lt;p&gt;
&nbsp;     * Note that since instances are immutable, you can NOT change settings
&nbsp;     * by accessing an instance and calling methods: this will simply create
&nbsp;     * new instance of factory object.
&nbsp;     */
&nbsp;    public SerializerFactory getSerializerFactory() {
<b class="nc">&nbsp;        return _serializerFactory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for setting &quot;blueprint&quot; {@link SerializerProvider} instance
&nbsp;     * to use as the base for actual provider instances to use for handling
&nbsp;     * caching of {@link JsonSerializer} instances.
&nbsp;     */
&nbsp;    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {
<b class="nc">&nbsp;        _serializerProvider = p;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor for the &quot;blueprint&quot; (or, factory) instance, from which instances
&nbsp;     * are created by calling {@link DefaultSerializerProvider#createInstance}.
&nbsp;     * Note that returned instance can not be directly used as it is not properly
&nbsp;     * configured: to get a properly configured instance to call, use
&nbsp;     * {@link #getSerializerProviderInstance()} instead.
&nbsp;     */
&nbsp;    public SerializerProvider getSerializerProvider() {
<b class="nc">&nbsp;        return _serializerProvider;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor for constructing and returning a {@link SerializerProvider}
&nbsp;     * instance that may be used for accessing serializers. This is same as
&nbsp;     * calling {@link #getSerializerProvider}, and calling &lt;code&gt;createInstance&lt;/code&gt;
&nbsp;     * on it.
&nbsp;     *
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    public SerializerProvider getSerializerProviderInstance() {
<b class="nc">&nbsp;        return _serializerProvider(_serializationConfig);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration: mix-in annotations
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method to use for defining mix-in annotations to use for augmenting
&nbsp;     * annotations that processable (serializable / deserializable)
&nbsp;     * classes have.
&nbsp;     * Mixing in is done when introspecting class annotations and properties.
&nbsp;     * Map passed contains keys that are target classes (ones to augment
&nbsp;     * with new annotation overrides), and values that are source classes
&nbsp;     * (have annotations to use for augmentation).
&nbsp;     * Annotations from source classes (and their supertypes)
&nbsp;     * will &lt;b&gt;override&lt;/b&gt;
&nbsp;     * annotations that target classes (and their super-types) have.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this method will CLEAR any previously defined mix-ins
&nbsp;     * for this mapper.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper setMixIns(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; sourceMixins)
&nbsp;    {
&nbsp;        // NOTE: does NOT change possible externally configured resolver, just local defs
<b class="nc">&nbsp;        _mixIns.setLocalDefinitions(sourceMixins);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to use for adding mix-in annotations to use for augmenting
&nbsp;     * specified class or interface. All annotations from
&nbsp;     * &lt;code&gt;mixinSource&lt;/code&gt; are taken to override annotations
&nbsp;     * that &lt;code&gt;target&lt;/code&gt; (or its supertypes) has.
&nbsp;     *
&nbsp;     * @param target Class (or interface) whose annotations to effectively override
&nbsp;     * @param mixinSource Class (or interface) whose annotations are to
&nbsp;     *   be &quot;added&quot; to target&#39;s annotations, overriding as necessary
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper addMixIn(Class&lt;?&gt; target, Class&lt;?&gt; mixinSource)
&nbsp;    {
<b class="nc">&nbsp;        _mixIns.addLocalDefinition(target, mixinSource);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be called to specify given resolver for locating
&nbsp;     * mix-in classes to use, overriding directly added mappings.
&nbsp;     * Note that direct mappings are not cleared, but they are only applied
&nbsp;     * if resolver does not provide mix-in matches.
&nbsp;     *
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver)
&nbsp;    {
<b class="nc">&nbsp;        SimpleMixInResolver r = _mixIns.withOverrides(resolver);</b>
<b class="nc">&nbsp;        if (r != _mixIns) {</b>
<b class="nc">&nbsp;            _mixIns = r;</b>
<b class="nc">&nbsp;            _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);</b>
<b class="nc">&nbsp;            _serializationConfig = new SerializationConfig(_serializationConfig, r);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public Class&lt;?&gt; findMixInClassFor(Class&lt;?&gt; cls) {
<b class="nc">&nbsp;        return _mixIns.findMixInClassFor(cls);</b>
&nbsp;    }
&nbsp;
&nbsp;    // For testing only:
&nbsp;    public int mixInCount() {
<b class="nc">&nbsp;        return _mixIns.localSize();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void setMixInAnnotations(Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; sourceMixins) {
<b class="nc">&nbsp;        setMixIns(sourceMixins);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final void addMixInAnnotations(Class&lt;?&gt; target, Class&lt;?&gt; mixinSource) {
<b class="nc">&nbsp;        addMixIn(target, mixinSource);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, introspection
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for accessing currently configured visibility checker;
&nbsp;     * object used for determining whether given property element
&nbsp;     * (method, field, constructor) can be auto-detected or not.
&nbsp;     */
&nbsp;    public VisibilityChecker&lt;?&gt; getVisibilityChecker() {
<b class="nc">&nbsp;        return _serializationConfig.getDefaultVisibilityChecker();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.6 use {@link #setVisibility(VisibilityChecker)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void setVisibilityChecker(VisibilityChecker&lt;?&gt; vc) {
<b class="nc">&nbsp;        setVisibility(vc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for setting currently configured {@link VisibilityChecker},
&nbsp;     * object used for determining whether given property element
&nbsp;     * (method, field, constructor) can be auto-detected or not.
&nbsp;     * This default checker is used if no per-class overrides
&nbsp;     * are defined.
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectMapper setVisibility(VisibilityChecker&lt;?&gt; vc) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(vc);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(vc);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method that allows changing configuration for
&nbsp;     * underlying {@link VisibilityChecker}s, to change details of what kinds of
&nbsp;     * properties are auto-detected.
&nbsp;     * Basically short cut for doing:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  mapper.setVisibilityChecker(
&nbsp;     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)
&nbsp;     *  );
&nbsp;     *&lt;/pre&gt;
&nbsp;     * one common use case would be to do:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
&nbsp;     *&lt;/pre&gt;
&nbsp;     * which would make all member fields serializable without further annotations,
&nbsp;     * instead of just public fields (default setting).
&nbsp;     * 
&nbsp;     * @param forMethod Type of property descriptor affected (field, getter/isGetter,
&nbsp;     *     setter, creator)
&nbsp;     * @param visibility Minimum visibility to require for the property descriptors of type
&nbsp;     * 
&nbsp;     * @return Modified mapper instance (that is, &quot;this&quot;), to allow chaining
&nbsp;     *    of configuration calls
&nbsp;     */
&nbsp;    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)
&nbsp;    {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for accessing subtype resolver in use.
&nbsp;     */
&nbsp;    public SubtypeResolver getSubtypeResolver() {
<b class="nc">&nbsp;        return _subtypeResolver;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for setting custom subtype resolver to use.
&nbsp;     */
&nbsp;    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {
<b class="nc">&nbsp;        _subtypeResolver = str;</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(str);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(str);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for setting {@link AnnotationIntrospector} used by this
&nbsp;     * mapper instance for both serialization and deserialization.
&nbsp;     * Note that doing this will replace the current introspector, which
&nbsp;     * may lead to unavailability of core Jackson annotations.
&nbsp;     * If you want to combine handling of multiple introspectors,
&nbsp;     * have a look at {@link com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair}.
&nbsp;     * 
&nbsp;     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
&nbsp;     */
&nbsp;    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(ai);</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(ai);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for changing {@link AnnotationIntrospector} instances used
&nbsp;     * by this mapper instance for serialization and deserialization,
&nbsp;     * specifying them separately so that different introspection can be
&nbsp;     * used for different aspects
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     * 
&nbsp;     * @param serializerAI {@link AnnotationIntrospector} to use for configuring
&nbsp;     *    serialization
&nbsp;     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring
&nbsp;     *    deserialization
&nbsp;     * 
&nbsp;     * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
&nbsp;     */
&nbsp;    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,
&nbsp;            AnnotationIntrospector deserializerAI) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(serializerAI);</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(deserializerAI);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for setting custom property naming strategy to use.
&nbsp;     */
&nbsp;    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(s);</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(s);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public PropertyNamingStrategy getPropertyNamingStrategy() {
&nbsp;        // arbitrary choice but let&#39;s do:
<b class="nc">&nbsp;        return _serializationConfig.getPropertyNamingStrategy();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, equivalent to calling:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  setPropertyInclusion(JsonInclude.Value.construct(incl, Include.ALWAYS));
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
<b class="nc">&nbsp;        setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS));</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for setting default POJO property inclusion strategy for serialization.
&nbsp;     *
&nbsp;     * @since 2.7
&nbsp;     */
&nbsp;    public ObjectMapper setPropertyInclusion(JsonInclude.Value incl) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.withPropertyInclusion(incl);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for specifying {@link PrettyPrinter} to use when &quot;default pretty-printing&quot;
&nbsp;     * is enabled (by enabling {@link SerializationFeature#INDENT_OUTPUT})
&nbsp;     * 
&nbsp;     * @param pp Pretty printer to use by default.
&nbsp;     * 
&nbsp;     * @return This mapper, useful for call-chaining
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Type information configuration
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that is equivalent to calling
&nbsp;     *&lt;pre&gt;
&nbsp;     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public ObjectMapper enableDefaultTyping() {
<b class="nc">&nbsp;        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that is equivalent to calling
&nbsp;     *&lt;pre&gt;
&nbsp;     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {
<b class="nc">&nbsp;        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling automatic inclusion of type information, needed
&nbsp;     * for proper deserialization of polymorphic types (unless types
&nbsp;     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).
&nbsp;     *&lt;P&gt;
&nbsp;     * NOTE: use of &lt;code&gt;JsonTypeInfo.As#EXTERNAL_PROPERTY&lt;/code&gt; &lt;b&gt;NOT SUPPORTED&lt;/b&gt;;
&nbsp;     * and attempts of do so will throw an {@link IllegalArgumentException} to make
&nbsp;     * this limitation explicit.
&nbsp;     * 
&nbsp;     * @param applicability Defines kinds of types for which additional type information
&nbsp;     *    is added; see {@link DefaultTyping} for more information.
&nbsp;     */
&nbsp;    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)
&nbsp;    {
&nbsp;        /* 18-Sep-2014, tatu: Let&#39;s add explicit check to ensure no one tries to
&nbsp;         *   use &quot;As.EXTERNAL_PROPERTY&quot;, since that will not work (with 2.5+)
&nbsp;         */
<b class="nc">&nbsp;        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can not use includeAs of &quot;+includeAs);</b>
&nbsp;        }
&nbsp;        
<b class="nc">&nbsp;        TypeResolverBuilder&lt;?&gt; typer = new DefaultTypeResolverBuilder(applicability);</b>
&nbsp;        // we&#39;ll always use full class name, when using defaulting
<b class="nc">&nbsp;        typer = typer.init(JsonTypeInfo.Id.CLASS, null);</b>
<b class="nc">&nbsp;        typer = typer.inclusion(includeAs);</b>
<b class="nc">&nbsp;        return setDefaultTyping(typer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling automatic inclusion of type information -- needed
&nbsp;     * for proper deserialization of polymorphic types (unless types
&nbsp;     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --
&nbsp;     * using &quot;As.PROPERTY&quot; inclusion mechanism and specified property name
&nbsp;     * to use for inclusion (default being &quot;@class&quot; since default type information
&nbsp;     * always uses class name as type identifier)
&nbsp;     */
&nbsp;    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)
&nbsp;    {
<b class="nc">&nbsp;        TypeResolverBuilder&lt;?&gt; typer = new DefaultTypeResolverBuilder(applicability);</b>
&nbsp;        // we&#39;ll always use full class name, when using defaulting
<b class="nc">&nbsp;        typer = typer.init(JsonTypeInfo.Id.CLASS, null);</b>
<b class="nc">&nbsp;        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);</b>
<b class="nc">&nbsp;        typer = typer.typeProperty(propertyName);</b>
<b class="nc">&nbsp;        return setDefaultTyping(typer);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for disabling automatic inclusion of type information; if so, only
&nbsp;     * explicitly annotated types (ones with
&nbsp;     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have
&nbsp;     * additional embedded type information.
&nbsp;     */
&nbsp;    public ObjectMapper disableDefaultTyping() {
<b class="nc">&nbsp;        return setDefaultTyping(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling automatic inclusion of type information, using
&nbsp;     * specified handler object for determining which types this affects,
&nbsp;     * as well as details of how information is embedded.
&nbsp;     * 
&nbsp;     * @param typer Type information inclusion handler
&nbsp;     */
&nbsp;    public ObjectMapper setDefaultTyping(TypeResolverBuilder&lt;?&gt; typer) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(typer);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(typer);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for registering specified class as a subtype, so that
&nbsp;     * typename-based resolution can link supertypes to subtypes
&nbsp;     * (as an alternative to using annotations).
&nbsp;     * Type for given class is determined from appropriate annotation;
&nbsp;     * or if missing, default name (unqualified class name)
&nbsp;     */
&nbsp;    public void registerSubtypes(Class&lt;?&gt;... classes) {
<b class="nc">&nbsp;        getSubtypeResolver().registerSubtypes(classes);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for registering specified class as a subtype, so that
&nbsp;     * typename-based resolution can link supertypes to subtypes
&nbsp;     * (as an alternative to using annotations).
&nbsp;     * Name may be provided as part of argument, but if not will
&nbsp;     * be based on annotations or use default name (unqualified
&nbsp;     * class name).
&nbsp;     */
&nbsp;    public void registerSubtypes(NamedType... types) {
<b class="nc">&nbsp;        getSubtypeResolver().registerSubtypes(types);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, basic type handling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor for getting a mutable configuration override object for
&nbsp;     * given type, needed to add or change per-type overrides applied
&nbsp;     * to properties of given type.
&nbsp;     * Usage is through returned object by colling &quot;setter&quot; methods, which
&nbsp;     * directly modify override object and take effect directly.
&nbsp;     * For example you can do
&nbsp;     *&lt;pre&gt;
&nbsp;     *   mapper.configOverride(java.util.Date.class)
&nbsp;     *       .setFormat(JsonFormat.Value.forPattern(&quot;yyyy-MM-dd&quot;));
&nbsp;     *&lt;pre&gt;
&nbsp;     * to change the default format to use for properties of type
&nbsp;     * {@link java.util.Date} (possibly further overridden by per-property
&nbsp;     * annotations)
&nbsp;     *
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public MutableConfigOverride configOverride(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        return _propertyOverrides.findOrCreateOverride(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, basic type handling
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Accessor for getting currently configured {@link TypeFactory} instance.
&nbsp;     */
&nbsp;    public TypeFactory getTypeFactory() {
<b class="nc">&nbsp;        return _typeFactory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to override {@link TypeFactory} instance
&nbsp;     * used by this mapper.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: will also set {@link TypeFactory} that deserialization and
&nbsp;     * serialization config objects use.
&nbsp;     */
&nbsp;    public ObjectMapper setTypeFactory(TypeFactory f)
&nbsp;    {
<b class="nc">&nbsp;        _typeFactory = f;</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(f);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method for constructing {@link JavaType} out of given
&nbsp;     * type (typically &lt;code&gt;java.lang.Class&lt;/code&gt;), but without explicit
&nbsp;     * context.
&nbsp;     */
&nbsp;    public JavaType constructType(Type t) {
<b class="nc">&nbsp;        return _typeFactory.constructType(t);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, deserialization
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to get hold of {@link JsonNodeFactory}
&nbsp;     * that this mapper will use when directly constructing
&nbsp;     * root {@link JsonNode} instances for Trees.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: this is just a shortcut for calling
&nbsp;     *&lt;pre&gt;
&nbsp;     *   getDeserializationConfig().getNodeFactory()
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public JsonNodeFactory getNodeFactory() {
<b class="nc">&nbsp;        return _deserializationConfig.getNodeFactory();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for specifying {@link JsonNodeFactory} to use for
&nbsp;     * constructing root level tree nodes (via method
&nbsp;     * {@link #createObjectNode}
&nbsp;     */
&nbsp;    public ObjectMapper setNodeFactory(JsonNodeFactory f) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for adding specified {@link DeserializationProblemHandler}
&nbsp;     * to be used for handling specific problems during deserialization.
&nbsp;     */
&nbsp;    public ObjectMapper addHandler(DeserializationProblemHandler h) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.withHandler(h);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for removing all registered {@link DeserializationProblemHandler}s
&nbsp;     * instances from this mapper.
&nbsp;     */
&nbsp;    public ObjectMapper clearProblemHandlers() {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that allows overriding of the underlying {@link DeserializationConfig}
&nbsp;     * object.
&nbsp;     * It is added as a fallback method that may be used if no other configuration
&nbsp;     * modifier method works: it should not be used if there are alternatives,
&nbsp;     * and its use is generally discouraged.
&nbsp;     *&lt;p&gt;
&nbsp;     * &lt;b&gt;NOTE&lt;/b&gt;: only use this method if you know what you are doing -- it allows
&nbsp;     * by-passing some of checks applied to other configuration methods.
&nbsp;     * Also keep in mind that as with all configuration of {@link ObjectMapper},
&nbsp;     * this is only thread-safe if done before calling any deserialization methods.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public ObjectMapper setConfig(DeserializationConfig config) {
<b class="nc">&nbsp;        _deserializationConfig = config;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, serialization
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.6, use {@link #setFilterProvider} instead (allows chaining)
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void setFilters(FilterProvider filterProvider) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.withFilters(filterProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for configuring this mapper to use specified {@link FilterProvider} for
&nbsp;     * mapping Filter Ids to actual filter instances.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that usually it is better to use method {@link #writer(FilterProvider)};
&nbsp;     * however, sometimes
&nbsp;     * this method is more convenient. For example, some frameworks only allow configuring
&nbsp;     * of ObjectMapper instances and not {@link ObjectWriter}s.
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectMapper setFilterProvider(FilterProvider filterProvider) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.withFilters(filterProvider);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that will configure default {@link Base64Variant} that
&nbsp;     * &lt;code&gt;byte[]&lt;/code&gt; serializers and deserializers will use.
&nbsp;     * 
&nbsp;     * @param v Base64 variant to use
&nbsp;     * 
&nbsp;     * @return This mapper, for convenience to allow chaining
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public ObjectMapper setBase64Variant(Base64Variant v) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(v);</b>
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(v);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that allows overriding of the underlying {@link SerializationConfig}
&nbsp;     * object, which contains serialization-specific configuration settings.
&nbsp;     * It is added as a fallback method that may be used if no other configuration
&nbsp;     * modifier method works: it should not be used if there are alternatives,
&nbsp;     * and its use is generally discouraged.
&nbsp;     *&lt;p&gt;
&nbsp;     * &lt;b&gt;NOTE&lt;/b&gt;: only use this method if you know what you are doing -- it allows
&nbsp;     * by-passing some of checks applied to other configuration methods.
&nbsp;     * Also keep in mind that as with all configuration of {@link ObjectMapper},
&nbsp;     * this is only thread-safe if done before calling any serialization methods.
&nbsp;     * 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public ObjectMapper setConfig(SerializationConfig config) {
<b class="nc">&nbsp;        _serializationConfig = config;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, other
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to get hold of {@link JsonFactory} that this
&nbsp;     * mapper uses if it needs to construct {@link JsonParser}s
&nbsp;     * and/or {@link JsonGenerator}s.
&nbsp;     *
&nbsp;     * @return {@link JsonFactory} that this mapper uses when it needs to
&nbsp;     *   construct Json parser and generators
&nbsp;     */
&nbsp;    @Override
<b class="nc">&nbsp;    public JsonFactory getFactory() { return _jsonFactory; }</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * @deprecated Since 2.1: Use {@link #getFactory} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @Override
<b class="nc">&nbsp;    public JsonFactory getJsonFactory() { return getFactory(); }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Method for configuring the default {@link DateFormat} to use when serializing time
&nbsp;     * values as Strings, and deserializing from JSON Strings.
&nbsp;     * This is preferably to directly modifying {@link SerializationConfig} and
&nbsp;     * {@link DeserializationConfig} instances.
&nbsp;     * If you need per-request configuration, use {@link #writer(DateFormat)} to
&nbsp;     * create properly configured {@link ObjectWriter} and use that; this because
&nbsp;     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only
&nbsp;     * thread-safe when configuring methods (such as this one) are NOT called.
&nbsp;     */
&nbsp;    public ObjectMapper setDateFormat(DateFormat dateFormat)
&nbsp;    {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(dateFormat);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(dateFormat);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public DateFormat getDateFormat() {
&nbsp;        // arbitrary choice but let&#39;s do:
<b class="nc">&nbsp;        return _serializationConfig.getDateFormat();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for configuring {@link HandlerInstantiator} to use for creating
&nbsp;     * instances of handlers (such as serializers, deserializers, type and type
&nbsp;     * id resolvers), given a class.
&nbsp;     *
&nbsp;     * @param hi Instantiator to use; if null, use the default implementation
&nbsp;     */
&nbsp;    public Object setHandlerInstantiator(HandlerInstantiator hi)
&nbsp;    {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(hi);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(hi);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for configuring {@link InjectableValues} which used to find
&nbsp;     * values to inject.
&nbsp;     */
&nbsp;    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {
<b class="nc">&nbsp;        _injectableValues = injectableValues;</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public InjectableValues getInjectableValues() {
<b class="nc">&nbsp;        return _injectableValues;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for overriding default locale to use for formatting.
&nbsp;     * Default value used is {@link Locale#getDefault()}.
&nbsp;     */
&nbsp;    public ObjectMapper setLocale(Locale l) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(l);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(l);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for overriding default TimeZone to use for formatting.
&nbsp;     * Default value used is UTC (NOT default TimeZone of JVM).
&nbsp;     */
&nbsp;    public ObjectMapper setTimeZone(TimeZone tz) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(tz);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(tz);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: MapperFeature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for checking whether given {@link MapperFeature} is enabled.
&nbsp;     */
&nbsp;    public boolean isEnabled(MapperFeature f) {
&nbsp;        // ok to use either one, should be kept in sync
<b class="nc">&nbsp;        return _serializationConfig.isEnabled(f);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for changing state of an on/off mapper feature for
&nbsp;     * this mapper instance.
&nbsp;     */
&nbsp;    public ObjectMapper configure(MapperFeature f, boolean state) {
<b class="nc">&nbsp;        _serializationConfig = state ?</b>
<b class="nc">&nbsp;                _serializationConfig.with(f) : _serializationConfig.without(f);</b>
<b class="nc">&nbsp;        _deserializationConfig = state ?</b>
<b class="nc">&nbsp;                _deserializationConfig.with(f) : _deserializationConfig.without(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link MapperConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper enable(MapperFeature... f) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(f);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper disable(MapperFeature... f) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.without(f);</b>
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.without(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: SerializationFeature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for checking whether given serialization-specific
&nbsp;     * feature is enabled.
&nbsp;     */
&nbsp;    public boolean isEnabled(SerializationFeature f) {
<b class="nc">&nbsp;        return _serializationConfig.isEnabled(f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for changing state of an on/off serialization feature for
&nbsp;     * this object mapper.
&nbsp;     */
&nbsp;    public ObjectMapper configure(SerializationFeature f, boolean state) {
<b class="nc">&nbsp;        _serializationConfig = state ?</b>
<b class="nc">&nbsp;                _serializationConfig.with(f) : _serializationConfig.without(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} feature.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper enable(SerializationFeature f) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper enable(SerializationFeature first,
&nbsp;            SerializationFeature... f) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.with(first, f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper disable(SerializationFeature f) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.without(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper disable(SerializationFeature first,
&nbsp;            SerializationFeature... f) {
<b class="nc">&nbsp;        _serializationConfig = _serializationConfig.without(first, f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: DeserializationFeature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method for checking whether given deserialization-specific
&nbsp;     * feature is enabled.
&nbsp;     */
&nbsp;    public boolean isEnabled(DeserializationFeature f) {
<b class="nc">&nbsp;        return _deserializationConfig.isEnabled(f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for changing state of an on/off deserialization feature for
&nbsp;     * this object mapper.
&nbsp;     */
&nbsp;    public ObjectMapper configure(DeserializationFeature f, boolean state) {
<b class="nc">&nbsp;        _deserializationConfig = state ?</b>
<b class="nc">&nbsp;                _deserializationConfig.with(f) : _deserializationConfig.without(f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper enable(DeserializationFeature feature) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(feature);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper enable(DeserializationFeature first,
&nbsp;            DeserializationFeature... f) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.with(first, f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper disable(DeserializationFeature feature) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.without(feature);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link DeserializationConfig} features.
&nbsp;     * Modifies and returns this instance; no new object is created.
&nbsp;     */
&nbsp;    public ObjectMapper disable(DeserializationFeature first,
&nbsp;            DeserializationFeature... f) {
<b class="nc">&nbsp;        _deserializationConfig = _deserializationConfig.without(first, f);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: JsonParser.Feature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    public boolean isEnabled(JsonParser.Feature f) {
<b class="nc">&nbsp;        return _deserializationConfig.isEnabled(f, _jsonFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s
&nbsp;     * for parser instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method
&nbsp;     * on {@link #getFactory}.
&nbsp;     */
&nbsp;    public ObjectMapper configure(JsonParser.Feature f, boolean state) {
<b class="nc">&nbsp;        _jsonFactory.configure(f, state);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s
&nbsp;     * for parser instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method on {@link #getFactory}.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper enable(JsonParser.Feature... features) {
<b class="nc">&nbsp;        for (JsonParser.Feature f : features) {</b>
<b class="nc">&nbsp;            _jsonFactory.enable(f);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s
&nbsp;     * for parser instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method on {@link #getFactory}.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper disable(JsonParser.Feature... features) {
<b class="nc">&nbsp;        for (JsonParser.Feature f : features) {</b>
<b class="nc">&nbsp;            _jsonFactory.disable(f);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: JsonGenerator.Feature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    public boolean isEnabled(JsonGenerator.Feature f) {
<b class="nc">&nbsp;        return _serializationConfig.isEnabled(f, _jsonFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for changing state of an on/off {@link JsonGenerator} feature for
&nbsp;     * generator instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method
&nbsp;     * on {@link #getFactory}.
&nbsp;     */
&nbsp;    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {
<b class="nc">&nbsp;        _jsonFactory.configure(f,  state);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s
&nbsp;     * for parser instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method on {@link #getFactory}.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper enable(JsonGenerator.Feature... features) {
<b class="nc">&nbsp;        for (JsonGenerator.Feature f : features) {</b>
<b class="nc">&nbsp;            _jsonFactory.enable(f);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s
&nbsp;     * for parser instances this object mapper creates.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that this is equivalent to directly calling same method on {@link #getFactory}.
&nbsp;     *
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectMapper disable(JsonGenerator.Feature... features) {
<b class="nc">&nbsp;        for (JsonGenerator.Feature f : features) {</b>
<b class="nc">&nbsp;            _jsonFactory.disable(f);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Configuration, simple features: JsonFactory.Feature
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;    
&nbsp;    /**
&nbsp;     * Convenience method, equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *  getJsonFactory().isEnabled(f);
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    public boolean isEnabled(JsonFactory.Feature f) {
<b class="nc">&nbsp;        return _jsonFactory.isEnabled(f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API (from ObjectCodec): deserialization
&nbsp;    /* (mapping from JSON to Java types);
&nbsp;    /* main methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content into a non-container
&nbsp;     * type (it can be an array type, however): typically a bean, array
&nbsp;     * or a wrapper type (like {@link java.lang.Boolean}).
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: this method should NOT be used if the result type is a
&nbsp;     * container ({@link java.util.Collection} or {@link java.util.Map}.
&nbsp;     * The reason is that due to type erasure, key and value types
&nbsp;     * can not be introspected when using this method.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @Override
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(JsonParser p, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content into a Java type, reference
&nbsp;     * to which is passed as argument. Type is passed using so-called
&nbsp;     * &quot;super type token&quot; (see )
&nbsp;     * and specifically needs to be used if the root type is a 
&nbsp;     * parameterized (generic) container type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @Override
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(JsonParser p, TypeReference&lt;?&gt; valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content into a Java type, reference
&nbsp;     * to which is passed as argument. Type is passed using 
&nbsp;     * Jackson specific type; instance of which can be constructed using
&nbsp;     * {@link TypeFactory}.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @Override
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public final &lt;T&gt; T readValue(JsonParser p, ResolvedType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readValue(getDeserializationConfig(), p, (JavaType) valueType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(JsonParser p, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readValue(getDeserializationConfig(), p, valueType);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed
&nbsp;     * using set of {@link JsonNode} instances. Returns
&nbsp;     * root of the resulting tree (where root can consist
&nbsp;     * of just a single node if the current event is a
&nbsp;     * value event, not container).
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public &lt;T extends TreeNode&gt; T readTree(JsonParser p)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
&nbsp;        /* 02-Mar-2009, tatu: One twist; deserialization provider
&nbsp;         *   will map JSON null straight into Java null. But what
&nbsp;         *   we want to return is the &quot;null node&quot; instead.
&nbsp;         */
&nbsp;        /* 05-Aug-2011, tatu: Also, must check for EOF here before
&nbsp;         *   calling readValue(), since that&#39;ll choke on it otherwise
&nbsp;         */
<b class="nc">&nbsp;        DeserializationConfig cfg = getDeserializationConfig();</b>
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == null) {</b>
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readValue(cfg, p, JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        if (n == null) {</b>
<b class="nc">&nbsp;            n = getNodeFactory().nullNode();</b>
&nbsp;        }
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        T result = (T) n;</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, equivalent in function to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   readerFor(valueType).readValues(p);
&nbsp;     *&lt;/pre&gt;
&nbsp;     *&lt;p&gt;
&nbsp;     * Method for reading sequence of Objects from parser stream.
&nbsp;     * Sequence can be either root-level &quot;unwrapped&quot; sequence (without surrounding
&nbsp;     * JSON array), or a sequence contained in a JSON Array.
&nbsp;     * In either case {@link JsonParser} &lt;b&gt;MUST&lt;/b&gt; point to the first token of
&nbsp;     * the first element, OR not point to any token (in which case it is advanced
&nbsp;     * to the next token). This means, specifically, that for wrapped sequences,
&nbsp;     * parser MUST NOT point to the surrounding &lt;code&gt;START_ARRAY&lt;/code&gt; (one that
&nbsp;     * contains values to read) but rather to the token following it which is the first
&nbsp;     * token of the first value to read.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that {@link ObjectReader} has more complete set of variants.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public &lt;T&gt; MappingIterator&lt;T&gt; readValues(JsonParser p, ResolvedType valueType)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        return readValues(p, (JavaType) valueType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, equivalent in function to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   readerFor(valueType).readValues(p);
&nbsp;     *&lt;/pre&gt;
&nbsp;     *&lt;p&gt;
&nbsp;     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
&nbsp;     */
&nbsp;    public &lt;T&gt; MappingIterator&lt;T&gt; readValues(JsonParser p, JavaType valueType)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        DeserializationConfig config = getDeserializationConfig();</b>
<b class="nc">&nbsp;        DeserializationContext ctxt = createDeserializationContext(p, config);</b>
<b class="nc">&nbsp;        JsonDeserializer&lt;?&gt; deser = _findRootDeserializer(ctxt, valueType);</b>
&nbsp;        // false -&gt; do NOT close JsonParser (since caller passed it)
<b class="nc">&nbsp;        return new MappingIterator&lt;T&gt;(valueType, p, ctxt, deser,</b>
&nbsp;                false, null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method, equivalent in function to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   readerFor(valueType).readValues(p);
&nbsp;     *&lt;/pre&gt;
&nbsp;     *&lt;p&gt;
&nbsp;     * Type-safe overload of {@link #readValues(JsonParser, ResolvedType)}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public &lt;T&gt; MappingIterator&lt;T&gt; readValues(JsonParser p, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        return readValues(p, _typeFactory.constructType(valueType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for reading sequence of Objects from parser stream.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public &lt;T&gt; MappingIterator&lt;T&gt; readValues(JsonParser p, TypeReference&lt;?&gt; valueTypeRef)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        return readValues(p, _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API not included in ObjectCodec: deserialization
&nbsp;    /* (mapping from JSON to Java types)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed
&nbsp;     * using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist
&nbsp;     * of just a single node if the current event is a
&nbsp;     * value event, not container).
&nbsp;     *&lt;p&gt;
&nbsp;     * If a low-level I/O problem (missing input, network error) occurs,
&nbsp;     * a {@link IOException} will be thrown.
&nbsp;     * If a parsing problem occurs (invalid JSON),
&nbsp;     * {@link JsonParseException} will be thrown.
&nbsp;     * If no content is found from input (end-of-input), Java
&nbsp;     * &lt;code&gt;null&lt;/code&gt; will be returned.
&nbsp;     * 
&nbsp;     * @param in Input stream used to read JSON content
&nbsp;     *   for building the JSON tree.
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     *   
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    public JsonNode readTree(InputStream in)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed
&nbsp;     * using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist
&nbsp;     * of just a single node if the current event is a
&nbsp;     * value event, not container).
&nbsp;     *&lt;p&gt;
&nbsp;     * If a low-level I/O problem (missing input, network error) occurs,
&nbsp;     * a {@link IOException} will be thrown.
&nbsp;     * If a parsing problem occurs (invalid JSON),
&nbsp;     * {@link JsonParseException} will be thrown.
&nbsp;     * If no content is found from input (end-of-input), Java
&nbsp;     * &lt;code&gt;null&lt;/code&gt; will be returned.
&nbsp;     *
&nbsp;     * @param r Reader used to read JSON content
&nbsp;     *   for building the JSON tree.
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     */
&nbsp;    public JsonNode readTree(Reader r)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist of just a single node if the current
&nbsp;     * event is a value event, not container).
&nbsp;     *&lt;p&gt;
&nbsp;     * If a low-level I/O problem (missing input, network error) occurs,
&nbsp;     * a {@link IOException} will be thrown.
&nbsp;     * If a parsing problem occurs (invalid JSON),
&nbsp;     * {@link JsonParseException} will be thrown.
&nbsp;     * If no content is found from input (end-of-input), Java
&nbsp;     * &lt;code&gt;null&lt;/code&gt; will be returned.
&nbsp;     *
&nbsp;     * @param content JSON content to parse to build the JSON tree.
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     *
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    public JsonNode readTree(String content)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist of just a single node if the current
&nbsp;     * event is a value event, not container).
&nbsp;     *
&nbsp;     * @param content JSON content to parse to build the JSON tree.
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     *
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    public JsonNode readTree(byte[] content)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist of just a single node if the current
&nbsp;     * event is a value event, not container).
&nbsp;     *
&nbsp;     * @param file File of which contents to parse as JSON for building a tree instance
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    public JsonNode readTree(File file)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.
&nbsp;     * Returns root of the resulting tree (where root can consist of just a single node if the current
&nbsp;     * event is a value event, not container).
&nbsp;     *
&nbsp;     * @param source URL to use for fetching contents to parse as JSON for building a tree instance
&nbsp;     * 
&nbsp;     * @return a {@link JsonNode}, if valid JSON content found; null
&nbsp;     *   if input has no content to bind -- note, however, that if
&nbsp;     *   JSON &lt;code&gt;null&lt;/code&gt; token is found, it will be represented
&nbsp;     *   as a non-null {@link JsonNode} (one that returns &lt;code&gt;true&lt;/code&gt;
&nbsp;     *   for {@link JsonNode#isNull()}
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     */
&nbsp;    public JsonNode readTree(URL source)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);</b>
<b class="nc">&nbsp;        return (n == null) ? NullNode.instance : n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API (from ObjectCodec): serialization
&nbsp;    /* (mapping from Java types to Json)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * JSON output, using provided {@link JsonGenerator}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void writeValue(JsonGenerator g, Object value)
&nbsp;        throws IOException, JsonGenerationException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        SerializationConfig config = getSerializationConfig();</b>
&nbsp;
&nbsp;        /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual
&nbsp;         *    &#39;config.initialize(g)` here, since it is assumed that generator
&nbsp;         *    has been configured by caller. But for some reason we don&#39;t
&nbsp;         *    trust indentation settings...
&nbsp;         */
&nbsp;        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:
<b class="nc">&nbsp;        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {</b>
<b class="nc">&nbsp;            if (g.getPrettyPrinter() == null) {</b>
<b class="nc">&nbsp;                g.setPrettyPrinter(config.constructDefaultPrettyPrinter());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value instanceof Closeable)) {</b>
<b class="nc">&nbsp;            _writeCloseableValue(g, value, config);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            _serializerProvider(config).serializeValue(g, value);</b>
<b class="nc">&nbsp;            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {</b>
<b class="nc">&nbsp;                g.flush();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Public API (from TreeCodec via ObjectCodec): Tree Model support
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public void writeTree(JsonGenerator jgen, TreeNode rootNode)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        SerializationConfig config = getSerializationConfig();</b>
<b class="nc">&nbsp;        _serializerProvider(config).serializeValue(jgen, rootNode);</b>
<b class="nc">&nbsp;        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {</b>
<b class="nc">&nbsp;            jgen.flush();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method to serialize given JSON Tree, using generator
&nbsp;     * provided.
&nbsp;     */
&nbsp;    public void writeTree(JsonGenerator jgen, JsonNode rootNode)
&nbsp;        throws IOException, JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        SerializationConfig config = getSerializationConfig();</b>
<b class="nc">&nbsp;        _serializerProvider(config).serializeValue(jgen, rootNode);</b>
<b class="nc">&nbsp;        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {</b>
<b class="nc">&nbsp;            jgen.flush();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: return type is co-variant, as basic ObjectCodec
&nbsp;     * abstraction can not refer to concrete node types (as it&#39;s
&nbsp;     * part of core package, whereas impls are part of mapper
&nbsp;     * package)
&nbsp;     */
&nbsp;    @Override    
&nbsp;    public ObjectNode createObjectNode() {
<b class="nc">&nbsp;        return _deserializationConfig.getNodeFactory().objectNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: return type is co-variant, as basic ObjectCodec
&nbsp;     * abstraction can not refer to concrete node types (as it&#39;s
&nbsp;     * part of core package, whereas impls are part of mapper
&nbsp;     * package)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ArrayNode createArrayNode() {
<b class="nc">&nbsp;        return _deserializationConfig.getNodeFactory().arrayNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for constructing a {@link JsonParser} out of JSON tree
&nbsp;     * representation.
&nbsp;     * 
&nbsp;     * @param n Root node of the tree that resulting parser will read from
&nbsp;     */
&nbsp;    @Override
&nbsp;    public JsonParser treeAsTokens(TreeNode n) {
<b class="nc">&nbsp;        return new TreeTraversingParser((JsonNode) n, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience conversion method that will bind data given JSON tree
&nbsp;     * contains into specific value (usually bean) type.
&nbsp;     *&lt;p&gt;
&nbsp;     * Functionally equivalent to:
&nbsp;     *&lt;pre&gt;
&nbsp;     *   objectMapper.convertValue(n, valueClass);
&nbsp;     *&lt;/pre&gt;
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T treeToValue(TreeNode n, Class&lt;T&gt; valueType)
&nbsp;        throws JsonProcessingException
&nbsp;    {
&nbsp;        try {
&nbsp;            // Simple cast when we just want to cast to, say, ObjectNode
&nbsp;            // ... one caveat; while everything is Object.class, let&#39;s not take shortcut
<b class="nc">&nbsp;            if (valueType != Object.class &amp;&amp; valueType.isAssignableFrom(n.getClass())) {</b>
<b class="nc">&nbsp;                return (T) n;</b>
&nbsp;            }
&nbsp;            // 20-Apr-2016, tatu: Another thing: for VALUE_EMBEDDED_OBJECT, assume similar
&nbsp;            //    short-cut coercion
<b class="nc">&nbsp;            if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {</b>
<b class="nc">&nbsp;                if (n instanceof POJONode) {</b>
<b class="nc">&nbsp;                    Object ob = ((POJONode) n).getPojo();</b>
<b class="nc">&nbsp;                    if ((ob == null) || valueType.isInstance(ob)) {</b>
<b class="nc">&nbsp;                        return (T) ob;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return readValue(treeAsTokens(n), valueType);</b>
<b class="nc">&nbsp;        } catch (JsonProcessingException e) {</b>
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (IOException e) { // should not occur, no real i/o...</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(e.getMessage(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reverse of {@link #treeToValue}; given a value (usually bean), will
&nbsp;     * construct equivalent JSON Tree representation. Functionally similar
&nbsp;     * to serializing value into JSON and parsing JSON as tree, but
&nbsp;     * more efficient.
&nbsp;     *&lt;p&gt;
&nbsp;     * NOTE: while results are usually identical to that of serialization followed
&nbsp;     * by deserialization, this is not always the case. In some cases serialization
&nbsp;     * into intermediate representation will retain encapsulation of things like
&nbsp;     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
&nbsp;     * node identity ({@link JsonNode}). If so, result is a valid tree, but values
&nbsp;     * are not re-constructed through actual JSON representation. So if transformation
&nbsp;     * requires actual materialization of JSON (or other data format that this mapper
&nbsp;     * produces), it will be necessary to do actual serialization.
&nbsp;     * 
&nbsp;     * @param &lt;T&gt; Actual node type; usually either basic {@link JsonNode} or
&nbsp;     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}
&nbsp;     * @param fromValue Bean value to convert
&nbsp;     * @return Root node of the resulting JSON tree
&nbsp;     */
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;resource&quot; })
&nbsp;    public &lt;T extends JsonNode&gt; T valueToTree(Object fromValue)
&nbsp;        throws IllegalArgumentException
&nbsp;    {
<b class="nc">&nbsp;        if (fromValue == null) return null;</b>
<b class="nc">&nbsp;        TokenBuffer buf = new TokenBuffer(this, false);</b>
<b class="nc">&nbsp;        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {</b>
<b class="nc">&nbsp;            buf = buf.forceUseOfBigDecimal(true);</b>
&nbsp;        }
&nbsp;        JsonNode result;
&nbsp;        try {
<b class="nc">&nbsp;            writeValue(buf, fromValue);</b>
<b class="nc">&nbsp;            JsonParser p = buf.asParser();</b>
<b class="nc">&nbsp;            result = readTree(p);</b>
<b class="nc">&nbsp;            p.close();</b>
<b class="nc">&nbsp;        } catch (IOException e) { // should not occur, no real i/o...</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(e.getMessage(), e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return (T) result;</b>
&nbsp;    } 
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API, accessors
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be called to check whether mapper thinks
&nbsp;     * it could serialize an instance of given Class.
&nbsp;     * Check is done
&nbsp;     * by checking whether a serializer can be found for the type.
&nbsp;     *&lt;p&gt;
&nbsp;     * NOTE: since this method does NOT throw exceptions, but internal
&nbsp;     * processing may, caller usually has little information as to why
&nbsp;     * serialization would fail. If you want access to internal {@link Exception},
&nbsp;     * call {@link #canSerialize(Class, AtomicReference)} instead.
&nbsp;     *
&nbsp;     * @return True if mapper can find a serializer for instances of
&nbsp;     *  given class (potentially serializable), false otherwise (not
&nbsp;     *  serializable)
&nbsp;     */
&nbsp;    public boolean canSerialize(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method similar to {@link #canSerialize(Class)} but that can return
&nbsp;     * actual {@link Throwable} that was thrown when trying to construct
&nbsp;     * serializer: this may be useful in figuring out what the actual problem is.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public boolean canSerialize(Class&lt;?&gt; type, AtomicReference&lt;Throwable&gt; cause) {
<b class="nc">&nbsp;        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that can be called to check whether mapper thinks
&nbsp;     * it could deserialize an Object of given type.
&nbsp;     * Check is done by checking whether a registered deserializer can
&nbsp;     * be found or built for the type; if not (either by no mapping being
&nbsp;     * found, or through an &lt;code&gt;Exception&lt;/code&gt; being thrown, false
&nbsp;     * is returned.
&nbsp;     *&lt;p&gt;
&nbsp;     * &lt;b&gt;NOTE&lt;/b&gt;: in case an exception is thrown during course of trying
&nbsp;     * co construct matching deserializer, it will be effectively swallowed.
&nbsp;     * If you want access to that exception, call
&nbsp;     * {@link #canDeserialize(JavaType, AtomicReference)} instead.
&nbsp;     *
&nbsp;     * @return True if mapper can find a serializer for instances of
&nbsp;     *  given class (potentially serializable), false otherwise (not
&nbsp;     *  serializable)
&nbsp;     */
&nbsp;    public boolean canDeserialize(JavaType type)
&nbsp;    {
<b class="nc">&nbsp;        return createDeserializationContext(null,</b>
<b class="nc">&nbsp;                getDeserializationConfig()).hasValueDeserializerFor(type, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method similar to {@link #canDeserialize(JavaType)} but that can return
&nbsp;     * actual {@link Throwable} that was thrown when trying to construct
&nbsp;     * serializer: this may be useful in figuring out what the actual problem is.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public boolean canDeserialize(JavaType type, AtomicReference&lt;Throwable&gt; cause)
&nbsp;    {
<b class="nc">&nbsp;        return createDeserializationContext(null,</b>
<b class="nc">&nbsp;                getDeserializationConfig()).hasValueDeserializerFor(type, cause);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API, deserialization,
&nbsp;    /* convenience methods
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given file into given Java type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(File src, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given file into given Java type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(File src, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given file into given Java type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(File src, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given resource into given Java type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(URL src, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given resource into given Java type.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(URL src, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(URL src, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given JSON content String.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(String content, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given JSON content String.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(String content, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Method to deserialize JSON content from given JSON content String.
&nbsp;     * 
&nbsp;     * @throws IOException if a low-level I/O problem (unexpected end-of-input,
&nbsp;     *   network error) occurs (passed through as-is without additional wrapping -- note
&nbsp;     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
&nbsp;     *   does NOT result in wrapping of exception even if enabled)
&nbsp;     * @throws JsonParseException if underlying input contains invalid content
&nbsp;     *    of type {@link JsonParser} supports (JSON for default case)
&nbsp;     * @throws JsonMappingException if the input JSON structure does not match structure
&nbsp;     *   expected for result type (or has other mismatch issues)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(String content, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(Reader src, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(Reader src, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(Reader src, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(InputStream src, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(InputStream src, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(InputStream src, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(byte[] src, Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;    
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(byte[] src, int offset, int len, 
&nbsp;                               Class&lt;T&gt; valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(byte[] src, TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;    
&nbsp;    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
&nbsp;    public &lt;T&gt; T readValue(byte[] src, int offset, int len,
&nbsp;                           TypeReference valueTypeRef)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(byte[] src, JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(byte[] src, int offset, int len,
&nbsp;                           JavaType valueType)
&nbsp;        throws IOException, JsonParseException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(DataInput src, Class&lt;T&gt; valueType) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src),</b>
<b class="nc">&nbsp;                _typeFactory.constructType(valueType));</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T readValue(DataInput src, JavaType valueType) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API: serialization
&nbsp;    /* (mapping from Java types to JSON)
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * JSON output, written to File provided.
&nbsp;     */
&nbsp;    public void writeValue(File resultFile, Object value)
&nbsp;        throws IOException, JsonGenerationException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * JSON output, using output stream provided (using encoding
&nbsp;     * {@link JsonEncoding#UTF8}).
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: method does not close the underlying stream explicitly
&nbsp;     * here; however, {@link JsonFactory} this mapper uses may choose
&nbsp;     * to close the stream depending on its settings (by default,
&nbsp;     * it will try to close it when {@link JsonGenerator} we construct
&nbsp;     * is closed).
&nbsp;     */
&nbsp;    public void writeValue(OutputStream out, Object value)
&nbsp;        throws IOException, JsonGenerationException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.8
&nbsp;     */
&nbsp;    public void writeValue(DataOutput out, Object value)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * JSON output, using Writer provided.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: method does not close the underlying stream explicitly
&nbsp;     * here; however, {@link JsonFactory} this mapper uses may choose
&nbsp;     * to close the stream depending on its settings (by default,
&nbsp;     * it will try to close it when {@link JsonGenerator} we construct
&nbsp;     * is closed).
&nbsp;     */
&nbsp;    public void writeValue(Writer w, Object value)
&nbsp;        throws IOException, JsonGenerationException, JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        _configAndWriteValue(_jsonFactory.createGenerator(w), value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * a String. Functionally equivalent to calling
&nbsp;     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
&nbsp;     * and constructing String, but more efficient.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;resource&quot;)
&nbsp;    public String writeValueAsString(Object value)
&nbsp;        throws JsonProcessingException
&nbsp;    {
&nbsp;        // alas, we have to pull the recycler directly here...
<b class="nc">&nbsp;        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());</b>
&nbsp;        try {
<b class="nc">&nbsp;            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);</b>
<b class="nc">&nbsp;        } catch (JsonProcessingException e) { // to support [JACKSON-758]</b>
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (IOException e) { // shouldn&#39;t really happen, but is declared as possibility so:</b>
<b class="nc">&nbsp;            throw JsonMappingException.fromUnexpectedIOE(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return sw.getAndClear();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method that can be used to serialize any Java value as
&nbsp;     * a byte array. Functionally equivalent to calling
&nbsp;     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
&nbsp;     * and getting bytes, but more efficient.
&nbsp;     * Encoding used will be UTF-8.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;resource&quot;)
&nbsp;    public byte[] writeValueAsBytes(Object value)
&nbsp;        throws JsonProcessingException
&nbsp;    {
<b class="nc">&nbsp;        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());</b>
&nbsp;        try {
<b class="nc">&nbsp;            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);</b>
<b class="nc">&nbsp;        } catch (JsonProcessingException e) { // to support [JACKSON-758]</b>
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (IOException e) { // shouldn&#39;t really happen, but is declared as possibility so:</b>
<b class="nc">&nbsp;            throw JsonMappingException.fromUnexpectedIOE(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        byte[] result = bb.toByteArray();</b>
<b class="nc">&nbsp;        bb.release();</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API: constructing ObjectWriters
&nbsp;    /* for more advanced configuration
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for constructing {@link ObjectWriter}
&nbsp;     * with default settings.
&nbsp;     */
&nbsp;    public ObjectWriter writer() {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} with
&nbsp;     * specified feature enabled (compared to settings that this
&nbsp;     * mapper instance has).
&nbsp;     */
&nbsp;    public ObjectWriter writer(SerializationFeature feature) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().with(feature));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} with
&nbsp;     * specified features enabled (compared to settings that this
&nbsp;     * mapper instance has).
&nbsp;     */
&nbsp;    public ObjectWriter writer(SerializationFeature first,
&nbsp;            SerializationFeature... other) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().with(first, other));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified {@link DateFormat}; or, if
&nbsp;     * null passed, using timestamp (64-bit number.
&nbsp;     */
&nbsp;    public ObjectWriter writer(DateFormat df) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().with(df));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified JSON View (filter).
&nbsp;     */
&nbsp;    public ObjectWriter writerWithView(Class&lt;?&gt; serializationView) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().withView(serializationView));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified root type, instead of actual
&nbsp;     * runtime type of value. Type must be a super-type of runtime type.
&nbsp;     *&lt;p&gt;
&nbsp;     * Main reason for using this method is performance, as writer is able
&nbsp;     * to pre-fetch serializer to use before write, and if writer is used
&nbsp;     * more than once this avoids addition per-value serializer lookups.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectWriter writerFor(Class&lt;?&gt; rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(),</b>
<b class="nc">&nbsp;                ((rootType == null) ? null :_typeFactory.constructType(rootType)),</b>
&nbsp;                /*PrettyPrinter*/null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified root type, instead of actual
&nbsp;     * runtime type of value. Type must be a super-type of runtime type.
&nbsp;     *&lt;p&gt;
&nbsp;     * Main reason for using this method is performance, as writer is able
&nbsp;     * to pre-fetch serializer to use before write, and if writer is used
&nbsp;     * more than once this avoids addition per-value serializer lookups.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectWriter writerFor(TypeReference&lt;?&gt; rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(),</b>
<b class="nc">&nbsp;                ((rootType == null) ? null : _typeFactory.constructType(rootType)),</b>
&nbsp;                /*PrettyPrinter*/null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified root type, instead of actual
&nbsp;     * runtime type of value. Type must be a super-type of runtime type.
&nbsp;     *&lt;p&gt;
&nbsp;     * Main reason for using this method is performance, as writer is able
&nbsp;     * to pre-fetch serializer to use before write, and if writer is used
&nbsp;     * more than once this avoids addition per-value serializer lookups.
&nbsp;     * 
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public ObjectWriter writerFor(JavaType rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified pretty printer for indentation
&nbsp;     * (or if null, no pretty printer)
&nbsp;     */
&nbsp;    public ObjectWriter writer(PrettyPrinter pp) {
<b class="nc">&nbsp;        if (pp == null) { // need to use a marker to indicate explicit disabling of pp</b>
<b class="nc">&nbsp;            pp = ObjectWriter.NULL_PRETTY_PRINTER;</b>
&nbsp;        }
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using the default pretty printer for indentation
&nbsp;     */
&nbsp;    public ObjectWriter writerWithDefaultPrettyPrinter() {
<b class="nc">&nbsp;        SerializationConfig config = getSerializationConfig();</b>
<b class="nc">&nbsp;        return _newWriter(config,</b>
<b class="nc">&nbsp;                /*root type*/ null, config.getDefaultPrettyPrinter());</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * serialize objects using specified filter provider.
&nbsp;     */
&nbsp;    public ObjectWriter writer(FilterProvider filterProvider) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().withFilters(filterProvider));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * pass specific schema object to {@link JsonGenerator} used for
&nbsp;     * writing content.
&nbsp;     * 
&nbsp;     * @param schema Schema to pass to generator
&nbsp;     */
&nbsp;    public ObjectWriter writer(FormatSchema schema) {
<b class="nc">&nbsp;        _verifySchemaType(schema);</b>
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(), schema);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * use specified Base64 encoding variant for Base64-encoded binary data.
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public ObjectWriter writer(Base64Variant defaultBase64) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().with(defaultBase64));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * use specified character escaping details for output.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public ObjectWriter writer(CharacterEscapes escapes) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig()).with(escapes);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectWriter} that will
&nbsp;     * use specified default attributes.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public ObjectWriter writer(ContextAttributes attrs) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig().with(attrs));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectWriter writerWithType(Class&lt;?&gt; rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(),</b>
&nbsp;                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:
<b class="nc">&nbsp;                ((rootType == null) ? null :_typeFactory.constructType(rootType)),</b>
&nbsp;                /*PrettyPrinter*/null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectWriter writerWithType(TypeReference&lt;?&gt; rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(),</b>
&nbsp;                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:
<b class="nc">&nbsp;                ((rootType == null) ? null : _typeFactory.constructType(rootType)),</b>
&nbsp;                /*PrettyPrinter*/null);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectWriter writerWithType(JavaType rootType) {
<b class="nc">&nbsp;        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API: constructing ObjectReaders
&nbsp;    /* for more advanced configuration
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} with
&nbsp;     * default settings. Note that the resulting instance is NOT usable as is,
&nbsp;     * without defining expected value type.
&nbsp;     */
&nbsp;    public ObjectReader reader() {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig()).with(_injectableValues);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} with
&nbsp;     * specified feature enabled (compared to settings that this
&nbsp;     * mapper instance has).
&nbsp;     * Note that the resulting instance is NOT usable as is,
&nbsp;     * without defining expected value type.
&nbsp;     */
&nbsp;    public ObjectReader reader(DeserializationFeature feature) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig().with(feature));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} with
&nbsp;     * specified features enabled (compared to settings that this
&nbsp;     * mapper instance has).
&nbsp;     * Note that the resulting instance is NOT usable as is,
&nbsp;     * without defining expected value type.
&nbsp;     */
&nbsp;    public ObjectReader reader(DeserializationFeature first,
&nbsp;            DeserializationFeature... other) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig().with(first, other));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * update given Object (usually Bean, but can be a Collection or Map
&nbsp;     * as well, but NOT an array) with JSON data. Deserialization occurs
&nbsp;     * normally except that the root-level value in JSON is not used for
&nbsp;     * instantiating a new object; instead give updateable object is used
&nbsp;     * as root.
&nbsp;     * Runtime type of value object is used for locating deserializer,
&nbsp;     * unless overridden by other factory methods of {@link ObjectReader}
&nbsp;     */
&nbsp;    public ObjectReader readerForUpdating(Object valueToUpdate) {
<b class="nc">&nbsp;        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());</b>
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), t, valueToUpdate,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * read or update instances of specified type
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectReader readerFor(JavaType type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), type, null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * read or update instances of specified type
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectReader readerFor(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * read or update instances of specified type
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public ObjectReader readerFor(TypeReference&lt;?&gt; type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * use specified {@link JsonNodeFactory} for constructing JSON trees.
&nbsp;     */
&nbsp;    public ObjectReader reader(JsonNodeFactory f) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig()).with(f);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * pass specific schema object to {@link JsonParser} used for
&nbsp;     * reading content.
&nbsp;     * 
&nbsp;     * @param schema Schema to pass to parser
&nbsp;     */
&nbsp;    public ObjectReader reader(FormatSchema schema) {
<b class="nc">&nbsp;        _verifySchemaType(schema);</b>
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), null, null,</b>
&nbsp;                schema, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * use specified injectable values.
&nbsp;     * 
&nbsp;     * @param injectableValues Injectable values to use
&nbsp;     */
&nbsp;    public ObjectReader reader(InjectableValues injectableValues) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), null, null,</b>
&nbsp;                null, injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * deserialize objects using specified JSON View (filter).
&nbsp;     */
&nbsp;    public ObjectReader readerWithView(Class&lt;?&gt; view) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig().withView(view));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * use specified Base64 encoding variant for Base64-encoded binary data.
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public ObjectReader reader(Base64Variant defaultBase64) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig().with(defaultBase64));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method for constructing {@link ObjectReader} that will
&nbsp;     * use specified default attributes.
&nbsp;     * 
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public ObjectReader reader(ContextAttributes attrs) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig().with(attrs));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #readerFor(JavaType)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectReader reader(JavaType type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), type, null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #readerFor(Class)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectReader reader(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Since 2.5, use {@link #readerFor(TypeReference)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ObjectReader reader(TypeReference&lt;?&gt; type) {
<b class="nc">&nbsp;        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,</b>
&nbsp;                null, _injectableValues);
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API: convenience type conversion
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method for doing two-step conversion from given value, into
&nbsp;     * instance of given value type, if (but only if!) conversion is needed.
&nbsp;     * If given value is already of requested type, value is returned as is.
&nbsp;     *&lt;p&gt;
&nbsp;     * This method is functionally similar to first
&nbsp;     * serializing given value into JSON, and then binding JSON data into value
&nbsp;     * of given type, but should be more efficient since full serialization does
&nbsp;     * not (need to) occur.
&nbsp;     * However, same converters (serializers, deserializers) will be used as for
&nbsp;     * data binding, meaning same object mapper configuration works.
&nbsp;     *&lt;p&gt;
&nbsp;     * Note that it is possible that in some cases behavior does differ from
&nbsp;     * full serialize-then-deserialize cycle: in most case differences are
&nbsp;     * unintentional (that is, flaws to fix) and should be reported.
&nbsp;     * It is not guaranteed, however, that the behavior is 100% the same:
&nbsp;     * the goal is just to allow efficient value conversions for structurally
&nbsp;     * compatible Objects, according to standard Jackson configuration.
&nbsp;     *&lt;p&gt;
&nbsp;     * Further note that functianality is not designed to support &quot;advanced&quot; use
&nbsp;     * cases, such as conversion of polymorphic values, or cases where Object Identity
&nbsp;     * is used.
&nbsp;     *      
&nbsp;     * @throws IllegalArgumentException If conversion fails due to incompatible type;
&nbsp;     *    if so, root cause will contain underlying checked exception data binding
&nbsp;     *    functionality threw
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T convertValue(Object fromValue, Class&lt;T&gt; toValueType)
&nbsp;        throws IllegalArgumentException
&nbsp;    {
&nbsp;        // sanity check for null first:
<b class="nc">&nbsp;        if (fromValue == null) return null;</b>
<b class="nc">&nbsp;        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * See {@link #convertValue(Object, Class)}
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T convertValue(Object fromValue, TypeReference&lt;?&gt; toValueTypeRef)
&nbsp;        throws IllegalArgumentException
&nbsp;    {
<b class="nc">&nbsp;        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * See {@link #convertValue(Object, Class)}
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; T convertValue(Object fromValue, JavaType toValueType)
&nbsp;        throws IllegalArgumentException
&nbsp;    {
&nbsp;        // sanity check for null first:
<b class="nc">&nbsp;        if (fromValue == null) return null;</b>
<b class="nc">&nbsp;        return (T) _convert(fromValue, toValueType);</b>
&nbsp;    } 
&nbsp;
&nbsp;    /**
&nbsp;     * Actual conversion implementation: instead of using existing read
&nbsp;     * and write methods, much of code is inlined. Reason for this is
&nbsp;     * that we must avoid root value wrapping/unwrapping both for efficiency and
&nbsp;     * for correctness. If root value wrapping/unwrapping is actually desired,
&nbsp;     * caller must use explicit &lt;code&gt;writeValue&lt;/code&gt; and
&nbsp;     * &lt;code&gt;readValue&lt;/code&gt; methods.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;resource&quot;)
&nbsp;    protected Object _convert(Object fromValue, JavaType toValueType)
&nbsp;        throws IllegalArgumentException
&nbsp;    {        
&nbsp;        // also, as per [databind#11], consider case for simple cast
&nbsp;        /* But with caveats: one is that while everything is Object.class, we don&#39;t
&nbsp;         * want to &quot;optimize&quot; that out; and the other is that we also do not want
&nbsp;         * to lose conversions of generic types.
&nbsp;         */
<b class="nc">&nbsp;        Class&lt;?&gt; targetType = toValueType.getRawClass();</b>
<b class="nc">&nbsp;        if (targetType != Object.class</b>
<b class="nc">&nbsp;                &amp;&amp; !toValueType.hasGenericTypes()</b>
<b class="nc">&nbsp;                &amp;&amp; targetType.isAssignableFrom(fromValue.getClass())) {</b>
<b class="nc">&nbsp;            return fromValue;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Then use TokenBuffer, which is a JsonGenerator:
<b class="nc">&nbsp;        TokenBuffer buf = new TokenBuffer(this, false);</b>
<b class="nc">&nbsp;        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {</b>
<b class="nc">&nbsp;            buf = buf.forceUseOfBigDecimal(true);</b>
&nbsp;        }
&nbsp;        try {
&nbsp;            // inlined &#39;writeValue&#39; with minor changes:
&nbsp;            // first: disable wrapping when writing
<b class="nc">&nbsp;            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);</b>
&nbsp;            // no need to check for closing of TokenBuffer
<b class="nc">&nbsp;            _serializerProvider(config).serializeValue(buf, fromValue);</b>
&nbsp;
&nbsp;            // then matching read, inlined &#39;readValue&#39; with minor mods:
<b class="nc">&nbsp;            final JsonParser p = buf.asParser();</b>
&nbsp;            Object result;
&nbsp;            // ok to pass in existing feature flags; unwrapping handled by mapper
<b class="nc">&nbsp;            final DeserializationConfig deserConfig = getDeserializationConfig();</b>
<b class="nc">&nbsp;            JsonToken t = _initForReading(p);</b>
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
<b class="nc">&nbsp;                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);</b>
<b class="nc">&nbsp;                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);</b>
<b class="nc">&nbsp;            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {</b>
<b class="nc">&nbsp;                result = null;</b>
&nbsp;            } else { // pointing to event other than null
<b class="nc">&nbsp;                DeserializationContext ctxt = createDeserializationContext(p, deserConfig);</b>
<b class="nc">&nbsp;                JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, toValueType);</b>
&nbsp;                // note: no handling of unwrapping
<b class="nc">&nbsp;                result = deser.deserialize(p, ctxt);</b>
&nbsp;            }
<b class="nc">&nbsp;            p.close();</b>
<b class="nc">&nbsp;            return result;</b>
<b class="nc">&nbsp;        } catch (IOException e) { // should not occur, no real i/o...</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(e.getMessage(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Extended Public API: JSON Schema generation
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Generate &lt;a href=&quot;http://json-schema.org/&quot;&gt;Json-schema&lt;/a&gt;
&nbsp;     * instance for specified class.
&nbsp;     *
&nbsp;     * @param t The class to generate schema for
&nbsp;     * @return Constructed JSON schema.
&nbsp;     * 
&nbsp;     * @deprecated Since 2.6 use external JSON Schema generator (https://github.com/FasterXML/jackson-module-jsonSchema)
&nbsp;     *    (which under the hood calls {@link #acceptJsonFormatVisitor(JavaType, JsonFormatVisitorWrapper)})
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class&lt;?&gt; t)
&nbsp;            throws JsonMappingException {
<b class="nc">&nbsp;        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method for visiting type hierarchy for given type, using specified visitor.
&nbsp;     *&lt;p&gt;
&nbsp;     * This method can be used for things like
&nbsp;     * generating &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON Schema&lt;/a&gt;
&nbsp;     * instance for specified type.
&nbsp;     *
&nbsp;     * @param type Type to generate schema for (possibly with generic signature)
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public void acceptJsonFormatVisitor(Class&lt;?&gt; type, JsonFormatVisitorWrapper visitor)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Method for visiting type hierarchy for given type, using specified visitor.
&nbsp;     * Visitation uses &lt;code&gt;Serializer&lt;/code&gt; hierarchy and related properties
&nbsp;     *&lt;p&gt;
&nbsp;     * This method can be used for things like
&nbsp;     * generating &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON Schema&lt;/a&gt;
&nbsp;     * instance for specified type.
&nbsp;     *
&nbsp;     * @param type Type to generate schema for (possibly with generic signature)
&nbsp;     * 
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)
&nbsp;        throws JsonMappingException
&nbsp;    {
<b class="nc">&nbsp;        if (type == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;type must be provided&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Internal methods for serialization, overridable
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Overridable helper method used for constructing
&nbsp;     * {@link SerializerProvider} to use for serialization.
&nbsp;     */
&nbsp;    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {
<b class="nc">&nbsp;        return _serializerProvider.createInstance(config, _serializerFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to configure the generator as necessary and then
&nbsp;     * call write functionality
&nbsp;     */
&nbsp;    protected final void _configAndWriteValue(JsonGenerator g, Object value)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        SerializationConfig cfg = getSerializationConfig();</b>
<b class="nc">&nbsp;        cfg.initialize(g); // since 2.5</b>
<b class="nc">&nbsp;        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value instanceof Closeable)) {</b>
<b class="nc">&nbsp;            _configAndWriteCloseable(g, value, cfg);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            _serializerProvider(cfg).serializeValue(g, value);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            ClassUtil.closeOnFailAndThrowAsIAE(g, e);</b>
&nbsp;            return;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        g.close();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method used when value to serialize is {@link Closeable} and its &lt;code&gt;close()&lt;/code&gt;
&nbsp;     * method is to be called right after serialization has been called
&nbsp;     */
&nbsp;    private final void _configAndWriteCloseable(JsonGenerator g, Object value, SerializationConfig cfg)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        Closeable toClose = (Closeable) value;</b>
&nbsp;        try {
<b class="nc">&nbsp;            _serializerProvider(cfg).serializeValue(g, value);</b>
<b class="nc">&nbsp;            Closeable tmpToClose = toClose;</b>
<b class="nc">&nbsp;            toClose = null;</b>
<b class="nc">&nbsp;            tmpToClose.close();</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            ClassUtil.closeOnFailAndThrowAsIAE(g, toClose, e);</b>
&nbsp;            return;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        g.close();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method used when value to serialize is {@link Closeable} and its &lt;code&gt;close()&lt;/code&gt;
&nbsp;     * method is to be called right after serialization has been called
&nbsp;     */
&nbsp;    private final void _writeCloseableValue(JsonGenerator g, Object value, SerializationConfig cfg)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        Closeable toClose = (Closeable) value;</b>
&nbsp;        try {
<b class="nc">&nbsp;            _serializerProvider(cfg).serializeValue(g, value);</b>
<b class="nc">&nbsp;            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {</b>
<b class="nc">&nbsp;                g.flush();</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            ClassUtil.closeOnFailAndThrowAsIAE(null, toClose, e);</b>
&nbsp;            return;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        toClose.close();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Internal methods for deserialization, overridable
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Internal helper method called to create an instance of {@link DeserializationContext}
&nbsp;     * for deserializing a single root value.
&nbsp;     * Can be overridden if a custom context is needed.
&nbsp;     */
&nbsp;    protected DefaultDeserializationContext createDeserializationContext(JsonParser p,
&nbsp;            DeserializationConfig cfg) {
<b class="nc">&nbsp;        return _deserializationContext.createInstance(cfg, p, _injectableValues);</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Actual implementation of value reading+binding operation.
&nbsp;     */
&nbsp;    protected Object _readValue(DeserializationConfig cfg, JsonParser p, JavaType valueType)
&nbsp;        throws IOException
&nbsp;    {
&nbsp;        /* First: may need to read the next token, to initialize
&nbsp;         * state (either before first read from parser, or after
&nbsp;         * previous token has been cleared)
&nbsp;         */
&nbsp;        Object result;
<b class="nc">&nbsp;        JsonToken t = _initForReading(p);</b>
<b class="nc">&nbsp;        if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;            // Ask JsonDeserializer what &#39;null value&#39; to use:
<b class="nc">&nbsp;            DeserializationContext ctxt = createDeserializationContext(p, cfg);</b>
<b class="nc">&nbsp;            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);</b>
<b class="nc">&nbsp;        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {</b>
<b class="nc">&nbsp;            result = null;</b>
&nbsp;        } else { // pointing to event other than null
<b class="nc">&nbsp;            DeserializationContext ctxt = createDeserializationContext(p, cfg);</b>
<b class="nc">&nbsp;            JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType);</b>
&nbsp;            // ok, let&#39;s get the value
<b class="nc">&nbsp;            if (cfg.useRootWrapping()) {</b>
<b class="nc">&nbsp;                result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                result = deser.deserialize(p, ctxt);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Need to consume the token too
<b class="nc">&nbsp;        p.clearCurrentToken();</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    
&nbsp;    protected Object _readMapAndClose(JsonParser p0, JavaType valueType)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        try (JsonParser p = p0) {</b>
&nbsp;            Object result;
<b class="nc">&nbsp;            JsonToken t = _initForReading(p);</b>
<b class="nc">&nbsp;            if (t == JsonToken.VALUE_NULL) {</b>
&nbsp;                // Ask JsonDeserializer what &#39;null value&#39; to use:
<b class="nc">&nbsp;                DeserializationContext ctxt = createDeserializationContext(p,</b>
<b class="nc">&nbsp;                        getDeserializationConfig());</b>
<b class="nc">&nbsp;                result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);</b>
<b class="nc">&nbsp;            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {</b>
<b class="nc">&nbsp;                result = null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                DeserializationConfig cfg = getDeserializationConfig();</b>
<b class="nc">&nbsp;                DeserializationContext ctxt = createDeserializationContext(p, cfg);</b>
<b class="nc">&nbsp;                JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType);</b>
<b class="nc">&nbsp;                if (cfg.useRootWrapping()) {</b>
<b class="nc">&nbsp;                    result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    result = deser.deserialize(p, ctxt);</b>
&nbsp;                }
<b class="nc">&nbsp;                ctxt.checkUnresolvedObjectId();</b>
&nbsp;            }
&nbsp;            // Need to consume the token too
<b class="nc">&nbsp;            p.clearCurrentToken();</b>
<b class="nc">&nbsp;            return result;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to ensure that given parser is ready for reading
&nbsp;     * content for data binding.
&nbsp;     *
&nbsp;     * @return First token to be used for data binding after this call:
&nbsp;     *  can never be null as exception will be thrown if parser can not
&nbsp;     *  provide more tokens.
&nbsp;     *
&nbsp;     * @throws IOException if the underlying input source has problems during
&nbsp;     *   parsing
&nbsp;     * @throws JsonParseException if parser has problems parsing content
&nbsp;     * @throws JsonMappingException if the parser does not have any more
&nbsp;     *   content to map (note: Json &quot;null&quot; value is considered content;
&nbsp;     *   enf-of-stream not)
&nbsp;     */
&nbsp;    protected JsonToken _initForReading(JsonParser p) throws IOException
&nbsp;    {
<b class="nc">&nbsp;        _deserializationConfig.initialize(p); // since 2.5</b>
&nbsp;
&nbsp;        /* First: must point to a token; if not pointing to one, advance.
&nbsp;         * This occurs before first read from JsonParser, as well as
&nbsp;         * after clearing of current token.
&nbsp;         */
<b class="nc">&nbsp;        JsonToken t = p.getCurrentToken();</b>
<b class="nc">&nbsp;        if (t == null) {</b>
&nbsp;            // and then we must get something...
<b class="nc">&nbsp;            t = p.nextToken();</b>
<b class="nc">&nbsp;            if (t == null) {</b>
&nbsp;                // Throw mapping exception, since it&#39;s failure to map,
&nbsp;                //   not an actual parsing problem
<b class="nc">&nbsp;                throw JsonMappingException.from(p, &quot;No content to map due to end-of-input&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return t;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, 
&nbsp;            DeserializationConfig config,
&nbsp;            JavaType rootType, JsonDeserializer&lt;Object&gt; deser)
&nbsp;        throws IOException
&nbsp;    {
<b class="nc">&nbsp;        PropertyName expRootName = config.findRootName(rootType);</b>
&nbsp;        // 12-Jun-2015, tatu: Should try to support namespaces etc but...
<b class="nc">&nbsp;        String expSimpleName = expRootName.getSimpleName();</b>
<b class="nc">&nbsp;        if (p.getCurrentToken() != JsonToken.START_OBJECT) {</b>
<b class="nc">&nbsp;            ctxt.reportWrongTokenException(p, JsonToken.START_OBJECT,</b>
&nbsp;                    &quot;Current token not START_OBJECT (needed to unwrap root name &#39;%s&#39;), but %s&quot;,
<b class="nc">&nbsp;                    expSimpleName, p.getCurrentToken());</b>
&nbsp;            
&nbsp;        }
<b class="nc">&nbsp;        if (p.nextToken() != JsonToken.FIELD_NAME) {</b>
<b class="nc">&nbsp;            ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,</b>
&nbsp;                    &quot;Current token not FIELD_NAME (to contain expected root name &#39;&quot;
<b class="nc">&nbsp;                    +expSimpleName+&quot;&#39;), but &quot;+p.getCurrentToken());</b>
&nbsp;        }
<b class="nc">&nbsp;        String actualName = p.getCurrentName();</b>
<b class="nc">&nbsp;        if (!expSimpleName.equals(actualName)) {</b>
<b class="nc">&nbsp;            ctxt.reportMappingException(&quot;Root name &#39;%s&#39; does not match expected (&#39;%s&#39;) for type %s&quot;,</b>
&nbsp;                    actualName, expSimpleName, rootType);
&nbsp;        }
&nbsp;        // ok, then move to value itself....
<b class="nc">&nbsp;        p.nextToken();</b>
<b class="nc">&nbsp;        Object result = deser.deserialize(p, ctxt);</b>
&nbsp;        // and last, verify that we now get matching END_OBJECT
<b class="nc">&nbsp;        if (p.nextToken() != JsonToken.END_OBJECT) {</b>
<b class="nc">&nbsp;            ctxt.reportWrongTokenException(p, JsonToken.END_OBJECT,</b>
&nbsp;                    &quot;Current token not END_OBJECT (to match wrapper object with root name &#39;%s&#39;), but %s&quot;,
<b class="nc">&nbsp;                    expSimpleName, p.getCurrentToken());</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /*
&nbsp;    /**********************************************************
&nbsp;    /* Internal methods, other
&nbsp;    /**********************************************************
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * Method called to locate deserializer for the passed root-level value.
&nbsp;     */
&nbsp;    protected JsonDeserializer&lt;Object&gt; _findRootDeserializer(DeserializationContext ctxt,
&nbsp;            JavaType valueType)
&nbsp;        throws JsonMappingException
&nbsp;    {
&nbsp;        // First: have we already seen it?
<b class="nc">&nbsp;        JsonDeserializer&lt;Object&gt; deser = _rootDeserializers.get(valueType);</b>
<b class="nc">&nbsp;        if (deser != null) {</b>
<b class="nc">&nbsp;            return deser;</b>
&nbsp;        }
&nbsp;        // Nope: need to ask provider to resolve it
<b class="nc">&nbsp;        deser = ctxt.findRootValueDeserializer(valueType);</b>
<b class="nc">&nbsp;        if (deser == null) { // can this happen?</b>
<b class="nc">&nbsp;            throw JsonMappingException.from(ctxt,</b>
&nbsp;                    &quot;Can not find a deserializer for type &quot;+valueType);
&nbsp;        }
<b class="nc">&nbsp;        _rootDeserializers.put(valueType, deser);</b>
<b class="nc">&nbsp;        return deser;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.2
&nbsp;     */
&nbsp;    protected void _verifySchemaType(FormatSchema schema)
&nbsp;    {
<b class="nc">&nbsp;        if (schema != null) {</b>
<b class="nc">&nbsp;            if (!_jsonFactory.canUseSchema(schema)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Can not use FormatSchema of type &quot;+schema.getClass().getName()</b>
<b class="nc">&nbsp;                            +&quot; for format &quot;+_jsonFactory.getFormatName());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-04 11:15</div>
</div>
</body>
</html>
