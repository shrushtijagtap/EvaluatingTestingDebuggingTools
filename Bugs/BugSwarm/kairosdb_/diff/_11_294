[<Line: +(function (window, document, undefined) {
>, <Line: +	'use strict';
>, <Line: +	/**
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * This object provides a utility for producing rich Error messages within
>, <Line: +	 * Angular. It can be called as follows:
>, <Line: +	 *
>, <Line: +	 * var exampleMinErr = minErr('example');
>, <Line: +	 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
>, <Line: +	 *
>, <Line: +	 * The above creates an instance of minErr in the example namespace. The
>, <Line: +	 * resulting error will have a namespaced error code of example.one.  The
>, <Line: +	 * resulting error will replace {0} with the value of foo, and {1} with the
>, <Line: +	 * value of bar. The object is not restricted in the number of arguments it can
>, <Line: +	 * take.
>, <Line: +	 *
>, <Line: +	 * If fewer arguments are specified than necessary for interpolation, the extra
>, <Line: +	 * interpolation markers will be preserved in the final string.
>, <Line: +	 *
>, <Line: +	 * Since data will be parsed statically during a build step, some restrictions
>, <Line: +	 * are applied with respect to how minErr instances are created and called.
>, <Line: +	 * Instances should have names of the form namespaceMinErr for a minErr created
>, <Line: +	 * using minErr('namespace') . Error codes, namespaces and template strings
>, <Line: +	 * should all be static strings, not variables or general expressions.
>, <Line: +	 *
>, <Line: +	 * @param {string} module The namespace to use for the new minErr instance.
>, <Line: +	 * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning
>, <Line: +	 *   error from returned function, for cases when a particular type of error is useful.
>, <Line: +	 * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance
>, <Line: +	 */
>, <Line: +	function minErr(module, ErrorConstructor) {
>, <Line: +		ErrorConstructor = ErrorConstructor || Error;
>, <Line: +		return function () {
>, <Line: +			var code = arguments[0],
>, <Line: +				prefix = '[' + (module ? module + ':' : '') + code + '] ',
>, <Line: +				template = arguments[1],
>, <Line: +				templateArgs = arguments,
>, <Line: +				message, i;
>, <Line: +			message = prefix + template.replace(/\{\d+\}/g, function (match) {
>, <Line: +					var index = +match.slice(1, -1), arg;
>, <Line: +					if (index + 2 < templateArgs.length) {
>, <Line: +						return toDebugString(templateArgs[index + 2]);
>, <Line: +					}
>, <Line: +					return match;
>, <Line: +				});
>, <Line: +			message = message + '\nhttp://errors.angularjs.org/1.3.4/' +
>, <Line: +				(module ? module + '/' : '') + code;
>, <Line: +			for (i = 2; i < arguments.length; i++) {
>, <Line: +				message = message + (i == 2 ? '?' : '&') + 'p' + (i - 2) + '=' +
>, <Line: +					encodeURIComponent(toDebugString(arguments[i]));
>, <Line: +			}
>, <Line: +			return new ErrorConstructor(message);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/* We need to tell jshint what variables are being exported */
>, <Line: +	/* global angular: true,
>, <Line: +	 msie: true,
>, <Line: +	 jqLite: true,
>, <Line: +	 jQuery: true,
>, <Line: +	 slice: true,
>, <Line: +	 splice: true,
>, <Line: +	 push: true,
>, <Line: +	 toString: true,
>, <Line: +	 ngMinErr: true,
>, <Line: +	 angularModule: true,
>, <Line: +	 uid: true,
>, <Line: +	 REGEX_STRING_REGEXP: true,
>, <Line: +	 VALIDITY_STATE_PROPERTY: true,
>, <Line: +	 lowercase: true,
>, <Line: +	 uppercase: true,
>, <Line: +	 manualLowercase: true,
>, <Line: +	 manualUppercase: true,
>, <Line: +	 nodeName_: true,
>, <Line: +	 isArrayLike: true,
>, <Line: +	 forEach: true,
>, <Line: +	 sortedKeys: true,
>, <Line: +	 forEachSorted: true,
>, <Line: +	 reverseParams: true,
>, <Line: +	 nextUid: true,
>, <Line: +	 setHashKey: true,
>, <Line: +	 extend: true,
>, <Line: +	 int: true,
>, <Line: +	 inherit: true,
>, <Line: +	 noop: true,
>, <Line: +	 identity: true,
>, <Line: +	 valueFn: true,
>, <Line: +	 isUndefined: true,
>, <Line: +	 isDefined: true,
>, <Line: +	 isObject: true,
>, <Line: +	 isString: true,
>, <Line: +	 isNumber: true,
>, <Line: +	 isDate: true,
>, <Line: +	 isArray: true,
>, <Line: +	 isFunction: true,
>, <Line: +	 isRegExp: true,
>, <Line: +	 isWindow: true,
>, <Line: +	 isScope: true,
>, <Line: +	 isFile: true,
>, <Line: +	 isBlob: true,
>, <Line: +	 isBoolean: true,
>, <Line: +	 isPromiseLike: true,
>, <Line: +	 trim: true,
>, <Line: +	 escapeForRegexp: true,
>, <Line: +	 isElement: true,
>, <Line: +	 makeMap: true,
>, <Line: +	 includes: true,
>, <Line: +	 arrayRemove: true,
>, <Line: +	 copy: true,
>, <Line: +	 shallowCopy: true,
>, <Line: +	 equals: true,
>, <Line: +	 csp: true,
>, <Line: +	 concat: true,
>, <Line: +	 sliceArgs: true,
>, <Line: +	 bind: true,
>, <Line: +	 toJsonReplacer: true,
>, <Line: +	 toJson: true,
>, <Line: +	 fromJson: true,
>, <Line: +	 startingTag: true,
>, <Line: +	 tryDecodeURIComponent: true,
>, <Line: +	 parseKeyValue: true,
>, <Line: +	 toKeyValue: true,
>, <Line: +	 encodeUriSegment: true,
>, <Line: +	 encodeUriQuery: true,
>, <Line: +	 angularInit: true,
>, <Line: +	 bootstrap: true,
>, <Line: +	 getTestability: true,
>, <Line: +	 snake_case: true,
>, <Line: +	 bindJQuery: true,
>, <Line: +	 assertArg: true,
>, <Line: +	 assertArgFn: true,
>, <Line: +	 assertNotHasOwnProperty: true,
>, <Line: +	 getter: true,
>, <Line: +	 getBlockNodes: true,
>, <Line: +	 hasOwnProperty: true,
>, <Line: +	 createMap: true,
>, <Line: +	 NODE_TYPE_ELEMENT: true,
>, <Line: +	 NODE_TYPE_TEXT: true,
>, <Line: +	 NODE_TYPE_COMMENT: true,
>, <Line: +	 NODE_TYPE_DOCUMENT: true,
>, <Line: +	 NODE_TYPE_DOCUMENT_FRAGMENT: true,
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc module
>, <Line: +	 * @name ng
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * # ng (core module)
>, <Line: +	 * The ng module is loaded by default when an AngularJS application is started. The module itself
>, <Line: +	 * contains the essential components for an AngularJS application to function. The table below
>, <Line: +	 * lists a high level breakdown of each of the services/factories, filters, directives and testing
>, <Line: +	 * components available within this core module.
>, <Line: +	 *
>, <Line: +	 * <div doc-module-components="ng"></div>
>, <Line: +	 */
>, <Line: +	var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
>, <Line: +	var VALIDITY_STATE_PROPERTY = 'validity';
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.lowercase
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description Converts the specified string to lowercase.
>, <Line: +	 * @param {string} string String to be converted to lowercase.
>, <Line: +	 * @returns {string} Lowercased string.
>, <Line: +	 */
>, <Line: +	var lowercase = function (string) {
>, <Line: +		return isString(string) ? string.toLowerCase() : string;
>, <Line: +	};
>, <Line: +	var hasOwnProperty = Object.prototype.hasOwnProperty;
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.uppercase
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description Converts the specified string to uppercase.
>, <Line: +	 * @param {string} string String to be converted to uppercase.
>, <Line: +	 * @returns {string} Uppercased string.
>, <Line: +	 */
>, <Line: +	var uppercase = function (string) {
>, <Line: +		return isString(string) ? string.toUpperCase() : string;
>, <Line: +	};
>, <Line: +	var manualLowercase = function (s) {
>, <Line: +		/* jshint bitwise: false */
>, <Line: +		return isString(s)
>, <Line: +			? s.replace(/[A-Z]/g, function (ch) {
>, <Line: +			return String.fromCharCode(ch.charCodeAt(0) | 32);
>, <Line: +		})
>, <Line: +			: s;
>, <Line: +	};
>, <Line: +	var manualUppercase = function (s) {
>, <Line: +		/* jshint bitwise: false */
>, <Line: +		return isString(s)
>, <Line: +			? s.replace(/[a-z]/g, function (ch) {
>, <Line: +			return String.fromCharCode(ch.charCodeAt(0) & ~32);
>, <Line: +		})
>, <Line: +			: s;
>, <Line: +	};
>, <Line: +	if ('i' !== 'I'.toLowerCase()) {
>, <Line: +		lowercase = manualLowercase;
>, <Line: +		uppercase = manualUppercase;
>, <Line: +	}
>, <Line: +	var /** holds major version number for IE or NaN for real browsers */
>, <Line: +		msie,
>, <Line: +		jqLite,           // delay binding since jQuery could be loaded after us.
>, <Line: +		jQuery,           // delay binding
>, <Line: +		slice = [].slice,
>, <Line: +		splice = [].splice,
>, <Line: +		push = [].push,
>, <Line: +		toString = Object.prototype.toString,
>, <Line: +		ngMinErr = minErr('ng'),
>, <Line: +		/** @name angular */
>, <Line: +		angular = window.angular || (window.angular = {}),
>, <Line: +		angularModule,
>, <Line: +		uid = 0;
>, <Line: +	/**
>, <Line: +	 * documentMode is an IE-only property
>, <Line: +	 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
>, <Line: +	 */
>, <Line: +	msie = document.documentMode;
>, <Line: +	/**
>, <Line: +	 * @private
>, <Line: +	 * @param {*} obj
>, <Line: +	 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
>, <Line: +	 *                   String ...)
>, <Line: +	 */
>, <Line: +	function isArrayLike(obj) {
>, <Line: +		if (obj == null || isWindow(obj)) {
>, <Line: +			return false;
>, <Line: +		}
>, <Line: +		var length = obj.length;
>, <Line: +		if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
>, <Line: +			return true;
>, <Line: +		}
>, <Line: +		return isString(obj) || isArray(obj) || length === 0 ||
>, <Line: +			typeof length === 'number' && length > 0 && (length - 1) in obj;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.forEach
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
>, <Line: +	 * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`
>, <Line: +	 * is the value of an object property or an array element, `key` is the object property key or
>, <Line: +	 * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.
>, <Line: +	 *
>, <Line: +	 * It is worth noting that `.forEach` does not iterate over inherited properties because it filters
>, <Line: +	 * using the `hasOwnProperty` method.
>, <Line: +	 *
>, <Line: +	 * Unlike ES262's
>, <Line: +	 * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),
>, <Line: +	 * Providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just
>, <Line: +	 * return the value provided.
>, <Line: +	 *
>, <Line: +	 ```js
>, <Line: +	 var values = {name: 'misko', gender: 'male'};
>, <Line: +	 var log = [];
>, <Line: +	 angular.forEach(values, function(value, key) {
>, <Line: +	 expect(log).toEqual(['name: misko', 'gender: male']);
>, <Line: +	 ```
>, <Line: +	 *
>, <Line: +	 * @param {Object|Array} obj Object to iterate over.
>, <Line: +	 * @param {Function} iterator Iterator function.
>, <Line: +	 * @param {Object=} context Object to become context (`this`) for the iterator function.
>, <Line: +	 * @returns {Object|Array} Reference to `obj`.
>, <Line: +	 */
>, <Line: +	function forEach(obj, iterator, context) {
>, <Line: +		var key, length;
>, <Line: +		if (obj) {
>, <Line: +			if (isFunction(obj)) {
>, <Line: +				for (key in obj) {
>, <Line: +					// Need to check if hasOwnProperty exists,
>, <Line: +					// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
>, <Line: +					if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
>, <Line: +						iterator.call(context, obj[key], key, obj);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else if (isArray(obj) || isArrayLike(obj)) {
>, <Line: +				var isPrimitive = typeof obj !== 'object';
>, <Line: +				for (key = 0, length = obj.length; key < length; key++) {
>, <Line: +					if (isPrimitive || key in obj) {
>, <Line: +						iterator.call(context, obj[key], key, obj);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else if (obj.forEach && obj.forEach !== forEach) {
>, <Line: +				obj.forEach(iterator, context, obj);
>, <Line: +			} else {
>, <Line: +				for (key in obj) {
>, <Line: +					if (obj.hasOwnProperty(key)) {
>, <Line: +						iterator.call(context, obj[key], key, obj);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	function sortedKeys(obj) {
>, <Line: +		return Object.keys(obj).sort();
>, <Line: +	}
>, <Line: +	function forEachSorted(obj, iterator, context) {
>, <Line: +		var keys = sortedKeys(obj);
>, <Line: +		for (var i = 0; i < keys.length; i++) {
>, <Line: +			iterator.call(context, obj[keys[i]], keys[i]);
>, <Line: +		}
>, <Line: +		return keys;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * when using forEach the params are value, key, but it is often useful to have key, value.
>, <Line: +	 * @param {function(string, *)} iteratorFn
>, <Line: +	 * @returns {function(*, string)}
>, <Line: +	 */
>, <Line: +	function reverseParams(iteratorFn) {
>, <Line: +		return function (value, key) {
>, <Line: +			iteratorFn(key, value);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * A consistent way of creating unique IDs in angular.
>, <Line: +	 *
>, <Line: +	 * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before
>, <Line: +	 * we hit number precision issues in JavaScript.
>, <Line: +	 *
>, <Line: +	 * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M
>, <Line: +	 *
>, <Line: +	 * @returns {number} an unique alpha-numeric string
>, <Line: +	 */
>, <Line: +	function nextUid() {
>, <Line: +		return ++uid;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Set or clear the hashkey for an object.
>, <Line: +	 * @param obj object
>, <Line: +	 * @param h the hashkey (!truthy to delete the hashkey)
>, <Line: +	 */
>, <Line: +	function setHashKey(obj, h) {
>, <Line: +		if (h) {
>, <Line: +			obj.$$hashKey = h;
>, <Line: +		}
>, <Line: +		else {
>, <Line: +			delete obj.$$hashKey;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.extend
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
>, <Line: +	 * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
>, <Line: +	 * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.
>, <Line: +	 * Note: Keep in mind that `angular.extend` does not support recursive merge (deep copy).
>, <Line: +	 *
>, <Line: +	 * @param {Object} dst Destination object.
>, <Line: +	 * @param {...Object} src Source object(s).
>, <Line: +	 * @returns {Object} Reference to `dst`.
>, <Line: +	 */
>, <Line: +	function extend(dst) {
>, <Line: +		var h = dst.$$hashKey;
>, <Line: +		for (var i = 1, ii = arguments.length; i < ii; i++) {
>, <Line: +			var obj = arguments[i];
>, <Line: +			if (obj) {
>, <Line: +				var keys = Object.keys(obj);
>, <Line: +				for (var j = 0, jj = keys.length; j < jj; j++) {
>, <Line: +					var key = keys[j];
>, <Line: +					dst[key] = obj[key];
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		setHashKey(dst, h);
>, <Line: +		return dst;
>, <Line: +	}
>, <Line: +	function int(str) {
>, <Line: +		return parseInt(str, 10);
>, <Line: +	}
>, <Line: +	function inherit(parent, extra) {
>, <Line: +		return extend(Object.create(parent), extra);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.noop
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A function that performs no operations. This function can be useful when writing code in the
>, <Line: +	 * functional style.
>, <Line: +	 ```js
>, <Line: +	 function foo(callback) {
>, <Line: +	 ```
>, <Line: +	 */
>, <Line: +	function noop() {
>, <Line: +	}
>, <Line: +	noop.$inject = [];
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.identity
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A function that returns its first argument. This function is useful when writing code in the
>, <Line: +	 * functional style.
>, <Line: +	 *
>, <Line: +	 ```js
>, <Line: +	 function transformer(transformationFn, value) {
>, <Line: +	 ```
>, <Line: +	 */
>, <Line: +	function identity($) {
>, <Line: +		return $;
>, <Line: +	}
>, <Line: +	identity.$inject = [];
>, <Line: +	function valueFn(value) {
>, <Line: +		return function () {
>, <Line: +			return value;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isUndefined
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is undefined.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is undefined.
>, <Line: +	 */
>, <Line: +	function isUndefined(value) {
>, <Line: +		return typeof value === 'undefined';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isDefined
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is defined.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is defined.
>, <Line: +	 */
>, <Line: +	function isDefined(value) {
>, <Line: +		return typeof value !== 'undefined';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isObject
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
>, <Line: +	 * considered to be objects. Note that JavaScript arrays are objects.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is an `Object` but not `null`.
>, <Line: +	 */
>, <Line: +	function isObject(value) {
>, <Line: +		// http://jsperf.com/isobject4
>, <Line: +		return value !== null && typeof value === 'object';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isString
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is a `String`.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a `String`.
>, <Line: +	 */
>, <Line: +	function isString(value) {
>, <Line: +		return typeof value === 'string';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isNumber
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is a `Number`.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a `Number`.
>, <Line: +	 */
>, <Line: +	function isNumber(value) {
>, <Line: +		return typeof value === 'number';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isDate
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a value is a date.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a `Date`.
>, <Line: +	 */
>, <Line: +	function isDate(value) {
>, <Line: +		return toString.call(value) === '[object Date]';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isArray
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is an `Array`.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is an `Array`.
>, <Line: +	 */
>, <Line: +	var isArray = Array.isArray;
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isFunction
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is a `Function`.
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a `Function`.
>, <Line: +	 */
>, <Line: +	function isFunction(value) {
>, <Line: +		return typeof value === 'function';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Determines if a value is a regular expression object.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a `RegExp`.
>, <Line: +	 */
>, <Line: +	function isRegExp(value) {
>, <Line: +		return toString.call(value) === '[object RegExp]';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Checks if `obj` is a window object.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param {*} obj Object to check
>, <Line: +	 * @returns {boolean} True if `obj` is a window obj.
>, <Line: +	 */
>, <Line: +	function isWindow(obj) {
>, <Line: +		return obj && obj.window === obj;
>, <Line: +	}
>, <Line: +	function isScope(obj) {
>, <Line: +		return obj && obj.$evalAsync && obj.$watch;
>, <Line: +	}
>, <Line: +	function isFile(obj) {
>, <Line: +		return toString.call(obj) === '[object File]';
>, <Line: +	}
>, <Line: +	function isBlob(obj) {
>, <Line: +		return toString.call(obj) === '[object Blob]';
>, <Line: +	}
>, <Line: +	function isBoolean(value) {
>, <Line: +		return typeof value === 'boolean';
>, <Line: +	}
>, <Line: +	function isPromiseLike(obj) {
>, <Line: +		return obj && isFunction(obj.then);
>, <Line: +	}
>, <Line: +	var trim = function (value) {
>, <Line: +		return isString(value) ? value.trim() : value;
>, <Line: +	};
>, <Line: +	var escapeForRegexp = function (s) {
>, <Line: +		return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
>, <Line: +			replace(/\x08/g, '\\x08');
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.isElement
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if a reference is a DOM element (or wrapped jQuery element).
>, <Line: +	 *
>, <Line: +	 * @param {*} value Reference to check.
>, <Line: +	 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
>, <Line: +	 */
>, <Line: +	function isElement(node) {
>, <Line: +		return !!(node &&
>, <Line: +		(node.nodeName  // we are a direct element
>, <Line: +		|| (node.prop && node.attr && node.find)));  // we have an on and find method part of jQuery API
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @param str 'key1,key2,...'
>, <Line: +	 * @returns {object} in the form of {key1:true, key2:true, ...}
>, <Line: +	 */
>, <Line: +	function makeMap(str) {
>, <Line: +		var obj = {}, items = str.split(","), i;
>, <Line: +		for (i = 0; i < items.length; i++)
>, <Line: +			obj[items[i]] = true;
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	function nodeName_(element) {
>, <Line: +		return lowercase(element.nodeName || (element[0] && element[0].nodeName));
>, <Line: +	}
>, <Line: +	function includes(array, obj) {
>, <Line: +		return Array.prototype.indexOf.call(array, obj) != -1;
>, <Line: +	}
>, <Line: +	function arrayRemove(array, value) {
>, <Line: +		var index = array.indexOf(value);
>, <Line: +		if (index >= 0)
>, <Line: +			array.splice(index, 1);
>, <Line: +		return value;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.copy
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Creates a deep copy of `source`, which should be an object or an array.
>, <Line: +	 *
>, <Line: +	 * * If no destination is supplied, a copy of the object or array is created.
>, <Line: +	 * * If a destination is provided, all of its elements (for array) or properties (for objects)
>, <Line: +	 *   are deleted and then all elements/properties from the source are copied to it.
>, <Line: +	 * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
>, <Line: +	 * * If `source` is identical to 'destination' an exception will be thrown.
>, <Line: +	 *
>, <Line: +	 * @param {*} source The source that will be used to make a copy.
>, <Line: +	 *                   Can be any type, including primitives, `null`, and `undefined`.
>, <Line: +	 * @param {(Object|Array)=} destination Destination into which the source is copied. If
>, <Line: +	 *     provided, must be of the same type as `source`.
>, <Line: +	 * @returns {*} The copy or updated `destination`, if `destination` was specified.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="copyExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form novalidate class="simple-form">
>, <Line: +	 Name: <input type="text" ng-model="user.name" /><br />
>, <Line: +	 E-mail: <input type="email" ng-model="user.email" /><br />
>, <Line: +	 Gender: <input type="radio" ng-model="user.gender" value="male" />male
>, <Line: +	 <input type="radio" ng-model="user.gender" value="female" />female<br />
>, <Line: +	 <button ng-click="reset()">RESET</button>
>, <Line: +	 <button ng-click="update(user)">SAVE</button>
>, <Line: +	 </form>
>, <Line: +	 <pre>form = {{user | json}}</pre>
>, <Line: +	 <pre>master = {{master | json}}</pre>
>, <Line: +	 </div>
>, <Line: +	 <script>
>, <Line: +	 angular.module('copyExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function copy(source, destination, stackSource, stackDest) {
>, <Line: +		if (isWindow(source) || isScope(source)) {
>, <Line: +			throw ngMinErr('cpws',
>, <Line: +				"Can't copy! Making copies of Window or Scope instances is not supported.");
>, <Line: +		}
>, <Line: +		if (!destination) {
>, <Line: +			destination = source;
>, <Line: +			if (source) {
>, <Line: +				if (isArray(source)) {
>, <Line: +					destination = copy(source, [], stackSource, stackDest);
>, <Line: +				} else if (isDate(source)) {
>, <Line: +					destination = new Date(source.getTime());
>, <Line: +				} else if (isRegExp(source)) {
>, <Line: +					destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
>, <Line: +					destination.lastIndex = source.lastIndex;
>, <Line: +				} else if (isObject(source)) {
>, <Line: +					var emptyObject = Object.create(Object.getPrototypeOf(source));
>, <Line: +					destination = copy(source, emptyObject, stackSource, stackDest);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			if (source === destination) throw ngMinErr('cpi',
>, <Line: +				"Can't copy! Source and destination are identical.");
>, <Line: +			stackSource = stackSource || [];
>, <Line: +			stackDest = stackDest || [];
>, <Line: +			if (isObject(source)) {
>, <Line: +				var index = stackSource.indexOf(source);
>, <Line: +				if (index !== -1) return stackDest[index];
>, <Line: +				stackSource.push(source);
>, <Line: +				stackDest.push(destination);
>, <Line: +			}
>, <Line: +			var result;
>, <Line: +			if (isArray(source)) {
>, <Line: +				destination.length = 0;
>, <Line: +				for (var i = 0; i < source.length; i++) {
>, <Line: +					result = copy(source[i], null, stackSource, stackDest);
>, <Line: +					if (isObject(source[i])) {
>, <Line: +						stackSource.push(source[i]);
>, <Line: +						stackDest.push(result);
>, <Line: +					}
>, <Line: +					destination.push(result);
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				var h = destination.$$hashKey;
>, <Line: +				if (isArray(destination)) {
>, <Line: +					destination.length = 0;
>, <Line: +				} else {
>, <Line: +					forEach(destination, function (value, key) {
>, <Line: +						delete destination[key];
>, <Line: +					});
>, <Line: +				}
>, <Line: +				for (var key in source) {
>, <Line: +					if (source.hasOwnProperty(key)) {
>, <Line: +						result = copy(source[key], null, stackSource, stackDest);
>, <Line: +						if (isObject(source[key])) {
>, <Line: +							stackSource.push(source[key]);
>, <Line: +							stackDest.push(result);
>, <Line: +						}
>, <Line: +						destination[key] = result;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				setHashKey(destination, h);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return destination;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Creates a shallow copy of an object, an array or a primitive.
>, <Line: +	 *
>, <Line: +	 * Assumes that there are no proto properties for objects.
>, <Line: +	 */
>, <Line: +	function shallowCopy(src, dst) {
>, <Line: +		if (isArray(src)) {
>, <Line: +			dst = dst || [];
>, <Line: +			for (var i = 0, ii = src.length; i < ii; i++) {
>, <Line: +				dst[i] = src[i];
>, <Line: +			}
>, <Line: +		} else if (isObject(src)) {
>, <Line: +			dst = dst || {};
>, <Line: +			for (var key in src) {
>, <Line: +				if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
>, <Line: +					dst[key] = src[key];
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return dst || src;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.equals
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Determines if two objects or two values are equivalent. Supports value types, regular
>, <Line: +	 * expressions, arrays and objects.
>, <Line: +	 *
>, <Line: +	 * Two objects or values are considered equivalent if at least one of the following is true:
>, <Line: +	 *
>, <Line: +	 * * Both objects or values pass `===` comparison.
>, <Line: +	 * * Both objects or values are of the same type and all of their properties are equal by
>, <Line: +	 *   comparing them with `angular.equals`.
>, <Line: +	 * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
>, <Line: +	 * * Both values represent the same regular expression (In JavaScript,
>, <Line: +	 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
>, <Line: +	 *   representation matches).
>, <Line: +	 *
>, <Line: +	 * During a property comparison, properties of `function` type and properties with names
>, <Line: +	 * that begin with `$` are ignored.
>, <Line: +	 *
>, <Line: +	 * Scope and DOMWindow objects are being compared only by identify (`===`).
>, <Line: +	 *
>, <Line: +	 * @param {*} o1 Object or value to compare.
>, <Line: +	 * @param {*} o2 Object or value to compare.
>, <Line: +	 * @returns {boolean} True if arguments are equal.
>, <Line: +	 */
>, <Line: +	function equals(o1, o2) {
>, <Line: +		if (o1 === o2) return true;
>, <Line: +		if (o1 === null || o2 === null) return false;
>, <Line: +		if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
>, <Line: +		var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
>, <Line: +		if (t1 == t2) {
>, <Line: +			if (t1 == 'object') {
>, <Line: +				if (isArray(o1)) {
>, <Line: +					if (!isArray(o2)) return false;
>, <Line: +					if ((length = o1.length) == o2.length) {
>, <Line: +						for (key = 0; key < length; key++) {
>, <Line: +							if (!equals(o1[key], o2[key])) return false;
>, <Line: +						}
>, <Line: +						return true;
>, <Line: +					}
>, <Line: +				} else if (isDate(o1)) {
>, <Line: +					if (!isDate(o2)) return false;
>, <Line: +					return equals(o1.getTime(), o2.getTime());
>, <Line: +				} else if (isRegExp(o1) && isRegExp(o2)) {
>, <Line: +					return o1.toString() == o2.toString();
>, <Line: +				} else {
>, <Line: +					if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
>, <Line: +					keySet = {};
>, <Line: +					for (key in o1) {
>, <Line: +						if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
>, <Line: +						if (!equals(o1[key], o2[key])) return false;
>, <Line: +						keySet[key] = true;
>, <Line: +					}
>, <Line: +					for (key in o2) {
>, <Line: +						if (!keySet.hasOwnProperty(key) &&
>, <Line: +							key.charAt(0) !== '$' &&
>, <Line: +							o2[key] !== undefined && !isFunction(o2[key])) return false;
>, <Line: +					}
>, <Line: +					return true;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return false;
>, <Line: +	}
>, <Line: +	var csp = function () {
>, <Line: +		if (isDefined(csp.isActive_)) return csp.isActive_;
>, <Line: +		var active = !!(document.querySelector('[ng-csp]') ||
>, <Line: +		document.querySelector('[data-ng-csp]'));
>, <Line: +		if (!active) {
>, <Line: +			try {
>, <Line: +				/* jshint -W031, -W054 */
>, <Line: +				new Function('');
>, <Line: +				/* jshint +W031, +W054 */
>, <Line: +			} catch (e) {
>, <Line: +				active = true;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return (csp.isActive_ = active);
>, <Line: +	};
>, <Line: +	function concat(array1, array2, index) {
>, <Line: +		return array1.concat(slice.call(array2, index));
>, <Line: +	}
>, <Line: +	function sliceArgs(args, startIndex) {
>, <Line: +		return slice.call(args, startIndex || 0);
>, <Line: +	}
>, <Line: +	/* jshint -W101 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.bind
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
>, <Line: +	 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
>, <Line: +	 * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
>, <Line: +	 * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
>, <Line: +	 *
>, <Line: +	 * @param {Object} self Context which `fn` should be evaluated in.
>, <Line: +	 * @param {function()} fn Function to be bound.
>, <Line: +	 * @param {...*} args Optional arguments to be prebound to the `fn` function call.
>, <Line: +	 * @returns {function()} Function that wraps the `fn` with all the specified bindings.
>, <Line: +	 */
>, <Line: +	/* jshint +W101 */
>, <Line: +	function bind(self, fn) {
>, <Line: +		var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
>, <Line: +		if (isFunction(fn) && !(fn instanceof RegExp)) {
>, <Line: +			return curryArgs.length
>, <Line: +				? function () {
>, <Line: +				return arguments.length
>, <Line: +					? fn.apply(self, concat(curryArgs, arguments, 0))
>, <Line: +					: fn.apply(self, curryArgs);
>, <Line: +			}
>, <Line: +				: function () {
>, <Line: +				return arguments.length
>, <Line: +					? fn.apply(self, arguments)
>, <Line: +					: fn.call(self);
>, <Line: +			};
>, <Line: +		} else {
>, <Line: +			// in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
>, <Line: +			return fn;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function toJsonReplacer(key, value) {
>, <Line: +		var val = value;
>, <Line: +		if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
>, <Line: +			val = undefined;
>, <Line: +		} else if (isWindow(value)) {
>, <Line: +			val = '$WINDOW';
>, <Line: +		} else if (value && document === value) {
>, <Line: +			val = '$DOCUMENT';
>, <Line: +		} else if (isScope(value)) {
>, <Line: +			val = '$SCOPE';
>, <Line: +		}
>, <Line: +		return val;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.toJson
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
>, <Line: +	 * stripped since angular uses this notation internally.
>, <Line: +	 *
>, <Line: +	 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
>, <Line: +	 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
>, <Line: +	 * @returns {string|undefined} JSON-ified string representing `obj`.
>, <Line: +	 */
>, <Line: +	function toJson(obj, pretty) {
>, <Line: +		if (typeof obj === 'undefined') return undefined;
>, <Line: +		return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.fromJson
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Deserializes a JSON string.
>, <Line: +	 *
>, <Line: +	 * @param {string} json JSON string to deserialize.
>, <Line: +	 * @returns {Object|Array|string|number} Deserialized thingy.
>, <Line: +	 */
>, <Line: +	function fromJson(json) {
>, <Line: +		return isString(json)
>, <Line: +			? JSON.parse(json)
>, <Line: +			: json;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @returns {string} Returns the string representation of the element.
>, <Line: +	 */
>, <Line: +	function startingTag(element) {
>, <Line: +		element = jqLite(element).clone();
>, <Line: +		try {
>, <Line: +			// turns out IE does not let you set .html() on elements which
>, <Line: +			// are not allowed to have children. So we just ignore it.
>, <Line: +			element.empty();
>, <Line: +		} catch (e) {
>, <Line: +		}
>, <Line: +		var elemHtml = jqLite('<div>').append(element).html();
>, <Line: +		try {
>, <Line: +			return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
>, <Line: +				elemHtml.
>, <Line: +					match(/^(<[^>]+>)/)[1].
>, <Line: +					replace(/^<([\w\-]+)/, function (match, nodeName) {
>, <Line: +						return '<' + lowercase(nodeName);
>, <Line: +					});
>, <Line: +		} catch (e) {
>, <Line: +			return lowercase(elemHtml);
>, <Line: +		}
>, <Line: +	}
>, <Line: +/////////////////////////////////////////////////
>, <Line: +	/**
>, <Line: +	 * Tries to decode the URI component without throwing an exception.
>, <Line: +	 *
>, <Line: +	 * @private
>, <Line: +	 * @param str value potential URI component to check.
>, <Line: +	 * @returns {boolean} True if `value` can be decoded
>, <Line: +	 * with the decodeURIComponent function.
>, <Line: +	 */
>, <Line: +	function tryDecodeURIComponent(value) {
>, <Line: +		try {
>, <Line: +			return decodeURIComponent(value);
>, <Line: +		} catch (e) {
>, <Line: +			// Ignore any invalid uri component
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Parses an escaped url query string into key-value pairs.
>, <Line: +	 * @returns {Object.<string,boolean|Array>}
>, <Line: +	 */
>, <Line: +	function parseKeyValue(/**string*/keyValue) {
>, <Line: +		var obj = {}, key_value, key;
>, <Line: +		forEach((keyValue || "").split('&'), function (keyValue) {
>, <Line: +			if (keyValue) {
>, <Line: +				key_value = keyValue.replace(/\+/g, '%20').split('=');
>, <Line: +				key = tryDecodeURIComponent(key_value[0]);
>, <Line: +				if (isDefined(key)) {
>, <Line: +					var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
>, <Line: +					if (!hasOwnProperty.call(obj, key)) {
>, <Line: +						obj[key] = val;
>, <Line: +					} else if (isArray(obj[key])) {
>, <Line: +						obj[key].push(val);
>, <Line: +					} else {
>, <Line: +						obj[key] = [obj[key], val];
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		});
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	function toKeyValue(obj) {
>, <Line: +		var parts = [];
>, <Line: +		forEach(obj, function (value, key) {
>, <Line: +			if (isArray(value)) {
>, <Line: +				forEach(value, function (arrayValue) {
>, <Line: +					parts.push(encodeUriQuery(key, true) +
>, <Line: +						(arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
>, <Line: +				});
>, <Line: +			} else {
>, <Line: +				parts.push(encodeUriQuery(key, true) +
>, <Line: +					(value === true ? '' : '=' + encodeUriQuery(value, true)));
>, <Line: +			}
>, <Line: +		});
>, <Line: +		return parts.length ? parts.join('&') : '';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
>, <Line: +	 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
>, <Line: +	 * segments:
>, <Line: +	 *    segment       = *pchar
>, <Line: +	 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
>, <Line: +	 *    pct-encoded   = "%" HEXDIG HEXDIG
>, <Line: +	 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
>, <Line: +	 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
>, <Line: +	 *                     / "*" / "+" / "," / ";" / "="
>, <Line: +	 */
>, <Line: +	function encodeUriSegment(val) {
>, <Line: +		return encodeUriQuery(val, true).
>, <Line: +			replace(/%26/gi, '&').
>, <Line: +			replace(/%3D/gi, '=').
>, <Line: +			replace(/%2B/gi, '+');
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
>, <Line: +	 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
>, <Line: +	 * encoded per http://tools.ietf.org/html/rfc3986:
>, <Line: +	 *    query       = *( pchar / "/" / "?" )
>, <Line: +	 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
>, <Line: +	 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
>, <Line: +	 *    pct-encoded   = "%" HEXDIG HEXDIG
>, <Line: +	 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
>, <Line: +	 *                     / "*" / "+" / "," / ";" / "="
>, <Line: +	 */
>, <Line: +	function encodeUriQuery(val, pctEncodeSpaces) {
>, <Line: +		return encodeURIComponent(val).
>, <Line: +			replace(/%40/gi, '@').
>, <Line: +			replace(/%3A/gi, ':').
>, <Line: +			replace(/%24/g, '$').
>, <Line: +			replace(/%2C/gi, ',').
>, <Line: +			replace(/%3B/gi, ';').
>, <Line: +			replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
>, <Line: +	}
>, <Line: +	var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
>, <Line: +	function getNgAttribute(element, ngAttr) {
>, <Line: +		var attr, i, ii = ngAttrPrefixes.length;
>, <Line: +		element = jqLite(element);
>, <Line: +		for (i = 0; i < ii; ++i) {
>, <Line: +			attr = ngAttrPrefixes[i] + ngAttr;
>, <Line: +			if (isString(attr = element.attr(attr))) {
>, <Line: +				return attr;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return null;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngApp
>, <Line: +	 * @module ng
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {angular.Module} ngApp an optional application
>, <Line: +	 *   {@link angular.module module} name to load.
>, <Line: +	 * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be
>, <Line: +	 *   created in "strict-di" mode. This means that the application will fail to invoke functions which
>, <Line: +	 *   do not use explicit function annotation (and are thus unsuitable for minification), as described
>, <Line: +	 *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in
>, <Line: +	 *   tracking down the root of these bugs.
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive
>, <Line: +	 * designates the **root element** of the application and is typically placed near the root element
>, <Line: +	 * of the page - e.g. on the `<body>` or `<html>` tags.
>, <Line: +	 *
>, <Line: +	 * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`
>, <Line: +	 * found in the document will be used to define the root element to auto-bootstrap as an
>, <Line: +	 * application. To run multiple applications in an HTML document you must manually bootstrap them using
>, <Line: +	 * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.
>, <Line: +	 *
>, <Line: +	 * You can specify an **AngularJS module** to be used as the root module for the application.  This
>, <Line: +	 * module will be loaded into the {@link auto.$injector} when the application is bootstrapped and
>, <Line: +	 * should contain the application code needed or have dependencies on other modules that will
>, <Line: +	 * contain the code. See {@link angular.module} for more information.
>, <Line: +	 *
>, <Line: +	 * In the example below if the `ngApp` directive were not placed on the `html` element then the
>, <Line: +	 * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`
>, <Line: +	 * would not be resolved to `3`.
>, <Line: +	 *
>, <Line: +	 * `ngApp` is the easiest, and most common, way to bootstrap an application.
>, <Line: +	 *
>, <Line: +	 <example module="ngAppDemo">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ngAppDemoController">
>, <Line: +	 I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
>, <Line: +     $scope.a = 1;
>, <Line: +     $scope.b = 2;
>, <Line: +   });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * Using `ngStrictDi`, you would see something like this:
>, <Line: +	 *
>, <Line: +	 <example ng-app-included="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-app="ngAppStrictDemo" ng-strict-di>
>, <Line: +	 <div ng-controller="GoodController1">
>, <Line: +	 I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: +	 <p>This renders because the controller does not fail to
>, <Line: +	 instantiate, by using explicit annotation style (see
>, <Line: +	 script.js for details)
>, <Line: +	 </p>
>, <Line: +	 </div>
>, <Line: +	 <div ng-controller="GoodController2">
>, <Line: +	 Name: <input ng-model="name"><br />
>, <Line: +	 Hello, {{name}}!
>, <Line: +	 <p>This renders because the controller does not fail to
>, <Line: +	 instantiate, by using explicit annotation style
>, <Line: +	 (see script.js for details)
>, <Line: +	 </p>
>, <Line: +	 </div>
>, <Line: +	 <div ng-controller="BadController">
>, <Line: +	 I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: +	 <p>The controller could not be instantiated, due to relying
>, <Line: +	 on automatic function annotations (which are disabled in
>, <Line: +	 strict mode). As such, the content of this section is not
>, <Line: +	 interpolated, and there should be an error in your web console.
>, <Line: +	 </p>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('ngAppStrictDemo', [])
>, <Line: +	 // BadController will fail to instantiate, due to relying on automatic function annotation,
>, <Line: +	 // rather than an explicit annotation
>, <Line: +	 .controller('BadController', function($scope) {
>, <Line: +       $scope.a = 1;
>, <Line: +       $scope.b = 2;
>, <Line: +     })
>, <Line: +	 // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,
>, <Line: +	 // due to using explicit annotations using the array style and $inject property, respectively.
>, <Line: +	 .controller('GoodController1', ['$scope', function($scope) {
>, <Line: +       $scope.a = 1;
>, <Line: +       $scope.b = 2;
>, <Line: +     }])
>, <Line: +	 .controller('GoodController2', GoodController2);
>, <Line: +	 function GoodController2($scope) {
>, <Line: +       $scope.name = "World";
>, <Line: +     }
>, <Line: +	 GoodController2.$inject = ['$scope'];
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 div[ng-controller] {
>, <Line: +       margin-bottom: 1em;
>, <Line: +       -webkit-border-radius: 4px;
>, <Line: +       border-radius: 4px;
>, <Line: +       border: 1px solid;
>, <Line: +       padding: .5em;
>, <Line: +   }
>, <Line: +	 div[ng-controller^=Good] {
>, <Line: +       border-color: #d6e9c6;
>, <Line: +       background-color: #dff0d8;
>, <Line: +       color: #3c763d;
>, <Line: +   }
>, <Line: +	 div[ng-controller^=Bad] {
>, <Line: +       border-color: #ebccd1;
>, <Line: +       background-color: #f2dede;
>, <Line: +       color: #a94442;
>, <Line: +       margin-bottom: 0;
>, <Line: +   }
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function angularInit(element, bootstrap) {
>, <Line: +		var appElement,
>, <Line: +			module,
>, <Line: +			config = {};
>, <Line: +		// The element `element` has priority over any other element
>, <Line: +		forEach(ngAttrPrefixes, function (prefix) {
>, <Line: +			var name = prefix + 'app';
>, <Line: +			if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
>, <Line: +				appElement = element;
>, <Line: +				module = element.getAttribute(name);
>, <Line: +			}
>, <Line: +		});
>, <Line: +		forEach(ngAttrPrefixes, function (prefix) {
>, <Line: +			var name = prefix + 'app';
>, <Line: +			var candidate;
>, <Line: +			if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
>, <Line: +				appElement = candidate;
>, <Line: +				module = candidate.getAttribute(name);
>, <Line: +			}
>, <Line: +		});
>, <Line: +		if (appElement) {
>, <Line: +			config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
>, <Line: +			bootstrap(appElement, module ? [module] : [], config);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.bootstrap
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 * Use this function to manually start up angular application.
>, <Line: +	 *
>, <Line: +	 * See: {@link guide/bootstrap Bootstrap}
>, <Line: +	 *
>, <Line: +	 * Note that Protractor based end-to-end tests cannot use this function to bootstrap manually.
>, <Line: +	 * They must use {@link ng.directive:ngApp ngApp}.
>, <Line: +	 *
>, <Line: +	 * Angular will detect if it has been loaded into the browser more than once and only allow the
>, <Line: +	 * first loaded script to be bootstrapped and will report a warning to the browser console for
>, <Line: +	 * each of the subsequent scripts. This prevents strange results in applications, where otherwise
>, <Line: +	 * multiple instances of Angular try to work on the DOM.
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <!doctype html>
>, <Line: +	 * <html>
>, <Line: +	 * <body>
>, <Line: +	 * <div ng-controller="WelcomeController">
>, <Line: +	 *   {{greeting}}
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * <script src="angular.js"></script>
>, <Line: +	 * <script>
>, <Line: +	 *   var app = angular.module('demo', [])
>, <Line: +	 *   .controller('WelcomeController', function($scope) {
>, <Line: + *       $scope.greeting = 'Welcome!';
>, <Line: + *   });
>, <Line: +	 *   angular.bootstrap(document, ['demo']);
>, <Line: +	 * </script>
>, <Line: +	 * </body>
>, <Line: +	 * </html>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @param {DOMElement} element DOM element which is the root of angular application.
>, <Line: +	 * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
>, <Line: +	 *     Each item in the array should be the name of a predefined module or a (DI annotated)
>, <Line: +	 *     function that will be invoked by the injector as a run block.
>, <Line: +	 *     See: {@link angular.module modules}
>, <Line: +	 * @param {Object=} config an object for defining configuration options for the application. The
>, <Line: +	 *     following keys are supported:
>, <Line: +	 *
>, <Line: +	 * * `strictDi` - disable automatic function annotation for the application. This is meant to
>, <Line: +	 *   assist in finding bugs which break minified code. Defaults to `false`.
>, <Line: +	 *
>, <Line: +	 * @returns {auto.$injector} Returns the newly created injector for this app.
>, <Line: +	 */
>, <Line: +	function bootstrap(element, modules, config) {
>, <Line: +		if (!isObject(config)) config = {};
>, <Line: +		var defaultConfig = {
>, <Line: +			strictDi: false
>, <Line: +		};
>, <Line: +		config = extend(defaultConfig, config);
>, <Line: +		var doBootstrap = function () {
>, <Line: +			element = jqLite(element);
>, <Line: +			if (element.injector()) {
>, <Line: +				var tag = (element[0] === document) ? 'document' : startingTag(element);
>, <Line: +				//Encode angle brackets to prevent input from being sanitized to empty string #8683
>, <Line: +				throw ngMinErr(
>, <Line: +					'btstrpd',
>, <Line: +					"App Already Bootstrapped with this Element '{0}'",
>, <Line: +					tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
>, <Line: +			}
>, <Line: +			modules = modules || [];
>, <Line: +			modules.unshift(['$provide', function ($provide) {
>, <Line: +				$provide.value('$rootElement', element);
>, <Line: +			}]);
>, <Line: +			if (config.debugInfoEnabled) {
>, <Line: +				// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.
>, <Line: +				modules.push(['$compileProvider', function ($compileProvider) {
>, <Line: +					$compileProvider.debugInfoEnabled(true);
>, <Line: +				}]);
>, <Line: +			}
>, <Line: +			modules.unshift('ng');
>, <Line: +			var injector = createInjector(modules, config.strictDi);
>, <Line: +			injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
>, <Line: +					function bootstrapApply(scope, element, compile, injector) {
>, <Line: +						scope.$apply(function () {
>, <Line: +							element.data('$injector', injector);
>, <Line: +							compile(element)(scope);
>, <Line: +						});
>, <Line: +					}]
>, <Line: +			);
>, <Line: +			return injector;
>, <Line: +		};
>, <Line: +		var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
>, <Line: +		var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
>, <Line: +		if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
>, <Line: +			config.debugInfoEnabled = true;
>, <Line: +			window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
>, <Line: +		}
>, <Line: +		if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
>, <Line: +			return doBootstrap();
>, <Line: +		}
>, <Line: +		window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
>, <Line: +		angular.resumeBootstrap = function (extraModules) {
>, <Line: +			forEach(extraModules, function (module) {
>, <Line: +				modules.push(module);
>, <Line: +			});
>, <Line: +			doBootstrap();
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.reloadWithDebugInfo
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 * Use this function to reload the current application with debug information turned on.
>, <Line: +	 * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.
>, <Line: +	 *
>, <Line: +	 * See {@link ng.$compileProvider#debugInfoEnabled} for more.
>, <Line: +	 */
>, <Line: +	function reloadWithDebugInfo() {
>, <Line: +		window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
>, <Line: +		window.location.reload();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @name angular.getTestability
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 * Get the testability service for the instance of Angular on the given
>, <Line: +	 * element.
>, <Line: +	 * @param {DOMElement} element DOM element which is the root of angular application.
>, <Line: +	 */
>, <Line: +	function getTestability(rootElement) {
>, <Line: +		return angular.element(rootElement).injector().get('$$testability');
>, <Line: +	}
>, <Line: +	var SNAKE_CASE_REGEXP = /[A-Z]/g;
>, <Line: +	function snake_case(name, separator) {
>, <Line: +		separator = separator || '_';
>, <Line: +		return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
>, <Line: +			return (pos ? separator : '') + letter.toLowerCase();
>, <Line: +		});
>, <Line: +	}
>, <Line: +	var bindJQueryFired = false;
>, <Line: +	var skipDestroyOnNextJQueryCleanData;
>, <Line: +	function bindJQuery() {
>, <Line: +		var originalCleanData;
>, <Line: +		if (bindJQueryFired) {
>, <Line: +			return;
>, <Line: +		}
>, <Line: +		// bind to jQuery if present;
>, <Line: +		jQuery = window.jQuery;
>, <Line: +		// Use jQuery if it exists with proper functionality, otherwise default to us.
>, <Line: +		// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.
>, <Line: +		// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older
>, <Line: +		// versions. It will not work for sure with jQuery <1.7, though.
>, <Line: +		if (jQuery && jQuery.fn.on) {
>, <Line: +			jqLite = jQuery;
>, <Line: +			extend(jQuery.fn, {
>, <Line: +				scope: JQLitePrototype.scope,
>, <Line: +				isolateScope: JQLitePrototype.isolateScope,
>, <Line: +				controller: JQLitePrototype.controller,
>, <Line: +				injector: JQLitePrototype.injector,
>, <Line: +				inheritedData: JQLitePrototype.inheritedData
>, <Line: +			});
>, <Line: +			// All nodes removed from the DOM via various jQuery APIs like .remove()
>, <Line: +			// are passed through jQuery.cleanData. Monkey-patch this method to fire
>, <Line: +			// the $destroy event on all removed nodes.
>, <Line: +			originalCleanData = jQuery.cleanData;
>, <Line: +			jQuery.cleanData = function (elems) {
>, <Line: +				var events;
>, <Line: +				if (!skipDestroyOnNextJQueryCleanData) {
>, <Line: +					for (var i = 0, elem; (elem = elems[i]) != null; i++) {
>, <Line: +						events = jQuery._data(elem, "events");
>, <Line: +						if (events && events.$destroy) {
>, <Line: +							jQuery(elem).triggerHandler('$destroy');
>, <Line: +						}
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					skipDestroyOnNextJQueryCleanData = false;
>, <Line: +				}
>, <Line: +				originalCleanData(elems);
>, <Line: +			};
>, <Line: +		} else {
>, <Line: +			jqLite = JQLite;
>, <Line: +		}
>, <Line: +		angular.element = jqLite;
>, <Line: +		// Prevent double-proxying.
>, <Line: +		bindJQueryFired = true;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * throw error if the argument is falsy.
>, <Line: +	 */
>, <Line: +	function assertArg(arg, name, reason) {
>, <Line: +		if (!arg) {
>, <Line: +			throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
>, <Line: +		}
>, <Line: +		return arg;
>, <Line: +	}
>, <Line: +	function assertArgFn(arg, name, acceptArrayAnnotation) {
>, <Line: +		if (acceptArrayAnnotation && isArray(arg)) {
>, <Line: +			arg = arg[arg.length - 1];
>, <Line: +		}
>, <Line: +		assertArg(isFunction(arg), name, 'not a function, got ' +
>, <Line: +			(arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
>, <Line: +		return arg;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * throw error if the name given is hasOwnProperty
>, <Line: +	 * @param  {String} name    the name to test
>, <Line: +	 * @param  {String} context the context in which the name is used, such as module or directive
>, <Line: +	 */
>, <Line: +	function assertNotHasOwnProperty(name, context) {
>, <Line: +		if (name === 'hasOwnProperty') {
>, <Line: +			throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Return the value accessible from the object by path. Any undefined traversals are ignored
>, <Line: +	 * @param {Object} obj starting object
>, <Line: +	 * @param {String} path path to traverse
>, <Line: +	 * @param {boolean} [bindFnToScope=true]
>, <Line: +	 * @returns {Object} value as accessible by path
>, <Line: +	 */
>, <Line: +//TODO(misko): this function needs to be removed
>, <Line: +	function getter(obj, path, bindFnToScope) {
>, <Line: +		if (!path) return obj;
>, <Line: +		var keys = path.split('.');
>, <Line: +		var key;
>, <Line: +		var lastInstance = obj;
>, <Line: +		var len = keys.length;
>, <Line: +		for (var i = 0; i < len; i++) {
>, <Line: +			key = keys[i];
>, <Line: +			if (obj) {
>, <Line: +				obj = (lastInstance = obj)[key];
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (!bindFnToScope && isFunction(obj)) {
>, <Line: +			return bind(lastInstance, obj);
>, <Line: +		}
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Return the DOM siblings between the first and last node in the given array.
>, <Line: +	 * @param {Array} array like object
>, <Line: +	 * @returns {jqLite} jqLite collection containing the nodes
>, <Line: +	 */
>, <Line: +	function getBlockNodes(nodes) {
>, <Line: +		// TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
>, <Line: +		//             collection, otherwise update the original collection.
>, <Line: +		var node = nodes[0];
>, <Line: +		var endNode = nodes[nodes.length - 1];
>, <Line: +		var blockNodes = [node];
>, <Line: +		do {
>, <Line: +			node = node.nextSibling;
>, <Line: +			if (!node) break;
>, <Line: +			blockNodes.push(node);
>, <Line: +		} while (node !== endNode);
>, <Line: +		return jqLite(blockNodes);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Creates a new object without a prototype. This object is useful for lookup without having to
>, <Line: +	 * guard against prototypically inherited properties via hasOwnProperty.
>, <Line: +	 *
>, <Line: +	 * Related micro-benchmarks:
>, <Line: +	 * - http://jsperf.com/object-create2
>, <Line: +	 * - http://jsperf.com/proto-map-lookup/2
>, <Line: +	 * - http://jsperf.com/for-in-vs-object-keys2
>, <Line: +	 *
>, <Line: +	 * @returns {Object}
>, <Line: +	 */
>, <Line: +	function createMap() {
>, <Line: +		return Object.create(null);
>, <Line: +	}
>, <Line: +	var NODE_TYPE_ELEMENT = 1;
>, <Line: +	var NODE_TYPE_TEXT = 3;
>, <Line: +	var NODE_TYPE_COMMENT = 8;
>, <Line: +	var NODE_TYPE_DOCUMENT = 9;
>, <Line: +	var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name angular.Module
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Interface for configuring angular {@link angular.module modules}.
>, <Line: +	 */
>, <Line: +	function setupModuleLoader(window) {
>, <Line: +		var $injectorMinErr = minErr('$injector');
>, <Line: +		var ngMinErr = minErr('ng');
>, <Line: +		function ensure(obj, name, factory) {
>, <Line: +			return obj[name] || (obj[name] = factory());
>, <Line: +		}
>, <Line: +		var angular = ensure(window, 'angular', Object);
>, <Line: +		// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
>, <Line: +		angular.$$minErr = angular.$$minErr || minErr;
>, <Line: +		return ensure(angular, 'module', function () {
>, <Line: +			/** @type {Object.<string, angular.Module>} */
>, <Line: +			var modules = {};
>, <Line: +			/**
>, <Line: +			 * @ngdoc function
>, <Line: +			 * @name angular.module
>, <Line: +			 * @module ng
>, <Line: +			 * @description
>, <Line: +			 *
>, <Line: +			 * The `angular.module` is a global place for creating, registering and retrieving Angular
>, <Line: +			 * modules.
>, <Line: +			 * All modules (angular core or 3rd party) that should be available to an application must be
>, <Line: +			 * registered using this mechanism.
>, <Line: +			 *
>, <Line: +			 * When passed two or more arguments, a new module is created.  If passed only one argument, an
>, <Line: +			 * existing module (the name passed as the first argument to `module`) is retrieved.
>, <Line: +			 *
>, <Line: +			 *
>, <Line: +			 * # Module
>, <Line: +			 *
>, <Line: +			 * A module is a collection of services, directives, controllers, filters, and configuration information.
>, <Line: +			 * `angular.module` is used to configure the {@link auto.$injector $injector}.
>, <Line: +			 *
>, <Line: +			 * ```js
>, <Line: +			 * // Create a new module
>, <Line: +			 * var myModule = angular.module('myModule', []);
>, <Line: +			 *
>, <Line: +			 * // register a new service
>, <Line: +			 * myModule.value('appName', 'MyCoolApp');
>, <Line: +			 *
>, <Line: +			 * // configure existing services inside initialization blocks.
>, <Line: +			 * myModule.config(['$locationProvider', function($locationProvider) {
>, <Line: +     *   // Configure existing providers
>, <Line: +     *   $locationProvider.hashPrefix('!');
>, <Line: +     * }]);
>, <Line: +			 * ```
>, <Line: +			 *
>, <Line: +			 * Then you can create an injector and load your modules like this:
>, <Line: +			 *
>, <Line: +			 * ```js
>, <Line: +			 * var injector = angular.injector(['ng', 'myModule'])
>, <Line: +			 * ```
>, <Line: +			 *
>, <Line: +			 * However it's more likely that you'll just use
>, <Line: +			 * {@link ng.directive:ngApp ngApp} or
>, <Line: +			 * {@link angular.bootstrap} to simplify this process for you.
>, <Line: +			 *
>, <Line: +			 * @param {!string} name The name of the module to create or retrieve.
>, <Line: +			 * @param {!Array.<string>=} requires If specified then new module is being created. If
>, <Line: +			 *        unspecified then the module is being retrieved for further configuration.
>, <Line: +			 * @param {Function=} configFn Optional configuration function for the module. Same as
>, <Line: +			 *        {@link angular.Module#config Module#config()}.
>, <Line: +			 * @returns {module} new module with the {@link angular.Module} api.
>, <Line: +			 */
>, <Line: +			return function module(name, requires, configFn) {
>, <Line: +				var assertNotHasOwnProperty = function (name, context) {
>, <Line: +					if (name === 'hasOwnProperty') {
>, <Line: +						throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
>, <Line: +					}
>, <Line: +				};
>, <Line: +				assertNotHasOwnProperty(name, 'module');
>, <Line: +				if (requires && modules.hasOwnProperty(name)) {
>, <Line: +					modules[name] = null;
>, <Line: +				}
>, <Line: +				return ensure(modules, name, function () {
>, <Line: +					if (!requires) {
>, <Line: +						throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
>, <Line: +							"the module name or forgot to load it. If registering a module ensure that you " +
>, <Line: +							"specify the dependencies as the second argument.", name);
>, <Line: +					}
>, <Line: +					/** @type {!Array.<Array.<*>>} */
>, <Line: +					var invokeQueue = [];
>, <Line: +					/** @type {!Array.<Function>} */
>, <Line: +					var configBlocks = [];
>, <Line: +					/** @type {!Array.<Function>} */
>, <Line: +					var runBlocks = [];
>, <Line: +					var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
>, <Line: +					/** @type {angular.Module} */
>, <Line: +					var moduleInstance = {
>, <Line: +						// Private state
>, <Line: +						_invokeQueue: invokeQueue,
>, <Line: +						_configBlocks: configBlocks,
>, <Line: +						_runBlocks: runBlocks,
>, <Line: +						/**
>, <Line: +						 * @ngdoc property
>, <Line: +						 * @name angular.Module#requires
>, <Line: +						 * @module ng
>, <Line: +						 *
>, <Line: +						 * @description
>, <Line: +						 * Holds the list of modules which the injector will load before the current module is
>, <Line: +						 * loaded.
>, <Line: +						 */
>, <Line: +						requires: requires,
>, <Line: +						/**
>, <Line: +						 * @ngdoc property
>, <Line: +						 * @name angular.Module#name
>, <Line: +						 * @module ng
>, <Line: +						 *
>, <Line: +						 * @description
>, <Line: +						 * Name of the module.
>, <Line: +						 */
>, <Line: +						name: name,
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#provider
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name service name
>, <Line: +						 * @param {Function} providerType Construction function for creating new instance of the
>, <Line: +						 *                                service.
>, <Line: +						 * @description
>, <Line: +						 * See {@link auto.$provide#provider $provide.provider()}.
>, <Line: +						 */
>, <Line: +						provider: invokeLater('$provide', 'provider'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#factory
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name service name
>, <Line: +						 * @param {Function} providerFunction Function for creating new instance of the service.
>, <Line: +						 * @description
>, <Line: +						 * See {@link auto.$provide#factory $provide.factory()}.
>, <Line: +						 */
>, <Line: +						factory: invokeLater('$provide', 'factory'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#service
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name service name
>, <Line: +						 * @param {Function} constructor A constructor function that will be instantiated.
>, <Line: +						 * @description
>, <Line: +						 * See {@link auto.$provide#service $provide.service()}.
>, <Line: +						 */
>, <Line: +						service: invokeLater('$provide', 'service'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#value
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name service name
>, <Line: +						 * @param {*} object Service instance object.
>, <Line: +						 * @description
>, <Line: +						 * See {@link auto.$provide#value $provide.value()}.
>, <Line: +						 */
>, <Line: +						value: invokeLater('$provide', 'value'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#constant
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name constant name
>, <Line: +						 * @param {*} object Constant value.
>, <Line: +						 * @description
>, <Line: +						 * Because the constant are fixed, they get applied before other provide methods.
>, <Line: +						 * See {@link auto.$provide#constant $provide.constant()}.
>, <Line: +						 */
>, <Line: +						constant: invokeLater('$provide', 'constant', 'unshift'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#animation
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name animation name
>, <Line: +						 * @param {Function} animationFactory Factory function for creating new instance of an
>, <Line: +						 *                                    animation.
>, <Line: +						 * @description
>, <Line: +						 *
>, <Line: +						 * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.
>, <Line: +						 *
>, <Line: +						 *
>, <Line: +						 * Defines an animation hook that can be later used with
>, <Line: +						 * {@link ngAnimate.$animate $animate} service and directives that use this service.
>, <Line: +						 *
>, <Line: +						 * ```js
>, <Line: +						 * module.animation('.animation-name', function($inject1, $inject2) {
>, <Line: +           *   return {
>, <Line: +           *     eventName : function(element, done) {
>, <Line: +           *       //code to run the animation
>, <Line: +           *       //once complete, then run done()
>, <Line: +           *       return function cancellationFunction(element) {
>, <Line: +           *         //code to cancel the animation
>, <Line: +           *       }
>, <Line: +           *     }
>, <Line: +           *   }
>, <Line: +           * })
>, <Line: +						 * ```
>, <Line: +						 *
>, <Line: +						 * See {@link ng.$animateProvider#register $animateProvider.register()} and
>, <Line: +						 * {@link ngAnimate ngAnimate module} for more information.
>, <Line: +						 */
>, <Line: +						animation: invokeLater('$animateProvider', 'register'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#filter
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string} name Filter name.
>, <Line: +						 * @param {Function} filterFactory Factory function for creating new instance of filter.
>, <Line: +						 * @description
>, <Line: +						 * See {@link ng.$filterProvider#register $filterProvider.register()}.
>, <Line: +						 */
>, <Line: +						filter: invokeLater('$filterProvider', 'register'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#controller
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string|Object} name Controller name, or an object map of controllers where the
>, <Line: +						 *    keys are the names and the values are the constructors.
>, <Line: +						 * @param {Function} constructor Controller constructor function.
>, <Line: +						 * @description
>, <Line: +						 * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
>, <Line: +						 */
>, <Line: +						controller: invokeLater('$controllerProvider', 'register'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#directive
>, <Line: +						 * @module ng
>, <Line: +						 * @param {string|Object} name Directive name, or an object map of directives where the
>, <Line: +						 *    keys are the names and the values are the factories.
>, <Line: +						 * @param {Function} directiveFactory Factory function for creating new instance of
>, <Line: +						 * directives.
>, <Line: +						 * @description
>, <Line: +						 * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
>, <Line: +						 */
>, <Line: +						directive: invokeLater('$compileProvider', 'directive'),
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#config
>, <Line: +						 * @module ng
>, <Line: +						 * @param {Function} configFn Execute this function on module load. Useful for service
>, <Line: +						 *    configuration.
>, <Line: +						 * @description
>, <Line: +						 * Use this method to register work which needs to be performed on module loading.
>, <Line: +						 * For more about how to configure services, see
>, <Line: +						 * {@link providers#provider-recipe Provider Recipe}.
>, <Line: +						 */
>, <Line: +						config: config,
>, <Line: +						/**
>, <Line: +						 * @ngdoc method
>, <Line: +						 * @name angular.Module#run
>, <Line: +						 * @module ng
>, <Line: +						 * @param {Function} initializationFn Execute this function after injector creation.
>, <Line: +						 *    Useful for application initialization.
>, <Line: +						 * @description
>, <Line: +						 * Use this method to register work which should be performed when the injector is done
>, <Line: +						 * loading all modules.
>, <Line: +						 */
>, <Line: +						run: function (block) {
>, <Line: +							runBlocks.push(block);
>, <Line: +							return this;
>, <Line: +						}
>, <Line: +					};
>, <Line: +					if (configFn) {
>, <Line: +						config(configFn);
>, <Line: +					}
>, <Line: +					return moduleInstance;
>, <Line: +					/**
>, <Line: +					 * @param {string} provider
>, <Line: +					 * @param {string} method
>, <Line: +					 * @param {String=} insertMethod
>, <Line: +					 * @returns {angular.Module}
>, <Line: +					 */
>, <Line: +					function invokeLater(provider, method, insertMethod, queue) {
>, <Line: +						if (!queue) queue = invokeQueue;
>, <Line: +						return function () {
>, <Line: +							queue[insertMethod || 'push']([provider, method, arguments]);
>, <Line: +							return moduleInstance;
>, <Line: +						};
>, <Line: +					}
>, <Line: +				});
>, <Line: +			};
>, <Line: +		});
>, <Line: +	}
>, <Line: +	/* global: toDebugString: true */
>, <Line: +	function serializeObject(obj) {
>, <Line: +		var seen = [];
>, <Line: +		return JSON.stringify(obj, function (key, val) {
>, <Line: +			val = toJsonReplacer(key, val);
>, <Line: +			if (isObject(val)) {
>, <Line: +				if (seen.indexOf(val) >= 0) return '<<already seen>>';
>, <Line: +				seen.push(val);
>, <Line: +			}
>, <Line: +			return val;
>, <Line: +		});
>, <Line: +	}
>, <Line: +	function toDebugString(obj) {
>, <Line: +		if (typeof obj === 'function') {
>, <Line: +			return obj.toString().replace(/ \{[\s\S]*$/, '');
>, <Line: +		} else if (typeof obj === 'undefined') {
>, <Line: +			return 'undefined';
>, <Line: +		} else if (typeof obj !== 'string') {
>, <Line: +			return serializeObject(obj);
>, <Line: +		}
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	/* global angularModule: true,
>, <Line: +	 version: true,
>, <Line: +	 $LocaleProvider,
>, <Line: +	 $CompileProvider,
>, <Line: +	 htmlAnchorDirective,
>, <Line: +	 inputDirective,
>, <Line: +	 inputDirective,
>, <Line: +	 formDirective,
>, <Line: +	 scriptDirective,
>, <Line: +	 selectDirective,
>, <Line: +	 styleDirective,
>, <Line: +	 optionDirective,
>, <Line: +	 ngBindDirective,
>, <Line: +	 ngBindHtmlDirective,
>, <Line: +	 ngBindTemplateDirective,
>, <Line: +	 ngClassDirective,
>, <Line: +	 ngClassEvenDirective,
>, <Line: +	 ngClassOddDirective,
>, <Line: +	 ngCspDirective,
>, <Line: +	 ngCloakDirective,
>, <Line: +	 ngControllerDirective,
>, <Line: +	 ngFormDirective,
>, <Line: +	 ngHideDirective,
>, <Line: +	 ngIfDirective,
>, <Line: +	 ngIncludeDirective,
>, <Line: +	 ngIncludeFillContentDirective,
>, <Line: +	 ngInitDirective,
>, <Line: +	 ngNonBindableDirective,
>, <Line: +	 ngPluralizeDirective,
>, <Line: +	 ngRepeatDirective,
>, <Line: +	 ngShowDirective,
>, <Line: +	 ngStyleDirective,
>, <Line: +	 ngSwitchDirective,
>, <Line: +	 ngSwitchWhenDirective,
>, <Line: +	 ngSwitchDefaultDirective,
>, <Line: +	 ngOptionsDirective,
>, <Line: +	 ngTranscludeDirective,
>, <Line: +	 ngModelDirective,
>, <Line: +	 ngListDirective,
>, <Line: +	 ngChangeDirective,
>, <Line: +	 patternDirective,
>, <Line: +	 patternDirective,
>, <Line: +	 requiredDirective,
>, <Line: +	 requiredDirective,
>, <Line: +	 minlengthDirective,
>, <Line: +	 minlengthDirective,
>, <Line: +	 maxlengthDirective,
>, <Line: +	 maxlengthDirective,
>, <Line: +	 ngValueDirective,
>, <Line: +	 ngModelOptionsDirective,
>, <Line: +	 ngAttributeAliasDirectives,
>, <Line: +	 ngEventDirectives,
>, <Line: +	 $AnchorScrollProvider,
>, <Line: +	 $AnimateProvider,
>, <Line: +	 $BrowserProvider,
>, <Line: +	 $CacheFactoryProvider,
>, <Line: +	 $ControllerProvider,
>, <Line: +	 $DocumentProvider,
>, <Line: +	 $ExceptionHandlerProvider,
>, <Line: +	 $FilterProvider,
>, <Line: +	 $InterpolateProvider,
>, <Line: +	 $IntervalProvider,
>, <Line: +	 $HttpProvider,
>, <Line: +	 $HttpBackendProvider,
>, <Line: +	 $LocationProvider,
>, <Line: +	 $LogProvider,
>, <Line: +	 $ParseProvider,
>, <Line: +	 $RootScopeProvider,
>, <Line: +	 $QProvider,
>, <Line: +	 $$QProvider,
>, <Line: +	 $$SanitizeUriProvider,
>, <Line: +	 $SceProvider,
>, <Line: +	 $SceDelegateProvider,
>, <Line: +	 $SnifferProvider,
>, <Line: +	 $TemplateCacheProvider,
>, <Line: +	 $TemplateRequestProvider,
>, <Line: +	 $$TestabilityProvider,
>, <Line: +	 $TimeoutProvider,
>, <Line: +	 $$RAFProvider,
>, <Line: +	 $$AsyncCallbackProvider,
>, <Line: +	 $WindowProvider
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc object
>, <Line: +	 * @name angular.version
>, <Line: +	 * @module ng
>, <Line: +	 * @description
>, <Line: +	 * An object that contains information about the current AngularJS version. This object has the
>, <Line: +	 * following properties:
>, <Line: +	 *
>, <Line: +	 * - `full`  `{string}`  Full version string, such as "0.9.18".
>, <Line: +	 * - `major`  `{number}`  Major version number, such as "0".
>, <Line: +	 * - `minor`  `{number}`  Minor version number, such as "9".
>, <Line: +	 * - `dot`  `{number}`  Dot version number, such as "18".
>, <Line: +	 * - `codeName`  `{string}`  Code name of the release, such as "jiggling-armfat".
>, <Line: +	 */
>, <Line: +	var version = {
>, <Line: +		full: '1.3.4',    // all of these placeholder strings will be replaced by grunt's
>, <Line: +		major: 1,    // package task
>, <Line: +		minor: 3,
>, <Line: +		dot: 4,
>, <Line: +		codeName: 'highfalutin-petroglyph'
>, <Line: +	};
>, <Line: +	function publishExternalAPI(angular) {
>, <Line: +		extend(angular, {
>, <Line: +			'bootstrap': bootstrap,
>, <Line: +			'copy': copy,
>, <Line: +			'extend': extend,
>, <Line: +			'equals': equals,
>, <Line: +			'element': jqLite,
>, <Line: +			'forEach': forEach,
>, <Line: +			'injector': createInjector,
>, <Line: +			'noop': noop,
>, <Line: +			'bind': bind,
>, <Line: +			'toJson': toJson,
>, <Line: +			'fromJson': fromJson,
>, <Line: +			'identity': identity,
>, <Line: +			'isUndefined': isUndefined,
>, <Line: +			'isDefined': isDefined,
>, <Line: +			'isString': isString,
>, <Line: +			'isFunction': isFunction,
>, <Line: +			'isObject': isObject,
>, <Line: +			'isNumber': isNumber,
>, <Line: +			'isElement': isElement,
>, <Line: +			'isArray': isArray,
>, <Line: +			'version': version,
>, <Line: +			'isDate': isDate,
>, <Line: +			'lowercase': lowercase,
>, <Line: +			'uppercase': uppercase,
>, <Line: +			'callbacks': {counter: 0},
>, <Line: +			'getTestability': getTestability,
>, <Line: +			'$$minErr': minErr,
>, <Line: +			'$$csp': csp,
>, <Line: +			'reloadWithDebugInfo': reloadWithDebugInfo
>, <Line: +		});
>, <Line: +		angularModule = setupModuleLoader(window);
>, <Line: +		try {
>, <Line: +			angularModule('ngLocale');
>, <Line: +		} catch (e) {
>, <Line: +			angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
>, <Line: +		}
>, <Line: +		angularModule('ng', ['ngLocale'], ['$provide',
>, <Line: +			function ngModule($provide) {
>, <Line: +				// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
>, <Line: +				$provide.provider({
>, <Line: +					$$sanitizeUri: $$SanitizeUriProvider
>, <Line: +				});
>, <Line: +				$provide.provider('$compile', $CompileProvider).
>, <Line: +					directive({
>, <Line: +						a: htmlAnchorDirective,
>, <Line: +						input: inputDirective,
>, <Line: +						textarea: inputDirective,
>, <Line: +						form: formDirective,
>, <Line: +						script: scriptDirective,
>, <Line: +						select: selectDirective,
>, <Line: +						style: styleDirective,
>, <Line: +						option: optionDirective,
>, <Line: +						ngBind: ngBindDirective,
>, <Line: +						ngBindHtml: ngBindHtmlDirective,
>, <Line: +						ngBindTemplate: ngBindTemplateDirective,
>, <Line: +						ngClass: ngClassDirective,
>, <Line: +						ngClassEven: ngClassEvenDirective,
>, <Line: +						ngClassOdd: ngClassOddDirective,
>, <Line: +						ngCloak: ngCloakDirective,
>, <Line: +						ngController: ngControllerDirective,
>, <Line: +						ngForm: ngFormDirective,
>, <Line: +						ngHide: ngHideDirective,
>, <Line: +						ngIf: ngIfDirective,
>, <Line: +						ngInclude: ngIncludeDirective,
>, <Line: +						ngInit: ngInitDirective,
>, <Line: +						ngNonBindable: ngNonBindableDirective,
>, <Line: +						ngPluralize: ngPluralizeDirective,
>, <Line: +						ngRepeat: ngRepeatDirective,
>, <Line: +						ngShow: ngShowDirective,
>, <Line: +						ngStyle: ngStyleDirective,
>, <Line: +						ngSwitch: ngSwitchDirective,
>, <Line: +						ngSwitchWhen: ngSwitchWhenDirective,
>, <Line: +						ngSwitchDefault: ngSwitchDefaultDirective,
>, <Line: +						ngOptions: ngOptionsDirective,
>, <Line: +						ngTransclude: ngTranscludeDirective,
>, <Line: +						ngModel: ngModelDirective,
>, <Line: +						ngList: ngListDirective,
>, <Line: +						ngChange: ngChangeDirective,
>, <Line: +						pattern: patternDirective,
>, <Line: +						ngPattern: patternDirective,
>, <Line: +						required: requiredDirective,
>, <Line: +						ngRequired: requiredDirective,
>, <Line: +						minlength: minlengthDirective,
>, <Line: +						ngMinlength: minlengthDirective,
>, <Line: +						maxlength: maxlengthDirective,
>, <Line: +						ngMaxlength: maxlengthDirective,
>, <Line: +						ngValue: ngValueDirective,
>, <Line: +						ngModelOptions: ngModelOptionsDirective
>, <Line: +					}).
>, <Line: +					directive({
>, <Line: +						ngInclude: ngIncludeFillContentDirective
>, <Line: +					}).
>, <Line: +					directive(ngAttributeAliasDirectives).
>, <Line: +					directive(ngEventDirectives);
>, <Line: +				$provide.provider({
>, <Line: +					$anchorScroll: $AnchorScrollProvider,
>, <Line: +					$animate: $AnimateProvider,
>, <Line: +					$browser: $BrowserProvider,
>, <Line: +					$cacheFactory: $CacheFactoryProvider,
>, <Line: +					$controller: $ControllerProvider,
>, <Line: +					$document: $DocumentProvider,
>, <Line: +					$exceptionHandler: $ExceptionHandlerProvider,
>, <Line: +					$filter: $FilterProvider,
>, <Line: +					$interpolate: $InterpolateProvider,
>, <Line: +					$interval: $IntervalProvider,
>, <Line: +					$http: $HttpProvider,
>, <Line: +					$httpBackend: $HttpBackendProvider,
>, <Line: +					$location: $LocationProvider,
>, <Line: +					$log: $LogProvider,
>, <Line: +					$parse: $ParseProvider,
>, <Line: +					$rootScope: $RootScopeProvider,
>, <Line: +					$q: $QProvider,
>, <Line: +					$$q: $$QProvider,
>, <Line: +					$sce: $SceProvider,
>, <Line: +					$sceDelegate: $SceDelegateProvider,
>, <Line: +					$sniffer: $SnifferProvider,
>, <Line: +					$templateCache: $TemplateCacheProvider,
>, <Line: +					$templateRequest: $TemplateRequestProvider,
>, <Line: +					$$testability: $$TestabilityProvider,
>, <Line: +					$timeout: $TimeoutProvider,
>, <Line: +					$window: $WindowProvider,
>, <Line: +					$$rAF: $$RAFProvider,
>, <Line: +					$$asyncCallback: $$AsyncCallbackProvider
>, <Line: +				});
>, <Line: +			}
>, <Line: +		]);
>, <Line: +	}
>, <Line: +	/* global JQLitePrototype: true,
>, <Line: +	 addEventListenerFn: true,
>, <Line: +	 removeEventListenerFn: true,
>, <Line: +	 BOOLEAN_ATTR: true,
>, <Line: +	 ALIASED_ATTR: true,
>, <Line: +	 */
>, <Line: +//////////////////////////////////
>, <Line: +//JQLite
>, <Line: +//////////////////////////////////
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @name angular.element
>, <Line: +	 * @module ng
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
>, <Line: +	 *
>, <Line: +	 * If jQuery is available, `angular.element` is an alias for the
>, <Line: +	 * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`
>, <Line: +	 * delegates to Angular's built-in subset of jQuery, called "jQuery lite" or "jqLite."
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-success">jqLite is a tiny, API-compatible subset of jQuery that allows
>, <Line: +	 * Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most
>, <Line: +	 * commonly needed functionality with the goal of having a very small footprint.</div>
>, <Line: +	 *
>, <Line: +	 * To use jQuery, simply load it before `DOMContentLoaded` event fired.
>, <Line: +	 *
>, <Line: +	 * <div class="alert">**Note:** all element references in Angular are always wrapped with jQuery or
>, <Line: +	 * jqLite; they are never raw DOM references.</div>
>, <Line: +	 *
>, <Line: +	 * ## Angular's jqLite
>, <Line: +	 * jqLite provides only the following jQuery methods:
>, <Line: +	 *
>, <Line: +	 * - [`addClass()`](http://api.jquery.com/addClass/)
>, <Line: +	 * - [`after()`](http://api.jquery.com/after/)
>, <Line: +	 * - [`append()`](http://api.jquery.com/append/)
>, <Line: +	 * - [`attr()`](http://api.jquery.com/attr/) - Does not support functions as parameters
>, <Line: +	 * - [`bind()`](http://api.jquery.com/bind/) - Does not support namespaces, selectors or eventData
>, <Line: +	 * - [`children()`](http://api.jquery.com/children/) - Does not support selectors
>, <Line: +	 * - [`clone()`](http://api.jquery.com/clone/)
>, <Line: +	 * - [`contents()`](http://api.jquery.com/contents/)
>, <Line: +	 * - [`css()`](http://api.jquery.com/css/) - Only retrieves inline-styles, does not call `getComputedStyle()`
>, <Line: +	 * - [`data()`](http://api.jquery.com/data/)
>, <Line: +	 * - [`detach()`](http://api.jquery.com/detach/)
>, <Line: +	 * - [`empty()`](http://api.jquery.com/empty/)
>, <Line: +	 * - [`eq()`](http://api.jquery.com/eq/)
>, <Line: +	 * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
>, <Line: +	 * - [`hasClass()`](http://api.jquery.com/hasClass/)
>, <Line: +	 * - [`html()`](http://api.jquery.com/html/)
>, <Line: +	 * - [`next()`](http://api.jquery.com/next/) - Does not support selectors
>, <Line: +	 * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
>, <Line: +	 * - [`off()`](http://api.jquery.com/off/) - Does not support namespaces or selectors
>, <Line: +	 * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors
>, <Line: +	 * - [`parent()`](http://api.jquery.com/parent/) - Does not support selectors
>, <Line: +	 * - [`prepend()`](http://api.jquery.com/prepend/)
>, <Line: +	 * - [`prop()`](http://api.jquery.com/prop/)
>, <Line: +	 * - [`ready()`](http://api.jquery.com/ready/)
>, <Line: +	 * - [`remove()`](http://api.jquery.com/remove/)
>, <Line: +	 * - [`removeAttr()`](http://api.jquery.com/removeAttr/)
>, <Line: +	 * - [`removeClass()`](http://api.jquery.com/removeClass/)
>, <Line: +	 * - [`removeData()`](http://api.jquery.com/removeData/)
>, <Line: +	 * - [`replaceWith()`](http://api.jquery.com/replaceWith/)
>, <Line: +	 * - [`text()`](http://api.jquery.com/text/)
>, <Line: +	 * - [`toggleClass()`](http://api.jquery.com/toggleClass/)
>, <Line: +	 * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
>, <Line: +	 * - [`unbind()`](http://api.jquery.com/unbind/) - Does not support namespaces
>, <Line: +	 * - [`val()`](http://api.jquery.com/val/)
>, <Line: +	 * - [`wrap()`](http://api.jquery.com/wrap/)
>, <Line: +	 *
>, <Line: +	 * ## jQuery/jqLite Extras
>, <Line: +	 * Angular also provides the following additional methods and events to both jQuery and jqLite:
>, <Line: +	 *
>, <Line: +	 * ### Events
>, <Line: +	 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
>, <Line: +	 *    on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM
>, <Line: +	 *    element before it is removed.
>, <Line: +	 *
>, <Line: +	 * ### Methods
>, <Line: +	 * - `controller(name)` - retrieves the controller of the current element or its parent. By default
>, <Line: +	 *   retrieves controller associated with the `ngController` directive. If `name` is provided as
>, <Line: +	 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
>, <Line: +	 *   `'ngModel'`).
>, <Line: +	 * - `injector()` - retrieves the injector of the current element or its parent.
>, <Line: +	 * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the current
>, <Line: +	 *   element or its parent. Requires {@link guide/production#disabling-debug-data Debug Data} to
>, <Line: +	 *   be enabled.
>, <Line: +	 * - `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope scope} if one is attached directly to the
>, <Line: +	 *   current element. This getter should be used only on elements that contain a directive which starts a new isolate
>, <Line: +	 *   scope. Calling `scope()` on this element always returns the original non-isolate scope.
>, <Line: +	 *   Requires {@link guide/production#disabling-debug-data Debug Data} to be enabled.
>, <Line: +	 * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
>, <Line: +	 *   parent element is reached.
>, <Line: +	 *
>, <Line: +	 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
>, <Line: +	 * @returns {Object} jQuery object.
>, <Line: +	 */
>, <Line: +	JQLite.expando = 'ng339';
>, <Line: +	var jqCache = JQLite.cache = {},
>, <Line: +		jqId = 1,
>, <Line: +		addEventListenerFn = function (element, type, fn) {
>, <Line: +			element.addEventListener(type, fn, false);
>, <Line: +		},
>, <Line: +		removeEventListenerFn = function (element, type, fn) {
>, <Line: +			element.removeEventListener(type, fn, false);
>, <Line: +		};
>, <Line: +	/*
>, <Line: +	 * !!! This is an undocumented "private" function !!!
>, <Line: +	 */
>, <Line: +	JQLite._data = function (node) {
>, <Line: +		//jQuery always returns an object on cache miss
>, <Line: +		return this.cache[node[this.expando]] || {};
>, <Line: +	};
>, <Line: +	function jqNextId() {
>, <Line: +		return ++jqId;
>, <Line: +	}
>, <Line: +	var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
>, <Line: +	var MOZ_HACK_REGEXP = /^moz([A-Z])/;
>, <Line: +	var MOUSE_EVENT_MAP = {mouseleave: "mouseout", mouseenter: "mouseover"};
>, <Line: +	var jqLiteMinErr = minErr('jqLite');
>, <Line: +	/**
>, <Line: +	 * Converts snake_case to camelCase.
>, <Line: +	 * Also there is special case for Moz prefix starting with upper case letter.
>, <Line: +	 * @param name Name to normalize
>, <Line: +	 */
>, <Line: +	function camelCase(name) {
>, <Line: +		return name.
>, <Line: +			replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
>, <Line: +				return offset ? letter.toUpperCase() : letter;
>, <Line: +			}).
>, <Line: +			replace(MOZ_HACK_REGEXP, 'Moz$1');
>, <Line: +	}
>, <Line: +	var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
>, <Line: +	var HTML_REGEXP = /<|&#?\w+;/;
>, <Line: +	var TAG_NAME_REGEXP = /<([\w:]+)/;
>, <Line: +	var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
>, <Line: +	var wrapMap = {
>, <Line: +		'option': [1, '<select multiple="multiple">', '</select>'],
>, <Line: +		'thead': [1, '<table>', '</table>'],
>, <Line: +		'col': [2, '<table><colgroup>', '</colgroup></table>'],
>, <Line: +		'tr': [2, '<table><tbody>', '</tbody></table>'],
>, <Line: +		'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
>, <Line: +		'_default': [0, "", ""]
>, <Line: +	};
>, <Line: +	wrapMap.optgroup = wrapMap.option;
>, <Line: +	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
>, <Line: +	wrapMap.th = wrapMap.td;
>, <Line: +	function jqLiteIsTextNode(html) {
>, <Line: +		return !HTML_REGEXP.test(html);
>, <Line: +	}
>, <Line: +	function jqLiteAcceptsData(node) {
>, <Line: +		// The window object can accept data but has no nodeType
>, <Line: +		// Otherwise we are only interested in elements (1) and documents (9)
>, <Line: +		var nodeType = node.nodeType;
>, <Line: +		return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
>, <Line: +	}
>, <Line: +	function jqLiteBuildFragment(html, context) {
>, <Line: +		var tmp, tag, wrap,
>, <Line: +			fragment = context.createDocumentFragment(),
>, <Line: +			nodes = [], i;
>, <Line: +		if (jqLiteIsTextNode(html)) {
>, <Line: +			// Convert non-html into a text node
>, <Line: +			nodes.push(context.createTextNode(html));
>, <Line: +		} else {
>, <Line: +			// Convert html into DOM nodes
>, <Line: +			tmp = tmp || fragment.appendChild(context.createElement("div"));
>, <Line: +			tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
>, <Line: +			wrap = wrapMap[tag] || wrapMap._default;
>, <Line: +			tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
>, <Line: +			// Descend through wrappers to the right content
>, <Line: +			i = wrap[0];
>, <Line: +			while (i--) {
>, <Line: +				tmp = tmp.lastChild;
>, <Line: +			}
>, <Line: +			nodes = concat(nodes, tmp.childNodes);
>, <Line: +			tmp = fragment.firstChild;
>, <Line: +			tmp.textContent = "";
>, <Line: +		}
>, <Line: +		// Remove wrapper from fragment
>, <Line: +		fragment.textContent = "";
>, <Line: +		fragment.innerHTML = ""; // Clear inner HTML
>, <Line: +		forEach(nodes, function (node) {
>, <Line: +			fragment.appendChild(node);
>, <Line: +		});
>, <Line: +		return fragment;
>, <Line: +	}
>, <Line: +	function jqLiteParseHTML(html, context) {
>, <Line: +		context = context || document;
>, <Line: +		var parsed;
>, <Line: +		if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
>, <Line: +			return [context.createElement(parsed[1])];
>, <Line: +		}
>, <Line: +		if ((parsed = jqLiteBuildFragment(html, context))) {
>, <Line: +			return parsed.childNodes;
>, <Line: +		}
>, <Line: +		return [];
>, <Line: +	}
>, <Line: +/////////////////////////////////////////////
>, <Line: +	function JQLite(element) {
>, <Line: +		if (element instanceof JQLite) {
>, <Line: +			return element;
>, <Line: +		}
>, <Line: +		var argIsString;
>, <Line: +		if (isString(element)) {
>, <Line: +			element = trim(element);
>, <Line: +			argIsString = true;
>, <Line: +		}
>, <Line: +		if (!(this instanceof JQLite)) {
>, <Line: +			if (argIsString && element.charAt(0) != '<') {
>, <Line: +				throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
>, <Line: +			}
>, <Line: +			return new JQLite(element);
>, <Line: +		}
>, <Line: +		if (argIsString) {
>, <Line: +			jqLiteAddNodes(this, jqLiteParseHTML(element));
>, <Line: +		} else {
>, <Line: +			jqLiteAddNodes(this, element);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteClone(element) {
>, <Line: +		return element.cloneNode(true);
>, <Line: +	}
>, <Line: +	function jqLiteDealoc(element, onlyDescendants) {
>, <Line: +		if (!onlyDescendants) jqLiteRemoveData(element);
>, <Line: +		if (element.querySelectorAll) {
>, <Line: +			var descendants = element.querySelectorAll('*');
>, <Line: +			for (var i = 0, l = descendants.length; i < l; i++) {
>, <Line: +				jqLiteRemoveData(descendants[i]);
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteOff(element, type, fn, unsupported) {
>, <Line: +		if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
>, <Line: +		var expandoStore = jqLiteExpandoStore(element);
>, <Line: +		var events = expandoStore && expandoStore.events;
>, <Line: +		var handle = expandoStore && expandoStore.handle;
>, <Line: +		if (!handle) return; //no listeners registered
>, <Line: +		if (!type) {
>, <Line: +			for (type in events) {
>, <Line: +				if (type !== '$destroy') {
>, <Line: +					removeEventListenerFn(element, type, handle);
>, <Line: +				}
>, <Line: +				delete events[type];
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			forEach(type.split(' '), function (type) {
>, <Line: +				if (isDefined(fn)) {
>, <Line: +					var listenerFns = events[type];
>, <Line: +					arrayRemove(listenerFns || [], fn);
>, <Line: +					if (listenerFns && listenerFns.length > 0) {
>, <Line: +						return;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				removeEventListenerFn(element, type, handle);
>, <Line: +				delete events[type];
>, <Line: +			});
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteRemoveData(element, name) {
>, <Line: +		var expandoId = element.ng339;
>, <Line: +		var expandoStore = expandoId && jqCache[expandoId];
>, <Line: +		if (expandoStore) {
>, <Line: +			if (name) {
>, <Line: +				delete expandoStore.data[name];
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			if (expandoStore.handle) {
>, <Line: +				if (expandoStore.events.$destroy) {
>, <Line: +					expandoStore.handle({}, '$destroy');
>, <Line: +				}
>, <Line: +				jqLiteOff(element);
>, <Line: +			}
>, <Line: +			delete jqCache[expandoId];
>, <Line: +			element.ng339 = undefined; // don't delete DOM expandos. IE and Chrome don't like it
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteExpandoStore(element, createIfNecessary) {
>, <Line: +		var expandoId = element.ng339,
>, <Line: +			expandoStore = expandoId && jqCache[expandoId];
>, <Line: +		if (createIfNecessary && !expandoStore) {
>, <Line: +			element.ng339 = expandoId = jqNextId();
>, <Line: +			expandoStore = jqCache[expandoId] = {
>, <Line: +				events: {},
>, <Line: +				data: {},
>, <Line: +				handle: undefined
>, <Line: +			};
>, <Line: +		}
>, <Line: +		return expandoStore;
>, <Line: +	}
>, <Line: +	function jqLiteData(element, key, value) {
>, <Line: +		if (jqLiteAcceptsData(element)) {
>, <Line: +			var isSimpleSetter = isDefined(value);
>, <Line: +			var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
>, <Line: +			var massGetter = !key;
>, <Line: +			var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
>, <Line: +			var data = expandoStore && expandoStore.data;
>, <Line: +			if (isSimpleSetter) { // data('key', value)
>, <Line: +				data[key] = value;
>, <Line: +			} else {
>, <Line: +				if (massGetter) {  // data()
>, <Line: +					return data;
>, <Line: +				} else {
>, <Line: +					if (isSimpleGetter) { // data('key')
>, <Line: +						// don't force creation of expandoStore if it doesn't exist yet
>, <Line: +						return data && data[key];
>, <Line: +					} else { // mass-setter: data({key1: val1, key2: val2})
>, <Line: +						extend(data, key);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteHasClass(element, selector) {
>, <Line: +		if (!element.getAttribute) return false;
>, <Line: +		return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").
>, <Line: +			indexOf(" " + selector + " ") > -1);
>, <Line: +	}
>, <Line: +	function jqLiteRemoveClass(element, cssClasses) {
>, <Line: +		if (cssClasses && element.setAttribute) {
>, <Line: +			forEach(cssClasses.split(' '), function (cssClass) {
>, <Line: +				element.setAttribute('class', trim(
>, <Line: +						(" " + (element.getAttribute('class') || '') + " ")
>, <Line: +							.replace(/[\n\t]/g, " ")
>, <Line: +							.replace(" " + trim(cssClass) + " ", " "))
>, <Line: +				);
>, <Line: +			});
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteAddClass(element, cssClasses) {
>, <Line: +		if (cssClasses && element.setAttribute) {
>, <Line: +			var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
>, <Line: +				.replace(/[\n\t]/g, " ");
>, <Line: +			forEach(cssClasses.split(' '), function (cssClass) {
>, <Line: +				cssClass = trim(cssClass);
>, <Line: +				if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
>, <Line: +					existingClasses += cssClass + ' ';
>, <Line: +				}
>, <Line: +			});
>, <Line: +			element.setAttribute('class', trim(existingClasses));
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteAddNodes(root, elements) {
>, <Line: +		// THIS CODE IS VERY HOT. Don't make changes without benchmarking.
>, <Line: +		if (elements) {
>, <Line: +			// if a Node (the most common case)
>, <Line: +			if (elements.nodeType) {
>, <Line: +				root[root.length++] = elements;
>, <Line: +			} else {
>, <Line: +				var length = elements.length;
>, <Line: +				// if an Array or NodeList and not a Window
>, <Line: +				if (typeof length === 'number' && elements.window !== elements) {
>, <Line: +					if (length) {
>, <Line: +						for (var i = 0; i < length; i++) {
>, <Line: +							root[root.length++] = elements[i];
>, <Line: +						}
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					root[root.length++] = elements;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteController(element, name) {
>, <Line: +		return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
>, <Line: +	}
>, <Line: +	function jqLiteInheritedData(element, name, value) {
>, <Line: +		// if element is the document object work with the html element instead
>, <Line: +		// this makes $(document).scope() possible
>, <Line: +		if (element.nodeType == NODE_TYPE_DOCUMENT) {
>, <Line: +			element = element.documentElement;
>, <Line: +		}
>, <Line: +		var names = isArray(name) ? name : [name];
>, <Line: +		while (element) {
>, <Line: +			for (var i = 0, ii = names.length; i < ii; i++) {
>, <Line: +				if ((value = jqLite.data(element, names[i])) !== undefined) return value;
>, <Line: +			}
>, <Line: +			// If dealing with a document fragment node with a host element, and no parent, use the host
>, <Line: +			// element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
>, <Line: +			// to lookup parent controllers.
>, <Line: +			element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteEmpty(element) {
>, <Line: +		jqLiteDealoc(element, true);
>, <Line: +		while (element.firstChild) {
>, <Line: +			element.removeChild(element.firstChild);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function jqLiteRemove(element, keepData) {
>, <Line: +		if (!keepData) jqLiteDealoc(element);
>, <Line: +		var parent = element.parentNode;
>, <Line: +		if (parent) parent.removeChild(element);
>, <Line: +	}
>, <Line: +	function jqLiteDocumentLoaded(action, win) {
>, <Line: +		win = win || window;
>, <Line: +		if (win.document.readyState === 'complete') {
>, <Line: +			// Force the action to be run async for consistent behaviour
>, <Line: +			// from the action's point of view
>, <Line: +			// i.e. it will definitely not be in a $apply
>, <Line: +			win.setTimeout(action);
>, <Line: +		} else {
>, <Line: +			// No need to unbind this handler as load is only ever called once
>, <Line: +			jqLite(win).on('load', action);
>, <Line: +		}
>, <Line: +	}
>, <Line: +//////////////////////////////////////////
>, <Line: +// Functions which are declared directly.
>, <Line: +//////////////////////////////////////////
>, <Line: +	var JQLitePrototype = JQLite.prototype = {
>, <Line: +		ready: function (fn) {
>, <Line: +			var fired = false;
>, <Line: +			function trigger() {
>, <Line: +				if (fired) return;
>, <Line: +				fired = true;
>, <Line: +				fn();
>, <Line: +			}
>, <Line: +			// check if document is already loaded
>, <Line: +			if (document.readyState === 'complete') {
>, <Line: +				setTimeout(trigger);
>, <Line: +			} else {
>, <Line: +				this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
>, <Line: +				// we can not use jqLite since we are not done loading and jQuery could be loaded later.
>, <Line: +				// jshint -W064
>, <Line: +				JQLite(window).on('load', trigger); // fallback to window.onload for others
>, <Line: +				// jshint +W064
>, <Line: +			}
>, <Line: +		},
>, <Line: +		toString: function () {
>, <Line: +			var value = [];
>, <Line: +			forEach(this, function (e) {
>, <Line: +				value.push('' + e);
>, <Line: +			});
>, <Line: +			return '[' + value.join(', ') + ']';
>, <Line: +		},
>, <Line: +		eq: function (index) {
>, <Line: +			return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
>, <Line: +		},
>, <Line: +		length: 0,
>, <Line: +		push: push,
>, <Line: +		sort: [].sort,
>, <Line: +		splice: [].splice
>, <Line: +	};
>, <Line: +//////////////////////////////////////////
>, <Line: +// Functions iterating getter/setters.
>, <Line: +// these functions return self on setter and
>, <Line: +// value on get.
>, <Line: +//////////////////////////////////////////
>, <Line: +	var BOOLEAN_ATTR = {};
>, <Line: +	forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {
>, <Line: +		BOOLEAN_ATTR[lowercase(value)] = value;
>, <Line: +	});
>, <Line: +	var BOOLEAN_ELEMENTS = {};
>, <Line: +	forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {
>, <Line: +		BOOLEAN_ELEMENTS[value] = true;
>, <Line: +	});
>, <Line: +	var ALIASED_ATTR = {
>, <Line: +		'ngMinlength': 'minlength',
>, <Line: +		'ngMaxlength': 'maxlength',
>, <Line: +		'ngMin': 'min',
>, <Line: +		'ngMax': 'max',
>, <Line: +		'ngPattern': 'pattern'
>, <Line: +	};
>, <Line: +	function getBooleanAttrName(element, name) {
>, <Line: +		// check dom last since we will most likely fail on name
>, <Line: +		var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
>, <Line: +		// booleanAttr is here twice to minimize DOM access
>, <Line: +		return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
>, <Line: +	}
>, <Line: +	function getAliasedAttrName(element, name) {
>, <Line: +		var nodeName = element.nodeName;
>, <Line: +		return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
>, <Line: +	}
>, <Line: +	forEach({
>, <Line: +		data: jqLiteData,
>, <Line: +		removeData: jqLiteRemoveData
>, <Line: +	}, function (fn, name) {
>, <Line: +		JQLite[name] = fn;
>, <Line: +	});
>, <Line: +	forEach({
>, <Line: +		data: jqLiteData,
>, <Line: +		inheritedData: jqLiteInheritedData,
>, <Line: +		scope: function (element) {
>, <Line: +			// Can't use jqLiteData here directly so we stay compatible with jQuery!
>, <Line: +			return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
>, <Line: +		},
>, <Line: +		isolateScope: function (element) {
>, <Line: +			// Can't use jqLiteData here directly so we stay compatible with jQuery!
>, <Line: +			return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
>, <Line: +		},
>, <Line: +		controller: jqLiteController,
>, <Line: +		injector: function (element) {
>, <Line: +			return jqLiteInheritedData(element, '$injector');
>, <Line: +		},
>, <Line: +		removeAttr: function (element, name) {
>, <Line: +			element.removeAttribute(name);
>, <Line: +		},
>, <Line: +		hasClass: jqLiteHasClass,
>, <Line: +		css: function (element, name, value) {
>, <Line: +			name = camelCase(name);
>, <Line: +			if (isDefined(value)) {
>, <Line: +				element.style[name] = value;
>, <Line: +			} else {
>, <Line: +				return element.style[name];
>, <Line: +			}
>, <Line: +		},
>, <Line: +		attr: function (element, name, value) {
>, <Line: +			var lowercasedName = lowercase(name);
>, <Line: +			if (BOOLEAN_ATTR[lowercasedName]) {
>, <Line: +				if (isDefined(value)) {
>, <Line: +					if (!!value) {
>, <Line: +						element[name] = true;
>, <Line: +						element.setAttribute(name, lowercasedName);
>, <Line: +					} else {
>, <Line: +						element[name] = false;
>, <Line: +						element.removeAttribute(lowercasedName);
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					return (element[name] ||
>, <Line: +					(element.attributes.getNamedItem(name) || noop).specified)
>, <Line: +						? lowercasedName
>, <Line: +						: undefined;
>, <Line: +				}
>, <Line: +			} else if (isDefined(value)) {
>, <Line: +				element.setAttribute(name, value);
>, <Line: +			} else if (element.getAttribute) {
>, <Line: +				// the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
>, <Line: +				// some elements (e.g. Document) don't have get attribute, so return undefined
>, <Line: +				var ret = element.getAttribute(name, 2);
>, <Line: +				// normalize non-existing attributes to undefined (as jQuery)
>, <Line: +				return ret === null ? undefined : ret;
>, <Line: +			}
>, <Line: +		},
>, <Line: +		prop: function (element, name, value) {
>, <Line: +			if (isDefined(value)) {
>, <Line: +				element[name] = value;
>, <Line: +			} else {
>, <Line: +				return element[name];
>, <Line: +			}
>, <Line: +		},
>, <Line: +		text: (function () {
>, <Line: +			getText.$dv = '';
>, <Line: +			return getText;
>, <Line: +			function getText(element, value) {
>, <Line: +				if (isUndefined(value)) {
>, <Line: +					var nodeType = element.nodeType;
>, <Line: +					return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
>, <Line: +				}
>, <Line: +				element.textContent = value;
>, <Line: +			}
>, <Line: +		})(),
>, <Line: +		val: function (element, value) {
>, <Line: +			if (isUndefined(value)) {
>, <Line: +				if (element.multiple && nodeName_(element) === 'select') {
>, <Line: +					var result = [];
>, <Line: +					forEach(element.options, function (option) {
>, <Line: +						if (option.selected) {
>, <Line: +							result.push(option.value || option.text);
>, <Line: +						}
>, <Line: +					});
>, <Line: +					return result.length === 0 ? null : result;
>, <Line: +				}
>, <Line: +				return element.value;
>, <Line: +			}
>, <Line: +			element.value = value;
>, <Line: +		},
>, <Line: +		html: function (element, value) {
>, <Line: +			if (isUndefined(value)) {
>, <Line: +				return element.innerHTML;
>, <Line: +			}
>, <Line: +			jqLiteDealoc(element, true);
>, <Line: +			element.innerHTML = value;
>, <Line: +		},
>, <Line: +		empty: jqLiteEmpty
>, <Line: +	}, function (fn, name) {
>, <Line: +		/**
>, <Line: +		 * Properties: writes return selection, reads return first value
>, <Line: +		 */
>, <Line: +		JQLite.prototype[name] = function (arg1, arg2) {
>, <Line: +			var i, key;
>, <Line: +			var nodeCount = this.length;
>, <Line: +			// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
>, <Line: +			// in a way that survives minification.
>, <Line: +			// jqLiteEmpty takes no arguments but is a setter.
>, <Line: +			if (fn !== jqLiteEmpty &&
>, <Line: +				(((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
>, <Line: +				if (isObject(arg1)) {
>, <Line: +					// we are a write, but the object properties are the key/values
>, <Line: +					for (i = 0; i < nodeCount; i++) {
>, <Line: +						if (fn === jqLiteData) {
>, <Line: +							// data() takes the whole object in jQuery
>, <Line: +							fn(this[i], arg1);
>, <Line: +						} else {
>, <Line: +							for (key in arg1) {
>, <Line: +								fn(this[i], key, arg1[key]);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					// return self for chaining
>, <Line: +					return this;
>, <Line: +				} else {
>, <Line: +					// we are a read, so read the first child.
>, <Line: +					// TODO: do we still need this?
>, <Line: +					var value = fn.$dv;
>, <Line: +					// Only if we have $dv do we iterate over all, otherwise it is just the first element.
>, <Line: +					var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
>, <Line: +					for (var j = 0; j < jj; j++) {
>, <Line: +						var nodeValue = fn(this[j], arg1, arg2);
>, <Line: +						value = value ? value + nodeValue : nodeValue;
>, <Line: +					}
>, <Line: +					return value;
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				// we are a write, so apply to all children
>, <Line: +				for (i = 0; i < nodeCount; i++) {
>, <Line: +					fn(this[i], arg1, arg2);
>, <Line: +				}
>, <Line: +				// return self for chaining
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +		};
>, <Line: +	});
>, <Line: +	function createEventHandler(element, events) {
>, <Line: +		var eventHandler = function (event, type) {
>, <Line: +			// jQuery specific api
>, <Line: +			event.isDefaultPrevented = function () {
>, <Line: +				return event.defaultPrevented;
>, <Line: +			};
>, <Line: +			var eventFns = events[type || event.type];
>, <Line: +			var eventFnsLength = eventFns ? eventFns.length : 0;
>, <Line: +			if (!eventFnsLength) return;
>, <Line: +			if (isUndefined(event.immediatePropagationStopped)) {
>, <Line: +				var originalStopImmediatePropagation = event.stopImmediatePropagation;
>, <Line: +				event.stopImmediatePropagation = function () {
>, <Line: +					event.immediatePropagationStopped = true;
>, <Line: +					if (event.stopPropagation) {
>, <Line: +						event.stopPropagation();
>, <Line: +					}
>, <Line: +					if (originalStopImmediatePropagation) {
>, <Line: +						originalStopImmediatePropagation.call(event);
>, <Line: +					}
>, <Line: +				};
>, <Line: +			}
>, <Line: +			event.isImmediatePropagationStopped = function () {
>, <Line: +				return event.immediatePropagationStopped === true;
>, <Line: +			};
>, <Line: +			// Copy event handlers in case event handlers array is modified during execution.
>, <Line: +			if ((eventFnsLength > 1)) {
>, <Line: +				eventFns = shallowCopy(eventFns);
>, <Line: +			}
>, <Line: +			for (var i = 0; i < eventFnsLength; i++) {
>, <Line: +				if (!event.isImmediatePropagationStopped()) {
>, <Line: +					eventFns[i].call(element, event);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +		// TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all
>, <Line: +		//       events on `element`
>, <Line: +		eventHandler.elem = element;
>, <Line: +		return eventHandler;
>, <Line: +	}
>, <Line: +//////////////////////////////////////////
>, <Line: +// Functions iterating traversal.
>, <Line: +// These functions chain results into a single
>, <Line: +// selector.
>, <Line: +//////////////////////////////////////////
>, <Line: +	forEach({
>, <Line: +		removeData: jqLiteRemoveData,
>, <Line: +		on: function jqLiteOn(element, type, fn, unsupported) {
>, <Line: +			if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
>, <Line: +			// Do not add event handlers to non-elements because they will not be cleaned up.
>, <Line: +			if (!jqLiteAcceptsData(element)) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			var expandoStore = jqLiteExpandoStore(element, true);
>, <Line: +			var events = expandoStore.events;
>, <Line: +			var handle = expandoStore.handle;
>, <Line: +			if (!handle) {
>, <Line: +				handle = expandoStore.handle = createEventHandler(element, events);
>, <Line: +			}
>, <Line: +			// http://jsperf.com/string-indexof-vs-split
>, <Line: +			var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
>, <Line: +			var i = types.length;
>, <Line: +			while (i--) {
>, <Line: +				type = types[i];
>, <Line: +				var eventFns = events[type];
>, <Line: +				if (!eventFns) {
>, <Line: +					events[type] = [];
>, <Line: +					if (type === 'mouseenter' || type === 'mouseleave') {
>, <Line: +						// Refer to jQuery's implementation of mouseenter & mouseleave
>, <Line: +						// Read about mouseenter and mouseleave:
>, <Line: +						// http://www.quirksmode.org/js/events_mouse.html#link8
>, <Line: +						jqLiteOn(element, MOUSE_EVENT_MAP[type], function (event) {
>, <Line: +							var target = this, related = event.relatedTarget;
>, <Line: +							// For mousenter/leave call the handler if related is outside the target.
>, <Line: +							// NB: No relatedTarget if the mouse left/entered the browser window
>, <Line: +							if (!related || (related !== target && !target.contains(related))) {
>, <Line: +								handle(event, type);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					} else {
>, <Line: +						if (type !== '$destroy') {
>, <Line: +							addEventListenerFn(element, type, handle);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					eventFns = events[type];
>, <Line: +				}
>, <Line: +				eventFns.push(fn);
>, <Line: +			}
>, <Line: +		},
>, <Line: +		off: jqLiteOff,
>, <Line: +		one: function (element, type, fn) {
>, <Line: +			element = jqLite(element);
>, <Line: +			//add the listener twice so that when it is called
>, <Line: +			//you can remove the original function and still be
>, <Line: +			//able to call element.off(ev, fn) normally
>, <Line: +			element.on(type, function onFn() {
>, <Line: +				element.off(type, fn);
>, <Line: +				element.off(type, onFn);
>, <Line: +			});
>, <Line: +			element.on(type, fn);
>, <Line: +		},
>, <Line: +		replaceWith: function (element, replaceNode) {
>, <Line: +			var index, parent = element.parentNode;
>, <Line: +			jqLiteDealoc(element);
>, <Line: +			forEach(new JQLite(replaceNode), function (node) {
>, <Line: +				if (index) {
>, <Line: +					parent.insertBefore(node, index.nextSibling);
>, <Line: +				} else {
>, <Line: +					parent.replaceChild(node, element);
>, <Line: +				}
>, <Line: +				index = node;
>, <Line: +			});
>, <Line: +		},
>, <Line: +		children: function (element) {
>, <Line: +			var children = [];
>, <Line: +			forEach(element.childNodes, function (element) {
>, <Line: +				if (element.nodeType === NODE_TYPE_ELEMENT)
>, <Line: +					children.push(element);
>, <Line: +			});
>, <Line: +			return children;
>, <Line: +		},
>, <Line: +		contents: function (element) {
>, <Line: +			return element.contentDocument || element.childNodes || [];
>, <Line: +		},
>, <Line: +		append: function (element, node) {
>, <Line: +			var nodeType = element.nodeType;
>, <Line: +			if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
>, <Line: +			node = new JQLite(node);
>, <Line: +			for (var i = 0, ii = node.length; i < ii; i++) {
>, <Line: +				var child = node[i];
>, <Line: +				element.appendChild(child);
>, <Line: +			}
>, <Line: +		},
>, <Line: +		prepend: function (element, node) {
>, <Line: +			if (element.nodeType === NODE_TYPE_ELEMENT) {
>, <Line: +				var index = element.firstChild;
>, <Line: +				forEach(new JQLite(node), function (child) {
>, <Line: +					element.insertBefore(child, index);
>, <Line: +				});
>, <Line: +			}
>, <Line: +		},
>, <Line: +		wrap: function (element, wrapNode) {
>, <Line: +			wrapNode = jqLite(wrapNode).eq(0).clone()[0];
>, <Line: +			var parent = element.parentNode;
>, <Line: +			if (parent) {
>, <Line: +				parent.replaceChild(wrapNode, element);
>, <Line: +			}
>, <Line: +			wrapNode.appendChild(element);
>, <Line: +		},
>, <Line: +		remove: jqLiteRemove,
>, <Line: +		detach: function (element) {
>, <Line: +			jqLiteRemove(element, true);
>, <Line: +		},
>, <Line: +		after: function (element, newElement) {
>, <Line: +			var index = element, parent = element.parentNode;
>, <Line: +			newElement = new JQLite(newElement);
>, <Line: +			for (var i = 0, ii = newElement.length; i < ii; i++) {
>, <Line: +				var node = newElement[i];
>, <Line: +				parent.insertBefore(node, index.nextSibling);
>, <Line: +				index = node;
>, <Line: +			}
>, <Line: +		},
>, <Line: +		addClass: jqLiteAddClass,
>, <Line: +		removeClass: jqLiteRemoveClass,
>, <Line: +		toggleClass: function (element, selector, condition) {
>, <Line: +			if (selector) {
>, <Line: +				forEach(selector.split(' '), function (className) {
>, <Line: +					var classCondition = condition;
>, <Line: +					if (isUndefined(classCondition)) {
>, <Line: +						classCondition = !jqLiteHasClass(element, className);
>, <Line: +					}
>, <Line: +					(classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
>, <Line: +				});
>, <Line: +			}
>, <Line: +		},
>, <Line: +		parent: function (element) {
>, <Line: +			var parent = element.parentNode;
>, <Line: +			return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
>, <Line: +		},
>, <Line: +		next: function (element) {
>, <Line: +			return element.nextElementSibling;
>, <Line: +		},
>, <Line: +		find: function (element, selector) {
>, <Line: +			if (element.getElementsByTagName) {
>, <Line: +				return element.getElementsByTagName(selector);
>, <Line: +			} else {
>, <Line: +				return [];
>, <Line: +			}
>, <Line: +		},
>, <Line: +		clone: jqLiteClone,
>, <Line: +		triggerHandler: function (element, event, extraParameters) {
>, <Line: +			var dummyEvent, eventFnsCopy, handlerArgs;
>, <Line: +			var eventName = event.type || event;
>, <Line: +			var expandoStore = jqLiteExpandoStore(element);
>, <Line: +			var events = expandoStore && expandoStore.events;
>, <Line: +			var eventFns = events && events[eventName];
>, <Line: +			if (eventFns) {
>, <Line: +				// Create a dummy event to pass to the handlers
>, <Line: +				dummyEvent = {
>, <Line: +					preventDefault: function () {
>, <Line: +						this.defaultPrevented = true;
>, <Line: +					},
>, <Line: +					isDefaultPrevented: function () {
>, <Line: +						return this.defaultPrevented === true;
>, <Line: +					},
>, <Line: +					stopImmediatePropagation: function () {
>, <Line: +						this.immediatePropagationStopped = true;
>, <Line: +					},
>, <Line: +					isImmediatePropagationStopped: function () {
>, <Line: +						return this.immediatePropagationStopped === true;
>, <Line: +					},
>, <Line: +					stopPropagation: noop,
>, <Line: +					type: eventName,
>, <Line: +					target: element
>, <Line: +				};
>, <Line: +				// If a custom event was provided then extend our dummy event with it
>, <Line: +				if (event.type) {
>, <Line: +					dummyEvent = extend(dummyEvent, event);
>, <Line: +				}
>, <Line: +				// Copy event handlers in case event handlers array is modified during execution.
>, <Line: +				eventFnsCopy = shallowCopy(eventFns);
>, <Line: +				handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
>, <Line: +				forEach(eventFnsCopy, function (fn) {
>, <Line: +					if (!dummyEvent.isImmediatePropagationStopped()) {
>, <Line: +						fn.apply(element, handlerArgs);
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}, function (fn, name) {
>, <Line: +		/**
>, <Line: +		 * chaining functions
>, <Line: +		 */
>, <Line: +		JQLite.prototype[name] = function (arg1, arg2, arg3) {
>, <Line: +			var value;
>, <Line: +			for (var i = 0, ii = this.length; i < ii; i++) {
>, <Line: +				if (isUndefined(value)) {
>, <Line: +					value = fn(this[i], arg1, arg2, arg3);
>, <Line: +					if (isDefined(value)) {
>, <Line: +						// any function which returns a value needs to be wrapped
>, <Line: +						value = jqLite(value);
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return isDefined(value) ? value : this;
>, <Line: +		};
>, <Line: +		// bind legacy bind/unbind to on/off
>, <Line: +		JQLite.prototype.bind = JQLite.prototype.on;
>, <Line: +		JQLite.prototype.unbind = JQLite.prototype.off;
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * Computes a hash of an 'obj'.
>, <Line: +	 * Hash of a:
>, <Line: +	 *  string is string
>, <Line: +	 *  number is number as string
>, <Line: +	 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
>, <Line: +	 *         that is also assigned to the $$hashKey property of the object.
>, <Line: +	 *
>, <Line: +	 * @param obj
>, <Line: +	 * @returns {string} hash string such that the same input will have the same hash string.
>, <Line: +	 *         The resulting string key is in 'type:hashKey' format.
>, <Line: +	 */
>, <Line: +	function hashKey(obj, nextUidFn) {
>, <Line: +		var key = obj && obj.$$hashKey;
>, <Line: +		if (key) {
>, <Line: +			if (typeof key === 'function') {
>, <Line: +				key = obj.$$hashKey();
>, <Line: +			}
>, <Line: +			return key;
>, <Line: +		}
>, <Line: +		var objType = typeof obj;
>, <Line: +		if (objType == 'function' || (objType == 'object' && obj !== null)) {
>, <Line: +			key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
>, <Line: +		} else {
>, <Line: +			key = objType + ':' + obj;
>, <Line: +		}
>, <Line: +		return key;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * HashMap which can use objects as keys
>, <Line: +	 */
>, <Line: +	function HashMap(array, isolatedUid) {
>, <Line: +		if (isolatedUid) {
>, <Line: +			var uid = 0;
>, <Line: +			this.nextUid = function () {
>, <Line: +				return ++uid;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		forEach(array, this.put, this);
>, <Line: +	}
>, <Line: +	HashMap.prototype = {
>, <Line: +		/**
>, <Line: +		 * Store key value pair
>, <Line: +		 * @param key key to store can be any type
>, <Line: +		 * @param value value to store can be any type
>, <Line: +		 */
>, <Line: +		put: function (key, value) {
>, <Line: +			this[hashKey(key, this.nextUid)] = value;
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * @param key
>, <Line: +		 * @returns {Object} the value for the key
>, <Line: +		 */
>, <Line: +		get: function (key) {
>, <Line: +			return this[hashKey(key, this.nextUid)];
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * Remove the key/value pair
>, <Line: +		 * @param key
>, <Line: +		 */
>, <Line: +		remove: function (key) {
>, <Line: +			var value = this[key = hashKey(key, this.nextUid)];
>, <Line: +			delete this[key];
>, <Line: +			return value;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc function
>, <Line: +	 * @module ng
>, <Line: +	 * @name angular.injector
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Creates an injector object that can be used for retrieving services as well as for
>, <Line: +	 * dependency injection (see {@link guide/di dependency injection}).
>, <Line: +	 *
>, <Line: +	 * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
>, <Line: +	 *     {@link angular.module}. The `ng` module must be explicitly added.
>, <Line: +	 * @param {boolean=} [strictDi=false] Whether the injector should be in strict mode, which
>, <Line: +	 *     disallows argument name annotation inference.
>, <Line: +	 * @returns {injector} Injector object. See {@link auto.$injector $injector}.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Typical usage
>, <Line: +	 * ```js
>, <Line: +	 *   // create an injector
>, <Line: +	 *   var $injector = angular.injector(['ng']);
>, <Line: +	 *
>, <Line: +	 *   // use the injector to kick off your application
>, <Line: +	 *   // use the type inference to auto inject arguments, or use implicit injection
>, <Line: +	 *   $injector.invoke(function($rootScope, $compile, $document) {
>, <Line: + *     $compile($document)($rootScope);
>, <Line: + *     $rootScope.$digest();
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Sometimes you want to get access to the injector of a currently running Angular app
>, <Line: +	 * from outside Angular. Perhaps, you want to inject and compile some markup after the
>, <Line: +	 * application has been bootstrapped. You can do this using the extra `injector()` added
>, <Line: +	 * to JQuery/jqLite elements. See {@link angular.element}.
>, <Line: +	 *
>, <Line: +	 * *This is fairly rare but could be the case if a third party library is injecting the
>, <Line: +	 * markup.*
>, <Line: +	 *
>, <Line: +	 * In the following example a new block of HTML containing a `ng-controller`
>, <Line: +	 * directive is added to the end of the document body by JQuery. We then compile and link
>, <Line: +	 * it into the current AngularJS scope.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
>, <Line: +	 * $(document.body).append($div);
>, <Line: +	 *
>, <Line: +	 * angular.element(document).injector().invoke(function($compile) {
>, <Line: + *   var scope = angular.element($div).scope();
>, <Line: + *   $compile($div)(scope);
>, <Line: + * });
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc module
>, <Line: +	 * @name auto
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Implicit module which gets automatically added to each {@link auto.$injector $injector}.
>, <Line: +	 */
>, <Line: +	var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
>, <Line: +	var FN_ARG_SPLIT = /,/;
>, <Line: +	var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
>, <Line: +	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
>, <Line: +	var $injectorMinErr = minErr('$injector');
>, <Line: +	function anonFn(fn) {
>, <Line: +		// For anonymous functions, showing at the very least the function signature can help in
>, <Line: +		// debugging.
>, <Line: +		var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
>, <Line: +			args = fnText.match(FN_ARGS);
>, <Line: +		if (args) {
>, <Line: +			return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
>, <Line: +		}
>, <Line: +		return 'fn';
>, <Line: +	}
>, <Line: +	function annotate(fn, strictDi, name) {
>, <Line: +		var $inject,
>, <Line: +			fnText,
>, <Line: +			argDecl,
>, <Line: +			last;
>, <Line: +		if (typeof fn === 'function') {
>, <Line: +			if (!($inject = fn.$inject)) {
>, <Line: +				$inject = [];
>, <Line: +				if (fn.length) {
>, <Line: +					if (strictDi) {
>, <Line: +						if (!isString(name) || !name) {
>, <Line: +							name = fn.name || anonFn(fn);
>, <Line: +						}
>, <Line: +						throw $injectorMinErr('strictdi',
>, <Line: +							'{0} is not using explicit annotation and cannot be invoked in strict mode', name);
>, <Line: +					}
>, <Line: +					fnText = fn.toString().replace(STRIP_COMMENTS, '');
>, <Line: +					argDecl = fnText.match(FN_ARGS);
>, <Line: +					forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
>, <Line: +						arg.replace(FN_ARG, function (all, underscore, name) {
>, <Line: +							$inject.push(name);
>, <Line: +						});
>, <Line: +					});
>, <Line: +				}
>, <Line: +				fn.$inject = $inject;
>, <Line: +			}
>, <Line: +		} else if (isArray(fn)) {
>, <Line: +			last = fn.length - 1;
>, <Line: +			assertArgFn(fn[last], 'fn');
>, <Line: +			$inject = fn.slice(0, last);
>, <Line: +		} else {
>, <Line: +			assertArgFn(fn, 'fn', true);
>, <Line: +		}
>, <Line: +		return $inject;
>, <Line: +	}
>, <Line: +///////////////////////////////////////
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $injector
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * `$injector` is used to retrieve object instances as defined by
>, <Line: +	 * {@link auto.$provide provider}, instantiate types, invoke methods,
>, <Line: +	 * and load modules.
>, <Line: +	 *
>, <Line: +	 * The following always holds true:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   var $injector = angular.injector();
>, <Line: +	 *   expect($injector.get('$injector')).toBe($injector);
>, <Line: +	 *   expect($injector.invoke(function($injector) {
>, <Line: + *     return $injector;
>, <Line: + *   })).toBe($injector);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * # Injection Function Annotation
>, <Line: +	 *
>, <Line: +	 * JavaScript does not have annotations, and annotations are needed for dependency injection. The
>, <Line: +	 * following are all valid ways of annotating function with injection arguments and are equivalent.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   // inferred (only works if code not minified/obfuscated)
>, <Line: +	 *   $injector.invoke(function(serviceA){});
>, <Line: +	 *
>, <Line: +	 *   // annotated
>, <Line: +	 *   function explicit(serviceA) {};
>, <Line: +	 *   explicit.$inject = ['serviceA'];
>, <Line: +	 *   $injector.invoke(explicit);
>, <Line: +	 *
>, <Line: +	 *   // inline
>, <Line: +	 *   $injector.invoke(['serviceA', function(serviceA){}]);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * ## Inference
>, <Line: +	 *
>, <Line: +	 * In JavaScript calling `toString()` on a function returns the function definition. The definition
>, <Line: +	 * can then be parsed and the function arguments can be extracted. This method of discovering
>, <Line: +	 * annotations is disallowed when the injector is in strict mode.
>, <Line: +	 * *NOTE:* This does not work with minification, and obfuscation tools since these tools change the
>, <Line: +	 * argument names.
>, <Line: +	 *
>, <Line: +	 * ## `$inject` Annotation
>, <Line: +	 * By adding an `$inject` property onto a function the injection parameters can be specified.
>, <Line: +	 *
>, <Line: +	 * ## Inline
>, <Line: +	 * As an array of injection names, where the last item in the array is the function to call.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $injector#get
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Return an instance of the service.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the instance to retrieve.
>, <Line: +	 * @return {*} The instance.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $injector#invoke
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Invoke the method and supply the method arguments from the `$injector`.
>, <Line: +	 *
>, <Line: +	 * @param {!Function} fn The function to invoke. Function parameters are injected according to the
>, <Line: +	 *   {@link guide/di $inject Annotation} rules.
>, <Line: +	 * @param {Object=} self The `this` for the invoked method.
>, <Line: +	 * @param {Object=} locals Optional object. If preset then any argument names are read from this
>, <Line: +	 *                         object first, before the `$injector` is consulted.
>, <Line: +	 * @returns {*} the value returned by the invoked `fn` function.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $injector#has
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Allows the user to query if the particular service exists.
>, <Line: +	 *
>, <Line: +	 * @param {string} name Name of the service to query.
>, <Line: +	 * @returns {boolean} `true` if injector has given service.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $injector#instantiate
>, <Line: +	 * @description
>, <Line: +	 * Create a new instance of JS type. The method takes a constructor function, invokes the new
>, <Line: +	 * operator, and supplies all of the arguments to the constructor function as specified by the
>, <Line: +	 * constructor annotation.
>, <Line: +	 *
>, <Line: +	 * @param {Function} Type Annotated constructor function.
>, <Line: +	 * @param {Object=} locals Optional object. If preset then any argument names are read from this
>, <Line: +	 * object first, before the `$injector` is consulted.
>, <Line: +	 * @returns {Object} new instance of `Type`.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $injector#annotate
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Returns an array of service names which the function is requesting for injection. This API is
>, <Line: +	 * used by the injector to determine which services need to be injected into the function when the
>, <Line: +	 * function is invoked. There are three ways in which the function can be annotated with the needed
>, <Line: +	 * dependencies.
>, <Line: +	 *
>, <Line: +	 * # Argument names
>, <Line: +	 *
>, <Line: +	 * The simplest form is to extract the dependencies from the arguments of the function. This is done
>, <Line: +	 * by converting the function into a string using `toString()` method and extracting the argument
>, <Line: +	 * names.
>, <Line: +	 * ```js
>, <Line: +	 *   // Given
>, <Line: +	 *   function MyController($scope, $route) {
>, <Line: + *     // ...
>, <Line: + *   }
>, <Line: +	 *
>, <Line: +	 *   // Then
>, <Line: +	 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * You can disallow this method by using strict injection mode.
>, <Line: +	 *
>, <Line: +	 * This method does not work with code minification / obfuscation. For this reason the following
>, <Line: +	 * annotation strategies are supported.
>, <Line: +	 *
>, <Line: +	 * # The `$inject` property
>, <Line: +	 *
>, <Line: +	 * If a function has an `$inject` property and its value is an array of strings, then the strings
>, <Line: +	 * represent names of services to be injected into the function.
>, <Line: +	 * ```js
>, <Line: +	 *   // Given
>, <Line: +	 *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
>, <Line: + *     // ...
>, <Line: + *   }
>, <Line: +	 *   // Define function dependencies
>, <Line: +	 *   MyController['$inject'] = ['$scope', '$route'];
>, <Line: +	 *
>, <Line: +	 *   // Then
>, <Line: +	 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * # The array notation
>, <Line: +	 *
>, <Line: +	 * It is often desirable to inline Injected functions and that's when setting the `$inject` property
>, <Line: +	 * is very inconvenient. In these situations using the array notation to specify the dependencies in
>, <Line: +	 * a way that survives minification is a better choice:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   // We wish to write this (not minification / obfuscation safe)
>, <Line: +	 *   injector.invoke(function($compile, $rootScope) {
>, <Line: + *     // ...
>, <Line: + *   });
>, <Line: +	 *
>, <Line: +	 *   // We are forced to write break inlining
>, <Line: +	 *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
>, <Line: + *     // ...
>, <Line: + *   };
>, <Line: +	 *   tmpFn.$inject = ['$compile', '$rootScope'];
>, <Line: +	 *   injector.invoke(tmpFn);
>, <Line: +	 *
>, <Line: +	 *   // To better support inline function the inline annotation is supported
>, <Line: +	 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
>, <Line: + *     // ...
>, <Line: + *   }]);
>, <Line: +	 *
>, <Line: +	 *   // Therefore
>, <Line: +	 *   expect(injector.annotate(
>, <Line: +	 *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
>, <Line: +	 *    ).toEqual(['$compile', '$rootScope']);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @param {Function|Array.<string|Function>} fn Function for which dependent service names need to
>, <Line: +	 * be retrieved as described above.
>, <Line: +	 *
>, <Line: +	 * @param {boolean=} [strictDi=false] Disallow argument name annotation inference.
>, <Line: +	 *
>, <Line: +	 * @returns {Array.<string>} The names of the services which the function requires.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $provide
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * The {@link auto.$provide $provide} service has a number of methods for registering components
>, <Line: +	 * with the {@link auto.$injector $injector}. Many of these functions are also exposed on
>, <Line: +	 * {@link angular.Module}.
>, <Line: +	 *
>, <Line: +	 * An Angular **service** is a singleton object created by a **service factory**.  These **service
>, <Line: +	 * factories** are functions which, in turn, are created by a **service provider**.
>, <Line: +	 * The **service providers** are constructor functions. When instantiated they must contain a
>, <Line: +	 * property called `$get`, which holds the **service factory** function.
>, <Line: +	 *
>, <Line: +	 * When you request a service, the {@link auto.$injector $injector} is responsible for finding the
>, <Line: +	 * correct **service provider**, instantiating it and then calling its `$get` **service factory**
>, <Line: +	 * function to get the instance of the **service**.
>, <Line: +	 *
>, <Line: +	 * Often services have no configuration options and there is no need to add methods to the service
>, <Line: +	 * provider.  The provider will be no more than a constructor function with a `$get` property. For
>, <Line: +	 * these cases the {@link auto.$provide $provide} service has additional helper methods to register
>, <Line: +	 * services without specifying a provider.
>, <Line: +	 *
>, <Line: +	 * * {@link auto.$provide#provider provider(provider)} - registers a **service provider** with the
>, <Line: +	 *     {@link auto.$injector $injector}
>, <Line: +	 * * {@link auto.$provide#constant constant(obj)} - registers a value/object that can be accessed by
>, <Line: +	 *     providers and services.
>, <Line: +	 * * {@link auto.$provide#value value(obj)} - registers a value/object that can only be accessed by
>, <Line: +	 *     services, not providers.
>, <Line: +	 * * {@link auto.$provide#factory factory(fn)} - registers a service **factory function**, `fn`,
>, <Line: +	 *     that will be wrapped in a **service provider** object, whose `$get` property will contain the
>, <Line: +	 *     given factory function.
>, <Line: +	 * * {@link auto.$provide#service service(class)} - registers a **constructor function**, `class`
>, <Line: +	 *     that will be wrapped in a **service provider** object, whose `$get` property will instantiate
>, <Line: +	 *      a new object using the given constructor function.
>, <Line: +	 *
>, <Line: +	 * See the individual methods for more information and examples.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#provider
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **provider function** with the {@link auto.$injector $injector}. Provider functions
>, <Line: +	 * are constructor functions, whose instances are responsible for "providing" a factory for a
>, <Line: +	 * service.
>, <Line: +	 *
>, <Line: +	 * Service provider names start with the name of the service they provide followed by `Provider`.
>, <Line: +	 * For example, the {@link ng.$log $log} service has a provider called
>, <Line: +	 * {@link ng.$logProvider $logProvider}.
>, <Line: +	 *
>, <Line: +	 * Service provider objects can have additional methods which allow configuration of the provider
>, <Line: +	 * and its service. Importantly, you can configure what kind of service is created by the `$get`
>, <Line: +	 * method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a
>, <Line: +	 * method {@link ng.$logProvider#debugEnabled debugEnabled}
>, <Line: +	 * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the
>, <Line: +	 * console or not.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the instance. NOTE: the provider will be available under `name +
>, <Line: +	 'Provider'` key.
>, <Line: +	 * @param {(Object|function())} provider If the provider is:
>, <Line: +	 *
>, <Line: +	 *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
>, <Line: +	 *     {@link auto.$injector#invoke $injector.invoke()} when an instance needs to be created.
>, <Line: +	 *   - `Constructor`: a new instance of the provider will be created using
>, <Line: +	 *     {@link auto.$injector#instantiate $injector.instantiate()}, then treated as `object`.
>, <Line: +	 *
>, <Line: +	 * @returns {Object} registered provider instance
>, <Line: +	 * @example
>, <Line: +	 *
>, <Line: +	 * The following example shows how to create a simple event tracking service and register it using
>, <Line: +	 * {@link auto.$provide#provider $provide.provider()}.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *  // Define the eventTracker provider
>, <Line: +	 *  function EventTrackerProvider() {
>, <Line: + *    var trackingUrl = '/track';
>, <Line: + *    // A provider method for configuring where the tracked events should been saved
>, <Line: + *    this.setTrackingUrl = function(url) {
>, <Line: + *      trackingUrl = url;
>, <Line: + *    };
>, <Line: + *    // The service factory function
>, <Line: + *    this.$get = ['$http', function($http) {
>, <Line: + *      var trackedEvents = {};
>, <Line: + *      return {
>, <Line: + *        // Call this to track an event
>, <Line: + *        event: function(event) {
>, <Line: + *          var count = trackedEvents[event] || 0;
>, <Line: + *          count += 1;
>, <Line: + *          trackedEvents[event] = count;
>, <Line: + *          return count;
>, <Line: + *        },
>, <Line: + *        // Call this to save the tracked events to the trackingUrl
>, <Line: + *        save: function() {
>, <Line: + *          $http.post(trackingUrl, trackedEvents);
>, <Line: + *        }
>, <Line: + *      };
>, <Line: + *    }];
>, <Line: + *  }
>, <Line: +	 *
>, <Line: +	 *  describe('eventTracker', function() {
>, <Line: + *    var postSpy;
>, <Line: + *    beforeEach(module(function($provide) {
>, <Line: + *      // Register the eventTracker provider
>, <Line: + *      $provide.provider('eventTracker', EventTrackerProvider);
>, <Line: + *    }));
>, <Line: + *    beforeEach(module(function(eventTrackerProvider) {
>, <Line: + *      // Configure eventTracker provider
>, <Line: + *      eventTrackerProvider.setTrackingUrl('/custom-track');
>, <Line: + *    }));
>, <Line: + *    it('tracks events', inject(function(eventTracker) {
>, <Line: + *      expect(eventTracker.event('login')).toEqual(1);
>, <Line: + *      expect(eventTracker.event('login')).toEqual(2);
>, <Line: + *    }));
>, <Line: + *    it('saves to the tracking url', inject(function(eventTracker, $http) {
>, <Line: + *      postSpy = spyOn($http, 'post');
>, <Line: + *      eventTracker.event('login');
>, <Line: + *      eventTracker.save();
>, <Line: + *      expect(postSpy).toHaveBeenCalled();
>, <Line: + *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');
>, <Line: + *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');
>, <Line: + *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });
>, <Line: + *    }));
>, <Line: + *  });
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#factory
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **service factory**, which will be called to return the service instance.
>, <Line: +	 * This is short for registering a service where its provider consists of only a `$get` property,
>, <Line: +	 * which is the given service factory function.
>, <Line: +	 * You should use {@link auto.$provide#factory $provide.factory(getFn)} if you do not need to
>, <Line: +	 * configure your service in a provider.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the instance.
>, <Line: +	 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand
>, <Line: +	 *                            for `$provide.provider(name, {$get: $getFn})`.
>, <Line: +	 * @returns {Object} registered provider instance
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here is an example of registering a service
>, <Line: +	 * ```js
>, <Line: +	 *   $provide.factory('ping', ['$http', function($http) {
>, <Line: + *     return function ping() {
>, <Line: + *       return $http.send('/ping');
>, <Line: + *     };
>, <Line: + *   }]);
>, <Line: +	 * ```
>, <Line: +	 * You would then inject and use this service like this:
>, <Line: +	 * ```js
>, <Line: +	 *   someModule.controller('Ctrl', ['ping', function(ping) {
>, <Line: + *     ping();
>, <Line: + *   }]);
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#service
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **service constructor**, which will be invoked with `new` to create the service
>, <Line: +	 * instance.
>, <Line: +	 * This is short for registering a service where its provider's `$get` property is the service
>, <Line: +	 * constructor function that will be used to instantiate the service instance.
>, <Line: +	 *
>, <Line: +	 * You should use {@link auto.$provide#service $provide.service(class)} if you define your service
>, <Line: +	 * as a type/class.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the instance.
>, <Line: +	 * @param {Function} constructor A class (constructor function) that will be instantiated.
>, <Line: +	 * @returns {Object} registered provider instance
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here is an example of registering a service using
>, <Line: +	 * {@link auto.$provide#service $provide.service(class)}.
>, <Line: +	 * ```js
>, <Line: +	 *   var Ping = function($http) {
>, <Line: + *     this.$http = $http;
>, <Line: + *   };
>, <Line: +	 *
>, <Line: +	 *   Ping.$inject = ['$http'];
>, <Line: +	 *
>, <Line: +	 *   Ping.prototype.send = function() {
>, <Line: + *     return this.$http.get('/ping');
>, <Line: + *   };
>, <Line: +	 *   $provide.service('ping', Ping);
>, <Line: +	 * ```
>, <Line: +	 * You would then inject and use this service like this:
>, <Line: +	 * ```js
>, <Line: +	 *   someModule.controller('Ctrl', ['ping', function(ping) {
>, <Line: + *     ping.send();
>, <Line: + *   }]);
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#value
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **value service** with the {@link auto.$injector $injector}, such as a string, a
>, <Line: +	 * number, an array, an object or a function.  This is short for registering a service where its
>, <Line: +	 * provider's `$get` property is a factory function that takes no arguments and returns the **value
>, <Line: +	 * service**.
>, <Line: +	 *
>, <Line: +	 * Value services are similar to constant services, except that they cannot be injected into a
>, <Line: +	 * module configuration function (see {@link angular.Module#config}) but they can be overridden by
>, <Line: +	 * an Angular
>, <Line: +	 * {@link auto.$provide#decorator decorator}.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the instance.
>, <Line: +	 * @param {*} value The value.
>, <Line: +	 * @returns {Object} registered provider instance
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here are some examples of creating value services.
>, <Line: +	 * ```js
>, <Line: +	 *   $provide.value('ADMIN_USER', 'admin');
>, <Line: +	 *
>, <Line: +	 *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });
>, <Line: +	 *
>, <Line: +	 *   $provide.value('halfOf', function(value) {
>, <Line: + *     return value / 2;
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#constant
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **constant service**, such as a string, a number, an array, an object or a function,
>, <Line: +	 * with the {@link auto.$injector $injector}. Unlike {@link auto.$provide#value value} it can be
>, <Line: +	 * injected into a module configuration function (see {@link angular.Module#config}) and it cannot
>, <Line: +	 * be overridden by an Angular {@link auto.$provide#decorator decorator}.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the constant.
>, <Line: +	 * @param {*} value The constant value.
>, <Line: +	 * @returns {Object} registered instance
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here a some examples of creating constants:
>, <Line: +	 * ```js
>, <Line: +	 *   $provide.constant('SHARD_HEIGHT', 306);
>, <Line: +	 *
>, <Line: +	 *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);
>, <Line: +	 *
>, <Line: +	 *   $provide.constant('double', function(value) {
>, <Line: + *     return value * 2;
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $provide#decorator
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Register a **service decorator** with the {@link auto.$injector $injector}. A service decorator
>, <Line: +	 * intercepts the creation of a service, allowing it to override or modify the behaviour of the
>, <Line: +	 * service. The object returned by the decorator may be the original service, or a new service
>, <Line: +	 * object which replaces or wraps and delegates to the original service.
>, <Line: +	 *
>, <Line: +	 * @param {string} name The name of the service to decorate.
>, <Line: +	 * @param {function()} decorator This function will be invoked when the service needs to be
>, <Line: +	 *    instantiated and should return the decorated service instance. The function is called using
>, <Line: +	 *    the {@link auto.$injector#invoke injector.invoke} method and is therefore fully injectable.
>, <Line: +	 *    Local injection arguments:
>, <Line: +	 *
>, <Line: +	 *    * `$delegate` - The original service instance, which can be monkey patched, configured,
>, <Line: +	 *      decorated or delegated to.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here we decorate the {@link ng.$log $log} service to convert warnings to errors by intercepting
>, <Line: +	 * calls to {@link ng.$log#error $log.warn()}.
>, <Line: +	 * ```js
>, <Line: +	 *   $provide.decorator('$log', ['$delegate', function($delegate) {
>, <Line: + *     $delegate.warn = $delegate.error;
>, <Line: + *     return $delegate;
>, <Line: + *   }]);
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	function createInjector(modulesToLoad, strictDi) {
>, <Line: +		strictDi = (strictDi === true);
>, <Line: +		var INSTANTIATING = {},
>, <Line: +			providerSuffix = 'Provider',
>, <Line: +			path = [],
>, <Line: +			loadedModules = new HashMap([], true),
>, <Line: +			providerCache = {
>, <Line: +				$provide: {
>, <Line: +					provider: supportObject(provider),
>, <Line: +					factory: supportObject(factory),
>, <Line: +					service: supportObject(service),
>, <Line: +					value: supportObject(value),
>, <Line: +					constant: supportObject(constant),
>, <Line: +					decorator: decorator
>, <Line: +				}
>, <Line: +			},
>, <Line: +			providerInjector = (providerCache.$injector =
>, <Line: +				createInternalInjector(providerCache, function () {
>, <Line: +					throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
>, <Line: +				})),
>, <Line: +			instanceCache = {},
>, <Line: +			instanceInjector = (instanceCache.$injector =
>, <Line: +				createInternalInjector(instanceCache, function (servicename) {
>, <Line: +					var provider = providerInjector.get(servicename + providerSuffix);
>, <Line: +					return instanceInjector.invoke(provider.$get, provider, undefined, servicename);
>, <Line: +				}));
>, <Line: +		forEach(loadModules(modulesToLoad), function (fn) {
>, <Line: +			instanceInjector.invoke(fn || noop);
>, <Line: +		});
>, <Line: +		return instanceInjector;
>, <Line: +		////////////////////////////////////
>, <Line: +		// $provider
>, <Line: +		////////////////////////////////////
>, <Line: +		function supportObject(delegate) {
>, <Line: +			return function (key, value) {
>, <Line: +				if (isObject(key)) {
>, <Line: +					forEach(key, reverseParams(delegate));
>, <Line: +				} else {
>, <Line: +					return delegate(key, value);
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}
>, <Line: +		function provider(name, provider_) {
>, <Line: +			assertNotHasOwnProperty(name, 'service');
>, <Line: +			if (isFunction(provider_) || isArray(provider_)) {
>, <Line: +				provider_ = providerInjector.instantiate(provider_);
>, <Line: +			}
>, <Line: +			if (!provider_.$get) {
>, <Line: +				throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
>, <Line: +			}
>, <Line: +			return providerCache[name + providerSuffix] = provider_;
>, <Line: +		}
>, <Line: +		function enforceReturnValue(name, factory) {
>, <Line: +			return function enforcedReturnValue() {
>, <Line: +				var result = instanceInjector.invoke(factory, this, undefined, name);
>, <Line: +				if (isUndefined(result)) {
>, <Line: +					throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
>, <Line: +				}
>, <Line: +				return result;
>, <Line: +			};
>, <Line: +		}
>, <Line: +		function factory(name, factoryFn, enforce) {
>, <Line: +			return provider(name, {
>, <Line: +				$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
>, <Line: +			});
>, <Line: +		}
>, <Line: +		function service(name, constructor) {
>, <Line: +			return factory(name, ['$injector', function ($injector) {
>, <Line: +				return $injector.instantiate(constructor);
>, <Line: +			}]);
>, <Line: +		}
>, <Line: +		function value(name, val) {
>, <Line: +			return factory(name, valueFn(val), false);
>, <Line: +		}
>, <Line: +		function constant(name, value) {
>, <Line: +			assertNotHasOwnProperty(name, 'constant');
>, <Line: +			providerCache[name] = value;
>, <Line: +			instanceCache[name] = value;
>, <Line: +		}
>, <Line: +		function decorator(serviceName, decorFn) {
>, <Line: +			var origProvider = providerInjector.get(serviceName + providerSuffix),
>, <Line: +				orig$get = origProvider.$get;
>, <Line: +			origProvider.$get = function () {
>, <Line: +				var origInstance = instanceInjector.invoke(orig$get, origProvider);
>, <Line: +				return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
>, <Line: +			};
>, <Line: +		}
>, <Line: +		////////////////////////////////////
>, <Line: +		// Module Loading
>, <Line: +		////////////////////////////////////
>, <Line: +		function loadModules(modulesToLoad) {
>, <Line: +			var runBlocks = [], moduleFn;
>, <Line: +			forEach(modulesToLoad, function (module) {
>, <Line: +				if (loadedModules.get(module)) return;
>, <Line: +				loadedModules.put(module, true);
>, <Line: +				function runInvokeQueue(queue) {
>, <Line: +					var i, ii;
>, <Line: +					for (i = 0, ii = queue.length; i < ii; i++) {
>, <Line: +						var invokeArgs = queue[i],
>, <Line: +							provider = providerInjector.get(invokeArgs[0]);
>, <Line: +						provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				try {
>, <Line: +					if (isString(module)) {
>, <Line: +						moduleFn = angularModule(module);
>, <Line: +						runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
>, <Line: +						runInvokeQueue(moduleFn._invokeQueue);
>, <Line: +						runInvokeQueue(moduleFn._configBlocks);
>, <Line: +					} else if (isFunction(module)) {
>, <Line: +						runBlocks.push(providerInjector.invoke(module));
>, <Line: +					} else if (isArray(module)) {
>, <Line: +						runBlocks.push(providerInjector.invoke(module));
>, <Line: +					} else {
>, <Line: +						assertArgFn(module, 'module');
>, <Line: +					}
>, <Line: +				} catch (e) {
>, <Line: +					if (isArray(module)) {
>, <Line: +						module = module[module.length - 1];
>, <Line: +					}
>, <Line: +					if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
>, <Line: +						// Safari & FF's stack traces don't contain error.message content
>, <Line: +						// unlike those of Chrome and IE
>, <Line: +						// So if stack doesn't contain message, we create a new string that contains both.
>, <Line: +						// Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
>, <Line: +						/* jshint -W022 */
>, <Line: +						e = e.message + '\n' + e.stack;
>, <Line: +					}
>, <Line: +					throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
>, <Line: +						module, e.stack || e.message || e);
>, <Line: +				}
>, <Line: +			});
>, <Line: +			return runBlocks;
>, <Line: +		}
>, <Line: +		////////////////////////////////////
>, <Line: +		// internal Injector
>, <Line: +		////////////////////////////////////
>, <Line: +		function createInternalInjector(cache, factory) {
>, <Line: +			function getService(serviceName) {
>, <Line: +				if (cache.hasOwnProperty(serviceName)) {
>, <Line: +					if (cache[serviceName] === INSTANTIATING) {
>, <Line: +						throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
>, <Line: +							serviceName + ' <- ' + path.join(' <- '));
>, <Line: +					}
>, <Line: +					return cache[serviceName];
>, <Line: +				} else {
>, <Line: +					try {
>, <Line: +						path.unshift(serviceName);
>, <Line: +						cache[serviceName] = INSTANTIATING;
>, <Line: +						return cache[serviceName] = factory(serviceName);
>, <Line: +					} catch (err) {
>, <Line: +						if (cache[serviceName] === INSTANTIATING) {
>, <Line: +							delete cache[serviceName];
>, <Line: +						}
>, <Line: +						throw err;
>, <Line: +					} finally {
>, <Line: +						path.shift();
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function invoke(fn, self, locals, serviceName) {
>, <Line: +				if (typeof locals === 'string') {
>, <Line: +					serviceName = locals;
>, <Line: +					locals = null;
>, <Line: +				}
>, <Line: +				var args = [],
>, <Line: +					$inject = annotate(fn, strictDi, serviceName),
>, <Line: +					length, i,
>, <Line: +					key;
>, <Line: +				for (i = 0, length = $inject.length; i < length; i++) {
>, <Line: +					key = $inject[i];
>, <Line: +					if (typeof key !== 'string') {
>, <Line: +						throw $injectorMinErr('itkn',
>, <Line: +							'Incorrect injection token! Expected service name as string, got {0}', key);
>, <Line: +					}
>, <Line: +					args.push(
>, <Line: +						locals && locals.hasOwnProperty(key)
>, <Line: +							? locals[key]
>, <Line: +							: getService(key)
>, <Line: +					);
>, <Line: +				}
>, <Line: +				if (isArray(fn)) {
>, <Line: +					fn = fn[length];
>, <Line: +				}
>, <Line: +				// http://jsperf.com/angularjs-invoke-apply-vs-switch
>, <Line: +				// #5388
>, <Line: +				return fn.apply(self, args);
>, <Line: +			}
>, <Line: +			function instantiate(Type, locals, serviceName) {
>, <Line: +				// Check if Type is annotated and use just the given function at n-1 as parameter
>, <Line: +				// e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
>, <Line: +				// Object creation: http://jsperf.com/create-constructor/2
>, <Line: +				var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype);
>, <Line: +				var returnedValue = invoke(Type, instance, locals, serviceName);
>, <Line: +				return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
>, <Line: +			}
>, <Line: +			return {
>, <Line: +				invoke: invoke,
>, <Line: +				instantiate: instantiate,
>, <Line: +				get: getService,
>, <Line: +				annotate: annotate,
>, <Line: +				has: function (name) {
>, <Line: +					return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}
>, <Line: +	}
>, <Line: +	createInjector.$$annotate = annotate;
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $anchorScrollProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Use `$anchorScrollProvider` to disable automatic scrolling whenever
>, <Line: +	 * {@link ng.$location#hash $location.hash()} changes.
>, <Line: +	 */
>, <Line: +	function $AnchorScrollProvider() {
>, <Line: +		var autoScrollingEnabled = true;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $anchorScrollProvider#disableAutoScrolling
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
>, <Line: +		 * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.<br />
>, <Line: +		 * Use this method to disable automatic scrolling.
>, <Line: +		 *
>, <Line: +		 * If automatic scrolling is disabled, one must explicitly call
>, <Line: +		 * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the element related to the
>, <Line: +		 * current hash.
>, <Line: +		 */
>, <Line: +		this.disableAutoScrolling = function () {
>, <Line: +			autoScrollingEnabled = false;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc service
>, <Line: +		 * @name $anchorScroll
>, <Line: +		 * @kind function
>, <Line: +		 * @requires $window
>, <Line: +		 * @requires $location
>, <Line: +		 * @requires $rootScope
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * When called, it checks the current value of {@link ng.$location#hash $location.hash()} and
>, <Line: +		 * scrolls to the related element, according to the rules specified in the
>, <Line: +		 * [Html5 spec](http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document).
>, <Line: +		 *
>, <Line: +		 * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to
>, <Line: +		 * match any anchor whenever it changes. This can be disabled by calling
>, <Line: +		 * {@link ng.$anchorScrollProvider#disableAutoScrolling $anchorScrollProvider.disableAutoScrolling()}.
>, <Line: +		 *
>, <Line: +		 * Additionally, you can use its {@link ng.$anchorScroll#yOffset yOffset} property to specify a
>, <Line: +		 * vertical scroll-offset (either fixed or dynamic).
>, <Line: +		 *
>, <Line: +		 * @property {(number|function|jqLite)} yOffset
>, <Line: +		 * If set, specifies a vertical scroll-offset. This is often useful when there are fixed
>, <Line: +		 * positioned elements at the top of the page, such as navbars, headers etc.
>, <Line: +		 *
>, <Line: +		 * `yOffset` can be specified in various ways:
>, <Line: +		 * - **number**: A fixed number of pixels to be used as offset.<br /><br />
>, <Line: +		 * - **function**: A getter function called everytime `$anchorScroll()` is executed. Must return
>, <Line: +		 *   a number representing the offset (in pixels).<br /><br />
>, <Line: +		 * - **jqLite**: A jqLite/jQuery element to be used for specifying the offset. The distance from
>, <Line: +		 *   the top of the page to the element's bottom will be used as offset.<br />
>, <Line: +		 *   **Note**: The element will be taken into account only as long as its `position` is set to
>, <Line: +		 *   `fixed`. This option is useful, when dealing with responsive navbars/headers that adjust
>, <Line: +		 *   their height and/or positioning according to the viewport's size.
>, <Line: +		 *
>, <Line: +		 * <br />
>, <Line: +		 * <div class="alert alert-warning">
>, <Line: +		 * In order for `yOffset` to work properly, scrolling should take place on the document's root and
>, <Line: +		 * not some child element.
>, <Line: +		 * </div>
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example module="anchorScrollExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <div id="scrollArea" ng-controller="ScrollController">
>, <Line: +		 <a ng-click="gotoBottom()">Go to bottom</a>
>, <Line: +		 <a id="bottom"></a> You're at the bottom!
>, <Line: +		 </div>
>, <Line: +		 </file>
>, <Line: +		 <file name="script.js">
>, <Line: +		 angular.module('anchorScrollExample', [])
>, <Line: +		 .controller('ScrollController', ['$scope', '$location', '$anchorScroll',
>, <Line: +		 function ($scope, $location, $anchorScroll) {
>, <Line: +               $scope.gotoBottom = function() {
>, <Line: +                 // set the location.hash to the id of
>, <Line: +                 // the element you wish to scroll to.
>, <Line: +                 $location.hash('bottom');
>, <Line: +                 // call $anchorScroll()
>, <Line: +                 $anchorScroll();
>, <Line: +               };
>, <Line: +             }]);
>, <Line: +		 </file>
>, <Line: +		 <file name="style.css">
>, <Line: +		 #scrollArea {
>, <Line: +           height: 280px;
>, <Line: +           overflow: auto;
>, <Line: +         }
>, <Line: +		 #bottom {
>, <Line: +           display: block;
>, <Line: +           margin-top: 2000px;
>, <Line: +         }
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 *
>, <Line: +		 * <hr />
>, <Line: +		 * The example below illustrates the use of a vertical scroll-offset (specified as a fixed value).
>, <Line: +		 * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more details.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example module="anchorScrollOffsetExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <div class="fixed-header" ng-controller="headerCtrl">
>, <Line: +		 <a href="" ng-click="gotoAnchor(x)" ng-repeat="x in [1,2,3,4,5]">
>, <Line: +		 Go to anchor {{x}}
>, <Line: +		 </a>
>, <Line: +		 </div>
>, <Line: +		 <div id="anchor{{x}}" class="anchor" ng-repeat="x in [1,2,3,4,5]">
>, <Line: +		 Anchor {{x}} of 5
>, <Line: +		 </div>
>, <Line: +		 </file>
>, <Line: +		 <file name="script.js">
>, <Line: +		 angular.module('anchorScrollOffsetExample', [])
>, <Line: +		 .run(['$anchorScroll', function($anchorScroll) {
>, <Line: +             $anchorScroll.yOffset = 50;   // always scroll by 50 extra pixels
>, <Line: +           }])
>, <Line: +		 .controller('headerCtrl', ['$anchorScroll', '$location', '$scope',
>, <Line: +		 function ($anchorScroll, $location, $scope) {
>, <Line: +               $scope.gotoAnchor = function(x) {
>, <Line: +                 var newHash = 'anchor' + x;
>, <Line: +                 if ($location.hash() !== newHash) {
>, <Line: +                   // set the $location.hash to `newHash` and
>, <Line: +                   // $anchorScroll will automatically scroll to it
>, <Line: +                   $location.hash('anchor' + x);
>, <Line: +                 } else {
>, <Line: +                   // call $anchorScroll() explicitly,
>, <Line: +                   // since $location.hash hasn't changed
>, <Line: +                   $anchorScroll();
>, <Line: +                 }
>, <Line: +               };
>, <Line: +             }
>, <Line: +		 ]);
>, <Line: +		 </file>
>, <Line: +		 <file name="style.css">
>, <Line: +		 body {
>, <Line: +           padding-top: 50px;
>, <Line: +         }
>, <Line: +		 .anchor {
>, <Line: +           border: 2px dashed DarkOrchid;
>, <Line: +           padding: 10px 10px 200px 10px;
>, <Line: +         }
>, <Line: +		 .fixed-header {
>, <Line: +           background-color: rgba(0, 0, 0, 0.2);
>, <Line: +           height: 50px;
>, <Line: +           position: fixed;
>, <Line: +           top: 0; left: 0; right: 0;
>, <Line: +         }
>, <Line: +		 .fixed-header > a {
>, <Line: +           display: inline-block;
>, <Line: +           margin: 5px 15px;
>, <Line: +         }
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		this.$get = ['$window', '$location', '$rootScope', function ($window, $location, $rootScope) {
>, <Line: +			var document = $window.document;
>, <Line: +			// Helper function to get first anchor from a NodeList
>, <Line: +			// (using `Array#some()` instead of `angular#forEach()` since it's more performant
>, <Line: +			//  and working in all supported browsers.)
>, <Line: +			function getFirstAnchor(list) {
>, <Line: +				var result = null;
>, <Line: +				Array.prototype.some.call(list, function (element) {
>, <Line: +					if (nodeName_(element) === 'a') {
>, <Line: +						result = element;
>, <Line: +						return true;
>, <Line: +					}
>, <Line: +				});
>, <Line: +				return result;
>, <Line: +			}
>, <Line: +			function getYOffset() {
>, <Line: +				var offset = scroll.yOffset;
>, <Line: +				if (isFunction(offset)) {
>, <Line: +					offset = offset();
>, <Line: +				} else if (isElement(offset)) {
>, <Line: +					var elem = offset[0];
>, <Line: +					var style = $window.getComputedStyle(elem);
>, <Line: +					if (style.position !== 'fixed') {
>, <Line: +						offset = 0;
>, <Line: +					} else {
>, <Line: +						offset = elem.getBoundingClientRect().bottom;
>, <Line: +					}
>, <Line: +				} else if (!isNumber(offset)) {
>, <Line: +					offset = 0;
>, <Line: +				}
>, <Line: +				return offset;
>, <Line: +			}
>, <Line: +			function scrollTo(elem) {
>, <Line: +				if (elem) {
>, <Line: +					elem.scrollIntoView();
>, <Line: +					var offset = getYOffset();
>, <Line: +					if (offset) {
>, <Line: +						// `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
>, <Line: +						// This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
>, <Line: +						// top of the viewport.
>, <Line: +						//
>, <Line: +						// IF the number of pixels from the top of `elem` to the end of the page's content is less
>, <Line: +						// than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some
>, <Line: +						// way down the page.
>, <Line: +						//
>, <Line: +						// This is often the case for elements near the bottom of the page.
>, <Line: +						//
>, <Line: +						// In such cases we do not need to scroll the whole `offset` up, just the difference between
>, <Line: +						// the top of the element and the offset, which is enough to align the top of `elem` at the
>, <Line: +						// desired position.
>, <Line: +						var elemTop = elem.getBoundingClientRect().top;
>, <Line: +						$window.scrollBy(0, elemTop - offset);
>, <Line: +					}
>, <Line: +				} else {
>, <Line: +					$window.scrollTo(0, 0);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function scroll() {
>, <Line: +				var hash = $location.hash(), elm;
>, <Line: +				// empty hash, scroll to the top of the page
>, <Line: +				if (!hash) scrollTo(null);
>, <Line: +				// element with given id
>, <Line: +				else if ((elm = document.getElementById(hash))) scrollTo(elm);
>, <Line: +				// first anchor with given name :-D
>, <Line: +				else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
>, <Line: +				// no element and hash == 'top', scroll to the top of the page
>, <Line: +				else if (hash === 'top') scrollTo(null);
>, <Line: +			}
>, <Line: +			// does not scroll when user clicks on anchor link that is currently on
>, <Line: +			// (no url change, no $location.hash() change), browser native does scroll
>, <Line: +			if (autoScrollingEnabled) {
>, <Line: +				$rootScope.$watch(function autoScrollWatch() {
>, <Line: +						return $location.hash();
>, <Line: +					},
>, <Line: +					function autoScrollWatchAction(newVal, oldVal) {
>, <Line: +						// skip the initial scroll if $location.hash is empty
>, <Line: +						if (newVal === oldVal && newVal === '') return;
>, <Line: +						jqLiteDocumentLoaded(function () {
>, <Line: +							$rootScope.$evalAsync(scroll);
>, <Line: +						});
>, <Line: +					});
>, <Line: +			}
>, <Line: +			return scroll;
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	var $animateMinErr = minErr('$animate');
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $animateProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Default implementation of $animate that doesn't perform any animations, instead just
>, <Line: +	 * synchronously performs DOM
>, <Line: +	 * updates and calls done() callbacks.
>, <Line: +	 *
>, <Line: +	 * In order to enable animations the ngAnimate module has to be loaded.
>, <Line: +	 *
>, <Line: +	 * To see the functional implementation check out src/ngAnimate/animate.js
>, <Line: +	 */
>, <Line: +	var $AnimateProvider = ['$provide', function ($provide) {
>, <Line: +		this.$$selectors = {};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $animateProvider#register
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Registers a new injectable animation factory function. The factory function produces the
>, <Line: +		 * animation object which contains callback functions for each event that is expected to be
>, <Line: +		 * animated.
>, <Line: +		 *
>, <Line: +		 *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction`
>, <Line: +		 *   must be called once the element animation is complete. If a function is returned then the
>, <Line: +		 *   animation service will use this function to cancel the animation whenever a cancel event is
>, <Line: +		 *   triggered.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 *   return {
>, <Line: +     *     eventFn : function(element, done) {
>, <Line: +     *       //code to run the animation
>, <Line: +     *       //once complete, then run done()
>, <Line: +     *       return function cancellationFunction() {
>, <Line: +     *         //code to cancel the animation
>, <Line: +     *       }
>, <Line: +     *     }
>, <Line: +     *   }
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {string} name The name of the animation.
>, <Line: +		 * @param {Function} factory The factory function that will be executed to return the animation
>, <Line: +		 *                           object.
>, <Line: +		 */
>, <Line: +		this.register = function (name, factory) {
>, <Line: +			var key = name + '-animation';
>, <Line: +			if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',
>, <Line: +				"Expecting class selector starting with '.' got '{0}'.", name);
>, <Line: +			this.$$selectors[name.substr(1)] = key;
>, <Line: +			$provide.factory(key, factory);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $animateProvider#classNameFilter
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets and/or returns the CSS class regular expression that is checked when performing
>, <Line: +		 * an animation. Upon bootstrap the classNameFilter value is not set at all and will
>, <Line: +		 * therefore enable $animate to attempt to perform an animation on any element.
>, <Line: +		 * When setting the classNameFilter value, animations will only be performed on elements
>, <Line: +		 * that successfully match the filter expression. This in turn can boost performance
>, <Line: +		 * for low-powered devices as well as applications containing a lot of structural operations.
>, <Line: +		 * @param {RegExp=} expression The className expression which will be checked against all animations
>, <Line: +		 * @return {RegExp} The current CSS className expression value. If null then there is no expression value
>, <Line: +		 */
>, <Line: +		this.classNameFilter = function (expression) {
>, <Line: +			if (arguments.length === 1) {
>, <Line: +				this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
>, <Line: +			}
>, <Line: +			return this.$$classNameFilter;
>, <Line: +		};
>, <Line: +		this.$get = ['$$q', '$$asyncCallback', '$rootScope', function ($$q, $$asyncCallback, $rootScope) {
>, <Line: +			var currentDefer;
>, <Line: +			function runAnimationPostDigest(fn) {
>, <Line: +				var cancelFn, defer = $$q.defer();
>, <Line: +				defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
>, <Line: +					cancelFn && cancelFn();
>, <Line: +				};
>, <Line: +				$rootScope.$$postDigest(function ngAnimatePostDigest() {
>, <Line: +					cancelFn = fn(function ngAnimateNotifyComplete() {
>, <Line: +						defer.resolve();
>, <Line: +					});
>, <Line: +				});
>, <Line: +				return defer.promise;
>, <Line: +			}
>, <Line: +			function resolveElementClasses(element, classes) {
>, <Line: +				var toAdd = [], toRemove = [];
>, <Line: +				var hasClasses = createMap();
>, <Line: +				forEach((element.attr('class') || '').split(/\s+/), function (className) {
>, <Line: +					hasClasses[className] = true;
>, <Line: +				});
>, <Line: +				forEach(classes, function (status, className) {
>, <Line: +					var hasClass = hasClasses[className];
>, <Line: +					// If the most recent class manipulation (via $animate) was to remove the class, and the
>, <Line: +					// element currently has the class, the class is scheduled for removal. Otherwise, if
>, <Line: +					// the most recent class manipulation (via $animate) was to add the class, and the
>, <Line: +					// element does not currently have the class, the class is scheduled to be added.
>, <Line: +					if (status === false && hasClass) {
>, <Line: +						toRemove.push(className);
>, <Line: +					} else if (status === true && !hasClass) {
>, <Line: +						toAdd.push(className);
>, <Line: +					}
>, <Line: +				});
>, <Line: +				return (toAdd.length + toRemove.length) > 0 &&
>, <Line: +					[toAdd.length ? toAdd : null, toRemove.length ? toRemove : null];
>, <Line: +			}
>, <Line: +			function cachedClassManipulation(cache, classes, op) {
>, <Line: +				for (var i = 0, ii = classes.length; i < ii; ++i) {
>, <Line: +					var className = classes[i];
>, <Line: +					cache[className] = op;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function asyncPromise() {
>, <Line: +				// only serve one instance of a promise in order to save CPU cycles
>, <Line: +				if (!currentDefer) {
>, <Line: +					currentDefer = $$q.defer();
>, <Line: +					$$asyncCallback(function () {
>, <Line: +						currentDefer.resolve();
>, <Line: +						currentDefer = null;
>, <Line: +					});
>, <Line: +				}
>, <Line: +				return currentDefer.promise;
>, <Line: +			}
>, <Line: +			function applyStyles(element, options) {
>, <Line: +				if (angular.isObject(options)) {
>, <Line: +					var styles = extend(options.from || {}, options.to || {});
>, <Line: +					element.css(styles);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 *
>, <Line: +			 * @ngdoc service
>, <Line: +			 * @name $animate
>, <Line: +			 * @description The $animate service provides rudimentary DOM manipulation functions to
>, <Line: +			 * insert, remove and move elements within the DOM, as well as adding and removing classes.
>, <Line: +			 * This service is the core service used by the ngAnimate $animator service which provides
>, <Line: +			 * high-level animation hooks for CSS and JavaScript.
>, <Line: +			 *
>, <Line: +			 * $animate is available in the AngularJS core, however, the ngAnimate module must be included
>, <Line: +			 * to enable full out animation support. Otherwise, $animate will only perform simple DOM
>, <Line: +			 * manipulation operations.
>, <Line: +			 *
>, <Line: +			 * To learn more about enabling animation support, click here to visit the {@link ngAnimate
>, <Line: +     * ngAnimate module page} as well as the {@link ngAnimate.$animate ngAnimate $animate service
>, <Line: +     * page}.
>, <Line: +			 */
>, <Line: +			return {
>, <Line: +				animate: function (element, from, to) {
>, <Line: +					applyStyles(element, {from: from, to: to});
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#enter
>, <Line: +				 * @kind function
>, <Line: +				 * @description Inserts the element into the DOM either after the `after` element or
>, <Line: +				 * as the first child within the `parent` element. When the function is called a promise
>, <Line: +				 * is returned that will be resolved at a later time.
>, <Line: +				 * @param {DOMElement} element the element which will be inserted into the DOM
>, <Line: +				 * @param {DOMElement} parent the parent element which will append the element as
>, <Line: +				 *   a child (if the after element is not present)
>, <Line: +				 * @param {DOMElement} after the sibling element which will append the element
>, <Line: +				 *   after itself
>, <Line: +				 * @param {object=} options an optional collection of styles that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				enter: function (element, parent, after, options) {
>, <Line: +					applyStyles(element, options);
>, <Line: +					after ? after.after(element)
>, <Line: +						: parent.prepend(element);
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#leave
>, <Line: +				 * @kind function
>, <Line: +				 * @description Removes the element from the DOM. When the function is called a promise
>, <Line: +				 * is returned that will be resolved at a later time.
>, <Line: +				 * @param {DOMElement} element the element which will be removed from the DOM
>, <Line: +				 * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				leave: function (element, options) {
>, <Line: +					element.remove();
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#move
>, <Line: +				 * @kind function
>, <Line: +				 * @description Moves the position of the provided element within the DOM to be placed
>, <Line: +				 * either after the `after` element or inside of the `parent` element. When the function
>, <Line: +				 * is called a promise is returned that will be resolved at a later time.
>, <Line: +				 *
>, <Line: +				 * @param {DOMElement} element the element which will be moved around within the
>, <Line: +				 *   DOM
>, <Line: +				 * @param {DOMElement} parent the parent element where the element will be
>, <Line: +				 *   inserted into (if the after element is not present)
>, <Line: +				 * @param {DOMElement} after the sibling element where the element will be
>, <Line: +				 *   positioned next to
>, <Line: +				 * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				move: function (element, parent, after, options) {
>, <Line: +					// Do not remove element before insert. Removing will cause data associated with the
>, <Line: +					// element to be dropped. Insert will implicitly do the remove.
>, <Line: +					return this.enter(element, parent, after, options);
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#addClass
>, <Line: +				 * @kind function
>, <Line: +				 * @description Adds the provided className CSS class value to the provided element.
>, <Line: +				 * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: +				 * @param {DOMElement} element the element which will have the className value
>, <Line: +				 *   added to it
>, <Line: +				 * @param {string} className the CSS class which will be added to the element
>, <Line: +				 * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				addClass: function (element, className, options) {
>, <Line: +					return this.setClass(element, className, [], options);
>, <Line: +				},
>, <Line: +				$$addClassImmediately: function (element, className, options) {
>, <Line: +					element = jqLite(element);
>, <Line: +					className = !isString(className)
>, <Line: +						? (isArray(className) ? className.join(' ') : '')
>, <Line: +						: className;
>, <Line: +					forEach(element, function (element) {
>, <Line: +						jqLiteAddClass(element, className);
>, <Line: +					});
>, <Line: +					applyStyles(element, options);
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#removeClass
>, <Line: +				 * @kind function
>, <Line: +				 * @description Removes the provided className CSS class value from the provided element.
>, <Line: +				 * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: +				 * @param {DOMElement} element the element which will have the className value
>, <Line: +				 *   removed from it
>, <Line: +				 * @param {string} className the CSS class which will be removed from the element
>, <Line: +				 * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				removeClass: function (element, className, options) {
>, <Line: +					return this.setClass(element, [], className, options);
>, <Line: +				},
>, <Line: +				$$removeClassImmediately: function (element, className, options) {
>, <Line: +					element = jqLite(element);
>, <Line: +					className = !isString(className)
>, <Line: +						? (isArray(className) ? className.join(' ') : '')
>, <Line: +						: className;
>, <Line: +					forEach(element, function (element) {
>, <Line: +						jqLiteRemoveClass(element, className);
>, <Line: +					});
>, <Line: +					applyStyles(element, options);
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				/**
>, <Line: +				 *
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $animate#setClass
>, <Line: +				 * @kind function
>, <Line: +				 * @description Adds and/or removes the given CSS classes to and from the element.
>, <Line: +				 * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: +				 * @param {DOMElement} element the element which will have its CSS classes changed
>, <Line: +				 *   removed from it
>, <Line: +				 * @param {string} add the CSS classes which will be added to the element
>, <Line: +				 * @param {string} remove the CSS class which will be removed from the element
>, <Line: +				 * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: +				 * @return {Promise} the animation callback promise
>, <Line: +				 */
>, <Line: +				setClass: function (element, add, remove, options) {
>, <Line: +					var self = this;
>, <Line: +					var STORAGE_KEY = '$$animateClasses';
>, <Line: +					var createdCache = false;
>, <Line: +					element = jqLite(element);
>, <Line: +					var cache = element.data(STORAGE_KEY);
>, <Line: +					if (!cache) {
>, <Line: +						cache = {
>, <Line: +							classes: {},
>, <Line: +							options: options
>, <Line: +						};
>, <Line: +						createdCache = true;
>, <Line: +					} else if (options && cache.options) {
>, <Line: +						cache.options = angular.extend(cache.options || {}, options);
>, <Line: +					}
>, <Line: +					var classes = cache.classes;
>, <Line: +					add = isArray(add) ? add : add.split(' ');
>, <Line: +					remove = isArray(remove) ? remove : remove.split(' ');
>, <Line: +					cachedClassManipulation(classes, add, true);
>, <Line: +					cachedClassManipulation(classes, remove, false);
>, <Line: +					if (createdCache) {
>, <Line: +						cache.promise = runAnimationPostDigest(function (done) {
>, <Line: +							var cache = element.data(STORAGE_KEY);
>, <Line: +							element.removeData(STORAGE_KEY);
>, <Line: +							// in the event that the element is removed before postDigest
>, <Line: +							// is run then the cache will be undefined and there will be
>, <Line: +							// no need anymore to add or remove and of the element classes
>, <Line: +							if (cache) {
>, <Line: +								var classes = resolveElementClasses(element, cache.classes);
>, <Line: +								if (classes) {
>, <Line: +									self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							done();
>, <Line: +						});
>, <Line: +						element.data(STORAGE_KEY, cache);
>, <Line: +					}
>, <Line: +					return cache.promise;
>, <Line: +				},
>, <Line: +				$$setClassImmediately: function (element, add, remove, options) {
>, <Line: +					add && this.$$addClassImmediately(element, add);
>, <Line: +					remove && this.$$removeClassImmediately(element, remove);
>, <Line: +					applyStyles(element, options);
>, <Line: +					return asyncPromise();
>, <Line: +				},
>, <Line: +				enabled: noop,
>, <Line: +				cancel: noop
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}];
>, <Line: +	function $$AsyncCallbackProvider() {
>, <Line: +		this.$get = ['$$rAF', '$timeout', function ($$rAF, $timeout) {
>, <Line: +			return $$rAF.supported
>, <Line: +				? function (fn) {
>, <Line: +				return $$rAF(fn);
>, <Line: +			}
>, <Line: +				: function (fn) {
>, <Line: +				return $timeout(fn, 0, false);
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/* global stripHash: true */
>, <Line: +	/**
>, <Line: +	 * ! This is a private undocumented service !
>, <Line: +	 *
>, <Line: +	 * @name $browser
>, <Line: +	 * @requires $log
>, <Line: +	 * @description
>, <Line: +	 * This object has two goals:
>, <Line: +	 *
>, <Line: +	 * - hide all the global state in the browser caused by the window object
>, <Line: +	 * - abstract away all the browser specific features and inconsistencies
>, <Line: +	 *
>, <Line: +	 * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
>, <Line: +	 * service, which can be used for convenient testing of the application without the interaction with
>, <Line: +	 * the real browser apis.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @param {object} window The global window object.
>, <Line: +	 * @param {object} document jQuery wrapped document.
>, <Line: +	 * @param {object} $log window.console or an object with the same interface.
>, <Line: +	 * @param {object} $sniffer $sniffer service
>, <Line: +	 */
>, <Line: +	function Browser(window, document, $log, $sniffer) {
>, <Line: +		var self = this,
>, <Line: +			rawDocument = document[0],
>, <Line: +			location = window.location,
>, <Line: +			history = window.history,
>, <Line: +			setTimeout = window.setTimeout,
>, <Line: +			clearTimeout = window.clearTimeout,
>, <Line: +			pendingDeferIds = {};
>, <Line: +		self.isMock = false;
>, <Line: +		var outstandingRequestCount = 0;
>, <Line: +		var outstandingRequestCallbacks = [];
>, <Line: +		// TODO(vojta): remove this temporary api
>, <Line: +		self.$$completeOutstandingRequest = completeOutstandingRequest;
>, <Line: +		self.$$incOutstandingRequestCount = function () {
>, <Line: +			outstandingRequestCount++;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
>, <Line: +		 * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
>, <Line: +		 */
>, <Line: +		function completeOutstandingRequest(fn) {
>, <Line: +			try {
>, <Line: +				fn.apply(null, sliceArgs(arguments, 1));
>, <Line: +			} finally {
>, <Line: +				outstandingRequestCount--;
>, <Line: +				if (outstandingRequestCount === 0) {
>, <Line: +					while (outstandingRequestCallbacks.length) {
>, <Line: +						try {
>, <Line: +							outstandingRequestCallbacks.pop()();
>, <Line: +						} catch (e) {
>, <Line: +							$log.error(e);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @private
>, <Line: +		 * Note: this method is used only by scenario runner
>, <Line: +		 * TODO(vojta): prefix this method with $$ ?
>, <Line: +		 * @param {function()} callback Function that will be called when no outstanding request
>, <Line: +		 */
>, <Line: +		self.notifyWhenNoOutstandingRequests = function (callback) {
>, <Line: +			// force browser to execute all pollFns - this is needed so that cookies and other pollers fire
>, <Line: +			// at some deterministic time in respect to the test runner's actions. Leaving things up to the
>, <Line: +			// regular poller would result in flaky tests.
>, <Line: +			forEach(pollFns, function (pollFn) {
>, <Line: +				pollFn();
>, <Line: +			});
>, <Line: +			if (outstandingRequestCount === 0) {
>, <Line: +				callback();
>, <Line: +			} else {
>, <Line: +				outstandingRequestCallbacks.push(callback);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		// Poll Watcher API
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		var pollFns = [],
>, <Line: +			pollTimeout;
>, <Line: +		/**
>, <Line: +		 * @name $browser#addPollFn
>, <Line: +		 *
>, <Line: +		 * @param {function()} fn Poll function to add
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Adds a function to the list of functions that poller periodically executes,
>, <Line: +		 * and starts polling if not started yet.
>, <Line: +		 *
>, <Line: +		 * @returns {function()} the added function
>, <Line: +		 */
>, <Line: +		self.addPollFn = function (fn) {
>, <Line: +			if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
>, <Line: +			pollFns.push(fn);
>, <Line: +			return fn;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @param {number} interval How often should browser call poll functions (ms)
>, <Line: +		 * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Configures the poller to run in the specified intervals, using the specified
>, <Line: +		 * setTimeout fn and kicks it off.
>, <Line: +		 */
>, <Line: +		function startPoller(interval, setTimeout) {
>, <Line: +			(function check() {
>, <Line: +				forEach(pollFns, function (pollFn) {
>, <Line: +					pollFn();
>, <Line: +				});
>, <Line: +				pollTimeout = setTimeout(check, interval);
>, <Line: +			})();
>, <Line: +		}
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		// URL API
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		var cachedState, lastHistoryState,
>, <Line: +			lastBrowserUrl = location.href,
>, <Line: +			baseElement = document.find('base'),
>, <Line: +			reloadLocation = null;
>, <Line: +		cacheState();
>, <Line: +		lastHistoryState = cachedState;
>, <Line: +		/**
>, <Line: +		 * @name $browser#url
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * GETTER:
>, <Line: +		 * Without any argument, this method just returns current value of location.href.
>, <Line: +		 *
>, <Line: +		 * SETTER:
>, <Line: +		 * With at least one argument, this method sets url to new value.
>, <Line: +		 * If html5 history api supported, pushState/replaceState is used, otherwise
>, <Line: +		 * location.href/location.replace is used.
>, <Line: +		 * Returns its own instance to allow chaining
>, <Line: +		 *
>, <Line: +		 * NOTE: this api is intended for use only by the $location service. Please use the
>, <Line: +		 * {@link ng.$location $location service} to change url.
>, <Line: +		 *
>, <Line: +		 * @param {string} url New url (when used as setter)
>, <Line: +		 * @param {boolean=} replace Should new url replace current history record?
>, <Line: +		 * @param {object=} state object to use with pushState/replaceState
>, <Line: +		 */
>, <Line: +		self.url = function (url, replace, state) {
>, <Line: +			// In modern browsers `history.state` is `null` by default; treating it separately
>, <Line: +			// from `undefined` would cause `$browser.url('/foo')` to change `history.state`
>, <Line: +			// to undefined via `pushState`. Instead, let's change `undefined` to `null` here.
>, <Line: +			if (isUndefined(state)) {
>, <Line: +				state = null;
>, <Line: +			}
>, <Line: +			// Android Browser BFCache causes location, history reference to become stale.
>, <Line: +			if (location !== window.location) location = window.location;
>, <Line: +			if (history !== window.history) history = window.history;
>, <Line: +			// setter
>, <Line: +			if (url) {
>, <Line: +				var sameState = lastHistoryState === state;
>, <Line: +				// Don't change anything if previous and current URLs and states match. This also prevents
>, <Line: +				// IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.
>, <Line: +				// See https://github.com/angular/angular.js/commit/ffb2701
>, <Line: +				if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
>, <Line: +					return self;
>, <Line: +				}
>, <Line: +				var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
>, <Line: +				lastBrowserUrl = url;
>, <Line: +				lastHistoryState = state;
>, <Line: +				// Don't use history API if only the hash changed
>, <Line: +				// due to a bug in IE10/IE11 which leads
>, <Line: +				// to not firing a `hashchange` nor `popstate` event
>, <Line: +				// in some cases (see #9143).
>, <Line: +				if ($sniffer.history && (!sameBase || !sameState)) {
>, <Line: +					history[replace ? 'replaceState' : 'pushState'](state, '', url);
>, <Line: +					cacheState();
>, <Line: +					// Do the assignment again so that those two variables are referentially identical.
>, <Line: +					lastHistoryState = cachedState;
>, <Line: +				} else {
>, <Line: +					if (!sameBase) {
>, <Line: +						reloadLocation = url;
>, <Line: +					}
>, <Line: +					if (replace) {
>, <Line: +						location.replace(url);
>, <Line: +					} else {
>, <Line: +						location.href = url;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return self;
>, <Line: +				// getter
>, <Line: +			} else {
>, <Line: +				// - reloadLocation is needed as browsers don't allow to read out
>, <Line: +				//   the new location.href if a reload happened.
>, <Line: +				// - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
>, <Line: +				return reloadLocation || location.href.replace(/%27/g, "'");
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @name $browser#state
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is a getter.
>, <Line: +		 *
>, <Line: +		 * Return history.state or null if history.state is undefined.
>, <Line: +		 *
>, <Line: +		 * @returns {object} state
>, <Line: +		 */
>, <Line: +		self.state = function () {
>, <Line: +			return cachedState;
>, <Line: +		};
>, <Line: +		var urlChangeListeners = [],
>, <Line: +			urlChangeInit = false;
>, <Line: +		function cacheStateAndFireUrlChange() {
>, <Line: +			cacheState();
>, <Line: +			fireUrlChange();
>, <Line: +		}
>, <Line: +		// This variable should be used *only* inside the cacheState function.
>, <Line: +		var lastCachedState = null;
>, <Line: +		function cacheState() {
>, <Line: +			// This should be the only place in $browser where `history.state` is read.
>, <Line: +			cachedState = window.history.state;
>, <Line: +			cachedState = isUndefined(cachedState) ? null : cachedState;
>, <Line: +			// Prevent callbacks fo fire twice if both hashchange & popstate were fired.
>, <Line: +			if (equals(cachedState, lastCachedState)) {
>, <Line: +				cachedState = lastCachedState;
>, <Line: +			}
>, <Line: +			lastCachedState = cachedState;
>, <Line: +		}
>, <Line: +		function fireUrlChange() {
>, <Line: +			if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			lastBrowserUrl = self.url();
>, <Line: +			lastHistoryState = cachedState;
>, <Line: +			forEach(urlChangeListeners, function (listener) {
>, <Line: +				listener(self.url(), cachedState);
>, <Line: +			});
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @name $browser#onUrlChange
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Register callback function that will be called, when url changes.
>, <Line: +		 *
>, <Line: +		 * It's only called when the url is changed from outside of angular:
>, <Line: +		 * - user types different url into address bar
>, <Line: +		 * - user clicks on history (forward/back) button
>, <Line: +		 * - user clicks on a link
>, <Line: +		 *
>, <Line: +		 * It's not called when url is changed by $browser.url() method
>, <Line: +		 *
>, <Line: +		 * The listener gets called with new url as parameter.
>, <Line: +		 *
>, <Line: +		 * NOTE: this api is intended for use only by the $location service. Please use the
>, <Line: +		 * {@link ng.$location $location service} to monitor url changes in angular apps.
>, <Line: +		 *
>, <Line: +		 * @param {function(string)} listener Listener function to be called when url changes.
>, <Line: +		 * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
>, <Line: +		 */
>, <Line: +		self.onUrlChange = function (callback) {
>, <Line: +			// TODO(vojta): refactor to use node's syntax for events
>, <Line: +			if (!urlChangeInit) {
>, <Line: +				// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
>, <Line: +				// don't fire popstate when user change the address bar and don't fire hashchange when url
>, <Line: +				// changed by push/replaceState
>, <Line: +				// html5 history api - popstate event
>, <Line: +				if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange);
>, <Line: +				// hashchange event
>, <Line: +				jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
>, <Line: +				urlChangeInit = true;
>, <Line: +			}
>, <Line: +			urlChangeListeners.push(callback);
>, <Line: +			return callback;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Checks whether the url has changed outside of Angular.
>, <Line: +		 * Needs to be exported to be able to check for changes that have been done in sync,
>, <Line: +		 * as hashchange/popstate events fire in async.
>, <Line: +		 */
>, <Line: +		self.$$checkUrlChange = fireUrlChange;
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		// Misc API
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		/**
>, <Line: +		 * @name $browser#baseHref
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Returns current <base href>
>, <Line: +		 * (always relative - without domain)
>, <Line: +		 *
>, <Line: +		 * @returns {string} The current base href
>, <Line: +		 */
>, <Line: +		self.baseHref = function () {
>, <Line: +			var href = baseElement.attr('href');
>, <Line: +			return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
>, <Line: +		};
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		// Cookies API
>, <Line: +		//////////////////////////////////////////////////////////////
>, <Line: +		var lastCookies = {};
>, <Line: +		var lastCookieString = '';
>, <Line: +		var cookiePath = self.baseHref();
>, <Line: +		function safeDecodeURIComponent(str) {
>, <Line: +			try {
>, <Line: +				return decodeURIComponent(str);
>, <Line: +			} catch (e) {
>, <Line: +				return str;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @name $browser#cookies
>, <Line: +		 *
>, <Line: +		 * @param {string=} name Cookie name
>, <Line: +		 * @param {string=} value Cookie value
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * The cookies method provides a 'private' low level access to browser cookies.
>, <Line: +		 * It is not meant to be used directly, use the $cookie service instead.
>, <Line: +		 *
>, <Line: +		 * The return values vary depending on the arguments that the method was called with as follows:
>, <Line: +		 *
>, <Line: +		 * - cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify
>, <Line: +		 *   it
>, <Line: +		 * - cookies(name, value) -> set name to value, if value is undefined delete the cookie
>, <Line: +		 * - cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that
>, <Line: +		 *   way)
>, <Line: +		 *
>, <Line: +		 * @returns {Object} Hash of all cookies (if called without any parameter)
>, <Line: +		 */
>, <Line: +		self.cookies = function (name, value) {
>, <Line: +			var cookieLength, cookieArray, cookie, i, index;
>, <Line: +			if (name) {
>, <Line: +				if (value === undefined) {
>, <Line: +					rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath +
>, <Line: +						";expires=Thu, 01 Jan 1970 00:00:00 GMT";
>, <Line: +				} else {
>, <Line: +					if (isString(value)) {
>, <Line: +						cookieLength = (rawDocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) +
>, <Line: +								';path=' + cookiePath).length + 1;
>, <Line: +						// per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
>, <Line: +						// - 300 cookies
>, <Line: +						// - 20 cookies per unique domain
>, <Line: +						// - 4096 bytes per cookie
>, <Line: +						if (cookieLength > 4096) {
>, <Line: +							$log.warn("Cookie '" + name +
>, <Line: +								"' possibly not set or overflowed because it was too large (" +
>, <Line: +								cookieLength + " > 4096 bytes)!");
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			} else {
>, <Line: +				if (rawDocument.cookie !== lastCookieString) {
>, <Line: +					lastCookieString = rawDocument.cookie;
>, <Line: +					cookieArray = lastCookieString.split("; ");
>, <Line: +					lastCookies = {};
>, <Line: +					for (i = 0; i < cookieArray.length; i++) {
>, <Line: +						cookie = cookieArray[i];
>, <Line: +						index = cookie.indexOf('=');
>, <Line: +						if (index > 0) { //ignore nameless cookies
>, <Line: +							name = safeDecodeURIComponent(cookie.substring(0, index));
>, <Line: +							// the first value that is seen for a cookie is the most
>, <Line: +							// specific one.  values for the same cookie name that
>, <Line: +							// follow are for less specific paths.
>, <Line: +							if (lastCookies[name] === undefined) {
>, <Line: +								lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return lastCookies;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @name $browser#defer
>, <Line: +		 * @param {function()} fn A function, who's execution should be deferred.
>, <Line: +		 * @param {number=} [delay=0] of milliseconds to defer the function execution.
>, <Line: +		 * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Executes a fn asynchronously via `setTimeout(fn, delay)`.
>, <Line: +		 *
>, <Line: +		 * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
>, <Line: +		 * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
>, <Line: +		 * via `$browser.defer.flush()`.
>, <Line: +		 *
>, <Line: +		 */
>, <Line: +		self.defer = function (fn, delay) {
>, <Line: +			var timeoutId;
>, <Line: +			outstandingRequestCount++;
>, <Line: +			timeoutId = setTimeout(function () {
>, <Line: +				delete pendingDeferIds[timeoutId];
>, <Line: +				completeOutstandingRequest(fn);
>, <Line: +			}, delay || 0);
>, <Line: +			pendingDeferIds[timeoutId] = true;
>, <Line: +			return timeoutId;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @name $browser#defer.cancel
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Cancels a deferred task identified with `deferId`.
>, <Line: +		 *
>, <Line: +		 * @param {*} deferId Token returned by the `$browser.defer` function.
>, <Line: +		 * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
>, <Line: +		 *                    canceled.
>, <Line: +		 */
>, <Line: +		self.defer.cancel = function (deferId) {
>, <Line: +			if (pendingDeferIds[deferId]) {
>, <Line: +				delete pendingDeferIds[deferId];
>, <Line: +				clearTimeout(deferId);
>, <Line: +				completeOutstandingRequest(noop);
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function $BrowserProvider() {
>, <Line: +		this.$get = ['$window', '$log', '$sniffer', '$document',
>, <Line: +			function ($window, $log, $sniffer, $document) {
>, <Line: +				return new Browser($window, $document, $log, $sniffer);
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $cacheFactory
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to
>, <Line: +	 * them.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *
>, <Line: +	 *  var cache = $cacheFactory('cacheId');
>, <Line: +	 *  expect($cacheFactory.get('cacheId')).toBe(cache);
>, <Line: +	 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
>, <Line: +	 *
>, <Line: +	 *  cache.put("key", "value");
>, <Line: +	 *  cache.put("another key", "another value");
>, <Line: +	 *
>, <Line: +	 *  // We've specified no options on creation
>, <Line: +	 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2});
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @param {string} cacheId Name or id of the newly created cache.
>, <Line: +	 * @param {object=} options Options object that specifies the cache behavior. Properties:
>, <Line: +	 *
>, <Line: +	 *   - `{number=}` `capacity`  turns the cache into LRU cache.
>, <Line: +	 *
>, <Line: +	 * @returns {object} Newly created cache object with the following set of methods:
>, <Line: +	 *
>, <Line: +	 * - `{object}` `info()`  Returns id, size, and options of cache.
>, <Line: +	 * - `{{*}}` `put({string} key, {*} value)`  Puts a new key-value pair into the cache and returns
>, <Line: +	 *   it.
>, <Line: +	 * - `{{*}}` `get({string} key)`  Returns cached value for `key` or undefined for cache miss.
>, <Line: +	 * - `{void}` `remove({string} key)`  Removes a key-value pair from the cache.
>, <Line: +	 * - `{void}` `removeAll()`  Removes all cached values.
>, <Line: +	 * - `{void}` `destroy()`  Removes references to this cache from $cacheFactory.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="cacheExampleApp">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="CacheController">
>, <Line: +	 <input ng-model="newCacheKey" placeholder="Key">
>, <Line: +	 <input ng-model="newCacheValue" placeholder="Value">
>, <Line: +	 <button ng-click="put(newCacheKey, newCacheValue)">Cache</button>
>, <Line: +	 <p ng-if="keys.length">Cached Values</p>
>, <Line: +	 <div ng-repeat="key in keys">
>, <Line: +	 <span ng-bind="key"></span>
>, <Line: +	 <span>: </span>
>, <Line: +	 <b ng-bind="cache.get(key)"></b>
>, <Line: +	 </div>
>, <Line: +	 <p>Cache Info</p>
>, <Line: +	 <div ng-repeat="(key, value) in cache.info()">
>, <Line: +	 <span ng-bind="key"></span>
>, <Line: +	 <span>: </span>
>, <Line: +	 <b ng-bind="value"></b>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('cacheExampleApp', []).
>, <Line: +	 controller('CacheController', ['$scope', '$cacheFactory', function($scope, $cacheFactory) {
>, <Line: +           $scope.keys = [];
>, <Line: +           $scope.cache = $cacheFactory('cacheId');
>, <Line: +           $scope.put = function(key, value) {
>, <Line: +             if ($scope.cache.get(key) === undefined) {
>, <Line: +               $scope.keys.push(key);
>, <Line: +             }
>, <Line: +             $scope.cache.put(key, value === undefined ? null : value);
>, <Line: +           };
>, <Line: +         }]);
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 p {
>, <Line: +         margin: 10px 0 3px;
>, <Line: +       }
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function $CacheFactoryProvider() {
>, <Line: +		this.$get = function () {
>, <Line: +			var caches = {};
>, <Line: +			function cacheFactory(cacheId, options) {
>, <Line: +				if (cacheId in caches) {
>, <Line: +					throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
>, <Line: +				}
>, <Line: +				var size = 0,
>, <Line: +					stats = extend({}, options, {id: cacheId}),
>, <Line: +					data = {},
>, <Line: +					capacity = (options && options.capacity) || Number.MAX_VALUE,
>, <Line: +					lruHash = {},
>, <Line: +					freshEnd = null,
>, <Line: +					staleEnd = null;
>, <Line: +				/**
>, <Line: +				 * @ngdoc type
>, <Line: +				 * @name $cacheFactory.Cache
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * A cache object used to store and retrieve data, primarily used by
>, <Line: +				 * {@link $http $http} and the {@link ng.directive:script script} directive to cache
>, <Line: +				 * templates and other data.
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 *  angular.module('superCache')
>, <Line: +				 *    .factory('superCache', ['$cacheFactory', function($cacheFactory) {
>, <Line: +       *      return $cacheFactory('super-cache');
>, <Line: +       *    }]);
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * Example test:
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 *  it('should behave like a cache', inject(function(superCache) {
>, <Line: +       *    superCache.put('key', 'value');
>, <Line: +       *    superCache.put('another key', 'another value');
>, <Line: +       *
>, <Line: +       *    expect(superCache.info()).toEqual({
>, <Line: +       *      id: 'super-cache',
>, <Line: +       *      size: 2
>, <Line: +       *    });
>, <Line: +       *
>, <Line: +       *    superCache.remove('another key');
>, <Line: +       *    expect(superCache.get('another key')).toBeUndefined();
>, <Line: +       *
>, <Line: +       *    superCache.removeAll();
>, <Line: +       *    expect(superCache.info()).toEqual({
>, <Line: +       *      id: 'super-cache',
>, <Line: +       *      size: 0
>, <Line: +       *    });
>, <Line: +       *  }));
>, <Line: +				 * ```
>, <Line: +				 */
>, <Line: +				return caches[cacheId] = {
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#put
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Inserts a named entry into the {@link $cacheFactory.Cache Cache} object to be
>, <Line: +					 * retrieved later, and incrementing the size of the cache if the key was not already
>, <Line: +					 * present in the cache. If behaving like an LRU cache, it will also remove stale
>, <Line: +					 * entries from the set.
>, <Line: +					 *
>, <Line: +					 * It will not insert undefined values into the cache.
>, <Line: +					 *
>, <Line: +					 * @param {string} key the key under which the cached data is stored.
>, <Line: +					 * @param {*} value the value to store alongside the key. If it is undefined, the key
>, <Line: +					 *    will not be stored.
>, <Line: +					 * @returns {*} the value stored.
>, <Line: +					 */
>, <Line: +					put: function (key, value) {
>, <Line: +						if (capacity < Number.MAX_VALUE) {
>, <Line: +							var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
>, <Line: +							refresh(lruEntry);
>, <Line: +						}
>, <Line: +						if (isUndefined(value)) return;
>, <Line: +						if (!(key in data)) size++;
>, <Line: +						data[key] = value;
>, <Line: +						if (size > capacity) {
>, <Line: +							this.remove(staleEnd.key);
>, <Line: +						}
>, <Line: +						return value;
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#get
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object.
>, <Line: +					 *
>, <Line: +					 * @param {string} key the key of the data to be retrieved
>, <Line: +					 * @returns {*} the value stored.
>, <Line: +					 */
>, <Line: +					get: function (key) {
>, <Line: +						if (capacity < Number.MAX_VALUE) {
>, <Line: +							var lruEntry = lruHash[key];
>, <Line: +							if (!lruEntry) return;
>, <Line: +							refresh(lruEntry);
>, <Line: +						}
>, <Line: +						return data[key];
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#remove
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Removes an entry from the {@link $cacheFactory.Cache Cache} object.
>, <Line: +					 *
>, <Line: +					 * @param {string} key the key of the entry to be removed
>, <Line: +					 */
>, <Line: +					remove: function (key) {
>, <Line: +						if (capacity < Number.MAX_VALUE) {
>, <Line: +							var lruEntry = lruHash[key];
>, <Line: +							if (!lruEntry) return;
>, <Line: +							if (lruEntry == freshEnd) freshEnd = lruEntry.p;
>, <Line: +							if (lruEntry == staleEnd) staleEnd = lruEntry.n;
>, <Line: +							link(lruEntry.n, lruEntry.p);
>, <Line: +							delete lruHash[key];
>, <Line: +						}
>, <Line: +						delete data[key];
>, <Line: +						size--;
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#removeAll
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Clears the cache object of any entries.
>, <Line: +					 */
>, <Line: +					removeAll: function () {
>, <Line: +						data = {};
>, <Line: +						size = 0;
>, <Line: +						lruHash = {};
>, <Line: +						freshEnd = staleEnd = null;
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#destroy
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Destroys the {@link $cacheFactory.Cache Cache} object entirely,
>, <Line: +					 * removing it from the {@link $cacheFactory $cacheFactory} set.
>, <Line: +					 */
>, <Line: +					destroy: function () {
>, <Line: +						data = null;
>, <Line: +						stats = null;
>, <Line: +						lruHash = null;
>, <Line: +						delete caches[cacheId];
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $cacheFactory.Cache#info
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Retrieve information regarding a particular {@link $cacheFactory.Cache Cache}.
>, <Line: +					 *
>, <Line: +					 * @returns {object} an object with the following properties:
>, <Line: +					 *   <ul>
>, <Line: +					 *     <li>**id**: the id of the cache instance</li>
>, <Line: +					 *     <li>**size**: the number of entries kept in the cache instance</li>
>, <Line: +					 *     <li>**...**: any additional properties from the options object when creating the
>, <Line: +					 *       cache.</li>
>, <Line: +					 *   </ul>
>, <Line: +					 */
>, <Line: +					info: function () {
>, <Line: +						return extend({}, stats, {size: size});
>, <Line: +					}
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * makes the `entry` the freshEnd of the LRU linked list
>, <Line: +				 */
>, <Line: +				function refresh(entry) {
>, <Line: +					if (entry != freshEnd) {
>, <Line: +						if (!staleEnd) {
>, <Line: +							staleEnd = entry;
>, <Line: +						} else if (staleEnd == entry) {
>, <Line: +							staleEnd = entry.n;
>, <Line: +						}
>, <Line: +						link(entry.n, entry.p);
>, <Line: +						link(entry, freshEnd);
>, <Line: +						freshEnd = entry;
>, <Line: +						freshEnd.n = null;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * bidirectionally links two entries of the LRU linked list
>, <Line: +				 */
>, <Line: +				function link(nextEntry, prevEntry) {
>, <Line: +					if (nextEntry != prevEntry) {
>, <Line: +						if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
>, <Line: +						if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $cacheFactory#info
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Get information about all the caches that have been created
>, <Line: +			 *
>, <Line: +			 * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
>, <Line: +			 */
>, <Line: +			cacheFactory.info = function () {
>, <Line: +				var info = {};
>, <Line: +				forEach(caches, function (cache, cacheId) {
>, <Line: +					info[cacheId] = cache.info();
>, <Line: +				});
>, <Line: +				return info;
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $cacheFactory#get
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Get access to a cache object by the `cacheId` used when it was created.
>, <Line: +			 *
>, <Line: +			 * @param {string} cacheId Name or id of a cache to access.
>, <Line: +			 * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
>, <Line: +			 */
>, <Line: +			cacheFactory.get = function (cacheId) {
>, <Line: +				return caches[cacheId];
>, <Line: +			};
>, <Line: +			return cacheFactory;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $templateCache
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The first time a template is used, it is loaded in the template cache for quick retrieval. You
>, <Line: +	 * can load templates directly into the cache in a `script` tag, or by consuming the
>, <Line: +	 * `$templateCache` service directly.
>, <Line: +	 *
>, <Line: +	 * Adding via the `script` tag:
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 *   <script type="text/ng-template" id="templateId.html">
>, <Line: +	 *     <p>This is the content of the template</p>
>, <Line: +	 *   </script>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * **Note:** the `script` tag containing the template does not need to be included in the `head` of
>, <Line: +	 * the document, but it must be a descendent of the {@link ng.$rootElement $rootElement} (IE,
>, <Line: +	 * element with ng-app attribute), otherwise the template will be ignored.
>, <Line: +	 *
>, <Line: +	 * Adding via the $templateCache service:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * var myApp = angular.module('myApp', []);
>, <Line: +	 * myApp.run(function($templateCache) {
>, <Line: + *   $templateCache.put('templateId.html', 'This is the content of the template');
>, <Line: + * });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * To retrieve the template later, simply use it in your HTML:
>, <Line: +	 * ```html
>, <Line: +	 * <div ng-include=" 'templateId.html' "></div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * or get it via Javascript:
>, <Line: +	 * ```js
>, <Line: +	 * $templateCache.get('templateId.html')
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * See {@link ng.$cacheFactory $cacheFactory}.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	function $TemplateCacheProvider() {
>, <Line: +		this.$get = ['$cacheFactory', function ($cacheFactory) {
>, <Line: +			return $cacheFactory('templates');
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
>, <Line: +	 *
>, <Line: +	 * DOM-related variables:
>, <Line: +	 *
>, <Line: +	 * - "node" - DOM Node
>, <Line: +	 * - "element" - DOM Element or Node
>, <Line: +	 * - "$node" or "$element" - jqLite-wrapped node or element
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * Compiler related stuff:
>, <Line: +	 *
>, <Line: +	 * - "linkFn" - linking fn of a single directive
>, <Line: +	 * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
>, <Line: +	 * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
>, <Line: +	 * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $compile
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Compiles an HTML string or DOM into a template and produces a template function, which
>, <Line: +	 * can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.
>, <Line: +	 *
>, <Line: +	 * The compilation is a process of walking the DOM tree and matching DOM elements to
>, <Line: +	 * {@link ng.$compileProvider#directive directives}.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** This document is an in-depth reference of all directive options.
>, <Line: +	 * For a gentle introduction to directives with examples of common use cases,
>, <Line: +	 * see the {@link guide/directive directive guide}.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * ## Comprehensive Directive API
>, <Line: +	 *
>, <Line: +	 * There are many different options for a directive.
>, <Line: +	 *
>, <Line: +	 * The difference resides in the return value of the factory function.
>, <Line: +	 * You can either return a "Directive Definition Object" (see below) that defines the directive properties,
>, <Line: +	 * or just the `postLink` function (all other properties will have the default values).
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-success">
>, <Line: +	 * **Best Practice:** It's recommended to use the "directive definition object" form.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * Here's an example directive declared with a Directive Definition Object:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   var myModule = angular.module(...);
>, <Line: +	 *
>, <Line: +	 *   myModule.directive('directiveName', function factory(injectables) {
>, <Line: + *     var directiveDefinitionObject = {
>, <Line: + *       priority: 0,
>, <Line: + *       template: '<div></div>', // or // function(tElement, tAttrs) { ... },
>, <Line: + *       // or
>, <Line: + *       // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
>, <Line: + *       transclude: false,
>, <Line: + *       restrict: 'A',
>, <Line: + *       templateNamespace: 'html',
>, <Line: + *       scope: false,
>, <Line: + *       controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
>, <Line: + *       controllerAs: 'stringAlias',
>, <Line: + *       require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
>, <Line: + *       compile: function compile(tElement, tAttrs, transclude) {
>, <Line: + *         return {
>, <Line: + *           pre: function preLink(scope, iElement, iAttrs, controller) { ... },
>, <Line: + *           post: function postLink(scope, iElement, iAttrs, controller) { ... }
>, <Line: + *         }
>, <Line: + *         // or
>, <Line: + *         // return function postLink( ... ) { ... }
>, <Line: + *       },
>, <Line: + *       // or
>, <Line: + *       // link: {
>, <Line: + *       //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
>, <Line: + *       //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
>, <Line: + *       // }
>, <Line: + *       // or
>, <Line: + *       // link: function postLink( ... ) { ... }
>, <Line: + *     };
>, <Line: + *     return directiveDefinitionObject;
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** Any unspecified options will use the default value. You can see the default values below.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * Therefore the above can be simplified as:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   var myModule = angular.module(...);
>, <Line: +	 *
>, <Line: +	 *   myModule.directive('directiveName', function factory(injectables) {
>, <Line: + *     var directiveDefinitionObject = {
>, <Line: + *       link: function postLink(scope, iElement, iAttrs) { ... }
>, <Line: + *     };
>, <Line: + *     return directiveDefinitionObject;
>, <Line: + *     // or
>, <Line: + *     // return function postLink(scope, iElement, iAttrs) { ... }
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ### Directive Definition Object
>, <Line: +	 *
>, <Line: +	 * The directive definition object provides instructions to the {@link ng.$compile
>, <Line: + * compiler}. The attributes are:
>, <Line: +	 *
>, <Line: +	 * #### `multiElement`
>, <Line: +	 * When this property is set to true, the HTML compiler will collect DOM nodes between
>, <Line: +	 * nodes with the attributes `directive-name-start` and `directive-name-end`, and group them
>, <Line: +	 * together as the directive elements. It is recomended that this feature be used on directives
>, <Line: +	 * which are not strictly behavioural (such as {@link ngClick}), and which
>, <Line: +	 * do not manipulate or replace child nodes (such as {@link ngInclude}).
>, <Line: +	 *
>, <Line: +	 * #### `priority`
>, <Line: +	 * When there are multiple directives defined on a single DOM element, sometimes it
>, <Line: +	 * is necessary to specify the order in which the directives are applied. The `priority` is used
>, <Line: +	 * to sort the directives before their `compile` functions get called. Priority is defined as a
>, <Line: +	 * number. Directives with greater numerical `priority` are compiled first. Pre-link functions
>, <Line: +	 * are also run in priority order, but post-link functions are run in reverse order. The order
>, <Line: +	 * of directives with the same priority is undefined. The default priority is `0`.
>, <Line: +	 *
>, <Line: +	 * #### `terminal`
>, <Line: +	 * If set to true then the current `priority` will be the last set of directives
>, <Line: +	 * which will execute (any directives at the current priority will still execute
>, <Line: +	 * as the order of execution on same `priority` is undefined). Note that expressions
>, <Line: +	 * and other directives used in the directive's template will also be excluded from execution.
>, <Line: +	 *
>, <Line: +	 * #### `scope`
>, <Line: +	 * **If set to `true`,** then a new scope will be created for this directive. If multiple directives on the
>, <Line: +	 * same element request a new scope, only one new scope is created. The new scope rule does not
>, <Line: +	 * apply for the root of the template since the root of the template always gets a new scope.
>, <Line: +	 *
>, <Line: +	 * **If set to `{}` (object hash),** then a new "isolate" scope is created. The 'isolate' scope differs from
>, <Line: +	 * normal scope in that it does not prototypically inherit from the parent scope. This is useful
>, <Line: +	 * when creating reusable components, which should not accidentally read or modify data in the
>, <Line: +	 * parent scope.
>, <Line: +	 *
>, <Line: +	 * The 'isolate' scope takes an object hash which defines a set of local scope properties
>, <Line: +	 * derived from the parent scope. These local properties are useful for aliasing values for
>, <Line: +	 * templates. Locals definition is a hash of local scope property to its source:
>, <Line: +	 *
>, <Line: +	 * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
>, <Line: +	 *   always a string since DOM attributes are strings. If no `attr` name is specified  then the
>, <Line: +	 *   attribute name is assumed to be the same as the local name.
>, <Line: +	 *   Given `<widget my-attr="hello {{name}}">` and widget definition
>, <Line: +	 *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
>, <Line: +	 *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
>, <Line: +	 *   `localName` property on the widget scope. The `name` is read from the parent scope (not
>, <Line: +	 *   component scope).
>, <Line: +	 *
>, <Line: +	 * * `=` or `=attr` - set up bi-directional binding between a local scope property and the
>, <Line: +	 *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`
>, <Line: +	 *   name is specified then the attribute name is assumed to be the same as the local name.
>, <Line: +	 *   Given `<widget my-attr="parentModel">` and widget definition of
>, <Line: +	 *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
>, <Line: +	 *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
>, <Line: +	 *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
>, <Line: +	 *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
>, <Line: +	 *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional. If
>, <Line: +	 *   you want to shallow watch for changes (i.e. $watchCollection instead of $watch) you can use
>, <Line: +	 *   `=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).
>, <Line: +	 *
>, <Line: +	 * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
>, <Line: +	 *   If no `attr` name is specified then the attribute name is assumed to be the same as the
>, <Line: +	 *   local name. Given `<widget my-attr="count = count + value">` and widget definition of
>, <Line: +	 *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
>, <Line: +	 *   a function wrapper for the `count = count + value` expression. Often it's desirable to
>, <Line: +	 *   pass data from the isolated scope via an expression to the parent scope, this can be
>, <Line: +	 *   done by passing a map of local variable names and values into the expression wrapper fn.
>, <Line: +	 *   For example, if the expression is `increment(amount)` then we can specify the amount value
>, <Line: +	 *   by calling the `localFn` as `localFn({amount: 22})`.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `bindToController`
>, <Line: +	 * When an isolate scope is used for a component (see above), and `controllerAs` is used, `bindToController: true` will
>, <Line: +	 * allow a component to have its properties bound to the controller, rather than to scope. When the controller
>, <Line: +	 * is instantiated, the initial values of the isolate scope bindings are already available.
>, <Line: +	 *
>, <Line: +	 * #### `controller`
>, <Line: +	 * Controller constructor function. The controller is instantiated before the
>, <Line: +	 * pre-linking phase and it is shared with other directives (see
>, <Line: +	 * `require` attribute). This allows the directives to communicate with each other and augment
>, <Line: +	 * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:
>, <Line: +	 *
>, <Line: +	 * * `$scope` - Current scope associated with the element
>, <Line: +	 * * `$element` - Current element
>, <Line: +	 * * `$attrs` - Current attributes object for the element
>, <Line: +	 * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:
>, <Line: +	 *   `function([scope], cloneLinkingFn, futureParentElement)`.
>, <Line: +	 *    * `scope`: optional argument to override the scope.
>, <Line: +	 *    * `cloneLinkingFn`: optional argument to create clones of the original transcluded content.
>, <Line: +	 *    * `futureParentElement`:
>, <Line: +	 *        * defines the parent to which the `cloneLinkingFn` will add the cloned elements.
>, <Line: +	 *        * default: `$element.parent()` resp. `$element` for `transclude:'element'` resp. `transclude:true`.
>, <Line: +	 *        * only needed for transcludes that are allowed to contain non html elements (e.g. SVG elements)
>, <Line: +	 *          and when the `cloneLinkinFn` is passed,
>, <Line: +	 *          as those elements need to created and cloned in a special way when they are defined outside their
>, <Line: +	 *          usual containers (e.g. like `<svg>`).
>, <Line: +	 *        * See also the `directive.templateNamespace` property.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `require`
>, <Line: +	 * Require another directive and inject its controller as the fourth argument to the linking function. The
>, <Line: +	 * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
>, <Line: +	 * injected argument will be an array in corresponding order. If no such directive can be
>, <Line: +	 * found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:
>, <Line: +	 *
>, <Line: +	 * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
>, <Line: +	 * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
>, <Line: +	 * * `^` - Locate the required controller by searching the element and its parents. Throw an error if not found.
>, <Line: +	 * * `^^` - Locate the required controller by searching the element's parents. Throw an error if not found.
>, <Line: +	 * * `?^` - Attempt to locate the required controller by searching the element and its parents or pass
>, <Line: +	 *   `null` to the `link` fn if not found.
>, <Line: +	 * * `?^^` - Attempt to locate the required controller by searching the element's parents, or pass
>, <Line: +	 *   `null` to the `link` fn if not found.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `controllerAs`
>, <Line: +	 * Controller alias at the directive scope. An alias for the controller so it
>, <Line: +	 * can be referenced at the directive template. The directive needs to define a scope for this
>, <Line: +	 * configuration to be used. Useful in the case when directive is used as component.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `restrict`
>, <Line: +	 * String of subset of `EACM` which restricts the directive to a specific directive
>, <Line: +	 * declaration style. If omitted, the defaults (elements and attributes) are used.
>, <Line: +	 *
>, <Line: +	 * * `E` - Element name (default): `<my-directive></my-directive>`
>, <Line: +	 * * `A` - Attribute (default): `<div my-directive="exp"></div>`
>, <Line: +	 * * `C` - Class: `<div class="my-directive: exp;"></div>`
>, <Line: +	 * * `M` - Comment: `<!-- directive: my-directive exp -->`
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `templateNamespace`
>, <Line: +	 * String representing the document type used by the markup in the template.
>, <Line: +	 * AngularJS needs this information as those elements need to be created and cloned
>, <Line: +	 * in a special way when they are defined outside their usual containers like `<svg>` and `<math>`.
>, <Line: +	 *
>, <Line: +	 * * `html` - All root nodes in the template are HTML. Root nodes may also be
>, <Line: +	 *   top-level elements such as `<svg>` or `<math>`.
>, <Line: +	 * * `svg` - The root nodes in the template are SVG elements (excluding `<math>`).
>, <Line: +	 * * `math` - The root nodes in the template are MathML elements (excluding `<svg>`).
>, <Line: +	 *
>, <Line: +	 * If no `templateNamespace` is specified, then the namespace is considered to be `html`.
>, <Line: +	 *
>, <Line: +	 * #### `template`
>, <Line: +	 * HTML markup that may:
>, <Line: +	 * * Replace the contents of the directive's element (default).
>, <Line: +	 * * Replace the directive's element itself (if `replace` is true - DEPRECATED).
>, <Line: +	 * * Wrap the contents of the directive's element (if `transclude` is true).
>, <Line: +	 *
>, <Line: +	 * Value may be:
>, <Line: +	 *
>, <Line: +	 * * A string. For example `<div red-on-hover>{{delete_str}}</div>`.
>, <Line: +	 * * A function which takes two arguments `tElement` and `tAttrs` (described in the `compile`
>, <Line: +	 *   function api below) and returns a string value.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `templateUrl`
>, <Line: +	 * This is similar to `template` but the template is loaded from the specified URL, asynchronously.
>, <Line: +	 *
>, <Line: +	 * Because template loading is asynchronous the compiler will suspend compilation of directives on that element
>, <Line: +	 * for later when the template has been resolved.  In the meantime it will continue to compile and link
>, <Line: +	 * sibling and parent elements as though this element had not contained any directives.
>, <Line: +	 *
>, <Line: +	 * The compiler does not suspend the entire compilation to wait for templates to be loaded because this
>, <Line: +	 * would result in the whole app "stalling" until all templates are loaded asynchronously - even in the
>, <Line: +	 * case when only one deeply nested directive has `templateUrl`.
>, <Line: +	 *
>, <Line: +	 * Template loading is asynchronous even if the template has been preloaded into the {@link $templateCache}
>, <Line: +	 *
>, <Line: +	 * You can specify `templateUrl` as a string representing the URL or as a function which takes two
>, <Line: +	 * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
>, <Line: +	 * a string value representing the url.  In either case, the template URL is passed through {@link
>, <Line: +		* $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `replace` ([*DEPRECATED*!], will be removed in next major release - i.e. v2.0)
>, <Line: +	 * specify what the template should replace. Defaults to `false`.
>, <Line: +	 *
>, <Line: +	 * * `true` - the template will replace the directive's element.
>, <Line: +	 * * `false` - the template will replace the contents of the directive's element.
>, <Line: +	 *
>, <Line: +	 * The replacement process migrates all of the attributes / classes from the old element to the new
>, <Line: +	 * one. See the {@link guide/directive#template-expanding-directive
>, <Line: + * Directives Guide} for an example.
>, <Line: +	 *
>, <Line: +	 * There are very few scenarios where element replacement is required for the application function,
>, <Line: +	 * the main one being reusable custom components that are used within SVG contexts
>, <Line: +	 * (because SVG doesn't work with custom elements in the DOM tree).
>, <Line: +	 *
>, <Line: +	 * #### `transclude`
>, <Line: +	 * Extract the contents of the element where the directive appears and make it available to the directive.
>, <Line: +	 * The contents are compiled and provided to the directive as a **transclusion function**. See the
>, <Line: +	 * {@link $compile#transclusion Transclusion} section below.
>, <Line: +	 *
>, <Line: +	 * There are two kinds of transclusion depending upon whether you want to transclude just the contents of the
>, <Line: +	 * directive's element or the entire element:
>, <Line: +	 *
>, <Line: +	 * * `true` - transclude the content (i.e. the child nodes) of the directive's element.
>, <Line: +	 * * `'element'` - transclude the whole of the directive's element including any directives on this
>, <Line: +	 *   element that defined at a lower priority than this directive. When used, the `template`
>, <Line: +	 *   property is ignored.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `compile`
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   function compile(tElement, tAttrs, transclude) { ... }
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The compile function deals with transforming the template DOM. Since most directives do not do
>, <Line: +	 * template transformation, it is not used often. The compile function takes the following arguments:
>, <Line: +	 *
>, <Line: +	 *   * `tElement` - template element - The element where the directive has been declared. It is
>, <Line: +	 *     safe to do template transformation on the element and child elements only.
>, <Line: +	 *
>, <Line: +	 *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
>, <Line: +	 *     between all directive compile functions.
>, <Line: +	 *
>, <Line: +	 *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** The template instance and the link instance may be different objects if the template has
>, <Line: +	 * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
>, <Line: +	 * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
>, <Line: +	 * should be done in a linking function rather than in a compile function.
>, <Line: +	 * </div>
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** The compile function cannot handle directives that recursively use themselves in their
>, <Line: +	 * own templates or compile functions. Compiling these directives results in an infinite loop and a
>, <Line: +	 * stack overflow errors.
>, <Line: +	 *
>, <Line: +	 * This can be avoided by manually using $compile in the postLink function to imperatively compile
>, <Line: +	 * a directive's template instead of relying on automatic template compilation via `template` or
>, <Line: +	 * `templateUrl` declaration or manual compilation inside the compile function.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-error">
>, <Line: +	 * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
>, <Line: +	 *   e.g. does not know about the right outer scope. Please use the transclude function that is passed
>, <Line: +	 *   to the link function instead.
>, <Line: +	 * </div>
>, <Line: +	 * A compile function can have a return value which can be either a function or an object.
>, <Line: +	 *
>, <Line: +	 * * returning a (post-link) function - is equivalent to registering the linking function via the
>, <Line: +	 *   `link` property of the config object when the compile function is empty.
>, <Line: +	 *
>, <Line: +	 * * returning an object with function(s) registered via `pre` and `post` properties - allows you to
>, <Line: +	 *   control when a linking function should be called during the linking phase. See info about
>, <Line: +	 *   pre-linking and post-linking functions below.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### `link`
>, <Line: +	 * This property is used only if the `compile` property is not defined.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The link function is responsible for registering DOM listeners as well as updating the DOM. It is
>, <Line: +	 * executed after the template has been cloned. This is where most of the directive logic will be
>, <Line: +	 * put.
>, <Line: +	 *
>, <Line: +	 *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be used by the
>, <Line: +	 *     directive for registering {@link ng.$rootScope.Scope#$watch watches}.
>, <Line: +	 *
>, <Line: +	 *   * `iElement` - instance element - The element where the directive is to be used. It is safe to
>, <Line: +	 *     manipulate the children of the element only in `postLink` function since the children have
>, <Line: +	 *     already been linked.
>, <Line: +	 *
>, <Line: +	 *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
>, <Line: +	 *     between all directive linking functions.
>, <Line: +	 *
>, <Line: +	 *   * `controller` - a controller instance - A controller instance if at least one directive on the
>, <Line: +	 *     element defines a controller. The controller is shared among all the directives, which allows
>, <Line: +	 *     the directives to use the controllers as a communication channel.
>, <Line: +	 *
>, <Line: +	 *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
>, <Line: +	 *     This is the same as the `$transclude`
>, <Line: +	 *     parameter of directive controllers, see there for details.
>, <Line: +	 *     `function([scope], cloneLinkingFn, futureParentElement)`.
>, <Line: +	 *
>, <Line: +	 * #### Pre-linking function
>, <Line: +	 *
>, <Line: +	 * Executed before the child elements are linked. Not safe to do DOM transformation since the
>, <Line: +	 * compiler linking function will fail to locate the correct elements for linking.
>, <Line: +	 *
>, <Line: +	 * #### Post-linking function
>, <Line: +	 *
>, <Line: +	 * Executed after the child elements are linked.
>, <Line: +	 *
>, <Line: +	 * Note that child elements that contain `templateUrl` directives will not have been compiled
>, <Line: +	 * and linked since they are waiting for their template to load asynchronously and their own
>, <Line: +	 * compilation and linking has been suspended until that occurs.
>, <Line: +	 *
>, <Line: +	 * It is safe to do DOM transformation in the post-linking function on elements that are not waiting
>, <Line: +	 * for their async templates to be resolved.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ### Transclusion
>, <Line: +	 *
>, <Line: +	 * Transclusion is the process of extracting a collection of DOM element from one part of the DOM and
>, <Line: +	 * copying them to another part of the DOM, while maintaining their connection to the original AngularJS
>, <Line: +	 * scope from where they were taken.
>, <Line: +	 *
>, <Line: +	 * Transclusion is used (often with {@link ngTransclude}) to insert the
>, <Line: +	 * original contents of a directive's element into a specified place in the template of the directive.
>, <Line: +	 * The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded
>, <Line: +	 * content has access to the properties on the scope from which it was taken, even if the directive
>, <Line: +	 * has isolated scope.
>, <Line: +	 * See the {@link guide/directive#creating-a-directive-that-wraps-other-elements Directives Guide}.
>, <Line: +	 *
>, <Line: +	 * This makes it possible for the widget to have private state for its template, while the transcluded
>, <Line: +	 * content has access to its originating scope.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** When testing an element transclude directive you must not place the directive at the root of the
>, <Line: +	 * DOM fragment that is being compiled. See {@link guide/unit-testing#testing-transclusion-directives
>, <Line: + * Testing Transclusion Directives}.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * #### Transclusion Functions
>, <Line: +	 *
>, <Line: +	 * When a directive requests transclusion, the compiler extracts its contents and provides a **transclusion
>, <Line: +	 * function** to the directive's `link` function and `controller`. This transclusion function is a special
>, <Line: +	 * **linking function** that will return the compiled contents linked to a new transclusion scope.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-info">
>, <Line: +	 * If you are just using {@link ngTransclude} then you don't need to worry about this function, since
>, <Line: +	 * ngTransclude will deal with it for us.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * If you want to manually control the insertion and removal of the transcluded content in your directive
>, <Line: +	 * then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery
>, <Line: +	 * object that contains the compiled DOM, which is linked to the correct transclusion scope.
>, <Line: +	 *
>, <Line: +	 * When you call a transclusion function you can pass in a **clone attach function**. This function accepts
>, <Line: +	 * two parameters, `function(clone, scope) { ... }`, where the `clone` is a fresh compiled copy of your transcluded
>, <Line: +	 * content and the `scope` is the newly created transclusion scope, to which the clone is bound.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-info">
>, <Line: +	 * **Best Practice**: Always provide a `cloneFn` (clone attach function) when you call a translude function
>, <Line: +	 * since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * It is normal practice to attach your transcluded content (`clone`) to the DOM inside your **clone
>, <Line: +	 * attach function**:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * var transcludedContent, transclusionScope;
>, <Line: +	 *
>, <Line: +	 * $transclude(function(clone, scope) {
>, <Line: + *   element.append(clone);
>, <Line: + *   transcludedContent = clone;
>, <Line: + *   transclusionScope = scope;
>, <Line: + * });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Later, if you want to remove the transcluded content from your DOM then you should also destroy the
>, <Line: +	 * associated transclusion scope:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * transcludedContent.remove();
>, <Line: +	 * transclusionScope.$destroy();
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-info">
>, <Line: +	 * **Best Practice**: if you intend to add and remove transcluded content manually in your directive
>, <Line: +	 * (by calling the transclude function to get the DOM and and calling `element.remove()` to remove it),
>, <Line: +	 * then you are also responsible for calling `$destroy` on the transclusion scope.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * The built-in DOM manipulation directives, such as {@link ngIf}, {@link ngSwitch} and {@link ngRepeat}
>, <Line: +	 * automatically destroy their transluded clones as necessary so you do not need to worry about this if
>, <Line: +	 * you are simply using {@link ngTransclude} to inject the transclusion into your directive.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * #### Transclusion Scopes
>, <Line: +	 *
>, <Line: +	 * When you call a transclude function it returns a DOM fragment that is pre-bound to a **transclusion
>, <Line: +	 * scope**. This scope is special, in that it is a child of the directive's scope (and so gets destroyed
>, <Line: +	 * when the directive's scope gets destroyed) but it inherits the properties of the scope from which it
>, <Line: +	 * was taken.
>, <Line: +	 *
>, <Line: +	 * For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look
>, <Line: +	 * like this:
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <div ng-app>
>, <Line: +	 *   <div isolate>
>, <Line: +	 *     <div transclusion>
>, <Line: +	 *     </div>
>, <Line: +	 *   </div>
>, <Line: +	 * </div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The `$parent` scope hierarchy will look like this:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * - $rootScope
>, <Line: +	 *   - isolate
>, <Line: +	 *     - transclusion
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * but the scopes will inherit prototypically from different scopes to their `$parent`.
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * - $rootScope
>, <Line: +	 *   - transclusion
>, <Line: +	 * - isolate
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ### Attributes
>, <Line: +	 *
>, <Line: +	 * The {@link ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the
>, <Line: +	 * `link()` or `compile()` functions. It has a variety of uses.
>, <Line: +	 *
>, <Line: +	 * accessing *Normalized attribute names:*
>, <Line: +	 * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
>, <Line: +	 * the attributes object allows for normalized access to
>, <Line: +	 *   the attributes.
>, <Line: +	 *
>, <Line: +	 * * *Directive inter-communication:* All directives share the same instance of the attributes
>, <Line: +	 *   object which allows the directives to use the attributes object as inter directive
>, <Line: +	 *   communication.
>, <Line: +	 *
>, <Line: +	 * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object
>, <Line: +	 *   allowing other directives to read the interpolated value.
>, <Line: +	 *
>, <Line: +	 * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
>, <Line: +	 *   that contain interpolation (e.g. `src="{{bar}}"`). Not only is this very efficient but it's also
>, <Line: +	 *   the only way to easily get the actual value because during the linking phase the interpolation
>, <Line: +	 *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * function linkingFn(scope, elm, attrs, ctrl) {
>, <Line: + *   // get the attribute value
>, <Line: + *   console.log(attrs.ngModel);
>, <Line: + *   // change the attribute
>, <Line: + *   attrs.$set('ngModel', 'new value');
>, <Line: + *   // observe changes to interpolated attribute
>, <Line: + *   attrs.$observe('ngModel', function(value) {
>, <Line: + *     console.log('ngModel has changed value to ' + value);
>, <Line: + *   });
>, <Line: + * }
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * ## Example
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note**: Typically directives are registered with `module.directive`. The example below is
>, <Line: +	 * to illustrate how `$compile` works.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 <example module="compileExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('compileExample', [], function($compileProvider) {
>, <Line: +        // configure new 'compile' directive by passing a directive
>, <Line: +        // factory function. The factory function injects the '$compile'
>, <Line: +        $compileProvider.directive('compile', function($compile) {
>, <Line: +          // directive factory creates a link function
>, <Line: +          return function(scope, element, attrs) {
>, <Line: +            scope.$watch(
>, <Line: +              function(scope) {
>, <Line: +                 // watch the 'compile' expression for changes
>, <Line: +                return scope.$eval(attrs.compile);
>, <Line: +              },
>, <Line: +              function(value) {
>, <Line: +                // when the 'compile' expression changes
>, <Line: +                // assign it into the current DOM
>, <Line: +                element.html(value);
>, <Line: +                // compile the new DOM and link it to the current
>, <Line: +                // scope.
>, <Line: +                // NOTE: we only compile .childNodes so that
>, <Line: +                // we don't get into infinite loop compiling ourselves
>, <Line: +                $compile(element.contents())(scope);
>, <Line: +              }
>, <Line: +            );
>, <Line: +          };
>, <Line: +        });
>, <Line: +      })
>, <Line: +	 .controller('GreeterController', ['$scope', function($scope) {
>, <Line: +        $scope.name = 'Angular';
>, <Line: +        $scope.html = 'Hello {{name}}';
>, <Line: +      }]);
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="GreeterController">
>, <Line: +	 <input ng-model="name"> <br>
>, <Line: +	 <textarea ng-model="html"></textarea> <br>
>, <Line: +	 <div compile="html"></div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should auto compile', function() {
>, <Line: +       var textarea = $('textarea');
>, <Line: +       var output = $('div[compile]');
>, <Line: +       // The initial state reads 'Hello Angular'.
>, <Line: +       expect(output.getText()).toBe('Hello Angular');
>, <Line: +       textarea.clear();
>, <Line: +       textarea.sendKeys('{{name}}!');
>, <Line: +       expect(output.getText()).toBe('Angular!');
>, <Line: +     });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
>, <Line: +	 * @param {function(angular.Scope, cloneAttachFn=)} transclude function available to directives - DEPRECATED.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-error">
>, <Line: +	 * **Note:** Passing a `transclude` function to the $compile function is deprecated, as it
>, <Line: +	 *   e.g. will not use the right outer scope. Please pass the transclude function as a
>, <Line: +	 *   `parentBoundTranscludeFn` to the link function instead.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * @param {number} maxPriority only apply directives lower than given priority (Only effects the
>, <Line: +	 *                 root element(s), not their children)
>, <Line: +	 * @returns {function(scope, cloneAttachFn=, options=)} a link function which is used to bind template
>, <Line: +	 * (a DOM element/tree) to a scope. Where:
>, <Line: +	 *
>, <Line: +	 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
>, <Line: +	 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
>, <Line: +	 *  `template` and call the `cloneAttachFn` function allowing the caller to attach the
>, <Line: +	 *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
>, <Line: +	 *  called as: <br> `cloneAttachFn(clonedElement, scope)` where:
>, <Line: +	 *
>, <Line: +	 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
>, <Line: +	 *      * `scope` - is the current scope with which the linking function is working with.
>, <Line: +	 *
>, <Line: +	 *  * `options` - An optional object hash with linking options. If `options` is provided, then the following
>, <Line: +	 *  keys may be used to control linking behavior:
>, <Line: +	 *
>, <Line: +	 *      * `parentBoundTranscludeFn` - the transclude function made available to
>, <Line: +	 *        directives; if given, it will be passed through to the link functions of
>, <Line: +	 *        directives found in `element` during compilation.
>, <Line: +	 *      * `transcludeControllers` - an object hash with keys that map controller names
>, <Line: +	 *        to controller instances; if given, it will make the controllers
>, <Line: +	 *        available to directives.
>, <Line: +	 *      * `futureParentElement` - defines the parent to which the `cloneAttachFn` will add
>, <Line: +	 *        the cloned elements; only needed for transcludes that are allowed to contain non html
>, <Line: +	 *        elements (e.g. SVG elements). See also the directive.controller property.
>, <Line: +	 *
>, <Line: +	 * Calling the linking function returns the element of the template. It is either the original
>, <Line: +	 * element passed in, or the clone of the element if the `cloneAttachFn` is provided.
>, <Line: +	 *
>, <Line: +	 * After linking the view is not updated until after a call to $digest which typically is done by
>, <Line: +	 * Angular automatically.
>, <Line: +	 *
>, <Line: +	 * If you need access to the bound view, there are two ways to do it:
>, <Line: +	 *
>, <Line: +	 * - If you are not asking the linking function to clone the template, create the DOM element(s)
>, <Line: +	 *   before you send them to the compiler and keep this reference around.
>, <Line: +	 *   ```js
>, <Line: +	 *     var element = $compile('<p>{{total}}</p>')(scope);
>, <Line: +	 *   ```
>, <Line: +	 *
>, <Line: +	 * - if on the other hand, you need the element to be cloned, the view reference from the original
>, <Line: +	 *   example would not point to the clone, but rather to the original template that was cloned. In
>, <Line: +	 *   this case, you can access the clone via the cloneAttachFn:
>, <Line: +	 *   ```js
>, <Line: +	 *     var templateElement = angular.element('<p>{{total}}</p>'),
>, <Line: +	 *         scope = ....;
>, <Line: +	 *
>, <Line: +	 *     var clonedElement = $compile(templateElement)(scope, function(clonedElement, scope) {
>, <Line: + *       //attach the clone to DOM document at the right place
>, <Line: + *     });
>, <Line: +	 *
>, <Line: +	 *     //now we have reference to the cloned DOM via `clonedElement`
>, <Line: +	 *   ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * For information on how the compiler works, see the
>, <Line: +	 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
>, <Line: +	 */
>, <Line: +	var $compileMinErr = minErr('$compile');
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $compileProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 */
>, <Line: +	$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
>, <Line: +	function $CompileProvider($provide, $$sanitizeUriProvider) {
>, <Line: +		var hasDirectives = {},
>, <Line: +			Suffix = 'Directive',
>, <Line: +			COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
>, <Line: +			CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
>, <Line: +			ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
>, <Line: +			REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
>, <Line: +		// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
>, <Line: +		// The assumption is that future DOM event attribute names will begin with
>, <Line: +		// 'on' and be composed of only English letters.
>, <Line: +		var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
>, <Line: +		function parseIsolateBindings(scope, directiveName) {
>, <Line: +			var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
>, <Line: +			var bindings = {};
>, <Line: +			forEach(scope, function (definition, scopeName) {
>, <Line: +				var match = definition.match(LOCAL_REGEXP);
>, <Line: +				if (!match) {
>, <Line: +					throw $compileMinErr('iscp',
>, <Line: +						"Invalid isolate scope definition for directive '{0}'." +
>, <Line: +						" Definition: {... {1}: '{2}' ...}",
>, <Line: +						directiveName, scopeName, definition);
>, <Line: +				}
>, <Line: +				bindings[scopeName] = {
>, <Line: +					mode: match[1][0],
>, <Line: +					collection: match[2] === '*',
>, <Line: +					optional: match[3] === '?',
>, <Line: +					attrName: match[4] || scopeName
>, <Line: +				};
>, <Line: +			});
>, <Line: +			return bindings;
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $compileProvider#directive
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Register a new directive with the compiler.
>, <Line: +		 *
>, <Line: +		 * @param {string|Object} name Name of the directive in camel-case (i.e. <code>ngBind</code> which
>, <Line: +		 *    will match as <code>ng-bind</code>), or an object map of directives where the keys are the
>, <Line: +		 *    names and the values are the factories.
>, <Line: +		 * @param {Function|Array} directiveFactory An injectable directive factory function. See
>, <Line: +		 *    {@link guide/directive} for more info.
>, <Line: +		 * @returns {ng.$compileProvider} Self for chaining.
>, <Line: +		 */
>, <Line: +		this.directive = function registerDirective(name, directiveFactory) {
>, <Line: +			assertNotHasOwnProperty(name, 'directive');
>, <Line: +			if (isString(name)) {
>, <Line: +				assertArg(directiveFactory, 'directiveFactory');
>, <Line: +				if (!hasDirectives.hasOwnProperty(name)) {
>, <Line: +					hasDirectives[name] = [];
>, <Line: +					$provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
>, <Line: +						function ($injector, $exceptionHandler) {
>, <Line: +							var directives = [];
>, <Line: +							forEach(hasDirectives[name], function (directiveFactory, index) {
>, <Line: +								try {
>, <Line: +									var directive = $injector.invoke(directiveFactory);
>, <Line: +									if (isFunction(directive)) {
>, <Line: +										directive = {compile: valueFn(directive)};
>, <Line: +									} else if (!directive.compile && directive.link) {
>, <Line: +										directive.compile = valueFn(directive.link);
>, <Line: +									}
>, <Line: +									directive.priority = directive.priority || 0;
>, <Line: +									directive.index = index;
>, <Line: +									directive.name = directive.name || name;
>, <Line: +									directive.require = directive.require || (directive.controller && directive.name);
>, <Line: +									directive.restrict = directive.restrict || 'EA';
>, <Line: +									if (isObject(directive.scope)) {
>, <Line: +										directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name);
>, <Line: +									}
>, <Line: +									directives.push(directive);
>, <Line: +								} catch (e) {
>, <Line: +									$exceptionHandler(e);
>, <Line: +								}
>, <Line: +							});
>, <Line: +							return directives;
>, <Line: +						}]);
>, <Line: +				}
>, <Line: +				hasDirectives[name].push(directiveFactory);
>, <Line: +			} else {
>, <Line: +				forEach(name, reverseParams(registerDirective));
>, <Line: +			}
>, <Line: +			return this;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $compileProvider#aHrefSanitizationWhitelist
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: +		 * urls during a[href] sanitization.
>, <Line: +		 *
>, <Line: +		 * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: +		 *
>, <Line: +		 * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
>, <Line: +		 * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
>, <Line: +		 * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: +		 * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: +		 *
>, <Line: +		 * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: +		 * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: +		 *    chaining otherwise.
>, <Line: +		 */
>, <Line: +		this.aHrefSanitizationWhitelist = function (regexp) {
>, <Line: +			if (isDefined(regexp)) {
>, <Line: +				$$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $compileProvider#imgSrcSanitizationWhitelist
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: +		 * urls during img[src] sanitization.
>, <Line: +		 *
>, <Line: +		 * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: +		 *
>, <Line: +		 * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
>, <Line: +		 * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
>, <Line: +		 * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: +		 * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: +		 *
>, <Line: +		 * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: +		 * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: +		 *    chaining otherwise.
>, <Line: +		 */
>, <Line: +		this.imgSrcSanitizationWhitelist = function (regexp) {
>, <Line: +			if (isDefined(regexp)) {
>, <Line: +				$$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name  $compileProvider#debugInfoEnabled
>, <Line: +		 *
>, <Line: +		 * @param {boolean=} enabled update the debugInfoEnabled state if provided, otherwise just return the
>, <Line: +		 * current debugInfoEnabled state
>, <Line: +		 * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: +		 *
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Call this method to enable/disable various debug runtime information in the compiler such as adding
>, <Line: +		 * binding information and a reference to the current scope on to DOM elements.
>, <Line: +		 * If enabled, the compiler will add the following to DOM elements that have been bound to the scope
>, <Line: +		 * * `ng-binding` CSS class
>, <Line: +		 * * `$binding` data property containing an array of the binding expressions
>, <Line: +		 *
>, <Line: +		 * You may want to use this in production for a significant performance boost. See
>, <Line: +		 * {@link guide/production#disabling-debug-data Disabling Debug Data} for more.
>, <Line: +		 *
>, <Line: +		 * The default value is true.
>, <Line: +		 */
>, <Line: +		var debugInfoEnabled = true;
>, <Line: +		this.debugInfoEnabled = function (enabled) {
>, <Line: +			if (isDefined(enabled)) {
>, <Line: +				debugInfoEnabled = enabled;
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +			return debugInfoEnabled;
>, <Line: +		};
>, <Line: +		this.$get = [
>, <Line: +			'$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse',
>, <Line: +			'$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri',
>, <Line: +			function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse,
>, <Line: +					  $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
>, <Line: +				var Attributes = function (element, attributesToCopy) {
>, <Line: +					if (attributesToCopy) {
>, <Line: +						var keys = Object.keys(attributesToCopy);
>, <Line: +						var i, l, key;
>, <Line: +						for (i = 0, l = keys.length; i < l; i++) {
>, <Line: +							key = keys[i];
>, <Line: +							this[key] = attributesToCopy[key];
>, <Line: +						}
>, <Line: +					} else {
>, <Line: +						this.$attr = {};
>, <Line: +					}
>, <Line: +					this.$$element = element;
>, <Line: +				};
>, <Line: +				Attributes.prototype = {
>, <Line: +					$normalize: directiveNormalize,
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $compile.directive.Attributes#$addClass
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Adds the CSS class value specified by the classVal parameter to the element. If animations
>, <Line: +					 * are enabled then an animation will be triggered for the class addition.
>, <Line: +					 *
>, <Line: +					 * @param {string} classVal The className value that will be added to the element
>, <Line: +					 */
>, <Line: +					$addClass: function (classVal) {
>, <Line: +						if (classVal && classVal.length > 0) {
>, <Line: +							$animate.addClass(this.$$element, classVal);
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $compile.directive.Attributes#$removeClass
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Removes the CSS class value specified by the classVal parameter from the element. If
>, <Line: +					 * animations are enabled then an animation will be triggered for the class removal.
>, <Line: +					 *
>, <Line: +					 * @param {string} classVal The className value that will be removed from the element
>, <Line: +					 */
>, <Line: +					$removeClass: function (classVal) {
>, <Line: +						if (classVal && classVal.length > 0) {
>, <Line: +							$animate.removeClass(this.$$element, classVal);
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $compile.directive.Attributes#$updateClass
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Adds and removes the appropriate CSS class values to the element based on the difference
>, <Line: +					 * between the new and old CSS class values (specified as newClasses and oldClasses).
>, <Line: +					 *
>, <Line: +					 * @param {string} newClasses The current CSS className value
>, <Line: +					 * @param {string} oldClasses The former CSS className value
>, <Line: +					 */
>, <Line: +					$updateClass: function (newClasses, oldClasses) {
>, <Line: +						var toAdd = tokenDifference(newClasses, oldClasses);
>, <Line: +						if (toAdd && toAdd.length) {
>, <Line: +							$animate.addClass(this.$$element, toAdd);
>, <Line: +						}
>, <Line: +						var toRemove = tokenDifference(oldClasses, newClasses);
>, <Line: +						if (toRemove && toRemove.length) {
>, <Line: +							$animate.removeClass(this.$$element, toRemove);
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * Set a normalized attribute on the element in a way such that all directives
>, <Line: +					 * can share the attribute. This function properly handles boolean attributes.
>, <Line: +					 * @param {string} key Normalized key. (ie ngAttribute)
>, <Line: +					 * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
>, <Line: +					 * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
>, <Line: +					 *     Defaults to true.
>, <Line: +					 * @param {string=} attrName Optional none normalized name. Defaults to key.
>, <Line: +					 */
>, <Line: +					$set: function (key, value, writeAttr, attrName) {
>, <Line: +						// TODO: decide whether or not to throw an error if "class"
>, <Line: +						//is set through this function since it may cause $updateClass to
>, <Line: +						//become unstable.
>, <Line: +						var node = this.$$element[0],
>, <Line: +							booleanKey = getBooleanAttrName(node, key),
>, <Line: +							aliasedKey = getAliasedAttrName(node, key),
>, <Line: +							observer = key,
>, <Line: +							nodeName;
>, <Line: +						if (booleanKey) {
>, <Line: +							this.$$element.prop(key, value);
>, <Line: +							attrName = booleanKey;
>, <Line: +						} else if (aliasedKey) {
>, <Line: +							this[aliasedKey] = value;
>, <Line: +							observer = aliasedKey;
>, <Line: +						}
>, <Line: +						this[key] = value;
>, <Line: +						// translate normalized key to actual key
>, <Line: +						if (attrName) {
>, <Line: +							this.$attr[key] = attrName;
>, <Line: +						} else {
>, <Line: +							attrName = this.$attr[key];
>, <Line: +							if (!attrName) {
>, <Line: +								this.$attr[key] = attrName = snake_case(key, '-');
>, <Line: +							}
>, <Line: +						}
>, <Line: +						nodeName = nodeName_(this.$$element);
>, <Line: +						if ((nodeName === 'a' && key === 'href') ||
>, <Line: +							(nodeName === 'img' && key === 'src')) {
>, <Line: +							// sanitize a[href] and img[src] values
>, <Line: +							this[key] = value = $$sanitizeUri(value, key === 'src');
>, <Line: +						} else if (nodeName === 'img' && key === 'srcset') {
>, <Line: +							// sanitize img[srcset] values
>, <Line: +							var result = "";
>, <Line: +							// first check if there are spaces because it's not the same pattern
>, <Line: +							var trimmedSrcset = trim(value);
>, <Line: +							//                (   999x   ,|   999w   ,|   ,|,   )
>, <Line: +							var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
>, <Line: +							var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
>, <Line: +							// split srcset into tuple of uri and descriptor except for the last item
>, <Line: +							var rawUris = trimmedSrcset.split(pattern);
>, <Line: +							// for each tuples
>, <Line: +							var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
>, <Line: +							for (var i = 0; i < nbrUrisWith2parts; i++) {
>, <Line: +								var innerIdx = i * 2;
>, <Line: +								// sanitize the uri
>, <Line: +								result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
>, <Line: +								// add the descriptor
>, <Line: +								result += (" " + trim(rawUris[innerIdx + 1]));
>, <Line: +							}
>, <Line: +							// split the last item into uri and descriptor
>, <Line: +							var lastTuple = trim(rawUris[i * 2]).split(/\s/);
>, <Line: +							// sanitize the last uri
>, <Line: +							result += $$sanitizeUri(trim(lastTuple[0]), true);
>, <Line: +							// and add the last descriptor if any
>, <Line: +							if (lastTuple.length === 2) {
>, <Line: +								result += (" " + trim(lastTuple[1]));
>, <Line: +							}
>, <Line: +							this[key] = value = result;
>, <Line: +						}
>, <Line: +						if (writeAttr !== false) {
>, <Line: +							if (value === null || value === undefined) {
>, <Line: +								this.$$element.removeAttr(attrName);
>, <Line: +							} else {
>, <Line: +								this.$$element.attr(attrName, value);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						// fire observers
>, <Line: +						var $$observers = this.$$observers;
>, <Line: +						$$observers && forEach($$observers[observer], function (fn) {
>, <Line: +							try {
>, <Line: +								fn(value);
>, <Line: +							} catch (e) {
>, <Line: +								$exceptionHandler(e);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $compile.directive.Attributes#$observe
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Observes an interpolated attribute.
>, <Line: +					 *
>, <Line: +					 * The observer function will be invoked once during the next `$digest` following
>, <Line: +					 * compilation. The observer is then invoked whenever the interpolated value
>, <Line: +					 * changes.
>, <Line: +					 *
>, <Line: +					 * @param {string} key Normalized key. (ie ngAttribute) .
>, <Line: +					 * @param {function(interpolatedValue)} fn Function that will be called whenever
>, <Line: +					 the interpolated value of the attribute changes.
>, <Line: +					 *        See the {@link guide/directive#text-and-attribute-bindings Directives} guide for more info.
>, <Line: +					 * @returns {function()} Returns a deregistration function for this observer.
>, <Line: +					 */
>, <Line: +					$observe: function (key, fn) {
>, <Line: +						var attrs = this,
>, <Line: +							$$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
>, <Line: +							listeners = ($$observers[key] || ($$observers[key] = []));
>, <Line: +						listeners.push(fn);
>, <Line: +						$rootScope.$evalAsync(function () {
>, <Line: +							if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
>, <Line: +								// no one registered attribute interpolation function, so lets call it manually
>, <Line: +								fn(attrs[key]);
>, <Line: +							}
>, <Line: +						});
>, <Line: +						return function () {
>, <Line: +							arrayRemove(listeners, fn);
>, <Line: +						};
>, <Line: +					}
>, <Line: +				};
>, <Line: +				function safeAddClass($element, className) {
>, <Line: +					try {
>, <Line: +						$element.addClass(className);
>, <Line: +					} catch (e) {
>, <Line: +						// ignore, since it means that we are trying to set class on
>, <Line: +						// SVG element, where class name is read-only.
>, <Line: +					}
>, <Line: +				}
>, <Line: +				var startSymbol = $interpolate.startSymbol(),
>, <Line: +					endSymbol = $interpolate.endSymbol(),
>, <Line: +					denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}')
>, <Line: +						? identity
>, <Line: +						: function denormalizeTemplate(template) {
>, <Line: +						return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
>, <Line: +					},
>, <Line: +					NG_ATTR_BINDING = /^ngAttr[A-Z]/;
>, <Line: +				compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
>, <Line: +					var bindings = $element.data('$binding') || [];
>, <Line: +					if (isArray(binding)) {
>, <Line: +						bindings = bindings.concat(binding);
>, <Line: +					} else {
>, <Line: +						bindings.push(binding);
>, <Line: +					}
>, <Line: +					$element.data('$binding', bindings);
>, <Line: +				} : noop;
>, <Line: +				compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
>, <Line: +					safeAddClass($element, 'ng-binding');
>, <Line: +				} : noop;
>, <Line: +				compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
>, <Line: +					var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
>, <Line: +					$element.data(dataName, scope);
>, <Line: +				} : noop;
>, <Line: +				compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
>, <Line: +					safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
>, <Line: +				} : noop;
>, <Line: +				return compile;
>, <Line: +				//================================
>, <Line: +				function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
>, <Line: +								 previousCompileContext) {
>, <Line: +					if (!($compileNodes instanceof jqLite)) {
>, <Line: +						// jquery always rewraps, whereas we need to preserve the original selector so that we can
>, <Line: +						// modify it.
>, <Line: +						$compileNodes = jqLite($compileNodes);
>, <Line: +					}
>, <Line: +					// We can not compile top level text elements since text nodes can be merged and we will
>, <Line: +					// not be able to attach scope data to them, so we will wrap them in <span>
>, <Line: +					forEach($compileNodes, function (node, index) {
>, <Line: +						if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) /* non-empty */) {
>, <Line: +							$compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
>, <Line: +						}
>, <Line: +					});
>, <Line: +					var compositeLinkFn =
>, <Line: +						compileNodes($compileNodes, transcludeFn, $compileNodes,
>, <Line: +							maxPriority, ignoreDirective, previousCompileContext);
>, <Line: +					compile.$$addScopeClass($compileNodes);
>, <Line: +					var namespace = null;
>, <Line: +					return function publicLinkFn(scope, cloneConnectFn, options) {
>, <Line: +						assertArg(scope, 'scope');
>, <Line: +						options = options || {};
>, <Line: +						var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
>, <Line: +							transcludeControllers = options.transcludeControllers,
>, <Line: +							futureParentElement = options.futureParentElement;
>, <Line: +						// When `parentBoundTranscludeFn` is passed, it is a
>, <Line: +						// `controllersBoundTransclude` function (it was previously passed
>, <Line: +						// as `transclude` to directive.link) so we must unwrap it to get
>, <Line: +						// its `boundTranscludeFn`
>, <Line: +						if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
>, <Line: +							parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
>, <Line: +						}
>, <Line: +						if (!namespace) {
>, <Line: +							namespace = detectNamespaceForChildElements(futureParentElement);
>, <Line: +						}
>, <Line: +						var $linkNode;
>, <Line: +						if (namespace !== 'html') {
>, <Line: +							// When using a directive with replace:true and templateUrl the $compileNodes
>, <Line: +							// (or a child element inside of them)
>, <Line: +							// might change, so we need to recreate the namespace adapted compileNodes
>, <Line: +							// for call to the link function.
>, <Line: +							// Note: This will already clone the nodes...
>, <Line: +							$linkNode = jqLite(
>, <Line: +								wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html())
>, <Line: +							);
>, <Line: +						} else if (cloneConnectFn) {
>, <Line: +							// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
>, <Line: +							// and sometimes changes the structure of the DOM.
>, <Line: +							$linkNode = JQLitePrototype.clone.call($compileNodes);
>, <Line: +						} else {
>, <Line: +							$linkNode = $compileNodes;
>, <Line: +						}
>, <Line: +						if (transcludeControllers) {
>, <Line: +							for (var controllerName in transcludeControllers) {
>, <Line: +								$linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						compile.$$addScopeInfo($linkNode, scope);
>, <Line: +						if (cloneConnectFn) cloneConnectFn($linkNode, scope);
>, <Line: +						if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
>, <Line: +						return $linkNode;
>, <Line: +					};
>, <Line: +				}
>, <Line: +				function detectNamespaceForChildElements(parentElement) {
>, <Line: +					// TODO: Make this detect MathML as well...
>, <Line: +					var node = parentElement && parentElement[0];
>, <Line: +					if (!node) {
>, <Line: +						return 'html';
>, <Line: +					} else {
>, <Line: +						return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
>, <Line: +					}
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Compile function matches each node in nodeList against the directives. Once all directives
>, <Line: +				 * for a particular node are collected their compile functions are executed. The compile
>, <Line: +				 * functions return values - the linking functions - are combined into a composite linking
>, <Line: +				 * function, which is the a linking function for the node.
>, <Line: +				 *
>, <Line: +				 * @param {NodeList} nodeList an array of nodes or NodeList to compile
>, <Line: +				 * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
>, <Line: +				 *        scope argument is auto-generated to the new child of the transcluded parent scope.
>, <Line: +				 * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then
>, <Line: +				 *        the rootElement must be set the jqLite collection of the compile root. This is
>, <Line: +				 *        needed so that the jqLite collection items can be replaced with widgets.
>, <Line: +				 * @param {number=} maxPriority Max directive priority.
>, <Line: +				 * @returns {Function} A composite linking function of all of the matched directives or null.
>, <Line: +				 */
>, <Line: +				function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
>, <Line: +									  previousCompileContext) {
>, <Line: +					var linkFns = [],
>, <Line: +						attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
>, <Line: +					for (var i = 0; i < nodeList.length; i++) {
>, <Line: +						attrs = new Attributes();
>, <Line: +						// we must always refer to nodeList[i] since the nodes can be replaced underneath us.
>, <Line: +						directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
>, <Line: +							ignoreDirective);
>, <Line: +						nodeLinkFn = (directives.length)
>, <Line: +							? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
>, <Line: +							null, [], [], previousCompileContext)
>, <Line: +							: null;
>, <Line: +						if (nodeLinkFn && nodeLinkFn.scope) {
>, <Line: +							compile.$$addScopeClass(attrs.$$element);
>, <Line: +						}
>, <Line: +						childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length)
>, <Line: +							? null
>, <Line: +							: compileNodes(childNodes,
>, <Line: +							nodeLinkFn ? (
>, <Line: +							(nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
>, <Line: +							&& nodeLinkFn.transclude) : transcludeFn);
>, <Line: +						if (nodeLinkFn || childLinkFn) {
>, <Line: +							linkFns.push(i, nodeLinkFn, childLinkFn);
>, <Line: +							linkFnFound = true;
>, <Line: +							nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
>, <Line: +						}
>, <Line: +						//use the previous context only for the first element in the virtual group
>, <Line: +						previousCompileContext = null;
>, <Line: +					}
>, <Line: +					// return a linking function if we have found anything, null otherwise
>, <Line: +					return linkFnFound ? compositeLinkFn : null;
>, <Line: +					function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
>, <Line: +						var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
>, <Line: +						var stableNodeList;
>, <Line: +						if (nodeLinkFnFound) {
>, <Line: +							// copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our
>, <Line: +							// offsets don't get screwed up
>, <Line: +							var nodeListLength = nodeList.length;
>, <Line: +							stableNodeList = new Array(nodeListLength);
>, <Line: +							// create a sparse array by only copying the elements which have a linkFn
>, <Line: +							for (i = 0; i < linkFns.length; i += 3) {
>, <Line: +								idx = linkFns[i];
>, <Line: +								stableNodeList[idx] = nodeList[idx];
>, <Line: +							}
>, <Line: +						} else {
>, <Line: +							stableNodeList = nodeList;
>, <Line: +						}
>, <Line: +						for (i = 0, ii = linkFns.length; i < ii;) {
>, <Line: +							node = stableNodeList[linkFns[i++]];
>, <Line: +							nodeLinkFn = linkFns[i++];
>, <Line: +							childLinkFn = linkFns[i++];
>, <Line: +							if (nodeLinkFn) {
>, <Line: +								if (nodeLinkFn.scope) {
>, <Line: +									childScope = scope.$new();
>, <Line: +									compile.$$addScopeInfo(jqLite(node), childScope);
>, <Line: +								} else {
>, <Line: +									childScope = scope;
>, <Line: +								}
>, <Line: +								if (nodeLinkFn.transcludeOnThisElement) {
>, <Line: +									childBoundTranscludeFn = createBoundTranscludeFn(
>, <Line: +										scope, nodeLinkFn.transclude, parentBoundTranscludeFn,
>, <Line: +										nodeLinkFn.elementTranscludeOnThisElement);
>, <Line: +								} else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
>, <Line: +									childBoundTranscludeFn = parentBoundTranscludeFn;
>, <Line: +								} else if (!parentBoundTranscludeFn && transcludeFn) {
>, <Line: +									childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
>, <Line: +								} else {
>, <Line: +									childBoundTranscludeFn = null;
>, <Line: +								}
>, <Line: +								nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
>, <Line: +							} else if (childLinkFn) {
>, <Line: +								childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
>, <Line: +					var boundTranscludeFn = function (transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
>, <Line: +						if (!transcludedScope) {
>, <Line: +							transcludedScope = scope.$new(false, containingScope);
>, <Line: +							transcludedScope.$$transcluded = true;
>, <Line: +						}
>, <Line: +						return transcludeFn(transcludedScope, cloneFn, {
>, <Line: +							parentBoundTranscludeFn: previousBoundTranscludeFn,
>, <Line: +							transcludeControllers: controllers,
>, <Line: +							futureParentElement: futureParentElement
>, <Line: +						});
>, <Line: +					};
>, <Line: +					return boundTranscludeFn;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Looks for directives on the given node and adds them to the directive collection which is
>, <Line: +				 * sorted.
>, <Line: +				 *
>, <Line: +				 * @param node Node to search.
>, <Line: +				 * @param directives An array to which the directives are added to. This array is sorted before
>, <Line: +				 *        the function returns.
>, <Line: +				 * @param attrs The shared attrs object which is used to populate the normalized attributes.
>, <Line: +				 * @param {number=} maxPriority Max directive priority.
>, <Line: +				 */
>, <Line: +				function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
>, <Line: +					var nodeType = node.nodeType,
>, <Line: +						attrsMap = attrs.$attr,
>, <Line: +						match,
>, <Line: +						className;
>, <Line: +					switch (nodeType) {
>, <Line: +						case NODE_TYPE_ELEMENT: /* Element */
>, <Line: +							// use the node name: <directive>
>, <Line: +							addDirective(directives,
>, <Line: +								directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
>, <Line: +							// iterate over the attributes
>, <Line: +							for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
>, <Line: +									 j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
>, <Line: +								var attrStartName = false;
>, <Line: +								var attrEndName = false;
>, <Line: +								attr = nAttrs[j];
>, <Line: +								name = attr.name;
>, <Line: +								value = trim(attr.value);
>, <Line: +								// support ngAttr attribute binding
>, <Line: +								ngAttrName = directiveNormalize(name);
>, <Line: +								if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
>, <Line: +									name = snake_case(ngAttrName.substr(6), '-');
>, <Line: +								}
>, <Line: +								var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
>, <Line: +								if (directiveIsMultiElement(directiveNName)) {
>, <Line: +									if (ngAttrName === directiveNName + 'Start') {
>, <Line: +										attrStartName = name;
>, <Line: +										attrEndName = name.substr(0, name.length - 5) + 'end';
>, <Line: +										name = name.substr(0, name.length - 6);
>, <Line: +									}
>, <Line: +								}
>, <Line: +								nName = directiveNormalize(name.toLowerCase());
>, <Line: +								attrsMap[nName] = name;
>, <Line: +								if (isNgAttr || !attrs.hasOwnProperty(nName)) {
>, <Line: +									attrs[nName] = value;
>, <Line: +									if (getBooleanAttrName(node, nName)) {
>, <Line: +										attrs[nName] = true; // presence means true
>, <Line: +									}
>, <Line: +								}
>, <Line: +								addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
>, <Line: +								addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
>, <Line: +									attrEndName);
>, <Line: +							}
>, <Line: +							// use class as directive
>, <Line: +							className = node.className;
>, <Line: +							if (isString(className) && className !== '') {
>, <Line: +								while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
>, <Line: +									nName = directiveNormalize(match[2]);
>, <Line: +									if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
>, <Line: +										attrs[nName] = trim(match[3]);
>, <Line: +									}
>, <Line: +									className = className.substr(match.index + match[0].length);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							break;
>, <Line: +						case NODE_TYPE_TEXT: /* Text Node */
>, <Line: +							addTextInterpolateDirective(directives, node.nodeValue);
>, <Line: +							break;
>, <Line: +						case NODE_TYPE_COMMENT: /* Comment */
>, <Line: +							try {
>, <Line: +								match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
>, <Line: +								if (match) {
>, <Line: +									nName = directiveNormalize(match[1]);
>, <Line: +									if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
>, <Line: +										attrs[nName] = trim(match[2]);
>, <Line: +									}
>, <Line: +								}
>, <Line: +							} catch (e) {
>, <Line: +								// turns out that under some circumstances IE9 throws errors when one attempts to read
>, <Line: +								// comment's node value.
>, <Line: +								// Just ignore it and continue. (Can't seem to reproduce in test case.)
>, <Line: +							}
>, <Line: +							break;
>, <Line: +					}
>, <Line: +					directives.sort(byPriority);
>, <Line: +					return directives;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Given a node with an directive-start it collects all of the siblings until it finds
>, <Line: +				 * directive-end.
>, <Line: +				 * @param node
>, <Line: +				 * @param attrStart
>, <Line: +				 * @param attrEnd
>, <Line: +				 * @returns {*}
>, <Line: +				 */
>, <Line: +				function groupScan(node, attrStart, attrEnd) {
>, <Line: +					var nodes = [];
>, <Line: +					var depth = 0;
>, <Line: +					if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
>, <Line: +						do {
>, <Line: +							if (!node) {
>, <Line: +								throw $compileMinErr('uterdir',
>, <Line: +									"Unterminated attribute, found '{0}' but no matching '{1}' found.",
>, <Line: +									attrStart, attrEnd);
>, <Line: +							}
>, <Line: +							if (node.nodeType == NODE_TYPE_ELEMENT) {
>, <Line: +								if (node.hasAttribute(attrStart)) depth++;
>, <Line: +								if (node.hasAttribute(attrEnd)) depth--;
>, <Line: +							}
>, <Line: +							nodes.push(node);
>, <Line: +							node = node.nextSibling;
>, <Line: +						} while (depth > 0);
>, <Line: +					} else {
>, <Line: +						nodes.push(node);
>, <Line: +					}
>, <Line: +					return jqLite(nodes);
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Wrapper for linking function which converts normal linking function into a grouped
>, <Line: +				 * linking function.
>, <Line: +				 * @param linkFn
>, <Line: +				 * @param attrStart
>, <Line: +				 * @param attrEnd
>, <Line: +				 * @returns {Function}
>, <Line: +				 */
>, <Line: +				function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
>, <Line: +					return function (scope, element, attrs, controllers, transcludeFn) {
>, <Line: +						element = groupScan(element[0], attrStart, attrEnd);
>, <Line: +						return linkFn(scope, element, attrs, controllers, transcludeFn);
>, <Line: +					};
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Once the directives have been collected, their compile functions are executed. This method
>, <Line: +				 * is responsible for inlining directive templates as well as terminating the application
>, <Line: +				 * of the directives if the terminal directive has been reached.
>, <Line: +				 *
>, <Line: +				 * @param {Array} directives Array of collected directives to execute their compile function.
>, <Line: +				 *        this needs to be pre-sorted by priority order.
>, <Line: +				 * @param {Node} compileNode The raw DOM node to apply the compile functions to
>, <Line: +				 * @param {Object} templateAttrs The shared attribute function
>, <Line: +				 * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
>, <Line: +				 *                                                  scope argument is auto-generated to the new
>, <Line: +				 *                                                  child of the transcluded parent scope.
>, <Line: +				 * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
>, <Line: +				 *                              argument has the root jqLite array so that we can replace nodes
>, <Line: +				 *                              on it.
>, <Line: +				 * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
>, <Line: +				 *                                           compiling the transclusion.
>, <Line: +				 * @param {Array.<Function>} preLinkFns
>, <Line: +				 * @param {Array.<Function>} postLinkFns
>, <Line: +				 * @param {Object} previousCompileContext Context used for previous compilation of the current
>, <Line: +				 *                                        node
>, <Line: +				 * @returns {Function} linkFn
>, <Line: +				 */
>, <Line: +				function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
>, <Line: +											   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
>, <Line: +											   previousCompileContext) {
>, <Line: +					previousCompileContext = previousCompileContext || {};
>, <Line: +					var terminalPriority = -Number.MAX_VALUE,
>, <Line: +						newScopeDirective,
>, <Line: +						controllerDirectives = previousCompileContext.controllerDirectives,
>, <Line: +						controllers,
>, <Line: +						newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
>, <Line: +						templateDirective = previousCompileContext.templateDirective,
>, <Line: +						nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
>, <Line: +						hasTranscludeDirective = false,
>, <Line: +						hasTemplate = false,
>, <Line: +						hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
>, <Line: +						$compileNode = templateAttrs.$$element = jqLite(compileNode),
>, <Line: +						directive,
>, <Line: +						directiveName,
>, <Line: +						$template,
>, <Line: +						replaceDirective = originalReplaceDirective,
>, <Line: +						childTranscludeFn = transcludeFn,
>, <Line: +						linkFn,
>, <Line: +						directiveValue;
>, <Line: +					// executes all directives on the current element
>, <Line: +					for (var i = 0, ii = directives.length; i < ii; i++) {
>, <Line: +						directive = directives[i];
>, <Line: +						var attrStart = directive.$$start;
>, <Line: +						var attrEnd = directive.$$end;
>, <Line: +						// collect multiblock sections
>, <Line: +						if (attrStart) {
>, <Line: +							$compileNode = groupScan(compileNode, attrStart, attrEnd);
>, <Line: +						}
>, <Line: +						$template = undefined;
>, <Line: +						if (terminalPriority > directive.priority) {
>, <Line: +							break; // prevent further processing of directives
>, <Line: +						}
>, <Line: +						if (directiveValue = directive.scope) {
>, <Line: +							// skip the check for directives with async templates, we'll check the derived sync
>, <Line: +							// directive when the template arrives
>, <Line: +							if (!directive.templateUrl) {
>, <Line: +								if (isObject(directiveValue)) {
>, <Line: +									// This directive is trying to add an isolated scope.
>, <Line: +									// Check that there is no scope of any kind already
>, <Line: +									assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
>, <Line: +										directive, $compileNode);
>, <Line: +									newIsolateScopeDirective = directive;
>, <Line: +								} else {
>, <Line: +									// This directive is trying to add a child scope.
>, <Line: +									// Check that there is no isolated scope already
>, <Line: +									assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
>, <Line: +										$compileNode);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							newScopeDirective = newScopeDirective || directive;
>, <Line: +						}
>, <Line: +						directiveName = directive.name;
>, <Line: +						if (!directive.templateUrl && directive.controller) {
>, <Line: +							directiveValue = directive.controller;
>, <Line: +							controllerDirectives = controllerDirectives || {};
>, <Line: +							assertNoDuplicate("'" + directiveName + "' controller",
>, <Line: +								controllerDirectives[directiveName], directive, $compileNode);
>, <Line: +							controllerDirectives[directiveName] = directive;
>, <Line: +						}
>, <Line: +						if (directiveValue = directive.transclude) {
>, <Line: +							hasTranscludeDirective = true;
>, <Line: +							// Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
>, <Line: +							// This option should only be used by directives that know how to safely handle element transclusion,
>, <Line: +							// where the transcluded nodes are added or replaced after linking.
>, <Line: +							if (!directive.$$tlb) {
>, <Line: +								assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
>, <Line: +								nonTlbTranscludeDirective = directive;
>, <Line: +							}
>, <Line: +							if (directiveValue == 'element') {
>, <Line: +								hasElementTranscludeDirective = true;
>, <Line: +								terminalPriority = directive.priority;
>, <Line: +								$template = $compileNode;
>, <Line: +								$compileNode = templateAttrs.$$element =
>, <Line: +									jqLite(document.createComment(' ' + directiveName + ': ' +
>, <Line: +										templateAttrs[directiveName] + ' '));
>, <Line: +								compileNode = $compileNode[0];
>, <Line: +								replaceWith(jqCollection, sliceArgs($template), compileNode);
>, <Line: +								childTranscludeFn = compile($template, transcludeFn, terminalPriority,
>, <Line: +									replaceDirective && replaceDirective.name, {
>, <Line: +										// Don't pass in:
>, <Line: +										// - controllerDirectives - otherwise we'll create duplicates controllers
>, <Line: +										// - newIsolateScopeDirective or templateDirective - combining templates with
>, <Line: +										//   element transclusion doesn't make sense.
>, <Line: +										//
>, <Line: +										// We need only nonTlbTranscludeDirective so that we prevent putting transclusion
>, <Line: +										// on the same element more than once.
>, <Line: +										nonTlbTranscludeDirective: nonTlbTranscludeDirective
>, <Line: +									});
>, <Line: +							} else {
>, <Line: +								$template = jqLite(jqLiteClone(compileNode)).contents();
>, <Line: +								$compileNode.empty(); // clear contents
>, <Line: +								childTranscludeFn = compile($template, transcludeFn);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (directive.template) {
>, <Line: +							hasTemplate = true;
>, <Line: +							assertNoDuplicate('template', templateDirective, directive, $compileNode);
>, <Line: +							templateDirective = directive;
>, <Line: +							directiveValue = (isFunction(directive.template))
>, <Line: +								? directive.template($compileNode, templateAttrs)
>, <Line: +								: directive.template;
>, <Line: +							directiveValue = denormalizeTemplate(directiveValue);
>, <Line: +							if (directive.replace) {
>, <Line: +								replaceDirective = directive;
>, <Line: +								if (jqLiteIsTextNode(directiveValue)) {
>, <Line: +									$template = [];
>, <Line: +								} else {
>, <Line: +									$template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
>, <Line: +								}
>, <Line: +								compileNode = $template[0];
>, <Line: +								if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
>, <Line: +									throw $compileMinErr('tplrt',
>, <Line: +										"Template for directive '{0}' must have exactly one root element. {1}",
>, <Line: +										directiveName, '');
>, <Line: +								}
>, <Line: +								replaceWith(jqCollection, $compileNode, compileNode);
>, <Line: +								var newTemplateAttrs = {$attr: {}};
>, <Line: +								// combine directives from the original node and from the template:
>, <Line: +								// - take the array of directives for this element
>, <Line: +								// - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
>, <Line: +								// - collect directives from the template and sort them by priority
>, <Line: +								// - combine directives as: processed + template + unprocessed
>, <Line: +								var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
>, <Line: +								var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
>, <Line: +								if (newIsolateScopeDirective) {
>, <Line: +									markDirectivesAsIsolate(templateDirectives);
>, <Line: +								}
>, <Line: +								directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
>, <Line: +								mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
>, <Line: +								ii = directives.length;
>, <Line: +							} else {
>, <Line: +								$compileNode.html(directiveValue);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (directive.templateUrl) {
>, <Line: +							hasTemplate = true;
>, <Line: +							assertNoDuplicate('template', templateDirective, directive, $compileNode);
>, <Line: +							templateDirective = directive;
>, <Line: +							if (directive.replace) {
>, <Line: +								replaceDirective = directive;
>, <Line: +							}
>, <Line: +							nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
>, <Line: +								templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
>, <Line: +									controllerDirectives: controllerDirectives,
>, <Line: +									newIsolateScopeDirective: newIsolateScopeDirective,
>, <Line: +									templateDirective: templateDirective,
>, <Line: +									nonTlbTranscludeDirective: nonTlbTranscludeDirective
>, <Line: +								});
>, <Line: +							ii = directives.length;
>, <Line: +						} else if (directive.compile) {
>, <Line: +							try {
>, <Line: +								linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
>, <Line: +								if (isFunction(linkFn)) {
>, <Line: +									addLinkFns(null, linkFn, attrStart, attrEnd);
>, <Line: +								} else if (linkFn) {
>, <Line: +									addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
>, <Line: +								}
>, <Line: +							} catch (e) {
>, <Line: +								$exceptionHandler(e, startingTag($compileNode));
>, <Line: +							}
>, <Line: +						}
>, <Line: +						if (directive.terminal) {
>, <Line: +							nodeLinkFn.terminal = true;
>, <Line: +							terminalPriority = Math.max(terminalPriority, directive.priority);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
>, <Line: +					nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
>, <Line: +					nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
>, <Line: +					nodeLinkFn.templateOnThisElement = hasTemplate;
>, <Line: +					nodeLinkFn.transclude = childTranscludeFn;
>, <Line: +					previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
>, <Line: +					// might be normal or delayed nodeLinkFn depending on if templateUrl is present
>, <Line: +					return nodeLinkFn;
>, <Line: +					////////////////////
>, <Line: +					function addLinkFns(pre, post, attrStart, attrEnd) {
>, <Line: +						if (pre) {
>, <Line: +							if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
>, <Line: +							pre.require = directive.require;
>, <Line: +							pre.directiveName = directiveName;
>, <Line: +							if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
>, <Line: +								pre = cloneAndAnnotateFn(pre, {isolateScope: true});
>, <Line: +							}
>, <Line: +							preLinkFns.push(pre);
>, <Line: +						}
>, <Line: +						if (post) {
>, <Line: +							if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
>, <Line: +							post.require = directive.require;
>, <Line: +							post.directiveName = directiveName;
>, <Line: +							if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
>, <Line: +								post = cloneAndAnnotateFn(post, {isolateScope: true});
>, <Line: +							}
>, <Line: +							postLinkFns.push(post);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function getControllers(directiveName, require, $element, elementControllers) {
>, <Line: +						var value, retrievalMethod = 'data', optional = false;
>, <Line: +						var $searchElement = $element;
>, <Line: +						var match;
>, <Line: +						if (isString(require)) {
>, <Line: +							match = require.match(REQUIRE_PREFIX_REGEXP);
>, <Line: +							require = require.substring(match[0].length);
>, <Line: +							if (match[3]) {
>, <Line: +								if (match[1]) match[3] = null;
>, <Line: +								else match[1] = match[3];
>, <Line: +							}
>, <Line: +							if (match[1] === '^') {
>, <Line: +								retrievalMethod = 'inheritedData';
>, <Line: +							} else if (match[1] === '^^') {
>, <Line: +								retrievalMethod = 'inheritedData';
>, <Line: +								$searchElement = $element.parent();
>, <Line: +							}
>, <Line: +							if (match[2] === '?') {
>, <Line: +								optional = true;
>, <Line: +							}
>, <Line: +							value = null;
>, <Line: +							if (elementControllers && retrievalMethod === 'data') {
>, <Line: +								if (value = elementControllers[require]) {
>, <Line: +									value = value.instance;
>, <Line: +								}
>, <Line: +							}
>, <Line: +							value = value || $searchElement[retrievalMethod]('$' + require + 'Controller');
>, <Line: +							if (!value && !optional) {
>, <Line: +								throw $compileMinErr('ctreq',
>, <Line: +									"Controller '{0}', required by directive '{1}', can't be found!",
>, <Line: +									require, directiveName);
>, <Line: +							}
>, <Line: +							return value || null;
>, <Line: +						} else if (isArray(require)) {
>, <Line: +							value = [];
>, <Line: +							forEach(require, function (require) {
>, <Line: +								value.push(getControllers(directiveName, require, $element, elementControllers));
>, <Line: +							});
>, <Line: +						}
>, <Line: +						return value;
>, <Line: +					}
>, <Line: +					function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
>, <Line: +						var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,
>, <Line: +							attrs;
>, <Line: +						if (compileNode === linkNode) {
>, <Line: +							attrs = templateAttrs;
>, <Line: +							$element = templateAttrs.$$element;
>, <Line: +						} else {
>, <Line: +							$element = jqLite(linkNode);
>, <Line: +							attrs = new Attributes($element, templateAttrs);
>, <Line: +						}
>, <Line: +						if (newIsolateScopeDirective) {
>, <Line: +							isolateScope = scope.$new(true);
>, <Line: +						}
>, <Line: +						if (boundTranscludeFn) {
>, <Line: +							// track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`
>, <Line: +							// is later passed as `parentBoundTranscludeFn` to `publicLinkFn`
>, <Line: +							transcludeFn = controllersBoundTransclude;
>, <Line: +							transcludeFn.$$boundTransclude = boundTranscludeFn;
>, <Line: +						}
>, <Line: +						if (controllerDirectives) {
>, <Line: +							// TODO: merge `controllers` and `elementControllers` into single object.
>, <Line: +							controllers = {};
>, <Line: +							elementControllers = {};
>, <Line: +							forEach(controllerDirectives, function (directive) {
>, <Line: +								var locals = {
>, <Line: +									$scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
>, <Line: +									$element: $element,
>, <Line: +									$attrs: attrs,
>, <Line: +									$transclude: transcludeFn
>, <Line: +								}, controllerInstance;
>, <Line: +								controller = directive.controller;
>, <Line: +								if (controller == '@') {
>, <Line: +									controller = attrs[directive.name];
>, <Line: +								}
>, <Line: +								controllerInstance = $controller(controller, locals, true, directive.controllerAs);
>, <Line: +								// For directives with element transclusion the element is a comment,
>, <Line: +								// but jQuery .data doesn't support attaching data to comment nodes as it's hard to
>, <Line: +								// clean up (http://bugs.jquery.com/ticket/8335).
>, <Line: +								// Instead, we save the controllers for the element in a local hash and attach to .data
>, <Line: +								// later, once we have the actual element.
>, <Line: +								elementControllers[directive.name] = controllerInstance;
>, <Line: +								if (!hasElementTranscludeDirective) {
>, <Line: +									$element.data('$' + directive.name + 'Controller', controllerInstance.instance);
>, <Line: +								}
>, <Line: +								controllers[directive.name] = controllerInstance;
>, <Line: +							});
>, <Line: +						}
>, <Line: +						if (newIsolateScopeDirective) {
>, <Line: +							compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective ||
>, <Line: +							templateDirective === newIsolateScopeDirective.$$originalDirective)));
>, <Line: +							compile.$$addScopeClass($element, true);
>, <Line: +							var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name];
>, <Line: +							var isolateBindingContext = isolateScope;
>, <Line: +							if (isolateScopeController && isolateScopeController.identifier &&
>, <Line: +								newIsolateScopeDirective.bindToController === true) {
>, <Line: +								isolateBindingContext = isolateScopeController.instance;
>, <Line: +							}
>, <Line: +							forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function (definition, scopeName) {
>, <Line: +								var attrName = definition.attrName,
>, <Line: +									optional = definition.optional,
>, <Line: +									mode = definition.mode, // @, =, or &
>, <Line: +									lastValue,
>, <Line: +									parentGet, parentSet, compare;
>, <Line: +								switch (mode) {
>, <Line: +									case '@':
>, <Line: +										attrs.$observe(attrName, function (value) {
>, <Line: +											isolateBindingContext[scopeName] = value;
>, <Line: +										});
>, <Line: +										attrs.$$observers[attrName].$$scope = scope;
>, <Line: +										if (attrs[attrName]) {
>, <Line: +											// If the attribute has been provided then we trigger an interpolation to ensure
>, <Line: +											// the value is there for use in the link fn
>, <Line: +											isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope);
>, <Line: +										}
>, <Line: +										break;
>, <Line: +									case '=':
>, <Line: +										if (optional && !attrs[attrName]) {
>, <Line: +											return;
>, <Line: +										}
>, <Line: +										parentGet = $parse(attrs[attrName]);
>, <Line: +										if (parentGet.literal) {
>, <Line: +											compare = equals;
>, <Line: +										} else {
>, <Line: +											compare = function (a, b) {
>, <Line: +												return a === b || (a !== a && b !== b);
>, <Line: +											};
>, <Line: +										}
>, <Line: +										parentSet = parentGet.assign || function () {
>, <Line: +												// reset the change, or we will throw this exception on every $digest
>, <Line: +												lastValue = isolateBindingContext[scopeName] = parentGet(scope);
>, <Line: +												throw $compileMinErr('nonassign',
>, <Line: +													"Expression '{0}' used with directive '{1}' is non-assignable!",
>, <Line: +													attrs[attrName], newIsolateScopeDirective.name);
>, <Line: +											};
>, <Line: +										lastValue = isolateBindingContext[scopeName] = parentGet(scope);
>, <Line: +										var parentValueWatch = function parentValueWatch(parentValue) {
>, <Line: +											if (!compare(parentValue, isolateBindingContext[scopeName])) {
>, <Line: +												// we are out of sync and need to copy
>, <Line: +												if (!compare(parentValue, lastValue)) {
>, <Line: +													// parent changed and it has precedence
>, <Line: +													isolateBindingContext[scopeName] = parentValue;
>, <Line: +												} else {
>, <Line: +													// if the parent can be assigned then do so
>, <Line: +													parentSet(scope, parentValue = isolateBindingContext[scopeName]);
>, <Line: +												}
>, <Line: +											}
>, <Line: +											return lastValue = parentValue;
>, <Line: +										};
>, <Line: +										parentValueWatch.$stateful = true;
>, <Line: +										var unwatch;
>, <Line: +										if (definition.collection) {
>, <Line: +											unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
>, <Line: +										} else {
>, <Line: +											unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
>, <Line: +										}
>, <Line: +										isolateScope.$on('$destroy', unwatch);
>, <Line: +										break;
>, <Line: +									case '&':
>, <Line: +										parentGet = $parse(attrs[attrName]);
>, <Line: +										isolateBindingContext[scopeName] = function (locals) {
>, <Line: +											return parentGet(scope, locals);
>, <Line: +										};
>, <Line: +										break;
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +						if (controllers) {
>, <Line: +							forEach(controllers, function (controller) {
>, <Line: +								controller();
>, <Line: +							});
>, <Line: +							controllers = null;
>, <Line: +						}
>, <Line: +						// PRELINKING
>, <Line: +						for (i = 0, ii = preLinkFns.length; i < ii; i++) {
>, <Line: +							linkFn = preLinkFns[i];
>, <Line: +							invokeLinkFn(linkFn,
>, <Line: +								linkFn.isolateScope ? isolateScope : scope,
>, <Line: +								$element,
>, <Line: +								attrs,
>, <Line: +								linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
>, <Line: +								transcludeFn
>, <Line: +							);
>, <Line: +						}
>, <Line: +						// RECURSION
>, <Line: +						// We only pass the isolate scope, if the isolate directive has a template,
>, <Line: +						// otherwise the child elements do not belong to the isolate directive.
>, <Line: +						var scopeToChild = scope;
>, <Line: +						if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
>, <Line: +							scopeToChild = isolateScope;
>, <Line: +						}
>, <Line: +						childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
>, <Line: +						// POSTLINKING
>, <Line: +						for (i = postLinkFns.length - 1; i >= 0; i--) {
>, <Line: +							linkFn = postLinkFns[i];
>, <Line: +							invokeLinkFn(linkFn,
>, <Line: +								linkFn.isolateScope ? isolateScope : scope,
>, <Line: +								$element,
>, <Line: +								attrs,
>, <Line: +								linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
>, <Line: +								transcludeFn
>, <Line: +							);
>, <Line: +						}
>, <Line: +						// This is the function that is injected as `$transclude`.
>, <Line: +						// Note: all arguments are optional!
>, <Line: +						function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
>, <Line: +							var transcludeControllers;
>, <Line: +							// No scope passed in:
>, <Line: +							if (!isScope(scope)) {
>, <Line: +								futureParentElement = cloneAttachFn;
>, <Line: +								cloneAttachFn = scope;
>, <Line: +								scope = undefined;
>, <Line: +							}
>, <Line: +							if (hasElementTranscludeDirective) {
>, <Line: +								transcludeControllers = elementControllers;
>, <Line: +							}
>, <Line: +							if (!futureParentElement) {
>, <Line: +								futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
>, <Line: +							}
>, <Line: +							return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function markDirectivesAsIsolate(directives) {
>, <Line: +					// mark all directives as needing isolate scope.
>, <Line: +					for (var j = 0, jj = directives.length; j < jj; j++) {
>, <Line: +						directives[j] = inherit(directives[j], {$$isolateScope: true});
>, <Line: +					}
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * looks up the directive and decorates it with exception handling and proper parameters. We
>, <Line: +				 * call this the boundDirective.
>, <Line: +				 *
>, <Line: +				 * @param {string} name name of the directive to look up.
>, <Line: +				 * @param {string} location The directive must be found in specific format.
>, <Line: +				 *   String containing any of theses characters:
>, <Line: +				 *
>, <Line: +				 *   * `E`: element name
>, <Line: +				 *   * `A': attribute
>, <Line: +				 *   * `C`: class
>, <Line: +				 *   * `M`: comment
>, <Line: +				 * @returns {boolean} true if directive was added.
>, <Line: +				 */
>, <Line: +				function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
>, <Line: +									  endAttrName) {
>, <Line: +					if (name === ignoreDirective) return null;
>, <Line: +					var match = null;
>, <Line: +					if (hasDirectives.hasOwnProperty(name)) {
>, <Line: +						for (var directive, directives = $injector.get(name + Suffix),
>, <Line: +								 i = 0, ii = directives.length; i < ii; i++) {
>, <Line: +							try {
>, <Line: +								directive = directives[i];
>, <Line: +								if ((maxPriority === undefined || maxPriority > directive.priority) &&
>, <Line: +									directive.restrict.indexOf(location) != -1) {
>, <Line: +									if (startAttrName) {
>, <Line: +										directive = inherit(directive, {
>, <Line: +											$$start: startAttrName,
>, <Line: +											$$end: endAttrName
>, <Line: +										});
>, <Line: +									}
>, <Line: +									tDirectives.push(directive);
>, <Line: +									match = directive;
>, <Line: +								}
>, <Line: +							} catch (e) {
>, <Line: +								$exceptionHandler(e);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					return match;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * looks up the directive and returns true if it is a multi-element directive,
>, <Line: +				 * and therefore requires DOM nodes between -start and -end markers to be grouped
>, <Line: +				 * together.
>, <Line: +				 *
>, <Line: +				 * @param {string} name name of the directive to look up.
>, <Line: +				 * @returns true if directive was registered as multi-element.
>, <Line: +				 */
>, <Line: +				function directiveIsMultiElement(name) {
>, <Line: +					if (hasDirectives.hasOwnProperty(name)) {
>, <Line: +						for (var directive, directives = $injector.get(name + Suffix),
>, <Line: +								 i = 0, ii = directives.length; i < ii; i++) {
>, <Line: +							directive = directives[i];
>, <Line: +							if (directive.multiElement) {
>, <Line: +								return true;
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					return false;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * When the element is replaced with HTML template then the new attributes
>, <Line: +				 * on the template need to be merged with the existing attributes in the DOM.
>, <Line: +				 * The desired effect is to have both of the attributes present.
>, <Line: +				 *
>, <Line: +				 * @param {object} dst destination attributes (original DOM)
>, <Line: +				 * @param {object} src source attributes (from the directive template)
>, <Line: +				 */
>, <Line: +				function mergeTemplateAttributes(dst, src) {
>, <Line: +					var srcAttr = src.$attr,
>, <Line: +						dstAttr = dst.$attr,
>, <Line: +						$element = dst.$$element;
>, <Line: +					// reapply the old attributes to the new element
>, <Line: +					forEach(dst, function (value, key) {
>, <Line: +						if (key.charAt(0) != '$') {
>, <Line: +							if (src[key] && src[key] !== value) {
>, <Line: +								value += (key === 'style' ? ';' : ' ') + src[key];
>, <Line: +							}
>, <Line: +							dst.$set(key, value, true, srcAttr[key]);
>, <Line: +						}
>, <Line: +					});
>, <Line: +					// copy the new attributes on the old attrs object
>, <Line: +					forEach(src, function (value, key) {
>, <Line: +						if (key == 'class') {
>, <Line: +							safeAddClass($element, value);
>, <Line: +							dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
>, <Line: +						} else if (key == 'style') {
>, <Line: +							$element.attr('style', $element.attr('style') + ';' + value);
>, <Line: +							dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
>, <Line: +							// `dst` will never contain hasOwnProperty as DOM parser won't let it.
>, <Line: +							// You will get an "InvalidCharacterError: DOM Exception 5" error if you
>, <Line: +							// have an attribute like "has-own-property" or "data-has-own-property", etc.
>, <Line: +						} else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
>, <Line: +							dst[key] = value;
>, <Line: +							dstAttr[key] = srcAttr[key];
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +				function compileTemplateUrl(directives, $compileNode, tAttrs,
>, <Line: +											$rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
>, <Line: +					var linkQueue = [],
>, <Line: +						afterTemplateNodeLinkFn,
>, <Line: +						afterTemplateChildLinkFn,
>, <Line: +						beforeTemplateCompileNode = $compileNode[0],
>, <Line: +						origAsyncDirective = directives.shift(),
>, <Line: +					// The fact that we have to copy and patch the directive seems wrong!
>, <Line: +						derivedSyncDirective = extend({}, origAsyncDirective, {
>, <Line: +							templateUrl: null,
>, <Line: +							transclude: null,
>, <Line: +							replace: null,
>, <Line: +							$$originalDirective: origAsyncDirective
>, <Line: +						}),
>, <Line: +						templateUrl = (isFunction(origAsyncDirective.templateUrl))
>, <Line: +							? origAsyncDirective.templateUrl($compileNode, tAttrs)
>, <Line: +							: origAsyncDirective.templateUrl,
>, <Line: +						templateNamespace = origAsyncDirective.templateNamespace;
>, <Line: +					$compileNode.empty();
>, <Line: +					$templateRequest($sce.getTrustedResourceUrl(templateUrl))
>, <Line: +						.then(function (content) {
>, <Line: +							var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
>, <Line: +							content = denormalizeTemplate(content);
>, <Line: +							if (origAsyncDirective.replace) {
>, <Line: +								if (jqLiteIsTextNode(content)) {
>, <Line: +									$template = [];
>, <Line: +								} else {
>, <Line: +									$template = removeComments(wrapTemplate(templateNamespace, trim(content)));
>, <Line: +								}
>, <Line: +								compileNode = $template[0];
>, <Line: +								if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
>, <Line: +									throw $compileMinErr('tplrt',
>, <Line: +										"Template for directive '{0}' must have exactly one root element. {1}",
>, <Line: +										origAsyncDirective.name, templateUrl);
>, <Line: +								}
>, <Line: +								tempTemplateAttrs = {$attr: {}};
>, <Line: +								replaceWith($rootElement, $compileNode, compileNode);
>, <Line: +								var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
>, <Line: +								if (isObject(origAsyncDirective.scope)) {
>, <Line: +									markDirectivesAsIsolate(templateDirectives);
>, <Line: +								}
>, <Line: +								directives = templateDirectives.concat(directives);
>, <Line: +								mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
>, <Line: +							} else {
>, <Line: +								compileNode = beforeTemplateCompileNode;
>, <Line: +								$compileNode.html(content);
>, <Line: +							}
>, <Line: +							directives.unshift(derivedSyncDirective);
>, <Line: +							afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
>, <Line: +								childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
>, <Line: +								previousCompileContext);
>, <Line: +							forEach($rootElement, function (node, i) {
>, <Line: +								if (node == compileNode) {
>, <Line: +									$rootElement[i] = $compileNode[0];
>, <Line: +								}
>, <Line: +							});
>, <Line: +							afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
>, <Line: +							while (linkQueue.length) {
>, <Line: +								var scope = linkQueue.shift(),
>, <Line: +									beforeTemplateLinkNode = linkQueue.shift(),
>, <Line: +									linkRootElement = linkQueue.shift(),
>, <Line: +									boundTranscludeFn = linkQueue.shift(),
>, <Line: +									linkNode = $compileNode[0];
>, <Line: +								if (scope.$$destroyed) continue;
>, <Line: +								if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
>, <Line: +									var oldClasses = beforeTemplateLinkNode.className;
>, <Line: +									if (!(previousCompileContext.hasElementTranscludeDirective &&
>, <Line: +										origAsyncDirective.replace)) {
>, <Line: +										// it was cloned therefore we have to clone as well.
>, <Line: +										linkNode = jqLiteClone(compileNode);
>, <Line: +									}
>, <Line: +									replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
>, <Line: +									// Copy in CSS classes from original node
>, <Line: +									safeAddClass(jqLite(linkNode), oldClasses);
>, <Line: +								}
>, <Line: +								if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
>, <Line: +									childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
>, <Line: +								} else {
>, <Line: +									childBoundTranscludeFn = boundTranscludeFn;
>, <Line: +								}
>, <Line: +								afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
>, <Line: +									childBoundTranscludeFn);
>, <Line: +							}
>, <Line: +							linkQueue = null;
>, <Line: +						});
>, <Line: +					return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
>, <Line: +						var childBoundTranscludeFn = boundTranscludeFn;
>, <Line: +						if (scope.$$destroyed) return;
>, <Line: +						if (linkQueue) {
>, <Line: +							linkQueue.push(scope,
>, <Line: +								node,
>, <Line: +								rootElement,
>, <Line: +								childBoundTranscludeFn);
>, <Line: +						} else {
>, <Line: +							if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
>, <Line: +								childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
>, <Line: +							}
>, <Line: +							afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
>, <Line: +						}
>, <Line: +					};
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Sorting function for bound directives.
>, <Line: +				 */
>, <Line: +				function byPriority(a, b) {
>, <Line: +					var diff = b.priority - a.priority;
>, <Line: +					if (diff !== 0) return diff;
>, <Line: +					if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
>, <Line: +					return a.index - b.index;
>, <Line: +				}
>, <Line: +				function assertNoDuplicate(what, previousDirective, directive, element) {
>, <Line: +					if (previousDirective) {
>, <Line: +						throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',
>, <Line: +							previousDirective.name, directive.name, what, startingTag(element));
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function addTextInterpolateDirective(directives, text) {
>, <Line: +					var interpolateFn = $interpolate(text, true);
>, <Line: +					if (interpolateFn) {
>, <Line: +						directives.push({
>, <Line: +							priority: 0,
>, <Line: +							compile: function textInterpolateCompileFn(templateNode) {
>, <Line: +								var templateNodeParent = templateNode.parent(),
>, <Line: +									hasCompileParent = !!templateNodeParent.length;
>, <Line: +								// When transcluding a template that has bindings in the root
>, <Line: +								// we don't have a parent and thus need to add the class during linking fn.
>, <Line: +								if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
>, <Line: +								return function textInterpolateLinkFn(scope, node) {
>, <Line: +									var parent = node.parent();
>, <Line: +									if (!hasCompileParent) compile.$$addBindingClass(parent);
>, <Line: +									compile.$$addBindingInfo(parent, interpolateFn.expressions);
>, <Line: +									scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
>, <Line: +										node[0].nodeValue = value;
>, <Line: +									});
>, <Line: +								};
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function wrapTemplate(type, template) {
>, <Line: +					type = lowercase(type || 'html');
>, <Line: +					switch (type) {
>, <Line: +						case 'svg':
>, <Line: +						case 'math':
>, <Line: +							var wrapper = document.createElement('div');
>, <Line: +							wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
>, <Line: +							return wrapper.childNodes[0].childNodes;
>, <Line: +						default:
>, <Line: +							return template;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function getTrustedContext(node, attrNormalizedName) {
>, <Line: +					if (attrNormalizedName == "srcdoc") {
>, <Line: +						return $sce.HTML;
>, <Line: +					}
>, <Line: +					var tag = nodeName_(node);
>, <Line: +					// maction[xlink:href] can source SVG.  It's not limited to <maction>.
>, <Line: +					if (attrNormalizedName == "xlinkHref" ||
>, <Line: +						(tag == "form" && attrNormalizedName == "action") ||
>, <Line: +						(tag != "img" && (attrNormalizedName == "src" ||
>, <Line: +						attrNormalizedName == "ngSrc"))) {
>, <Line: +						return $sce.RESOURCE_URL;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
>, <Line: +					var interpolateFn = $interpolate(value, true);
>, <Line: +					// no interpolation found -> ignore
>, <Line: +					if (!interpolateFn) return;
>, <Line: +					if (name === "multiple" && nodeName_(node) === "select") {
>, <Line: +						throw $compileMinErr("selmulti",
>, <Line: +							"Binding to the 'multiple' attribute is not supported. Element: {0}",
>, <Line: +							startingTag(node));
>, <Line: +					}
>, <Line: +					directives.push({
>, <Line: +						priority: 100,
>, <Line: +						compile: function () {
>, <Line: +							return {
>, <Line: +								pre: function attrInterpolatePreLinkFn(scope, element, attr) {
>, <Line: +									var $$observers = (attr.$$observers || (attr.$$observers = {}));
>, <Line: +									if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
>, <Line: +										throw $compileMinErr('nodomevents',
>, <Line: +											"Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
>, <Line: +											"ng- versions (such as ng-click instead of onclick) instead.");
>, <Line: +									}
>, <Line: +									// If the attribute was removed, then we are done
>, <Line: +									if (!attr[name]) {
>, <Line: +										return;
>, <Line: +									}
>, <Line: +									// we need to interpolate again, in case the attribute value has been updated
>, <Line: +									// (e.g. by another directive's compile function)
>, <Line: +									interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name),
>, <Line: +										ALL_OR_NOTHING_ATTRS[name] || allOrNothing);
>, <Line: +									// if attribute was updated so that there is no interpolation going on we don't want to
>, <Line: +									// register any observers
>, <Line: +									if (!interpolateFn) return;
>, <Line: +									// initialize attr object so that it's ready in case we need the value for isolate
>, <Line: +									// scope initialization, otherwise the value would not be available from isolate
>, <Line: +									// directive's linking fn during linking phase
>, <Line: +									attr[name] = interpolateFn(scope);
>, <Line: +									($$observers[name] || ($$observers[name] = [])).$$inter = true;
>, <Line: +									(attr.$$observers && attr.$$observers[name].$$scope || scope).
>, <Line: +										$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
>, <Line: +											//special case for class attribute addition + removal
>, <Line: +											//so that class changes can tap into the animation
>, <Line: +											//hooks provided by the $animate service. Be sure to
>, <Line: +											//skip animations when the first digest occurs (when
>, <Line: +											//both the new and the old values are the same) since
>, <Line: +											//the CSS classes are the non-interpolated values
>, <Line: +											if (name === 'class' && newValue != oldValue) {
>, <Line: +												attr.$updateClass(newValue, oldValue);
>, <Line: +											} else {
>, <Line: +												attr.$set(name, newValue);
>, <Line: +											}
>, <Line: +										});
>, <Line: +								}
>, <Line: +							};
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * This is a special jqLite.replaceWith, which can replace items which
>, <Line: +				 * have no parents, provided that the containing jqLite collection is provided.
>, <Line: +				 *
>, <Line: +				 * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
>, <Line: +				 *                               in the root of the tree.
>, <Line: +				 * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep
>, <Line: +				 *                                  the shell, but replace its DOM node reference.
>, <Line: +				 * @param {Node} newNode The new DOM node.
>, <Line: +				 */
>, <Line: +				function replaceWith($rootElement, elementsToRemove, newNode) {
>, <Line: +					var firstElementToRemove = elementsToRemove[0],
>, <Line: +						removeCount = elementsToRemove.length,
>, <Line: +						parent = firstElementToRemove.parentNode,
>, <Line: +						i, ii;
>, <Line: +					if ($rootElement) {
>, <Line: +						for (i = 0, ii = $rootElement.length; i < ii; i++) {
>, <Line: +							if ($rootElement[i] == firstElementToRemove) {
>, <Line: +								$rootElement[i++] = newNode;
>, <Line: +								for (var j = i, j2 = j + removeCount - 1,
>, <Line: +										 jj = $rootElement.length;
>, <Line: +									 j < jj; j++, j2++) {
>, <Line: +									if (j2 < jj) {
>, <Line: +										$rootElement[j] = $rootElement[j2];
>, <Line: +									} else {
>, <Line: +										delete $rootElement[j];
>, <Line: +									}
>, <Line: +								}
>, <Line: +								$rootElement.length -= removeCount - 1;
>, <Line: +								// If the replaced element is also the jQuery .context then replace it
>, <Line: +								// .context is a deprecated jQuery api, so we should set it only when jQuery set it
>, <Line: +								// http://api.jquery.com/context/
>, <Line: +								if ($rootElement.context === firstElementToRemove) {
>, <Line: +									$rootElement.context = newNode;
>, <Line: +								}
>, <Line: +								break;
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (parent) {
>, <Line: +						parent.replaceChild(newNode, firstElementToRemove);
>, <Line: +					}
>, <Line: +					// TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?
>, <Line: +					var fragment = document.createDocumentFragment();
>, <Line: +					fragment.appendChild(firstElementToRemove);
>, <Line: +					// Copy over user data (that includes Angular's $scope etc.). Don't copy private
>, <Line: +					// data here because there's no public interface in jQuery to do that and copying over
>, <Line: +					// event listeners (which is the main use of private data) wouldn't work anyway.
>, <Line: +					jqLite(newNode).data(jqLite(firstElementToRemove).data());
>, <Line: +					// Remove data of the replaced element. We cannot just call .remove()
>, <Line: +					// on the element it since that would deallocate scope that is needed
>, <Line: +					// for the new node. Instead, remove the data "manually".
>, <Line: +					if (!jQuery) {
>, <Line: +						delete jqLite.cache[firstElementToRemove[jqLite.expando]];
>, <Line: +					} else {
>, <Line: +						// jQuery 2.x doesn't expose the data storage. Use jQuery.cleanData to clean up after
>, <Line: +						// the replaced element. The cleanData version monkey-patched by Angular would cause
>, <Line: +						// the scope to be trashed and we do need the very same scope to work with the new
>, <Line: +						// element. However, we cannot just cache the non-patched version and use it here as
>, <Line: +						// that would break if another library patches the method after Angular does (one
>, <Line: +						// example is jQuery UI). Instead, set a flag indicating scope destroying should be
>, <Line: +						// skipped this one time.
>, <Line: +						skipDestroyOnNextJQueryCleanData = true;
>, <Line: +						jQuery.cleanData([firstElementToRemove]);
>, <Line: +					}
>, <Line: +					for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
>, <Line: +						var element = elementsToRemove[k];
>, <Line: +						jqLite(element).remove(); // must do this way to clean up expando
>, <Line: +						fragment.appendChild(element);
>, <Line: +						delete elementsToRemove[k];
>, <Line: +					}
>, <Line: +					elementsToRemove[0] = newNode;
>, <Line: +					elementsToRemove.length = 1;
>, <Line: +				}
>, <Line: +				function cloneAndAnnotateFn(fn, annotation) {
>, <Line: +					return extend(function () {
>, <Line: +						return fn.apply(null, arguments);
>, <Line: +					}, fn, annotation);
>, <Line: +				}
>, <Line: +				function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
>, <Line: +					try {
>, <Line: +						linkFn(scope, $element, attrs, controllers, transcludeFn);
>, <Line: +					} catch (e) {
>, <Line: +						$exceptionHandler(e, startingTag($element));
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
>, <Line: +	/**
>, <Line: +	 * Converts all accepted directives format into proper directive name.
>, <Line: +	 * All of these will become 'myDirective':
>, <Line: +	 *   my:Directive
>, <Line: +	 *   my-directive
>, <Line: +	 *   x-my-directive
>, <Line: +	 *   data-my:directive
>, <Line: +	 *
>, <Line: +	 * Also there is special case for Moz prefix starting with upper case letter.
>, <Line: +	 * @param name Name to normalize
>, <Line: +	 */
>, <Line: +	function directiveNormalize(name) {
>, <Line: +		return camelCase(name.replace(PREFIX_REGEXP, ''));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name $compile.directive.Attributes
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A shared object between directive compile / linking functions which contains normalized DOM
>, <Line: +	 * element attributes. The values reflect current binding state `{{ }}`. The normalization is
>, <Line: +	 * needed since all of these are treated as equivalent in Angular:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 *    <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc property
>, <Line: +	 * @name $compile.directive.Attributes#$attr
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A map of DOM element attribute names to the normalized name. This is
>, <Line: +	 * needed to do reverse lookup from normalized name back to actual name.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $compile.directive.Attributes#$set
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Set DOM element attribute value.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @param {string} name Normalized element attribute name of the property to modify. The name is
>, <Line: +	 *          reverse-translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
>, <Line: +	 *          property to the original name.
>, <Line: +	 * @param {string} value Value to set the attribute to. The value can be an interpolated string.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * Closure compiler type information
>, <Line: +	 */
>, <Line: +	function nodesetLinkingFn(/* angular.Scope */ scope,
>, <Line: +							  /* NodeList */ nodeList,
>, <Line: +							  /* Element */ rootElement,
>, <Line: +							  /* function(Function) */ boundTranscludeFn) {
>, <Line: +	}
>, <Line: +	function directiveLinkingFn(/* nodesetLinkingFn */ nodesetLinkingFn,
>, <Line: +								/* angular.Scope */ scope,
>, <Line: +								/* Node */ node,
>, <Line: +								/* Element */ rootElement,
>, <Line: +								/* function(Function) */ boundTranscludeFn) {
>, <Line: +	}
>, <Line: +	function tokenDifference(str1, str2) {
>, <Line: +		var values = '',
>, <Line: +			tokens1 = str1.split(/\s+/),
>, <Line: +			tokens2 = str2.split(/\s+/);
>, <Line: +		outer:
>, <Line: +			for (var i = 0; i < tokens1.length; i++) {
>, <Line: +				var token = tokens1[i];
>, <Line: +				for (var j = 0; j < tokens2.length; j++) {
>, <Line: +					if (token == tokens2[j]) continue outer;
>, <Line: +				}
>, <Line: +				values += (values.length > 0 ? ' ' : '') + token;
>, <Line: +			}
>, <Line: +		return values;
>, <Line: +	}
>, <Line: +	function removeComments(jqNodes) {
>, <Line: +		jqNodes = jqLite(jqNodes);
>, <Line: +		var i = jqNodes.length;
>, <Line: +		if (i <= 1) {
>, <Line: +			return jqNodes;
>, <Line: +		}
>, <Line: +		while (i--) {
>, <Line: +			var node = jqNodes[i];
>, <Line: +			if (node.nodeType === NODE_TYPE_COMMENT) {
>, <Line: +				splice.call(jqNodes, i, 1);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return jqNodes;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $controllerProvider
>, <Line: +	 * @description
>, <Line: +	 * The {@link ng.$controller $controller service} is used by Angular to create new
>, <Line: +	 * controllers.
>, <Line: +	 *
>, <Line: +	 * This provider allows controller registration via the
>, <Line: +	 * {@link ng.$controllerProvider#register register} method.
>, <Line: +	 */
>, <Line: +	function $ControllerProvider() {
>, <Line: +		var controllers = {},
>, <Line: +			globals = false,
>, <Line: +			CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $controllerProvider#register
>, <Line: +		 * @param {string|Object} name Controller name, or an object map of controllers where the keys are
>, <Line: +		 *    the names and the values are the constructors.
>, <Line: +		 * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
>, <Line: +		 *    annotations in the array notation).
>, <Line: +		 */
>, <Line: +		this.register = function (name, constructor) {
>, <Line: +			assertNotHasOwnProperty(name, 'controller');
>, <Line: +			if (isObject(name)) {
>, <Line: +				extend(controllers, name);
>, <Line: +			} else {
>, <Line: +				controllers[name] = constructor;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $controllerProvider#allowGlobals
>, <Line: +		 * @description If called, allows `$controller` to find controller constructors on `window`
>, <Line: +		 */
>, <Line: +		this.allowGlobals = function () {
>, <Line: +			globals = true;
>, <Line: +		};
>, <Line: +		this.$get = ['$injector', '$window', function ($injector, $window) {
>, <Line: +			/**
>, <Line: +			 * @ngdoc service
>, <Line: +			 * @name $controller
>, <Line: +			 * @requires $injector
>, <Line: +			 *
>, <Line: +			 * @param {Function|string} constructor If called with a function then it's considered to be the
>, <Line: +			 *    controller constructor function. Otherwise it's considered to be a string which is used
>, <Line: +			 *    to retrieve the controller constructor using the following steps:
>, <Line: +			 *
>, <Line: +			 *    * check if a controller with given name is registered via `$controllerProvider`
>, <Line: +			 *    * check if evaluating the string on the current scope returns a constructor
>, <Line: +			 *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global
>, <Line: +			 *      `window` object (not recommended)
>, <Line: +			 *
>, <Line: +			 *    The string can use the `controller as property` syntax, where the controller instance is published
>, <Line: +			 *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this
>, <Line: +			 *    to work correctly.
>, <Line: +			 *
>, <Line: +			 * @param {Object} locals Injection locals for Controller.
>, <Line: +			 * @return {Object} Instance of given controller.
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * `$controller` service is responsible for instantiating controllers.
>, <Line: +			 *
>, <Line: +			 * It's just a simple call to {@link auto.$injector $injector}, but extracted into
>, <Line: +			 * a service, so that one can override this service with [BC version](https://gist.github.com/1649788).
>, <Line: +			 */
>, <Line: +			return function (expression, locals, later, ident) {
>, <Line: +				// PRIVATE API:
>, <Line: +				//   param `later` --- indicates that the controller's constructor is invoked at a later time.
>, <Line: +				//                     If true, $controller will allocate the object with the correct
>, <Line: +				//                     prototype chain, but will not invoke the controller until a returned
>, <Line: +				//                     callback is invoked.
>, <Line: +				//   param `ident` --- An optional label which overrides the label parsed from the controller
>, <Line: +				//                     expression, if any.
>, <Line: +				var instance, match, constructor, identifier;
>, <Line: +				later = later === true;
>, <Line: +				if (ident && isString(ident)) {
>, <Line: +					identifier = ident;
>, <Line: +				}
>, <Line: +				if (isString(expression)) {
>, <Line: +					match = expression.match(CNTRL_REG),
>, <Line: +						constructor = match[1],
>, <Line: +						identifier = identifier || match[3];
>, <Line: +					expression = controllers.hasOwnProperty(constructor)
>, <Line: +						? controllers[constructor]
>, <Line: +						: getter(locals.$scope, constructor, true) ||
>, <Line: +					(globals ? getter($window, constructor, true) : undefined);
>, <Line: +					assertArgFn(expression, constructor, true);
>, <Line: +				}
>, <Line: +				if (later) {
>, <Line: +					// Instantiate controller later:
>, <Line: +					// This machinery is used to create an instance of the object before calling the
>, <Line: +					// controller's constructor itself.
>, <Line: +					//
>, <Line: +					// This allows properties to be added to the controller before the constructor is
>, <Line: +					// invoked. Primarily, this is used for isolate scope bindings in $compile.
>, <Line: +					//
>, <Line: +					// This feature is not intended for use by applications, and is thus not documented
>, <Line: +					// publicly.
>, <Line: +					// Object creation: http://jsperf.com/create-constructor/2
>, <Line: +					var controllerPrototype = (isArray(expression) ?
>, <Line: +						expression[expression.length - 1] : expression).prototype;
>, <Line: +					instance = Object.create(controllerPrototype);
>, <Line: +					if (identifier) {
>, <Line: +						addIdentifier(locals, identifier, instance, constructor || expression.name);
>, <Line: +					}
>, <Line: +					return extend(function () {
>, <Line: +						$injector.invoke(expression, instance, locals, constructor);
>, <Line: +						return instance;
>, <Line: +					}, {
>, <Line: +						instance: instance,
>, <Line: +						identifier: identifier
>, <Line: +					});
>, <Line: +				}
>, <Line: +				instance = $injector.instantiate(expression, locals, constructor);
>, <Line: +				if (identifier) {
>, <Line: +					addIdentifier(locals, identifier, instance, constructor || expression.name);
>, <Line: +				}
>, <Line: +				return instance;
>, <Line: +			};
>, <Line: +			function addIdentifier(locals, identifier, instance, name) {
>, <Line: +				if (!(locals && isObject(locals.$scope))) {
>, <Line: +					throw minErr('$controller')('noscp',
>, <Line: +						"Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
>, <Line: +						name, identifier);
>, <Line: +				}
>, <Line: +				locals.$scope[identifier] = instance;
>, <Line: +			}
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $document
>, <Line: +	 * @requires $window
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A {@link angular.element jQuery or jqLite} wrapper for the browser's `window.document` object.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="documentExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <p>$document title: <b ng-bind="title"></b></p>
>, <Line: +	 <p>window.document title: <b ng-bind="windowTitle"></b></p>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('documentExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', '$document', function($scope, $document) {
>, <Line: +           $scope.title = $document[0].title;
>, <Line: +           $scope.windowTitle = angular.element(window.document)[0].title;
>, <Line: +         }]);
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function $DocumentProvider() {
>, <Line: +		this.$get = ['$window', function (window) {
>, <Line: +			return jqLite(window.document);
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $exceptionHandler
>, <Line: +	 * @requires ng.$log
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Any uncaught exception in angular expressions is delegated to this service.
>, <Line: +	 * The default implementation simply delegates to `$log.error` which logs it into
>, <Line: +	 * the browser console.
>, <Line: +	 *
>, <Line: +	 * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
>, <Line: +	 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
>, <Line: +	 *
>, <Line: +	 * ## Example:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   angular.module('exceptionOverride', []).factory('$exceptionHandler', function() {
>, <Line: + *     return function(exception, cause) {
>, <Line: + *       exception.message += ' (caused by "' + cause + '")';
>, <Line: + *       throw exception;
>, <Line: + *     };
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * This example will override the normal action of `$exceptionHandler`, to make angular
>, <Line: +	 * exceptions fail hard when they happen, instead of just logging to the console.
>, <Line: +	 *
>, <Line: +	 * <hr />
>, <Line: +	 * Note, that code executed in event-listeners (even those registered using jqLite's `on`/`bind`
>, <Line: +	 * methods) does not delegate exceptions to the {@link ng.$exceptionHandler $exceptionHandler}
>, <Line: +	 * (unless executed during a digest).
>, <Line: +	 *
>, <Line: +	 * If you wish, you can manually delegate exceptions, e.g.
>, <Line: +	 * `try { ... } catch(e) { $exceptionHandler(e); }`
>, <Line: +	 *
>, <Line: +	 * @param {Error} exception Exception associated with the error.
>, <Line: +	 * @param {string=} cause optional information about the context in which
>, <Line: +	 *       the error was thrown.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	function $ExceptionHandlerProvider() {
>, <Line: +		this.$get = ['$log', function ($log) {
>, <Line: +			return function (exception, cause) {
>, <Line: +				$log.error.apply($log, arguments);
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	var APPLICATION_JSON = 'application/json';
>, <Line: +	var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
>, <Line: +	var JSON_START = /^\s*(\[|\{[^\{])/;
>, <Line: +	var JSON_END = /[\}\]]\s*$/;
>, <Line: +	var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
>, <Line: +	function defaultHttpResponseTransform(data, headers) {
>, <Line: +		if (isString(data)) {
>, <Line: +			// strip json vulnerability protection prefix
>, <Line: +			data = data.replace(JSON_PROTECTION_PREFIX, '');
>, <Line: +			var contentType = headers('Content-Type');
>, <Line: +			if ((contentType && contentType.indexOf(APPLICATION_JSON) === 0 && data.trim()) ||
>, <Line: +				(JSON_START.test(data) && JSON_END.test(data))) {
>, <Line: +				data = fromJson(data);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return data;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Parse headers into key value object
>, <Line: +	 *
>, <Line: +	 * @param {string} headers Raw headers as a string
>, <Line: +	 * @returns {Object} Parsed headers as key value object
>, <Line: +	 */
>, <Line: +	function parseHeaders(headers) {
>, <Line: +		var parsed = createMap(), key, val, i;
>, <Line: +		if (!headers) return parsed;
>, <Line: +		forEach(headers.split('\n'), function (line) {
>, <Line: +			i = line.indexOf(':');
>, <Line: +			key = lowercase(trim(line.substr(0, i)));
>, <Line: +			val = trim(line.substr(i + 1));
>, <Line: +			if (key) {
>, <Line: +				parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
>, <Line: +			}
>, <Line: +		});
>, <Line: +		return parsed;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Returns a function that provides access to parsed headers.
>, <Line: +	 *
>, <Line: +	 * Headers are lazy parsed when first requested.
>, <Line: +	 * @see parseHeaders
>, <Line: +	 *
>, <Line: +	 * @param {(string|Object)} headers Headers to provide access to.
>, <Line: +	 * @returns {function(string=)} Returns a getter function which if called with:
>, <Line: +	 *
>, <Line: +	 *   - if called with single an argument returns a single header value or null
>, <Line: +	 *   - if called with no arguments returns an object containing all headers.
>, <Line: +	 */
>, <Line: +	function headersGetter(headers) {
>, <Line: +		var headersObj = isObject(headers) ? headers : undefined;
>, <Line: +		return function (name) {
>, <Line: +			if (!headersObj) headersObj = parseHeaders(headers);
>, <Line: +			if (name) {
>, <Line: +				var value = headersObj[lowercase(name)];
>, <Line: +				if (value === void 0) {
>, <Line: +					value = null;
>, <Line: +				}
>, <Line: +				return value;
>, <Line: +			}
>, <Line: +			return headersObj;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Chain all given functions
>, <Line: +	 *
>, <Line: +	 * This function is used for both request and response transforming
>, <Line: +	 *
>, <Line: +	 * @param {*} data Data to transform.
>, <Line: +	 * @param {function(string=)} headers Http headers getter fn.
>, <Line: +	 * @param {(Function|Array.<Function>)} fns Function or an array of functions.
>, <Line: +	 * @returns {*} Transformed data.
>, <Line: +	 */
>, <Line: +	function transformData(data, headers, fns) {
>, <Line: +		if (isFunction(fns))
>, <Line: +			return fns(data, headers);
>, <Line: +		forEach(fns, function (fn) {
>, <Line: +			data = fn(data, headers);
>, <Line: +		});
>, <Line: +		return data;
>, <Line: +	}
>, <Line: +	function isSuccess(status) {
>, <Line: +		return 200 <= status && status < 300;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $httpProvider
>, <Line: +	 * @description
>, <Line: +	 * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
>, <Line: +	 * */
>, <Line: +	function $HttpProvider() {
>, <Line: +		/**
>, <Line: +		 * @ngdoc property
>, <Line: +		 * @name $httpProvider#defaults
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * Object containing default values for all {@link ng.$http $http} requests.
>, <Line: +		 *
>, <Line: +		 * - **`defaults.cache`** - {Object} - an object built with {@link ng.$cacheFactory `$cacheFactory`}
>, <Line: +		 * that will provide the cache for all requests who set their `cache` property to `true`.
>, <Line: +		 * If you set the `default.cache = false` then only requests that specify their own custom
>, <Line: +		 * cache object will be cached. See {@link $http#caching $http Caching} for more information.
>, <Line: +		 *
>, <Line: +		 * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
>, <Line: +		 * Defaults value is `'XSRF-TOKEN'`.
>, <Line: +		 *
>, <Line: +		 * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
>, <Line: +		 * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
>, <Line: +		 *
>, <Line: +		 * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
>, <Line: +		 * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
>, <Line: +		 * setting default headers.
>, <Line: +		 *     - **`defaults.headers.common`**
>, <Line: +		 *     - **`defaults.headers.post`**
>, <Line: +		 *     - **`defaults.headers.put`**
>, <Line: +		 *     - **`defaults.headers.patch`**
>, <Line: +		 *
>, <Line: +		 **/
>, <Line: +		var defaults = this.defaults = {
>, <Line: +			// transform incoming response data
>, <Line: +			transformResponse: [defaultHttpResponseTransform],
>, <Line: +			// transform outgoing request data
>, <Line: +			transformRequest: [function (d) {
>, <Line: +				return isObject(d) && !isFile(d) && !isBlob(d) ? toJson(d) : d;
>, <Line: +			}],
>, <Line: +			// default headers
>, <Line: +			headers: {
>, <Line: +				common: {
>, <Line: +					'Accept': 'application/json, text/plain, */*'
>, <Line: +				},
>, <Line: +				post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
>, <Line: +				put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
>, <Line: +				patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
>, <Line: +			},
>, <Line: +			xsrfCookieName: 'XSRF-TOKEN',
>, <Line: +			xsrfHeaderName: 'X-XSRF-TOKEN'
>, <Line: +		};
>, <Line: +		var useApplyAsync = false;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $httpProvider#useApplyAsync
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * Configure $http service to combine processing of multiple http responses received at around
>, <Line: +		 * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in
>, <Line: +		 * significant performance improvement for bigger applications that make many HTTP requests
>, <Line: +		 * concurrently (common during application bootstrap).
>, <Line: +		 *
>, <Line: +		 * Defaults to false. If no value is specifed, returns the current configured value.
>, <Line: +		 *
>, <Line: +		 * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred
>, <Line: +		 *    "apply" on the next tick, giving time for subsequent requests in a roughly ~10ms window
>, <Line: +		 *    to load and share the same digest cycle.
>, <Line: +		 *
>, <Line: +		 * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
>, <Line: +		 *    otherwise, returns the current configured value.
>, <Line: +		 **/
>, <Line: +		this.useApplyAsync = function (value) {
>, <Line: +			if (isDefined(value)) {
>, <Line: +				useApplyAsync = !!value;
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +			return useApplyAsync;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc property
>, <Line: +		 * @name $httpProvider#interceptors
>, <Line: +		 * @description
>, <Line: +		 *
>, <Line: +		 * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
>, <Line: +		 * pre-processing of request or postprocessing of responses.
>, <Line: +		 *
>, <Line: +		 * These service factories are ordered by request, i.e. they are applied in the same order as the
>, <Line: +		 * array, on request, but reverse order, on response.
>, <Line: +		 *
>, <Line: +		 * {@link ng.$http#interceptors Interceptors detailed info}
>, <Line: +		 **/
>, <Line: +		var interceptorFactories = this.interceptors = [];
>, <Line: +		this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
>, <Line: +			function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
>, <Line: +				var defaultCache = $cacheFactory('$http');
>, <Line: +				/**
>, <Line: +				 * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
>, <Line: +				 * The reversal is needed so that we can build up the interception chain around the
>, <Line: +				 * server request.
>, <Line: +				 */
>, <Line: +				var reversedInterceptors = [];
>, <Line: +				forEach(interceptorFactories, function (interceptorFactory) {
>, <Line: +					reversedInterceptors.unshift(isString(interceptorFactory)
>, <Line: +						? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
>, <Line: +				});
>, <Line: +				/**
>, <Line: +				 * @ngdoc service
>, <Line: +				 * @kind function
>, <Line: +				 * @name $http
>, <Line: +				 * @requires ng.$httpBackend
>, <Line: +				 * @requires $cacheFactory
>, <Line: +				 * @requires $rootScope
>, <Line: +				 * @requires $q
>, <Line: +				 * @requires $injector
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * The `$http` service is a core Angular service that facilitates communication with the remote
>, <Line: +				 * HTTP servers via the browser's [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)
>, <Line: +				 * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).
>, <Line: +				 *
>, <Line: +				 * For unit testing applications that use `$http` service, see
>, <Line: +				 * {@link ngMock.$httpBackend $httpBackend mock}.
>, <Line: +				 *
>, <Line: +				 * For a higher level of abstraction, please check out the {@link ngResource.$resource
>, <Line: +     * $resource} service.
>, <Line: +				 *
>, <Line: +				 * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
>, <Line: +				 * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
>, <Line: +				 * it is important to familiarize yourself with these APIs and the guarantees they provide.
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * ## General usage
>, <Line: +				 * The `$http` service is a function which takes a single argument  a configuration object 
>, <Line: +				 * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
>, <Line: +				 * with two $http specific methods: `success` and `error`.
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 *   // Simple GET request example :
>, <Line: +				 *   $http.get('/someUrl').
>, <Line: +				 *     success(function(data, status, headers, config) {
>, <Line: +     *       // this callback will be called asynchronously
>, <Line: +     *       // when the response is available
>, <Line: +     *     }).
>, <Line: +				 *     error(function(data, status, headers, config) {
>, <Line: +     *       // called asynchronously if an error occurs
>, <Line: +     *       // or server returns response with an error status.
>, <Line: +     *     });
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 *   // Simple POST request example (passing data) :
>, <Line: +				 *   $http.post('/someUrl', {msg:'hello word!'}).
>, <Line: +				 *     success(function(data, status, headers, config) {
>, <Line: +     *       // this callback will be called asynchronously
>, <Line: +     *       // when the response is available
>, <Line: +     *     }).
>, <Line: +				 *     error(function(data, status, headers, config) {
>, <Line: +     *       // called asynchronously if an error occurs
>, <Line: +     *       // or server returns response with an error status.
>, <Line: +     *     });
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * Since the returned value of calling the $http function is a `promise`, you can also use
>, <Line: +				 * the `then` method to register callbacks, and these callbacks will receive a single argument 
>, <Line: +				 * an object representing the response. See the API signature and type info below for more
>, <Line: +				 * details.
>, <Line: +				 *
>, <Line: +				 * A response status code between 200 and 299 is considered a success status and
>, <Line: +				 * will result in the success callback being called. Note that if the response is a redirect,
>, <Line: +				 * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
>, <Line: +				 * called for such responses.
>, <Line: +				 *
>, <Line: +				 * ## Writing Unit Tests that use $http
>, <Line: +				 * When unit testing (using {@link ngMock ngMock}), it is necessary to call
>, <Line: +				 * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush each pending
>, <Line: +				 * request using trained responses.
>, <Line: +				 *
>, <Line: +				 * ```
>, <Line: +				 * $httpBackend.expectGET(...);
>, <Line: +				 * $http.get(...);
>, <Line: +				 * $httpBackend.flush();
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * ## Shortcut methods
>, <Line: +				 *
>, <Line: +				 * Shortcut methods are also available. All shortcut methods require passing in the URL, and
>, <Line: +				 * request data must be passed in for POST/PUT requests.
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 *   $http.get('/someUrl').success(successCallback);
>, <Line: +				 *   $http.post('/someUrl', data).success(successCallback);
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * Complete list of shortcut methods:
>, <Line: +				 *
>, <Line: +				 * - {@link ng.$http#get $http.get}
>, <Line: +				 * - {@link ng.$http#head $http.head}
>, <Line: +				 * - {@link ng.$http#post $http.post}
>, <Line: +				 * - {@link ng.$http#put $http.put}
>, <Line: +				 * - {@link ng.$http#delete $http.delete}
>, <Line: +				 * - {@link ng.$http#jsonp $http.jsonp}
>, <Line: +				 * - {@link ng.$http#patch $http.patch}
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * ## Setting HTTP Headers
>, <Line: +				 *
>, <Line: +				 * The $http service will automatically add certain HTTP headers to all requests. These defaults
>, <Line: +				 * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
>, <Line: +				 * object, which currently contains this default configuration:
>, <Line: +				 *
>, <Line: +				 * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
>, <Line: +				 *   - `Accept: application/json, text/plain, * / *`
>, <Line: +				 * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
>, <Line: +				 *   - `Content-Type: application/json`
>, <Line: +				 * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
>, <Line: +				 *   - `Content-Type: application/json`
>, <Line: +				 *
>, <Line: +				 * To add or overwrite these defaults, simply add or remove a property from these configuration
>, <Line: +				 * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
>, <Line: +				 * with the lowercased HTTP method name as the key, e.g.
>, <Line: +				 * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }.
>, <Line: +				 *
>, <Line: +				 * The defaults can also be set at runtime via the `$http.defaults` object in the same
>, <Line: +				 * fashion. For example:
>, <Line: +				 *
>, <Line: +				 * ```
>, <Line: +				 * module.run(function($http) {
>, <Line: +     *   $http.defaults.headers.common.Authorization = 'Basic YmVlcDpib29w'
>, <Line: +     * });
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * In addition, you can supply a `headers` property in the config object passed when
>, <Line: +				 * calling `$http(config)`, which overrides the defaults without changing them globally.
>, <Line: +				 *
>, <Line: +				 * To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis,
>, <Line: +				 * Use the `headers` property, setting the desired header to `undefined`. For example:
>, <Line: +				 *
>, <Line: +				 * ```js
>, <Line: +				 * var req = {
>, <Line: +     *  method: 'POST',
>, <Line: +     *  url: 'http://example.com',
>, <Line: +     *  headers: {
>, <Line: +     *    'Content-Type': undefined
>, <Line: +     *  },
>, <Line: +     *  data: { test: 'test' },
>, <Line: +     * }
>, <Line: +				 *
>, <Line: +				 * $http(req).success(function(){...}).error(function(){...});
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * ## Transforming Requests and Responses
>, <Line: +				 *
>, <Line: +				 * Both requests and responses can be transformed using transformation functions: `transformRequest`
>, <Line: +				 * and `transformResponse`. These properties can be a single function that returns
>, <Line: +				 * the transformed value (`{function(data, headersGetter)`) or an array of such transformation functions,
>, <Line: +     * which allows you to `push` or `unshift` a new transformation function into the transformation chain.
>, <Line: +     *
>, <Line: +     * ### Default Transformations
>, <Line: +     *
>, <Line: +     * The `$httpProvider` provider and `$http` service expose `defaults.transformRequest` and
>, <Line: +     * `defaults.transformResponse` properties. If a request does not provide its own transformations
>, <Line: +     * then these will be applied.
>, <Line: +     * You can augment or replace the default transformations by modifying these properties by adding to or
>, <Line: +     * replacing the array.
>, <Line: +     * Angular provides the following default transformations:
>, <Line: +     * Request transformations (`$httpProvider.defaults.transformRequest` and `$http.defaults.transformRequest`):
>, <Line: +     * - If the `data` property of the request configuration object contains an object, serialize it
>, <Line: +     *   into JSON format.
>, <Line: +     * Response transformations (`$httpProvider.defaults.transformResponse` and `$http.defaults.transformResponse`):
>, <Line: +     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
>, <Line: +     *  - If JSON response is detected, deserialize it using a JSON parser.
>, <Line: +     * ### Overriding the Default Transformations Per Request
>, <Line: +     *
>, <Line: +     * If you wish override the request/response transformations only for a single request then provide
>, <Line: +     * `transformRequest` and/or `transformResponse` properties on the configuration object passed
>, <Line: +     * into `$http`.
>, <Line: +     *
>, <Line: +     * Note that if you provide these properties on the config object the default transformations will be
>, <Line: +     * overwritten. If you wish to augment the default transformations then you must include them in your
>, <Line: +     * local transformation array.
>, <Line: +     * The following code demonstrates adding a new response transformation to be run after the default response
>, <Line: +     * transformations have been run.
>, <Line: +     * function appendTransform(defaults, transform) {
>, <Line: +     *
>, <Line: +     *   // We can't guarantee that the default transformation is an array
>, <Line: +     *   defaults = angular.isArray(defaults) ? defaults : [defaults];
>, <Line: +     *
>, <Line: +     *   // Append the new transformation to the defaults
>, <Line: +     *   return defaults.concat(transform);
>, <Line: +     * }
>, <Line: +     *
>, <Line: +     * $http({
>, <Line: +     *   url: '...',
>, <Line: +     *   method: 'GET',
>, <Line: +     *   transformResponse: appendTransform($http.defaults.transformResponse, function(value) {
>, <Line: +     *     return doTransform(value);
>, <Line: +     *   })
>, <Line: +     * });
>, <Line: +     * ## Caching
>, <Line: +     *
>, <Line: +     * To enable caching, set the request configuration `cache` property to `true` (to use default
>, <Line: +     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).
>, <Line: +     * When the cache is enabled, `$http` stores the response from the server in the specified
>, <Line: +     * cache. The next time the same request is made, the response is served from the cache without
>, <Line: +     * sending a request to the server.
>, <Line: +     *
>, <Line: +     * Note that even if the response is served from cache, delivery of the data is asynchronous in
>, <Line: +     * the same way that real requests are.
>, <Line: +     *
>, <Line: +     * If there are multiple GET requests for the same URL that should be cached using the same
>, <Line: +     * cache, but the cache is not populated yet, only one request to the server will be made and
>, <Line: +     * the remaining requests will be fulfilled using the response from the first request.
>, <Line: +     *
>, <Line: +     * You can change the default cache to a new object (built with
>, <Line: +     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the
>, <Line: +     * {@link ng.$http#defaults `$http.defaults.cache`} property. All requests who set
>, <Line: +     * their `cache` property to `true` will now use this cache object.
>, <Line: +     *
>, <Line: +     * If you set the default cache to `false` then only requests that specify their own custom
>, <Line: +     * cache object will be cached.
>, <Line: +     *
>, <Line: +     * ## Interceptors
>, <Line: +     *
>, <Line: +     * Before you start creating interceptors, be sure to understand the
>, <Line: +     * {@link ng.$q $q and deferred/promise APIs}.
>, <Line: +     *
>, <Line: +     * For purposes of global error handling, authentication, or any kind of synchronous or
>, <Line: +     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
>, <Line: +     * able to intercept requests before they are handed to the server and
>, <Line: +     * responses before they are handed over to the application code that
>, <Line: +     * initiated these requests. The interceptors leverage the {@link ng.$q
>, <Line: +     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
>, <Line: +     *
>, <Line: +     * The interceptors are service factories that are registered with the `$httpProvider` by
>, <Line: +     * adding them to the `$httpProvider.interceptors` array. The factory is called and
>, <Line: +     * injected with dependencies (if specified) and returns the interceptor.
>, <Line: +     *
>, <Line: +     * There are two kinds of interceptors (and two kinds of rejection interceptors):
>, <Line: +     *
>, <Line: +     *   * `request`: interceptors get called with a http `config` object. The function is free to
>, <Line: +     *     modify the `config` object or create a new one. The function needs to return the `config`
>, <Line: +     *     object directly, or a promise containing the `config` or a new `config` object.
>, <Line: +     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or
>, <Line: +     *     resolved with a rejection.
>, <Line: +     *   * `response`: interceptors get called with http `response` object. The function is free to
>, <Line: +     *     modify the `response` object or create a new one. The function needs to return the `response`
>, <Line: +     *     object directly, or as a promise containing the `response` or a new `response` object.
>, <Line: +     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or
>, <Line: +     *     resolved with a rejection.
>, <Line: +     *
>, <Line: +     *
>, <Line: +     * ```js
>, <Line: +     *   // register the interceptor as a service
>, <Line: +     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
>, <Line: +     *     return {
>, <Line: +     *       // optional method
>, <Line: +     *       'request': function(config) {
>, <Line: +     *         // do something on success
>, <Line: +     *         return config;
>, <Line: +     *       },
>, <Line: +     *
>, <Line: +     *       // optional method
>, <Line: +     *      'requestError': function(rejection) {
>, <Line: +     *         // do something on error
>, <Line: +     *         if (canRecover(rejection)) {
>, <Line: +     *           return responseOrNewPromise
>, <Line: +     *         }
>, <Line: +     *         return $q.reject(rejection);
>, <Line: +     *       },
>, <Line: +     *
>, <Line: +     *
>, <Line: +     *
>, <Line: +     *       // optional method
>, <Line: +     *       'response': function(response) {
>, <Line: +     *         // do something on success
>, <Line: +     *         return response;
>, <Line: +     *       },
>, <Line: +     *
>, <Line: +     *       // optional method
>, <Line: +     *      'responseError': function(rejection) {
>, <Line: +     *         // do something on error
>, <Line: +     *         if (canRecover(rejection)) {
>, <Line: +     *           return responseOrNewPromise
>, <Line: +     *         }
>, <Line: +     *         return $q.reject(rejection);
>, <Line: +     *       }
>, <Line: +     *     };
>, <Line: +     *   });
>, <Line: +     *
>, <Line: +     *   $httpProvider.interceptors.push('myHttpInterceptor');
>, <Line: +     *
>, <Line: +     *
>, <Line: +     *   // alternatively, register the interceptor via an anonymous factory
>, <Line: +     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
>, <Line: +     *     return {
>, <Line: +     *      'request': function(config) {
>, <Line: +     *          // same as above
>, <Line: +     *       },
>, <Line: +     *
>, <Line: +     *       'response': function(response) {
>, <Line: +     *          // same as above
>, <Line: +     *       }
>, <Line: +     *     };
>, <Line: +     *   });
>, <Line: +     * ```
>, <Line: +     *
>, <Line: +     * ## Security Considerations
>, <Line: +     *
>, <Line: +     * When designing web applications, consider security threats from:
>, <Line: +     *
>, <Line: +     * - [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
>, <Line: +     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)
>, <Line: +     *
>, <Line: +     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
>, <Line: +     * pre-configured with strategies that address these issues, but for this to work backend server
>, <Line: +     * cooperation is required.
>, <Line: +     *
>, <Line: +     * ### JSON Vulnerability Protection
>, <Line: +     *
>, <Line: +     * A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
>, <Line: +     * allows third party website to turn your JSON resource URL into
>, <Line: +     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To
>, <Line: +     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
>, <Line: +				 * Angular will automatically strip the prefix before processing it as JSON.
>, <Line: +				 *
>, <Line: +				 * For example if your server needs to return:
>, <Line: +				 * ```js
>, <Line: +				 * ['one','two']
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * which is vulnerable to attack, your server can return:
>, <Line: +				 * ```js
>, <Line: +				 * )]}',
>, <Line: +				 * ['one','two']
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * Angular will strip the prefix, before processing the JSON.
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * ### Cross Site Request Forgery (XSRF) Protection
>, <Line: +				 *
>, <Line: +				 * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which
>, <Line: +				 * an unauthorized site can gain your user's private data. Angular provides a mechanism
>, <Line: +				 * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
>, <Line: +				 * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
>, <Line: +				 * JavaScript that runs on your domain could read the cookie, your server can be assured that
>, <Line: +				 * the XHR came from JavaScript running on your domain. The header will not be set for
>, <Line: +				 * cross-domain requests.
>, <Line: +				 *
>, <Line: +				 * To take advantage of this, your server needs to set a token in a JavaScript readable session
>, <Line: +				 * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
>, <Line: +				 * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
>, <Line: +				 * that only JavaScript running on your domain could have sent the request. The token must be
>, <Line: +				 * unique for each user and must be verifiable by the server (to prevent the JavaScript from
>, <Line: +				 * making up its own tokens). We recommend that the token is a digest of your site's
>, <Line: +				 * authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&#41;)
>, <Line: +				 * for added security.
>, <Line: +				 *
>, <Line: +				 * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
>, <Line: +				 * properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,
>, <Line: +				 * or the per-request config object.
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * @param {object} config Object describing the request to be made and how it should be
>, <Line: +				 *    processed. The object has following properties:
>, <Line: +				 *
>, <Line: +				 *    - **method**  `{string}`  HTTP method (e.g. 'GET', 'POST', etc)
>, <Line: +				 *    - **url**  `{string}`  Absolute or relative URL of the resource that is being requested.
>, <Line: +				 *    - **params**  `{Object.<string|Object>}`  Map of strings or objects which will be turned
>, <Line: +				 *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be
>, <Line: +				 *      JSONified.
>, <Line: +				 *    - **data**  `{string|Object}`  Data to be sent as the request message data.
>, <Line: +				 *    - **headers**  `{Object}`  Map of strings or functions which return strings representing
>, <Line: +				 *      HTTP headers to send to the server. If the return value of a function is null, the
>, <Line: +				 *      header will not be sent.
>, <Line: +				 *    - **xsrfHeaderName**  `{string}`  Name of HTTP header to populate with the XSRF token.
>, <Line: +				 *    - **xsrfCookieName**  `{string}`  Name of cookie containing the XSRF token.
>, <Line: +				 *    - **transformRequest** 
>, <Line: +				 *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
>, <Line: +				 *      transform function or an array of such functions. The transform function takes the http
>, <Line: +				 *      request body and headers and returns its transformed (typically serialized) version.
>, <Line: +				 *      See {@link #overriding-the-default-transformations-per-request Overriding the Default Transformations}
>, <Line: +				 *    - **transformResponse** 
>, <Line: +				 *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
>, <Line: +				 *      transform function or an array of such functions. The transform function takes the http
>, <Line: +				 *      response body and headers and returns its transformed (typically deserialized) version.
>, <Line: +				 *      See {@link #overriding-the-default-transformations-per-request Overriding the Default Transformations}
>, <Line: +				 *    - **cache**  `{boolean|Cache}`  If true, a default $http cache will be used to cache the
>, <Line: +				 *      GET request, otherwise if a cache instance built with
>, <Line: +				 *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
>, <Line: +				 *      caching.
>, <Line: +				 *    - **timeout**  `{number|Promise}`  timeout in milliseconds, or {@link ng.$q promise}
>, <Line: +				 *      that should abort the request when resolved.
>, <Line: +				 *    - **withCredentials** - `{boolean}` - whether to set the `withCredentials` flag on the
>, <Line: +				 *      XHR object. See [requests with credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials)
>, <Line: +				 *      for more information.
>, <Line: +				 *    - **responseType** - `{string}` - see
>, <Line: +				 *      [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).
>, <Line: +				 *
>, <Line: +				 * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
>, <Line: +				 *   standard `then` method and two http specific methods: `success` and `error`. The `then`
>, <Line: +				 *   method takes two arguments a success and an error callback which will be called with a
>, <Line: +				 *   response object. The `success` and `error` methods take a single argument - a function that
>, <Line: +				 *   will be called when the request succeeds or fails respectively. The arguments passed into
>, <Line: +				 *   these functions are destructured representation of the response object passed into the
>, <Line: +				 *   `then` method. The response object has these properties:
>, <Line: +				 *
>, <Line: +				 *   - **data**  `{string|Object}`  The response body transformed with the transform
>, <Line: +				 *     functions.
>, <Line: +				 *   - **status**  `{number}`  HTTP status code of the response.
>, <Line: +				 *   - **headers**  `{function([headerName])}`  Header getter function.
>, <Line: +				 *   - **config**  `{Object}`  The configuration object that was used to generate the request.
>, <Line: +				 *   - **statusText**  `{string}`  HTTP status text of the response.
>, <Line: +				 *
>, <Line: +				 * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
>, <Line: +				 *   requests. This is primarily meant to be used for debugging purposes.
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 <example module="httpExample">
>, <Line: +				 <file name="index.html">
>, <Line: +				 <div ng-controller="FetchController">
>, <Line: +				 <select ng-model="method">
>, <Line: +				 <option>GET</option>
>, <Line: +				 <option>JSONP</option>
>, <Line: +				 </select>
>, <Line: +				 <input type="text" ng-model="url" size="80"/>
>, <Line: +				 <button id="fetchbtn" ng-click="fetch()">fetch</button><br>
>, <Line: +				 <button id="samplegetbtn" ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
>, <Line: +				 <button id="samplejsonpbtn"
>, <Line: +				 ng-click="updateModel('JSONP',
>, <Line: +				 'https://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">
>, <Line: +				 Sample JSONP
>, <Line: +				 </button>
>, <Line: +				 <button id="invalidjsonpbtn"
>, <Line: +				 ng-click="updateModel('JSONP', 'https://angularjs.org/doesntexist&callback=JSON_CALLBACK')">
>, <Line: +				 Invalid JSONP
>, <Line: +				 </button>
>, <Line: +				 <pre>http status code: {{status}}</pre>
>, <Line: +				 <pre>http response data: {{data}}</pre>
>, <Line: +				 </div>
>, <Line: +				 </file>
>, <Line: +				 <file name="script.js">
>, <Line: +				 angular.module('httpExample', [])
>, <Line: +				 .controller('FetchController', ['$scope', '$http', '$templateCache',
>, <Line: +				 function($scope, $http, $templateCache) {
>, <Line: +        $scope.method = 'GET';
>, <Line: +        $scope.url = 'http-hello.html';
>, <Line: +        $scope.fetch = function() {
>, <Line: +          $scope.code = null;
>, <Line: +          $scope.response = null;
>, <Line: +          $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
>, <Line: +            success(function(data, status) {
>, <Line: +              $scope.status = status;
>, <Line: +              $scope.data = data;
>, <Line: +            }).
>, <Line: +            error(function(data, status) {
>, <Line: +              $scope.data = data || "Request failed";
>, <Line: +              $scope.status = status;
>, <Line: +          });
>, <Line: +        };
>, <Line: +        $scope.updateModel = function(method, url) {
>, <Line: +          $scope.method = method;
>, <Line: +          $scope.url = url;
>, <Line: +        };
>, <Line: +      }]);
>, <Line: +				 </file>
>, <Line: +				 <file name="http-hello.html">
>, <Line: +				 Hello, $http!
>, <Line: +				 </file>
>, <Line: +				 <file name="protractor.js" type="protractor">
>, <Line: +				 var status = element(by.binding('status'));
>, <Line: +				 var data = element(by.binding('data'));
>, <Line: +				 var fetchBtn = element(by.id('fetchbtn'));
>, <Line: +				 var sampleGetBtn = element(by.id('samplegetbtn'));
>, <Line: +				 var sampleJsonpBtn = element(by.id('samplejsonpbtn'));
>, <Line: +				 var invalidJsonpBtn = element(by.id('invalidjsonpbtn'));
>, <Line: +				 it('should make an xhr GET request', function() {
>, <Line: +    sampleGetBtn.click();
>, <Line: +    fetchBtn.click();
>, <Line: +    expect(status.getText()).toMatch('200');
>, <Line: +    expect(data.getText()).toMatch(/Hello, \$http!/);
>, <Line: +				 // Commented out due to flakes. See https://github.com/angular/angular.js/issues/9185
>, <Line: +				 // it('should make a JSONP request to angularjs.org', function() {
>, <Line: +//   sampleJsonpBtn.click();
>, <Line: +//   fetchBtn.click();
>, <Line: +//   expect(status.getText()).toMatch('200');
>, <Line: +//   expect(data.getText()).toMatch(/Super Hero!/);
>, <Line: +// });
>, <Line: +				 it('should make JSONP request to invalid URL and invoke the error handler',
>, <Line: +				 function() {
>, <Line: +    invalidJsonpBtn.click();
>, <Line: +    fetchBtn.click();
>, <Line: +    expect(status.getText()).toMatch('0');
>, <Line: +    expect(data.getText()).toMatch('Request failed');
>, <Line: +				 </file>
>, <Line: +				 </example>
>, <Line: +				 */
>, <Line: +				function $http(requestConfig) {
>, <Line: +					var config = {
>, <Line: +						method: 'get',
>, <Line: +						transformRequest: defaults.transformRequest,
>, <Line: +						transformResponse: defaults.transformResponse
>, <Line: +					};
>, <Line: +					var headers = mergeHeaders(requestConfig);
>, <Line: +					if (!angular.isObject(requestConfig)) {
>, <Line: +						throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
>, <Line: +					}
>, <Line: +					extend(config, requestConfig);
>, <Line: +					config.headers = headers;
>, <Line: +					config.method = uppercase(config.method);
>, <Line: +					var serverRequest = function (config) {
>, <Line: +						headers = config.headers;
>, <Line: +						var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
>, <Line: +						// strip content-type if data is undefined
>, <Line: +						if (isUndefined(reqData)) {
>, <Line: +							forEach(headers, function (value, header) {
>, <Line: +								if (lowercase(header) === 'content-type') {
>, <Line: +									delete headers[header];
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +						if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
>, <Line: +							config.withCredentials = defaults.withCredentials;
>, <Line: +						}
>, <Line: +						// send request
>, <Line: +						return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
>, <Line: +					};
>, <Line: +					var chain = [serverRequest, undefined];
>, <Line: +					var promise = $q.when(config);
>, <Line: +					// apply interceptors
>, <Line: +					forEach(reversedInterceptors, function (interceptor) {
>, <Line: +						if (interceptor.request || interceptor.requestError) {
>, <Line: +							chain.unshift(interceptor.request, interceptor.requestError);
>, <Line: +						}
>, <Line: +						if (interceptor.response || interceptor.responseError) {
>, <Line: +							chain.push(interceptor.response, interceptor.responseError);
>, <Line: +						}
>, <Line: +					});
>, <Line: +					while (chain.length) {
>, <Line: +						var thenFn = chain.shift();
>, <Line: +						var rejectFn = chain.shift();
>, <Line: +						promise = promise.then(thenFn, rejectFn);
>, <Line: +					}
>, <Line: +					promise.success = function (fn) {
>, <Line: +						promise.then(function (response) {
>, <Line: +							fn(response.data, response.status, response.headers, config);
>, <Line: +						});
>, <Line: +						return promise;
>, <Line: +					};
>, <Line: +					promise.error = function (fn) {
>, <Line: +						promise.then(null, function (response) {
>, <Line: +							fn(response.data, response.status, response.headers, config);
>, <Line: +						});
>, <Line: +						return promise;
>, <Line: +					};
>, <Line: +					return promise;
>, <Line: +					function transformResponse(response) {
>, <Line: +						// make a copy since the response must be cacheable
>, <Line: +						var resp = extend({}, response);
>, <Line: +						if (!response.data) {
>, <Line: +							resp.data = response.data;
>, <Line: +						} else {
>, <Line: +							resp.data = transformData(response.data, response.headers, config.transformResponse);
>, <Line: +						}
>, <Line: +						return (isSuccess(response.status))
>, <Line: +							? resp
>, <Line: +							: $q.reject(resp);
>, <Line: +					}
>, <Line: +					function mergeHeaders(config) {
>, <Line: +						var defHeaders = defaults.headers,
>, <Line: +							reqHeaders = extend({}, config.headers),
>, <Line: +							defHeaderName, lowercaseDefHeaderName, reqHeaderName;
>, <Line: +						defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
>, <Line: +						// using for-in instead of forEach to avoid unecessary iteration after header has been found
>, <Line: +						defaultHeadersIteration:
>, <Line: +							for (defHeaderName in defHeaders) {
>, <Line: +								lowercaseDefHeaderName = lowercase(defHeaderName);
>, <Line: +								for (reqHeaderName in reqHeaders) {
>, <Line: +									if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
>, <Line: +										continue defaultHeadersIteration;
>, <Line: +									}
>, <Line: +								}
>, <Line: +								reqHeaders[defHeaderName] = defHeaders[defHeaderName];
>, <Line: +							}
>, <Line: +						// execute if header value is a function for merged headers
>, <Line: +						execHeaders(reqHeaders);
>, <Line: +						return reqHeaders;
>, <Line: +						function execHeaders(headers) {
>, <Line: +							var headerContent;
>, <Line: +							forEach(headers, function (headerFn, header) {
>, <Line: +								if (isFunction(headerFn)) {
>, <Line: +									headerContent = headerFn();
>, <Line: +									if (headerContent != null) {
>, <Line: +										headers[header] = headerContent;
>, <Line: +									} else {
>, <Line: +										delete headers[header];
>, <Line: +									}
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				$http.pendingRequests = [];
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#get
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `GET` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#delete
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `DELETE` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#head
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `HEAD` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#jsonp
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `JSONP` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request.
>, <Line: +				 *                     The name of the callback should be the string `JSON_CALLBACK`.
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				createShortMethods('get', 'delete', 'head', 'jsonp');
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#post
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `POST` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {*} data Request content
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#put
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `PUT` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {*} data Request content
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $http#patch
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut method to perform `PATCH` request.
>, <Line: +				 *
>, <Line: +				 * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: +				 * @param {*} data Request content
>, <Line: +				 * @param {Object=} config Optional configuration object
>, <Line: +				 * @returns {HttpPromise} Future object
>, <Line: +				 */
>, <Line: +				createShortMethodsWithData('post', 'put', 'patch');
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $http#defaults
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
>, <Line: +				 * default headers, withCredentials as well as request and response transformations.
>, <Line: +				 *
>, <Line: +				 * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
>, <Line: +				 */
>, <Line: +				$http.defaults = defaults;
>, <Line: +				return $http;
>, <Line: +				function createShortMethods(names) {
>, <Line: +					forEach(arguments, function (name) {
>, <Line: +						$http[name] = function (url, config) {
>, <Line: +							return $http(extend(config || {}, {
>, <Line: +								method: name,
>, <Line: +								url: url
>, <Line: +							}));
>, <Line: +						};
>, <Line: +					});
>, <Line: +				}
>, <Line: +				function createShortMethodsWithData(name) {
>, <Line: +					forEach(arguments, function (name) {
>, <Line: +						$http[name] = function (url, data, config) {
>, <Line: +							return $http(extend(config || {}, {
>, <Line: +								method: name,
>, <Line: +								url: url,
>, <Line: +								data: data
>, <Line: +							}));
>, <Line: +						};
>, <Line: +					});
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * Makes the request.
>, <Line: +				 *
>, <Line: +				 * !!! ACCESSES CLOSURE VARS:
>, <Line: +				 * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
>, <Line: +				 */
>, <Line: +				function sendReq(config, reqData, reqHeaders) {
>, <Line: +					var deferred = $q.defer(),
>, <Line: +						promise = deferred.promise,
>, <Line: +						cache,
>, <Line: +						cachedResp,
>, <Line: +						url = buildUrl(config.url, config.params);
>, <Line: +					$http.pendingRequests.push(config);
>, <Line: +					promise.then(removePendingReq, removePendingReq);
>, <Line: +					if ((config.cache || defaults.cache) && config.cache !== false &&
>, <Line: +						(config.method === 'GET' || config.method === 'JSONP')) {
>, <Line: +						cache = isObject(config.cache) ? config.cache
>, <Line: +							: isObject(defaults.cache) ? defaults.cache
>, <Line: +							: defaultCache;
>, <Line: +					}
>, <Line: +					if (cache) {
>, <Line: +						cachedResp = cache.get(url);
>, <Line: +						if (isDefined(cachedResp)) {
>, <Line: +							if (isPromiseLike(cachedResp)) {
>, <Line: +								// cached request has already been sent, but there is no response yet
>, <Line: +								cachedResp.then(removePendingReq, removePendingReq);
>, <Line: +								return cachedResp;
>, <Line: +							} else {
>, <Line: +								// serving from cache
>, <Line: +								if (isArray(cachedResp)) {
>, <Line: +									resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
>, <Line: +								} else {
>, <Line: +									resolvePromise(cachedResp, 200, {}, 'OK');
>, <Line: +								}
>, <Line: +							}
>, <Line: +						} else {
>, <Line: +							// put the promise for the non-transformed response into cache as a placeholder
>, <Line: +							cache.put(url, promise);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					// if we won't have the response in cache, set the xsrf headers and
>, <Line: +					// send the request to the backend
>, <Line: +					if (isUndefined(cachedResp)) {
>, <Line: +						var xsrfValue = urlIsSameOrigin(config.url)
>, <Line: +							? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
>, <Line: +							: undefined;
>, <Line: +						if (xsrfValue) {
>, <Line: +							reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
>, <Line: +						}
>, <Line: +						$httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
>, <Line: +							config.withCredentials, config.responseType);
>, <Line: +					}
>, <Line: +					return promise;
>, <Line: +					/**
>, <Line: +					 * Callback registered to $httpBackend():
>, <Line: +					 *  - caches the response if desired
>, <Line: +					 *  - resolves the raw $http promise
>, <Line: +					 *  - calls $apply
>, <Line: +					 */
>, <Line: +					function done(status, response, headersString, statusText) {
>, <Line: +						if (cache) {
>, <Line: +							if (isSuccess(status)) {
>, <Line: +								cache.put(url, [status, response, parseHeaders(headersString), statusText]);
>, <Line: +							} else {
>, <Line: +								// remove promise from the cache
>, <Line: +								cache.remove(url);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						function resolveHttpPromise() {
>, <Line: +							resolvePromise(response, status, headersString, statusText);
>, <Line: +						}
>, <Line: +						if (useApplyAsync) {
>, <Line: +							$rootScope.$applyAsync(resolveHttpPromise);
>, <Line: +						} else {
>, <Line: +							resolveHttpPromise();
>, <Line: +							if (!$rootScope.$$phase) $rootScope.$apply();
>, <Line: +						}
>, <Line: +					}
>, <Line: +					/**
>, <Line: +					 * Resolves the raw $http promise.
>, <Line: +					 */
>, <Line: +					function resolvePromise(response, status, headers, statusText) {
>, <Line: +						// normalize internal statuses to 0
>, <Line: +						status = Math.max(status, 0);
>, <Line: +						(isSuccess(status) ? deferred.resolve : deferred.reject)({
>, <Line: +							data: response,
>, <Line: +							status: status,
>, <Line: +							headers: headersGetter(headers),
>, <Line: +							config: config,
>, <Line: +							statusText: statusText
>, <Line: +						});
>, <Line: +					}
>, <Line: +					function removePendingReq() {
>, <Line: +						var idx = $http.pendingRequests.indexOf(config);
>, <Line: +						if (idx !== -1) $http.pendingRequests.splice(idx, 1);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function buildUrl(url, params) {
>, <Line: +					if (!params) return url;
>, <Line: +					var parts = [];
>, <Line: +					forEachSorted(params, function (value, key) {
>, <Line: +						if (value === null || isUndefined(value)) return;
>, <Line: +						if (!isArray(value)) value = [value];
>, <Line: +						forEach(value, function (v) {
>, <Line: +							if (isObject(v)) {
>, <Line: +								if (isDate(v)) {
>, <Line: +									v = v.toISOString();
>, <Line: +								} else {
>, <Line: +									v = toJson(v);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							parts.push(encodeUriQuery(key) + '=' +
>, <Line: +								encodeUriQuery(v));
>, <Line: +						});
>, <Line: +					});
>, <Line: +					if (parts.length > 0) {
>, <Line: +						url += ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
>, <Line: +					}
>, <Line: +					return url;
>, <Line: +				}
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	function createXhr() {
>, <Line: +		return new window.XMLHttpRequest();
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $httpBackend
>, <Line: +	 * @requires $window
>, <Line: +	 * @requires $document
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * HTTP backend used by the {@link ng.$http service} that delegates to
>, <Line: +	 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
>, <Line: +	 *
>, <Line: +	 * You should never need to use this service directly, instead use the higher-level abstractions:
>, <Line: +	 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
>, <Line: +	 *
>, <Line: +	 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
>, <Line: + * $httpBackend} which can be trained with responses.
>, <Line: +	 */
>, <Line: +	function $HttpBackendProvider() {
>, <Line: +		this.$get = ['$browser', '$window', '$document', function ($browser, $window, $document) {
>, <Line: +			return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
>, <Line: +		// TODO(vojta): fix the signature
>, <Line: +		return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
>, <Line: +			$browser.$$incOutstandingRequestCount();
>, <Line: +			url = url || $browser.url();
>, <Line: +			if (lowercase(method) == 'jsonp') {
>, <Line: +				var callbackId = '_' + (callbacks.counter++).toString(36);
>, <Line: +				callbacks[callbackId] = function (data) {
>, <Line: +					callbacks[callbackId].data = data;
>, <Line: +					callbacks[callbackId].called = true;
>, <Line: +				};
>, <Line: +				var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
>, <Line: +					callbackId, function (status, text) {
>, <Line: +						completeRequest(callback, status, callbacks[callbackId].data, "", text);
>, <Line: +						callbacks[callbackId] = noop;
>, <Line: +					});
>, <Line: +			} else {
>, <Line: +				var xhr = createXhr();
>, <Line: +				xhr.open(method, url, true);
>, <Line: +				forEach(headers, function (value, key) {
>, <Line: +					if (isDefined(value)) {
>, <Line: +						xhr.setRequestHeader(key, value);
>, <Line: +					}
>, <Line: +				});
>, <Line: +				xhr.onload = function requestLoaded() {
>, <Line: +					var statusText = xhr.statusText || '';
>, <Line: +					// responseText is the old-school way of retrieving response (supported by IE8 & 9)
>, <Line: +					// response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
>, <Line: +					var response = ('response' in xhr) ? xhr.response : xhr.responseText;
>, <Line: +					// normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
>, <Line: +					var status = xhr.status === 1223 ? 204 : xhr.status;
>, <Line: +					// fix status code when it is 0 (0 status is undocumented).
>, <Line: +					// Occurs when accessing file resources or on Android 4.1 stock browser
>, <Line: +					// while retrieving files from application cache.
>, <Line: +					if (status === 0) {
>, <Line: +						status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
>, <Line: +					}
>, <Line: +					completeRequest(callback,
>, <Line: +						status,
>, <Line: +						response,
>, <Line: +						xhr.getAllResponseHeaders(),
>, <Line: +						statusText);
>, <Line: +				};
>, <Line: +				var requestError = function () {
>, <Line: +					// The response is always empty
>, <Line: +					// See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
>, <Line: +					completeRequest(callback, -1, null, null, '');
>, <Line: +				};
>, <Line: +				xhr.onerror = requestError;
>, <Line: +				xhr.onabort = requestError;
>, <Line: +				if (withCredentials) {
>, <Line: +					xhr.withCredentials = true;
>, <Line: +				}
>, <Line: +				if (responseType) {
>, <Line: +					try {
>, <Line: +						xhr.responseType = responseType;
>, <Line: +					} catch (e) {
>, <Line: +						// WebKit added support for the json responseType value on 09/03/2013
>, <Line: +						// https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
>, <Line: +						// known to throw when setting the value "json" as the response type. Other older
>, <Line: +						// browsers implementing the responseType
>, <Line: +						//
>, <Line: +						// The json response type can be ignored if not supported, because JSON payloads are
>, <Line: +						// parsed on the client-side regardless.
>, <Line: +						if (responseType !== 'json') {
>, <Line: +							throw e;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				xhr.send(post || null);
>, <Line: +			}
>, <Line: +			if (timeout > 0) {
>, <Line: +				var timeoutId = $browserDefer(timeoutRequest, timeout);
>, <Line: +			} else if (isPromiseLike(timeout)) {
>, <Line: +				timeout.then(timeoutRequest);
>, <Line: +			}
>, <Line: +			function timeoutRequest() {
>, <Line: +				jsonpDone && jsonpDone();
>, <Line: +				xhr && xhr.abort();
>, <Line: +			}
>, <Line: +			function completeRequest(callback, status, response, headersString, statusText) {
>, <Line: +				// cancel timeout and subsequent timeout promise resolution
>, <Line: +				timeoutId && $browserDefer.cancel(timeoutId);
>, <Line: +				jsonpDone = xhr = null;
>, <Line: +				callback(status, response, headersString, statusText);
>, <Line: +				$browser.$$completeOutstandingRequest(noop);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		function jsonpReq(url, callbackId, done) {
>, <Line: +			// we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
>, <Line: +			// - fetches local scripts via XHR and evals them
>, <Line: +			// - adds and immediately removes script elements from the document
>, <Line: +			var script = rawDocument.createElement('script'), callback = null;
>, <Line: +			script.type = "text/javascript";
>, <Line: +			script.src = url;
>, <Line: +			script.async = true;
>, <Line: +			callback = function (event) {
>, <Line: +				removeEventListenerFn(script, "load", callback);
>, <Line: +				removeEventListenerFn(script, "error", callback);
>, <Line: +				rawDocument.body.removeChild(script);
>, <Line: +				script = null;
>, <Line: +				var status = -1;
>, <Line: +				var text = "unknown";
>, <Line: +				if (event) {
>, <Line: +					if (event.type === "load" && !callbacks[callbackId].called) {
>, <Line: +						event = {type: "error"};
>, <Line: +					}
>, <Line: +					text = event.type;
>, <Line: +					status = event.type === "error" ? 404 : 200;
>, <Line: +				}
>, <Line: +				if (done) {
>, <Line: +					done(status, text);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			addEventListenerFn(script, "load", callback);
>, <Line: +			addEventListenerFn(script, "error", callback);
>, <Line: +			rawDocument.body.appendChild(script);
>, <Line: +			return callback;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	var $interpolateMinErr = minErr('$interpolate');
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $interpolateProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="customInterpolationApp">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 var customInterpolationApp = angular.module('customInterpolationApp', []);
>, <Line: +	 customInterpolationApp.config(function($interpolateProvider) {
>, <Line: +    $interpolateProvider.startSymbol('//');
>, <Line: +    $interpolateProvider.endSymbol('//');
>, <Line: +	 customInterpolationApp.controller('DemoController', function() {
>, <Line: +      this.label = "This binding is brought you by // interpolation symbols.";
>, <Line: +  });
>, <Line: +	 </script>
>, <Line: +	 <div ng-app="App" ng-controller="DemoController as demo">
>, <Line: +	 //demo.label//
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should interpolate binding with custom symbols', function() {
>, <Line: +    expect(element(by.binding('demo.label')).getText()).toBe('This binding is brought you by // interpolation symbols.');
>, <Line: +  });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function $InterpolateProvider() {
>, <Line: +		var startSymbol = '{{';
>, <Line: +		var endSymbol = '}}';
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $interpolateProvider#startSymbol
>, <Line: +		 * @description
>, <Line: +		 * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
>, <Line: +   *
>, <Line: +		 * @param {string=} value new value to set the starting symbol to.
>, <Line: +		 * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
>, <Line: +		 */
>, <Line: +		this.startSymbol = function (value) {
>, <Line: +			if (value) {
>, <Line: +				startSymbol = value;
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return startSymbol;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $interpolateProvider#endSymbol
>, <Line: +		 * @description
>, <Line: +		 * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
>, <Line: +		 *
>, <Line: +		 * @param {string=} value new value to set the ending symbol to.
>, <Line: +		 * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
>, <Line: +		 */
>, <Line: +		this.endSymbol = function (value) {
>, <Line: +			if (value) {
>, <Line: +				endSymbol = value;
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return endSymbol;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = ['$parse', '$exceptionHandler', '$sce', function ($parse, $exceptionHandler, $sce) {
>, <Line: +			var startSymbolLength = startSymbol.length,
>, <Line: +				endSymbolLength = endSymbol.length,
>, <Line: +				escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
>, <Line: +				escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
>, <Line: +			function escape(ch) {
>, <Line: +				return '\\\\\\' + ch;
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc service
>, <Line: +			 * @name $interpolate
>, <Line: +			 * @kind function
>, <Line: +			 *
>, <Line: +			 * @requires $parse
>, <Line: +			 * @requires $sce
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 *
>, <Line: +			 * Compiles a string with markup into an interpolation function. This service is used by the
>, <Line: +			 * HTML {@link ng.$compile $compile} service for data binding. See
>, <Line: +			 * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
>, <Line: +			 * interpolation markup.
>, <Line: +			 *
>, <Line: +			 *
>, <Line: +			 * ```js
>, <Line: +			 *   var $interpolate = ...; // injected
>, <Line: +			 *   var exp = $interpolate('Hello {{name | uppercase}}!');
>, <Line: +			 *   expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');
>, <Line: +			 * ```
>, <Line: +			 *
>, <Line: +			 * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
>, <Line: +			 * `true`, the interpolation function will return `undefined` unless all embedded expressions
>, <Line: +			 * evaluate to a value other than `undefined`.
>, <Line: +			 *
>, <Line: +			 * ```js
>, <Line: +			 *   var $interpolate = ...; // injected
>, <Line: +			 *   var context = {greeting: 'Hello', name: undefined };
>, <Line: +			 *
>, <Line: +			 *   // default "forgiving" mode
>, <Line: +			 *   var exp = $interpolate('{{greeting}} {{name}}!');
>, <Line: +			 *   expect(exp(context)).toEqual('Hello !');
>, <Line: +			 *
>, <Line: +			 *   // "allOrNothing" mode
>, <Line: +			 *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
>, <Line: +			 *   expect(exp(context)).toBeUndefined();
>, <Line: +			 *   context.name = 'Angular';
>, <Line: +			 *   expect(exp(context)).toEqual('Hello Angular!');
>, <Line: +			 * ```
>, <Line: +			 *
>, <Line: +			 * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.
>, <Line: +			 *
>, <Line: +			 * ####Escaped Interpolation
>, <Line: +			 * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers
>, <Line: +			 * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).
>, <Line: +			 * It will be rendered as a regular start/end marker, and will not be interpreted as an expression
>, <Line: +			 * or binding.
>, <Line: +			 *
>, <Line: +			 * This enables web-servers to prevent script injection attacks and defacing attacks, to some
>, <Line: +			 * degree, while also enabling code examples to work without relying on the
>, <Line: +			 * {@link ng.directive:ngNonBindable ngNonBindable} directive.
>, <Line: +			 *
>, <Line: +			 * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,
>, <Line: +			 * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all
>, <Line: +			 * interpolation start/end markers with their escaped counterparts.**
>, <Line: +			 *
>, <Line: +			 * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered
>, <Line: +			 * output when the $interpolate service processes the text. So, for HTML elements interpolated
>, <Line: +			 * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter
>, <Line: +			 * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,
>, <Line: +			 * this is typically useful only when user-data is used in rendering a template from the server, or
>, <Line: +			 * when otherwise untrusted data is used by a directive.
>, <Line: +			 *
>, <Line: +			 * <example>
>, <Line: +			 *  <file name="index.html">
>, <Line: +			 *    <div ng-init="username='A user'">
>, <Line: +			 *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
>, <Line: +			 *        </p>
>, <Line: +			 *      <p><strong>{{username}}</strong> attempts to inject code which will deface the
>, <Line: +			 *        application, but fails to accomplish their task, because the server has correctly
>, <Line: +			 *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)
>, <Line: +			 *        characters.</p>
>, <Line: +			 *      <p>Instead, the result of the attempted script injection is visible, and can be removed
>, <Line: +			 *        from the database by an administrator.</p>
>, <Line: +			 *    </div>
>, <Line: +			 *  </file>
>, <Line: +			 * </example>
>, <Line: +			 *
>, <Line: +			 * @param {string} text The text with markup to interpolate.
>, <Line: +			 * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
>, <Line: +			 *    embedded expression in order to return an interpolation function. Strings with no
>, <Line: +			 *    embedded expression will return null for the interpolation function.
>, <Line: +			 * @param {string=} trustedContext when provided, the returned function passes the interpolated
>, <Line: +			 *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
>, <Line: +     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
>, <Line: +			 *    provides Strict Contextual Escaping for details.
>, <Line: +			 * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
>, <Line: +			 *    unless all embedded expressions evaluate to a value other than `undefined`.
>, <Line: +			 * @returns {function(context)} an interpolation function which is used to compute the
>, <Line: +			 *    interpolated string. The function has these parameters:
>, <Line: +			 *
>, <Line: +			 * - `context`: evaluation context for all expressions embedded in the interpolated text
>, <Line: +			 */
>, <Line: +			function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
>, <Line: +				allOrNothing = !!allOrNothing;
>, <Line: +				var startIndex,
>, <Line: +					endIndex,
>, <Line: +					index = 0,
>, <Line: +					expressions = [],
>, <Line: +					parseFns = [],
>, <Line: +					textLength = text.length,
>, <Line: +					exp,
>, <Line: +					concat = [],
>, <Line: +					expressionPositions = [];
>, <Line: +				while (index < textLength) {
>, <Line: +					if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&
>, <Line: +						((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
>, <Line: +						if (index !== startIndex) {
>, <Line: +							concat.push(unescapeText(text.substring(index, startIndex)));
>, <Line: +						}
>, <Line: +						exp = text.substring(startIndex + startSymbolLength, endIndex);
>, <Line: +						expressions.push(exp);
>, <Line: +						parseFns.push($parse(exp, parseStringifyInterceptor));
>, <Line: +						index = endIndex + endSymbolLength;
>, <Line: +						expressionPositions.push(concat.length);
>, <Line: +						concat.push('');
>, <Line: +					} else {
>, <Line: +						// we did not find an interpolation, so we have to add the remainder to the separators array
>, <Line: +						if (index !== textLength) {
>, <Line: +							concat.push(unescapeText(text.substring(index)));
>, <Line: +						}
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				// Concatenating expressions makes it hard to reason about whether some combination of
>, <Line: +				// concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
>, <Line: +				// single expression be used for iframe[src], object[src], etc., we ensure that the value
>, <Line: +				// that's used is assigned or constructed by some JS code somewhere that is more testable or
>, <Line: +				// make it obvious that you bound the value to some user controlled value.  This helps reduce
>, <Line: +				// the load when auditing for XSS issues.
>, <Line: +				if (trustedContext && concat.length > 1) {
>, <Line: +					throw $interpolateMinErr('noconcat',
>, <Line: +						"Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
>, <Line: +						"interpolations that concatenate multiple expressions when a trusted value is " +
>, <Line: +						"required.  See http://docs.angularjs.org/api/ng.$sce", text);
>, <Line: +				}
>, <Line: +				if (!mustHaveExpression || expressions.length) {
>, <Line: +					var compute = function (values) {
>, <Line: +						for (var i = 0, ii = expressions.length; i < ii; i++) {
>, <Line: +							if (allOrNothing && isUndefined(values[i])) return;
>, <Line: +							concat[expressionPositions[i]] = values[i];
>, <Line: +						}
>, <Line: +						return concat.join('');
>, <Line: +					};
>, <Line: +					var getValue = function (value) {
>, <Line: +						return trustedContext ?
>, <Line: +							$sce.getTrusted(trustedContext, value) :
>, <Line: +							$sce.valueOf(value);
>, <Line: +					};
>, <Line: +					var stringify = function (value) {
>, <Line: +						if (value == null) { // null || undefined
>, <Line: +							return '';
>, <Line: +						}
>, <Line: +						switch (typeof value) {
>, <Line: +							case 'string':
>, <Line: +								break;
>, <Line: +							case 'number':
>, <Line: +								value = '' + value;
>, <Line: +								break;
>, <Line: +							default:
>, <Line: +								value = toJson(value);
>, <Line: +						}
>, <Line: +						return value;
>, <Line: +					};
>, <Line: +					return extend(function interpolationFn(context) {
>, <Line: +						var i = 0;
>, <Line: +						var ii = expressions.length;
>, <Line: +						var values = new Array(ii);
>, <Line: +						try {
>, <Line: +							for (; i < ii; i++) {
>, <Line: +								values[i] = parseFns[i](context);
>, <Line: +							}
>, <Line: +							return compute(values);
>, <Line: +						} catch (err) {
>, <Line: +							var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text,
>, <Line: +								err.toString());
>, <Line: +							$exceptionHandler(newErr);
>, <Line: +						}
>, <Line: +					}, {
>, <Line: +						// all of these properties are undocumented for now
>, <Line: +						exp: text, //just for compatibility with regular watchers created via $watch
>, <Line: +						expressions: expressions,
>, <Line: +						$$watchDelegate: function (scope, listener, objectEquality) {
>, <Line: +							var lastValue;
>, <Line: +							return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
>, <Line: +								var currValue = compute(values);
>, <Line: +								if (isFunction(listener)) {
>, <Line: +									listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
>, <Line: +								}
>, <Line: +								lastValue = currValue;
>, <Line: +							}, objectEquality);
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +				function unescapeText(text) {
>, <Line: +					return text.replace(escapedStartRegexp, startSymbol).
>, <Line: +						replace(escapedEndRegexp, endSymbol);
>, <Line: +				}
>, <Line: +				function parseStringifyInterceptor(value) {
>, <Line: +					try {
>, <Line: +						value = getValue(value);
>, <Line: +						return allOrNothing && !isDefined(value) ? value : stringify(value);
>, <Line: +					} catch (err) {
>, <Line: +						var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text,
>, <Line: +							err.toString());
>, <Line: +						$exceptionHandler(newErr);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $interpolate#startSymbol
>, <Line: +			 * @description
>, <Line: +			 * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
>, <Line: +     * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
>, <Line: +     * the symbol.
>, <Line: +			 * @returns {string} start symbol.
>, <Line: +			 */
>, <Line: +			$interpolate.startSymbol = function () {
>, <Line: +				return startSymbol;
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $interpolate#endSymbol
>, <Line: +			 * @description
>, <Line: +			 * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
>, <Line: +			 *
>, <Line: +			 * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
>, <Line: +			 * the symbol.
>, <Line: +			 *
>, <Line: +			 * @returns {string} end symbol.
>, <Line: +			 */
>, <Line: +			$interpolate.endSymbol = function () {
>, <Line: +				return endSymbol;
>, <Line: +			};
>, <Line: +			return $interpolate;
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	function $IntervalProvider() {
>, <Line: +		this.$get = ['$rootScope', '$window', '$q', '$$q',
>, <Line: +			function ($rootScope, $window, $q, $$q) {
>, <Line: +				var intervals = {};
>, <Line: +				/**
>, <Line: +				 * @ngdoc service
>, <Line: +				 * @name $interval
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
>, <Line: +				 * milliseconds.
>, <Line: +				 *
>, <Line: +				 * The return value of registering an interval function is a promise. This promise will be
>, <Line: +				 * notified upon each tick of the interval, and will be resolved after `count` iterations, or
>, <Line: +				 * run indefinitely if `count` is not defined. The value of the notification will be the
>, <Line: +				 * number of iterations that have run.
>, <Line: +				 * To cancel an interval, call `$interval.cancel(promise)`.
>, <Line: +				 *
>, <Line: +				 * In tests you can use {@link ngMock.$interval#flush `$interval.flush(millis)`} to
>, <Line: +				 * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
>, <Line: +				 * time.
>, <Line: +				 *
>, <Line: +				 * <div class="alert alert-warning">
>, <Line: +				 * **Note**: Intervals created by this service must be explicitly destroyed when you are finished
>, <Line: +				 * with them.  In particular they are not automatically destroyed when a controller's scope or a
>, <Line: +				 * directive's element are destroyed.
>, <Line: +				 * You should take this into consideration and make sure to always cancel the interval at the
>, <Line: +				 * appropriate moment.  See the example below for more details on how and when to do this.
>, <Line: +				 * </div>
>, <Line: +				 *
>, <Line: +				 * @param {function()} fn A function that should be called repeatedly.
>, <Line: +				 * @param {number} delay Number of milliseconds between each function call.
>, <Line: +				 * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
>, <Line: +				 *   indefinitely.
>, <Line: +				 * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: +				 *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: +				 * @returns {promise} A promise which will be notified on each iteration.
>, <Line: +				 *
>, <Line: +				 * @example
>, <Line: +				 * <example module="intervalExample">
>, <Line: +				 * <file name="index.html">
>, <Line: +				 *   <script>
>, <Line: +				 *     angular.module('intervalExample', [])
>, <Line: +				 *       .controller('ExampleController', ['$scope', '$interval',
>, <Line: +				 *         function($scope, $interval) {
>, <Line: +      *           $scope.format = 'M/d/yy h:mm:ss a';
>, <Line: +      *           $scope.blood_1 = 100;
>, <Line: +      *           $scope.blood_2 = 120;
>, <Line: +      *
>, <Line: +      *           var stop;
>, <Line: +      *           $scope.fight = function() {
>, <Line: +      *             // Don't start a new fight if we are already fighting
>, <Line: +      *             if ( angular.isDefined(stop) ) return;
>, <Line: +      *
>, <Line: +      *           stop = $interval(function() {
>, <Line: +      *             if ($scope.blood_1 > 0 && $scope.blood_2 > 0) {
>, <Line: +      *               $scope.blood_1 = $scope.blood_1 - 3;
>, <Line: +      *               $scope.blood_2 = $scope.blood_2 - 4;
>, <Line: +      *             } else {
>, <Line: +      *               $scope.stopFight();
>, <Line: +      *             }
>, <Line: +      *           }, 100);
>, <Line: +      *         };
>, <Line: +      *
>, <Line: +      *         $scope.stopFight = function() {
>, <Line: +      *           if (angular.isDefined(stop)) {
>, <Line: +      *             $interval.cancel(stop);
>, <Line: +      *             stop = undefined;
>, <Line: +      *           }
>, <Line: +      *         };
>, <Line: +      *
>, <Line: +      *         $scope.resetFight = function() {
>, <Line: +      *           $scope.blood_1 = 100;
>, <Line: +      *           $scope.blood_2 = 120;
>, <Line: +      *         };
>, <Line: +      *
>, <Line: +      *         $scope.$on('$destroy', function() {
>, <Line: +      *           // Make sure that the interval is destroyed too
>, <Line: +      *           $scope.stopFight();
>, <Line: +      *         });
>, <Line: +      *       }])
>, <Line: +				 *       // Register the 'myCurrentTime' directive factory method.
>, <Line: +				 *       // We inject $interval and dateFilter service since the factory method is DI.
>, <Line: +				 *       .directive('myCurrentTime', ['$interval', 'dateFilter',
>, <Line: +				 *         function($interval, dateFilter) {
>, <Line: +      *           // return the directive link function. (compile function not needed)
>, <Line: +      *           return function(scope, element, attrs) {
>, <Line: +      *             var format,  // date format
>, <Line: +      *                 stopTime; // so that we can cancel the time updates
>, <Line: +      *
>, <Line: +      *             // used to update the UI
>, <Line: +      *             function updateTime() {
>, <Line: +      *               element.text(dateFilter(new Date(), format));
>, <Line: +      *             }
>, <Line: +      *
>, <Line: +      *             // watch the expression, and update the UI on change.
>, <Line: +      *             scope.$watch(attrs.myCurrentTime, function(value) {
>, <Line: +      *               format = value;
>, <Line: +      *               updateTime();
>, <Line: +      *             });
>, <Line: +      *             stopTime = $interval(updateTime, 1000);
>, <Line: +      *
>, <Line: +      *             // listen on DOM destroy (removal) event, and cancel the next UI update
>, <Line: +      *             // to prevent updating time after the DOM element was removed.
>, <Line: +      *             element.on('$destroy', function() {
>, <Line: +      *               $interval.cancel(stopTime);
>, <Line: +      *             });
>, <Line: +      *           }
>, <Line: +      *         }]);
>, <Line: +				 *   </script>
>, <Line: +				 *
>, <Line: +				 *   <div>
>, <Line: +				 *     <div ng-controller="ExampleController">
>, <Line: +				 *       Date format: <input ng-model="format"> <hr/>
>, <Line: +				 *       Current time is: <span my-current-time="format"></span>
>, <Line: +				 *       <hr/>
>, <Line: +				 *       Blood 1 : <font color='red'>{{blood_1}}</font>
>, <Line: +				 *       Blood 2 : <font color='red'>{{blood_2}}</font>
>, <Line: +				 *       <button type="button" data-ng-click="fight()">Fight</button>
>, <Line: +				 *       <button type="button" data-ng-click="stopFight()">StopFight</button>
>, <Line: +				 *       <button type="button" data-ng-click="resetFight()">resetFight</button>
>, <Line: +				 *     </div>
>, <Line: +				 *   </div>
>, <Line: +				 *
>, <Line: +				 * </file>
>, <Line: +				 * </example>
>, <Line: +				 */
>, <Line: +				function interval(fn, delay, count, invokeApply) {
>, <Line: +					var setInterval = $window.setInterval,
>, <Line: +						clearInterval = $window.clearInterval,
>, <Line: +						iteration = 0,
>, <Line: +						skipApply = (isDefined(invokeApply) && !invokeApply),
>, <Line: +						deferred = (skipApply ? $$q : $q).defer(),
>, <Line: +						promise = deferred.promise;
>, <Line: +					count = isDefined(count) ? count : 0;
>, <Line: +					promise.then(null, null, fn);
>, <Line: +					promise.$$intervalId = setInterval(function tick() {
>, <Line: +						deferred.notify(iteration++);
>, <Line: +						if (count > 0 && iteration >= count) {
>, <Line: +							deferred.resolve(iteration);
>, <Line: +							clearInterval(promise.$$intervalId);
>, <Line: +							delete intervals[promise.$$intervalId];
>, <Line: +						}
>, <Line: +						if (!skipApply) $rootScope.$apply();
>, <Line: +					}, delay);
>, <Line: +					intervals[promise.$$intervalId] = deferred;
>, <Line: +					return promise;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $interval#cancel
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Cancels a task associated with the `promise`.
>, <Line: +				 *
>, <Line: +				 * @param {promise} promise returned by the `$interval` function.
>, <Line: +				 * @returns {boolean} Returns `true` if the task was successfully canceled.
>, <Line: +				 */
>, <Line: +				interval.cancel = function (promise) {
>, <Line: +					if (promise && promise.$$intervalId in intervals) {
>, <Line: +						intervals[promise.$$intervalId].reject('canceled');
>, <Line: +						$window.clearInterval(promise.$$intervalId);
>, <Line: +						delete intervals[promise.$$intervalId];
>, <Line: +						return true;
>, <Line: +					}
>, <Line: +					return false;
>, <Line: +				};
>, <Line: +				return interval;
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $locale
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * $locale service provides localization rules for various Angular components. As of right now the
>, <Line: +	 * only public api is:
>, <Line: +	 *
>, <Line: +	 * * `id`  `{string}`  locale id formatted as `languageId-countryId` (e.g. `en-us`)
>, <Line: +	 */
>, <Line: +	function $LocaleProvider() {
>, <Line: +		this.$get = function () {
>, <Line: +			return {
>, <Line: +				id: 'en-us',
>, <Line: +				NUMBER_FORMATS: {
>, <Line: +					DECIMAL_SEP: '.',
>, <Line: +					GROUP_SEP: ',',
>, <Line: +					PATTERNS: [
>, <Line: +						{ // Decimal Pattern
>, <Line: +							minInt: 1,
>, <Line: +							minFrac: 0,
>, <Line: +							maxFrac: 3,
>, <Line: +							posPre: '',
>, <Line: +							posSuf: '',
>, <Line: +							negPre: '-',
>, <Line: +							negSuf: '',
>, <Line: +							gSize: 3,
>, <Line: +							lgSize: 3
>, <Line: +						}, { //Currency Pattern
>, <Line: +							minInt: 1,
>, <Line: +							minFrac: 2,
>, <Line: +							maxFrac: 2,
>, <Line: +							posPre: '\u00A4',
>, <Line: +							posSuf: '',
>, <Line: +							negPre: '(\u00A4',
>, <Line: +							negSuf: ')',
>, <Line: +							gSize: 3,
>, <Line: +							lgSize: 3
>, <Line: +						}
>, <Line: +					],
>, <Line: +					CURRENCY_SYM: '$'
>, <Line: +				},
>, <Line: +				DATETIME_FORMATS: {
>, <Line: +					MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'
>, <Line: +						.split(','),
>, <Line: +					SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
>, <Line: +					DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
>, <Line: +					SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
>, <Line: +					AMPMS: ['AM', 'PM'],
>, <Line: +					medium: 'MMM d, y h:mm:ss a',
>, <Line: +					'short': 'M/d/yy h:mm a',
>, <Line: +					fullDate: 'EEEE, MMMM d, y',
>, <Line: +					longDate: 'MMMM d, y',
>, <Line: +					mediumDate: 'MMM d, y',
>, <Line: +					shortDate: 'M/d/yy',
>, <Line: +					mediumTime: 'h:mm:ss a',
>, <Line: +					shortTime: 'h:mm a'
>, <Line: +				},
>, <Line: +				pluralCat: function (num) {
>, <Line: +					if (num === 1) {
>, <Line: +						return 'one';
>, <Line: +					}
>, <Line: +					return 'other';
>, <Line: +				}
>, <Line: +			};
>, <Line: +		};
>, <Line: +	}
>, <Line: +	var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
>, <Line: +		DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
>, <Line: +	var $locationMinErr = minErr('$location');
>, <Line: +	/**
>, <Line: +	 * Encode path using encodeUriSegment, ignoring forward slashes
>, <Line: +	 *
>, <Line: +	 * @param {string} path Path to encode
>, <Line: +	 * @returns {string}
>, <Line: +	 */
>, <Line: +	function encodePath(path) {
>, <Line: +		var segments = path.split('/'),
>, <Line: +			i = segments.length;
>, <Line: +		while (i--) {
>, <Line: +			segments[i] = encodeUriSegment(segments[i]);
>, <Line: +		}
>, <Line: +		return segments.join('/');
>, <Line: +	}
>, <Line: +	function parseAbsoluteUrl(absoluteUrl, locationObj) {
>, <Line: +		var parsedUrl = urlResolve(absoluteUrl);
>, <Line: +		locationObj.$$protocol = parsedUrl.protocol;
>, <Line: +		locationObj.$$host = parsedUrl.hostname;
>, <Line: +		locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
>, <Line: +	}
>, <Line: +	function parseAppUrl(relativeUrl, locationObj) {
>, <Line: +		var prefixed = (relativeUrl.charAt(0) !== '/');
>, <Line: +		if (prefixed) {
>, <Line: +			relativeUrl = '/' + relativeUrl;
>, <Line: +		}
>, <Line: +		var match = urlResolve(relativeUrl);
>, <Line: +		locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
>, <Line: +			match.pathname.substring(1) : match.pathname);
>, <Line: +		locationObj.$$search = parseKeyValue(match.search);
>, <Line: +		locationObj.$$hash = decodeURIComponent(match.hash);
>, <Line: +		// make sure path starts with '/';
>, <Line: +		if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
>, <Line: +			locationObj.$$path = '/' + locationObj.$$path;
>, <Line: +		}
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 *
>, <Line: +	 * @param {string} begin
>, <Line: +	 * @param {string} whole
>, <Line: +	 * @returns {string} returns text from whole after begin or undefined if it does not begin with
>, <Line: +	 *                   expected string.
>, <Line: +	 */
>, <Line: +	function beginsWith(begin, whole) {
>, <Line: +		if (whole.indexOf(begin) === 0) {
>, <Line: +			return whole.substr(begin.length);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function stripHash(url) {
>, <Line: +		var index = url.indexOf('#');
>, <Line: +		return index == -1 ? url : url.substr(0, index);
>, <Line: +	}
>, <Line: +	function stripFile(url) {
>, <Line: +		return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
>, <Line: +	}
>, <Line: +	/* return the server only (scheme://host:port) */
>, <Line: +	function serverBase(url) {
>, <Line: +		return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * LocationHtml5Url represents an url
>, <Line: +	 * This object is exposed as $location service when HTML5 mode is enabled and supported
>, <Line: +	 *
>, <Line: +	 * @constructor
>, <Line: +	 * @param {string} appBase application base URL
>, <Line: +	 * @param {string} basePrefix url path prefix
>, <Line: +	 */
>, <Line: +	function LocationHtml5Url(appBase, basePrefix) {
>, <Line: +		this.$$html5 = true;
>, <Line: +		basePrefix = basePrefix || '';
>, <Line: +		var appBaseNoFile = stripFile(appBase);
>, <Line: +		parseAbsoluteUrl(appBase, this);
>, <Line: +		/**
>, <Line: +		 * Parse given html5 (regular) url string into properties
>, <Line: +		 * @param {string} url HTML5 url
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		this.$$parse = function (url) {
>, <Line: +			var pathUrl = beginsWith(appBaseNoFile, url);
>, <Line: +			if (!isString(pathUrl)) {
>, <Line: +				throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
>, <Line: +					appBaseNoFile);
>, <Line: +			}
>, <Line: +			parseAppUrl(pathUrl, this);
>, <Line: +			if (!this.$$path) {
>, <Line: +				this.$$path = '/';
>, <Line: +			}
>, <Line: +			this.$$compose();
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Compose url and update `absUrl` property
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		this.$$compose = function () {
>, <Line: +			var search = toKeyValue(this.$$search),
>, <Line: +				hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: +			this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: +			this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
>, <Line: +		};
>, <Line: +		this.$$parseLinkUrl = function (url, relHref) {
>, <Line: +			if (relHref && relHref[0] === '#') {
>, <Line: +				// special case for links to hash fragments:
>, <Line: +				// keep the old url and only replace the hash fragment
>, <Line: +				this.hash(relHref.slice(1));
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			var appUrl, prevAppUrl;
>, <Line: +			var rewrittenUrl;
>, <Line: +			if ((appUrl = beginsWith(appBase, url)) !== undefined) {
>, <Line: +				prevAppUrl = appUrl;
>, <Line: +				if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
>, <Line: +					rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
>, <Line: +				} else {
>, <Line: +					rewrittenUrl = appBase + prevAppUrl;
>, <Line: +				}
>, <Line: +			} else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
>, <Line: +				rewrittenUrl = appBaseNoFile + appUrl;
>, <Line: +			} else if (appBaseNoFile == url + '/') {
>, <Line: +				rewrittenUrl = appBaseNoFile;
>, <Line: +			}
>, <Line: +			if (rewrittenUrl) {
>, <Line: +				this.$$parse(rewrittenUrl);
>, <Line: +			}
>, <Line: +			return !!rewrittenUrl;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * LocationHashbangUrl represents url
>, <Line: +	 * This object is exposed as $location service when developer doesn't opt into html5 mode.
>, <Line: +	 * It also serves as the base class for html5 mode fallback on legacy browsers.
>, <Line: +	 *
>, <Line: +	 * @constructor
>, <Line: +	 * @param {string} appBase application base URL
>, <Line: +	 * @param {string} hashPrefix hashbang prefix
>, <Line: +	 */
>, <Line: +	function LocationHashbangUrl(appBase, hashPrefix) {
>, <Line: +		var appBaseNoFile = stripFile(appBase);
>, <Line: +		parseAbsoluteUrl(appBase, this);
>, <Line: +		/**
>, <Line: +		 * Parse given hashbang url into properties
>, <Line: +		 * @param {string} url Hashbang url
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		this.$$parse = function (url) {
>, <Line: +			var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
>, <Line: +			var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
>, <Line: +				? beginsWith(hashPrefix, withoutBaseUrl)
>, <Line: +				: (this.$$html5)
>, <Line: +				? withoutBaseUrl
>, <Line: +				: '';
>, <Line: +			if (!isString(withoutHashUrl)) {
>, <Line: +				throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url,
>, <Line: +					hashPrefix);
>, <Line: +			}
>, <Line: +			parseAppUrl(withoutHashUrl, this);
>, <Line: +			this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
>, <Line: +			this.$$compose();
>, <Line: +			/*
>, <Line: +			 * In Windows, on an anchor node on documents loaded from
>, <Line: +			 * the filesystem, the browser will return a pathname
>, <Line: +			 * prefixed with the drive name ('/C:/path') when a
>, <Line: +			 * pathname without a drive is set:
>, <Line: +			 *  * a.setAttribute('href', '/foo')
>, <Line: +			 *   * a.pathname === '/C:/foo' //true
>, <Line: +			 *
>, <Line: +			 * Inside of Angular, we're always using pathnames that
>, <Line: +			 * do not include drive names for routing.
>, <Line: +			 */
>, <Line: +			function removeWindowsDriveName(path, url, base) {
>, <Line: +				/*
>, <Line: +				 Matches paths for file protocol on windows,
>, <Line: +				 such as /C:/foo/bar, and captures only /foo/bar.
>, <Line: +				 */
>, <Line: +				var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
>, <Line: +				var firstPathSegmentMatch;
>, <Line: +				//Get the relative path from the input URL.
>, <Line: +				if (url.indexOf(base) === 0) {
>, <Line: +					url = url.replace(base, '');
>, <Line: +				}
>, <Line: +				// The input URL intentionally contains a first path segment that ends with a colon.
>, <Line: +				if (windowsFilePathExp.exec(url)) {
>, <Line: +					return path;
>, <Line: +				}
>, <Line: +				firstPathSegmentMatch = windowsFilePathExp.exec(path);
>, <Line: +				return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * Compose hashbang url and update `absUrl` property
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		this.$$compose = function () {
>, <Line: +			var search = toKeyValue(this.$$search),
>, <Line: +				hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: +			this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: +			this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
>, <Line: +		};
>, <Line: +		this.$$parseLinkUrl = function (url, relHref) {
>, <Line: +			if (stripHash(appBase) == stripHash(url)) {
>, <Line: +				this.$$parse(url);
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * LocationHashbangUrl represents url
>, <Line: +	 * This object is exposed as $location service when html5 history api is enabled but the browser
>, <Line: +	 * does not support it.
>, <Line: +	 *
>, <Line: +	 * @constructor
>, <Line: +	 * @param {string} appBase application base URL
>, <Line: +	 * @param {string} hashPrefix hashbang prefix
>, <Line: +	 */
>, <Line: +	function LocationHashbangInHtml5Url(appBase, hashPrefix) {
>, <Line: +		this.$$html5 = true;
>, <Line: +		LocationHashbangUrl.apply(this, arguments);
>, <Line: +		var appBaseNoFile = stripFile(appBase);
>, <Line: +		this.$$parseLinkUrl = function (url, relHref) {
>, <Line: +			if (relHref && relHref[0] === '#') {
>, <Line: +				// special case for links to hash fragments:
>, <Line: +				// keep the old url and only replace the hash fragment
>, <Line: +				this.hash(relHref.slice(1));
>, <Line: +				return true;
>, <Line: +			}
>, <Line: +			var rewrittenUrl;
>, <Line: +			var appUrl;
>, <Line: +			if (appBase == stripHash(url)) {
>, <Line: +				rewrittenUrl = url;
>, <Line: +			} else if ((appUrl = beginsWith(appBaseNoFile, url))) {
>, <Line: +				rewrittenUrl = appBase + hashPrefix + appUrl;
>, <Line: +			} else if (appBaseNoFile === url + '/') {
>, <Line: +				rewrittenUrl = appBaseNoFile;
>, <Line: +			}
>, <Line: +			if (rewrittenUrl) {
>, <Line: +				this.$$parse(rewrittenUrl);
>, <Line: +			}
>, <Line: +			return !!rewrittenUrl;
>, <Line: +		};
>, <Line: +		this.$$compose = function () {
>, <Line: +			var search = toKeyValue(this.$$search),
>, <Line: +				hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: +			this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: +			// include hashPrefix in $$absUrl when $$url is empty so IE8 & 9 do not reload page because of removal of '#'
>, <Line: +			this.$$absUrl = appBase + hashPrefix + this.$$url;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	var locationPrototype = {
>, <Line: +		/**
>, <Line: +		 * Are we in html5 mode?
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		$$html5: false,
>, <Line: +		/**
>, <Line: +		 * Has any change been replacing?
>, <Line: +		 * @private
>, <Line: +		 */
>, <Line: +		$$replace: false,
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#absUrl
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter only.
>, <Line: +		 *
>, <Line: +		 * Return full url representation with all segments encoded according to rules specified in
>, <Line: +		 * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var absUrl = $location.absUrl();
>, <Line: +		 * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @return {string} full url
>, <Line: +		 */
>, <Line: +		absUrl: locationGetter('$$absUrl'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#url
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter / setter.
>, <Line: +		 *
>, <Line: +		 * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
>, <Line: +		 *
>, <Line: +		 * Change path, search and hash, when called with parameter and return `$location`.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var url = $location.url();
>, <Line: +		 * // => "/some/path?foo=bar&baz=xoxo"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
>, <Line: +		 * @return {string} url
>, <Line: +		 */
>, <Line: +		url: function (url) {
>, <Line: +			if (isUndefined(url))
>, <Line: +				return this.$$url;
>, <Line: +			var match = PATH_MATCH.exec(url);
>, <Line: +			if (match[1] || url === '') this.path(decodeURIComponent(match[1]));
>, <Line: +			if (match[2] || match[1] || url === '') this.search(match[3] || '');
>, <Line: +			this.hash(match[5] || '');
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#protocol
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter only.
>, <Line: +		 *
>, <Line: +		 * Return protocol of current url.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var protocol = $location.protocol();
>, <Line: +		 * // => "http"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @return {string} protocol of current url
>, <Line: +		 */
>, <Line: +		protocol: locationGetter('$$protocol'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#host
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter only.
>, <Line: +		 *
>, <Line: +		 * Return host of current url.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var host = $location.host();
>, <Line: +		 * // => "example.com"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @return {string} host of current url.
>, <Line: +		 */
>, <Line: +		host: locationGetter('$$host'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#port
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter only.
>, <Line: +		 *
>, <Line: +		 * Return port of current url.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var port = $location.port();
>, <Line: +		 * // => 80
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @return {Number} port
>, <Line: +		 */
>, <Line: +		port: locationGetter('$$port'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#path
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter / setter.
>, <Line: +		 *
>, <Line: +		 * Return path of current url when called without any parameter.
>, <Line: +		 *
>, <Line: +		 * Change path when called with parameter and return `$location`.
>, <Line: +		 *
>, <Line: +		 * Note: Path should always begin with forward slash (/), this method will add the forward slash
>, <Line: +		 * if it is missing.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var path = $location.path();
>, <Line: +		 * // => "/some/path"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {(string|number)=} path New path
>, <Line: +		 * @return {string} path
>, <Line: +		 */
>, <Line: +		path: locationGetterSetter('$$path', function (path) {
>, <Line: +			path = path !== null ? path.toString() : '';
>, <Line: +			return path.charAt(0) == '/' ? path : '/' + path;
>, <Line: +		}),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#search
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter / setter.
>, <Line: +		 *
>, <Line: +		 * Return search part (as object) of current url when called without any parameter.
>, <Line: +		 *
>, <Line: +		 * Change search part when called with parameter and return `$location`.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: +		 * var searchObject = $location.search();
>, <Line: +		 * // => {foo: 'bar', baz: 'xoxo'}
>, <Line: +		 *
>, <Line: +		 * // set foo to 'yipee'
>, <Line: +		 * $location.search('foo', 'yipee');
>, <Line: +		 * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
>, <Line: +		 * hash object.
>, <Line: +		 *
>, <Line: +		 * When called with a single argument the method acts as a setter, setting the `search` component
>, <Line: +		 * of `$location` to the specified value.
>, <Line: +		 *
>, <Line: +		 * If the argument is a hash object containing an array of values, these values will be encoded
>, <Line: +		 * as duplicate search parameters in the url.
>, <Line: +		 *
>, <Line: +		 * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number, then `paramValue`
>, <Line: +		 * will override only a single search property.
>, <Line: +		 *
>, <Line: +		 * If `paramValue` is an array, it will override the property of the `search` component of
>, <Line: +		 * `$location` specified via the first argument.
>, <Line: +		 *
>, <Line: +		 * If `paramValue` is `null`, the property specified via the first argument will be deleted.
>, <Line: +		 *
>, <Line: +		 * If `paramValue` is `true`, the property specified via the first argument will be added with no
>, <Line: +		 * value nor trailing equal sign.
>, <Line: +		 *
>, <Line: +		 * @return {Object} If called with no arguments returns the parsed `search` object. If called with
>, <Line: +		 * one or more arguments returns `$location` object itself.
>, <Line: +		 */
>, <Line: +		search: function (search, paramValue) {
>, <Line: +			switch (arguments.length) {
>, <Line: +				case 0:
>, <Line: +					return this.$$search;
>, <Line: +				case 1:
>, <Line: +					if (isString(search) || isNumber(search)) {
>, <Line: +						search = search.toString();
>, <Line: +						this.$$search = parseKeyValue(search);
>, <Line: +					} else if (isObject(search)) {
>, <Line: +						search = copy(search, {});
>, <Line: +						// remove object undefined or null properties
>, <Line: +						forEach(search, function (value, key) {
>, <Line: +							if (value == null) delete search[key];
>, <Line: +						});
>, <Line: +						this.$$search = search;
>, <Line: +					} else {
>, <Line: +						throw $locationMinErr('isrcharg',
>, <Line: +							'The first argument of the `$location#search()` call must be a string or an object.');
>, <Line: +					}
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					if (isUndefined(paramValue) || paramValue === null) {
>, <Line: +						delete this.$$search[search];
>, <Line: +					} else {
>, <Line: +						this.$$search[search] = paramValue;
>, <Line: +					}
>, <Line: +			}
>, <Line: +			this.$$compose();
>, <Line: +			return this;
>, <Line: +		},
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#hash
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter / setter.
>, <Line: +		 *
>, <Line: +		 * Return hash fragment when called without any parameter.
>, <Line: +		 *
>, <Line: +		 * Change hash fragment when called with parameter and return `$location`.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 * // given url http://example.com/some/path?foo=bar&baz=xoxo#hashValue
>, <Line: +		 * var hash = $location.hash();
>, <Line: +		 * // => "hashValue"
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {(string|number)=} hash New hash fragment
>, <Line: +		 * @return {string} hash
>, <Line: +		 */
>, <Line: +		hash: locationGetterSetter('$$hash', function (hash) {
>, <Line: +			return hash !== null ? hash.toString() : '';
>, <Line: +		}),
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#replace
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * If called, all changes to $location during current `$digest` will be replacing current history
>, <Line: +		 * record, instead of adding new one.
>, <Line: +		 */
>, <Line: +		replace: function () {
>, <Line: +			this.$$replace = true;
>, <Line: +			return this;
>, <Line: +		}
>, <Line: +	};
>, <Line: +	forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function (Location) {
>, <Line: +		Location.prototype = Object.create(locationPrototype);
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $location#state
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * This method is getter / setter.
>, <Line: +		 *
>, <Line: +		 * Return the history state object when called without any parameter.
>, <Line: +		 *
>, <Line: +		 * Change the history state object when called with one parameter and return `$location`.
>, <Line: +		 * The state object is later passed to `pushState` or `replaceState`.
>, <Line: +		 *
>, <Line: +		 * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
>, <Line: +		 * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
>, <Line: +		 * older browsers (like IE9 or Android < 4.0), don't use this method.
>, <Line: +		 *
>, <Line: +		 * @param {object=} state State object for pushState or replaceState
>, <Line: +		 * @return {object} state
>, <Line: +		 */
>, <Line: +		Location.prototype.state = function (state) {
>, <Line: +			if (!arguments.length)
>, <Line: +				return this.$$state;
>, <Line: +			if (Location !== LocationHtml5Url || !this.$$html5) {
>, <Line: +				throw $locationMinErr('nostate', 'History API state support is available only ' +
>, <Line: +					'in HTML5 mode and only in browsers supporting HTML5 History API');
>, <Line: +			}
>, <Line: +			// The user might modify `stateObject` after invoking `$location.state(stateObject)`
>, <Line: +			// but we're changing the $$state reference to $browser.state() during the $digest
>, <Line: +			// so the modification window is narrow.
>, <Line: +			this.$$state = isUndefined(state) ? null : state;
>, <Line: +			return this;
>, <Line: +		};
>, <Line: +	});
>, <Line: +	function locationGetter(property) {
>, <Line: +		return function () {
>, <Line: +			return this[property];
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function locationGetterSetter(property, preprocess) {
>, <Line: +		return function (value) {
>, <Line: +			if (isUndefined(value))
>, <Line: +				return this[property];
>, <Line: +			this[property] = preprocess(value);
>, <Line: +			this.$$compose();
>, <Line: +			return this;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $location
>, <Line: +	 *
>, <Line: +	 * @requires $rootElement
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The $location service parses the URL in the browser address bar (based on the
>, <Line: +	 * [window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
>, <Line: +	 * available to your application. Changes to the URL in the address bar are reflected into
>, <Line: +	 * $location service and changes to $location are reflected into the browser address bar.
>, <Line: +	 *
>, <Line: +	 * **The $location service:**
>, <Line: +	 *
>, <Line: +	 * - Exposes the current URL in the browser address bar, so you can
>, <Line: +	 *   - Watch and observe the URL.
>, <Line: +	 *   - Change the URL.
>, <Line: +	 * - Synchronizes the URL with the browser when the user
>, <Line: +	 *   - Changes the address bar.
>, <Line: +	 *   - Clicks the back or forward button (or clicks a History link).
>, <Line: +	 *   - Clicks on a link.
>, <Line: +	 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
>, <Line: +	 *
>, <Line: +	 * For more information see {@link guide/$location Developer Guide: Using $location}
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $locationProvider
>, <Line: +	 * @description
>, <Line: +	 * Use the `$locationProvider` to configure how the application deep linking paths are stored.
>, <Line: +	 */
>, <Line: +	function $LocationProvider() {
>, <Line: +		var hashPrefix = '',
>, <Line: +			html5Mode = {
>, <Line: +				enabled: false,
>, <Line: +				requireBase: true,
>, <Line: +				rewriteLinks: true
>, <Line: +			};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $locationProvider#hashPrefix
>, <Line: +		 * @description
>, <Line: +		 * @param {string=} prefix Prefix for hash part (containing path and search)
>, <Line: +		 * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: +		 */
>, <Line: +		this.hashPrefix = function (prefix) {
>, <Line: +			if (isDefined(prefix)) {
>, <Line: +				hashPrefix = prefix;
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return hashPrefix;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $locationProvider#html5Mode
>, <Line: +		 * @description
>, <Line: +		 * @param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.
>, <Line: +		 *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported
>, <Line: +		 *   properties:
>, <Line: +		 *   - **enabled**  `{boolean}`  (default: false) If true, will rely on `history.pushState` to
>, <Line: +		 *     change urls where supported. Will fall back to hash-prefixed paths in browsers that do not
>, <Line: +		 *     support `pushState`.
>, <Line: +		 *   - **requireBase** - `{boolean}` - (default: `true`) When html5Mode is enabled, specifies
>, <Line: +		 *     whether or not a <base> tag is required to be present. If `enabled` and `requireBase` are
>, <Line: +		 *     true, and a base tag is not present, an error will be thrown when `$location` is injected.
>, <Line: +		 *     See the {@link guide/$location $location guide for more information}
>, <Line: +		 *   - **rewriteLinks** - `{boolean}` - (default: `true`) When html5Mode is enabled,
>, <Line: +		 *     enables/disables url rewriting for relative links.
>, <Line: +		 *
>, <Line: +		 * @returns {Object} html5Mode object if used as getter or itself (chaining) if used as setter
>, <Line: +		 */
>, <Line: +		this.html5Mode = function (mode) {
>, <Line: +			if (isBoolean(mode)) {
>, <Line: +				html5Mode.enabled = mode;
>, <Line: +				return this;
>, <Line: +			} else if (isObject(mode)) {
>, <Line: +				if (isBoolean(mode.enabled)) {
>, <Line: +					html5Mode.enabled = mode.enabled;
>, <Line: +				}
>, <Line: +				if (isBoolean(mode.requireBase)) {
>, <Line: +					html5Mode.requireBase = mode.requireBase;
>, <Line: +				}
>, <Line: +				if (isBoolean(mode.rewriteLinks)) {
>, <Line: +					html5Mode.rewriteLinks = mode.rewriteLinks;
>, <Line: +				}
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return html5Mode;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc event
>, <Line: +		 * @name $location#$locationChangeStart
>, <Line: +		 * @eventType broadcast on root scope
>, <Line: +		 * @description
>, <Line: +		 * Broadcasted before a URL will change.
>, <Line: +		 *
>, <Line: +		 * This change can be prevented by calling
>, <Line: +		 * `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on} for more
>, <Line: +		 * details about event object. Upon successful change
>, <Line: +		 * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} is fired.
>, <Line: +		 *
>, <Line: +		 * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
>, <Line: +		 * the browser supports the HTML5 History API.
>, <Line: +		 *
>, <Line: +		 * @param {Object} angularEvent Synthetic event object.
>, <Line: +		 * @param {string} newUrl New URL
>, <Line: +		 * @param {string=} oldUrl URL that was before it was changed.
>, <Line: +		 * @param {string=} newState New history state object
>, <Line: +		 * @param {string=} oldState History state object that was before it was changed.
>, <Line: +		 */
>, <Line: +		/**
>, <Line: +		 * @ngdoc event
>, <Line: +		 * @name $location#$locationChangeSuccess
>, <Line: +		 * @eventType broadcast on root scope
>, <Line: +		 * @description
>, <Line: +		 * Broadcasted after a URL was changed.
>, <Line: +		 *
>, <Line: +		 * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
>, <Line: +		 * the browser supports the HTML5 History API.
>, <Line: +		 *
>, <Line: +		 * @param {Object} angularEvent Synthetic event object.
>, <Line: +		 * @param {string} newUrl New URL
>, <Line: +		 * @param {string=} oldUrl URL that was before it was changed.
>, <Line: +		 * @param {string=} newState New history state object
>, <Line: +		 * @param {string=} oldState History state object that was before it was changed.
>, <Line: +		 */
>, <Line: +		this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
>, <Line: +			function ($rootScope, $browser, $sniffer, $rootElement) {
>, <Line: +				var $location,
>, <Line: +					LocationMode,
>, <Line: +					baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
>, <Line: +					initialUrl = $browser.url(),
>, <Line: +					appBase;
>, <Line: +				if (html5Mode.enabled) {
>, <Line: +					if (!baseHref && html5Mode.requireBase) {
>, <Line: +						throw $locationMinErr('nobase',
>, <Line: +							"$location in HTML5 mode requires a <base> tag to be present!");
>, <Line: +					}
>, <Line: +					appBase = serverBase(initialUrl) + (baseHref || '/');
>, <Line: +					LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
>, <Line: +				} else {
>, <Line: +					appBase = stripHash(initialUrl);
>, <Line: +					LocationMode = LocationHashbangUrl;
>, <Line: +				}
>, <Line: +				$location = new LocationMode(appBase, '#' + hashPrefix);
>, <Line: +				$location.$$parseLinkUrl(initialUrl, initialUrl);
>, <Line: +				$location.$$state = $browser.state();
>, <Line: +				var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
>, <Line: +				function setBrowserUrlWithFallback(url, replace, state) {
>, <Line: +					var oldUrl = $location.url();
>, <Line: +					var oldState = $location.$$state;
>, <Line: +					try {
>, <Line: +						$browser.url(url, replace, state);
>, <Line: +						// Make sure $location.state() returns referentially identical (not just deeply equal)
>, <Line: +						// state object; this makes possible quick checking if the state changed in the digest
>, <Line: +						// loop. Checking deep equality would be too expensive.
>, <Line: +						$location.$$state = $browser.state();
>, <Line: +					} catch (e) {
>, <Line: +						// Restore old values if pushState fails
>, <Line: +						$location.url(oldUrl);
>, <Line: +						$location.$$state = oldState;
>, <Line: +						throw e;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				$rootElement.on('click', function (event) {
>, <Line: +					// TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
>, <Line: +					// currently we open nice url link and redirect then
>, <Line: +					if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.which == 2) return;
>, <Line: +					var elm = jqLite(event.target);
>, <Line: +					// traverse the DOM up to find first A tag
>, <Line: +					while (nodeName_(elm[0]) !== 'a') {
>, <Line: +						// ignore rewriting if no A tag (reached root element, or no parent - removed from document)
>, <Line: +						if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
>, <Line: +					}
>, <Line: +					var absHref = elm.prop('href');
>, <Line: +					// get the actual href attribute - see
>, <Line: +					// http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx
>, <Line: +					var relHref = elm.attr('href') || elm.attr('xlink:href');
>, <Line: +					if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
>, <Line: +						// SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
>, <Line: +						// an animation.
>, <Line: +						absHref = urlResolve(absHref.animVal).href;
>, <Line: +					}
>, <Line: +					// Ignore when url is started with javascript: or mailto:
>, <Line: +					if (IGNORE_URI_REGEXP.test(absHref)) return;
>, <Line: +					if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
>, <Line: +						if ($location.$$parseLinkUrl(absHref, relHref)) {
>, <Line: +							// We do a preventDefault for all urls that are part of the angular application,
>, <Line: +							// in html5mode and also without, so that we are able to abort navigation without
>, <Line: +							// getting double entries in the location history.
>, <Line: +							event.preventDefault();
>, <Line: +							// update location manually
>, <Line: +							if ($location.absUrl() != $browser.url()) {
>, <Line: +								$rootScope.$apply();
>, <Line: +								// hack to work around FF6 bug 684208 when scenario runner clicks on links
>, <Line: +								window.angular['ff-684208-preventDefault'] = true;
>, <Line: +							}
>, <Line: +						}
>, <Line: +					}
>, <Line: +				});
>, <Line: +				// rewrite hashbang url <> html5 url
>, <Line: +				if ($location.absUrl() != initialUrl) {
>, <Line: +					$browser.url($location.absUrl(), true);
>, <Line: +				}
>, <Line: +				var initializing = true;
>, <Line: +				// update $location when $browser url changes
>, <Line: +				$browser.onUrlChange(function (newUrl, newState) {
>, <Line: +					$rootScope.$evalAsync(function () {
>, <Line: +						var oldUrl = $location.absUrl();
>, <Line: +						var oldState = $location.$$state;
>, <Line: +						var defaultPrevented;
>, <Line: +						$location.$$parse(newUrl);
>, <Line: +						$location.$$state = newState;
>, <Line: +						defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
>, <Line: +							newState, oldState).defaultPrevented;
>, <Line: +						// if the location was changed by a `$locationChangeStart` handler then stop
>, <Line: +						// processing this location change
>, <Line: +						if ($location.absUrl() !== newUrl) return;
>, <Line: +						if (defaultPrevented) {
>, <Line: +							$location.$$parse(oldUrl);
>, <Line: +							$location.$$state = oldState;
>, <Line: +							setBrowserUrlWithFallback(oldUrl, false, oldState);
>, <Line: +						} else {
>, <Line: +							initializing = false;
>, <Line: +							afterLocationChange(oldUrl, oldState);
>, <Line: +						}
>, <Line: +					});
>, <Line: +					if (!$rootScope.$$phase) $rootScope.$digest();
>, <Line: +				});
>, <Line: +				// update browser
>, <Line: +				$rootScope.$watch(function $locationWatch() {
>, <Line: +					var oldUrl = $browser.url();
>, <Line: +					var oldState = $browser.state();
>, <Line: +					var currentReplace = $location.$$replace;
>, <Line: +					var urlOrStateChanged = oldUrl !== $location.absUrl() ||
>, <Line: +						($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
>, <Line: +					if (initializing || urlOrStateChanged) {
>, <Line: +						initializing = false;
>, <Line: +						$rootScope.$evalAsync(function () {
>, <Line: +							var newUrl = $location.absUrl();
>, <Line: +							var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
>, <Line: +								$location.$$state, oldState).defaultPrevented;
>, <Line: +							// if the location was changed by a `$locationChangeStart` handler then stop
>, <Line: +							// processing this location change
>, <Line: +							if ($location.absUrl() !== newUrl) return;
>, <Line: +							if (defaultPrevented) {
>, <Line: +								$location.$$parse(oldUrl);
>, <Line: +								$location.$$state = oldState;
>, <Line: +							} else {
>, <Line: +								if (urlOrStateChanged) {
>, <Line: +									setBrowserUrlWithFallback(newUrl, currentReplace,
>, <Line: +										oldState === $location.$$state ? null : $location.$$state);
>, <Line: +								}
>, <Line: +								afterLocationChange(oldUrl, oldState);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +					$location.$$replace = false;
>, <Line: +					// we don't need to return anything because $evalAsync will make the digest loop dirty when
>, <Line: +					// there is a change
>, <Line: +				});
>, <Line: +				return $location;
>, <Line: +				function afterLocationChange(oldUrl, oldState) {
>, <Line: +					$rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl,
>, <Line: +						$location.$$state, oldState);
>, <Line: +				}
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $log
>, <Line: +	 * @requires $window
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Simple service for logging. Default implementation safely writes the message
>, <Line: +	 * into the browser's console (if present).
>, <Line: +	 *
>, <Line: +	 * The main purpose of this service is to simplify debugging and troubleshooting.
>, <Line: +	 *
>, <Line: +	 * The default is to log `debug` messages. You can use
>, <Line: +	 * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="logExample">
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('logExample', [])
>, <Line: +	 .controller('LogController', ['$scope', '$log', function($scope, $log) {
>, <Line: +           $scope.$log = $log;
>, <Line: +           $scope.message = 'Hello World!';
>, <Line: +         }]);
>, <Line: +	 </file>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="LogController">
>, <Line: +	 <p>Reload this page with open console, enter text and hit the log button...</p>
>, <Line: +	 Message:
>, <Line: +	 <input type="text" ng-model="message"/>
>, <Line: +	 <button ng-click="$log.log(message)">log</button>
>, <Line: +	 <button ng-click="$log.warn(message)">warn</button>
>, <Line: +	 <button ng-click="$log.info(message)">info</button>
>, <Line: +	 <button ng-click="$log.error(message)">error</button>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $logProvider
>, <Line: +	 * @description
>, <Line: +	 * Use the `$logProvider` to configure how the application logs messages
>, <Line: +	 */
>, <Line: +	function $LogProvider() {
>, <Line: +		var debug = true,
>, <Line: +			self = this;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $logProvider#debugEnabled
>, <Line: +		 * @description
>, <Line: +		 * @param {boolean=} flag enable or disable debug level messages
>, <Line: +		 * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: +		 */
>, <Line: +		this.debugEnabled = function (flag) {
>, <Line: +			if (isDefined(flag)) {
>, <Line: +				debug = flag;
>, <Line: +				return this;
>, <Line: +			} else {
>, <Line: +				return debug;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		this.$get = ['$window', function ($window) {
>, <Line: +			return {
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $log#log
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Write a log message
>, <Line: +				 */
>, <Line: +				log: consoleLog('log'),
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $log#info
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Write an information message
>, <Line: +				 */
>, <Line: +				info: consoleLog('info'),
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $log#warn
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Write a warning message
>, <Line: +				 */
>, <Line: +				warn: consoleLog('warn'),
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $log#error
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Write an error message
>, <Line: +				 */
>, <Line: +				error: consoleLog('error'),
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $log#debug
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Write a debug message
>, <Line: +				 */
>, <Line: +				debug: (function () {
>, <Line: +					var fn = consoleLog('debug');
>, <Line: +					return function () {
>, <Line: +						if (debug) {
>, <Line: +							fn.apply(self, arguments);
>, <Line: +						}
>, <Line: +					};
>, <Line: +				}())
>, <Line: +			};
>, <Line: +			function formatError(arg) {
>, <Line: +				if (arg instanceof Error) {
>, <Line: +					if (arg.stack) {
>, <Line: +						arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
>, <Line: +							? 'Error: ' + arg.message + '\n' + arg.stack
>, <Line: +							: arg.stack;
>, <Line: +					} else if (arg.sourceURL) {
>, <Line: +						arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return arg;
>, <Line: +			}
>, <Line: +			function consoleLog(type) {
>, <Line: +				var console = $window.console || {},
>, <Line: +					logFn = console[type] || console.log || noop,
>, <Line: +					hasApply = false;
>, <Line: +				// Note: reading logFn.apply throws an error in IE11 in IE8 document mode.
>, <Line: +				// The reason behind this is that console.log has type "object" in IE8...
>, <Line: +				try {
>, <Line: +					hasApply = !!logFn.apply;
>, <Line: +				} catch (e) {
>, <Line: +				}
>, <Line: +				if (hasApply) {
>, <Line: +					return function () {
>, <Line: +						var args = [];
>, <Line: +						forEach(arguments, function (arg) {
>, <Line: +							args.push(formatError(arg));
>, <Line: +						});
>, <Line: +						return logFn.apply(console, args);
>, <Line: +					};
>, <Line: +				}
>, <Line: +				// we are IE which either doesn't have window.console => this is noop and we do nothing,
>, <Line: +				// or we are IE where console.log doesn't have apply so we log at least first 2 args
>, <Line: +				return function (arg1, arg2) {
>, <Line: +					logFn(arg1, arg2 == null ? '' : arg2);
>, <Line: +				};
>, <Line: +			}
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	var $parseMinErr = minErr('$parse');
>, <Line: +// Sandboxing Angular Expressions
>, <Line: +// ------------------------------
>, <Line: +// Angular expressions are generally considered safe because these expressions only have direct
>, <Line: +// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by
>, <Line: +// obtaining a reference to native JS functions such as the Function constructor.
>, <Line: +//
>, <Line: +// As an example, consider the following Angular expression:
>, <Line: +//
>, <Line: +//   {}.toString.constructor('alert("evil JS code")')
>, <Line: +//
>, <Line: +// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
>, <Line: +// against the expression language, but not to prevent exploits that were enabled by exposing
>, <Line: +// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good
>, <Line: +// practice and therefore we are not even trying to protect against interaction with an object
>, <Line: +// explicitly exposed in this way.
>, <Line: +//
>, <Line: +// In general, it is not possible to access a Window object from an angular expression unless a
>, <Line: +// window or some DOM object that has a reference to window is published onto a Scope.
>, <Line: +// Similarly we prevent invocations of function known to be dangerous, as well as assignments to
>, <Line: +// native objects.
>, <Line: +//
>, <Line: +// See https://docs.angularjs.org/guide/security
>, <Line: +	function ensureSafeMemberName(name, fullExpression) {
>, <Line: +		if (name === "__defineGetter__" || name === "__defineSetter__"
>, <Line: +			|| name === "__lookupGetter__" || name === "__lookupSetter__"
>, <Line: +			|| name === "__proto__") {
>, <Line: +			throw $parseMinErr('isecfld',
>, <Line: +				'Attempting to access a disallowed field in Angular expressions! '
>, <Line: +				+ 'Expression: {0}', fullExpression);
>, <Line: +		}
>, <Line: +		return name;
>, <Line: +	}
>, <Line: +	function ensureSafeObject(obj, fullExpression) {
>, <Line: +		// nifty check if obj is Function that is fast and works across iframes and other contexts
>, <Line: +		if (obj) {
>, <Line: +			if (obj.constructor === obj) {
>, <Line: +				throw $parseMinErr('isecfn',
>, <Line: +					'Referencing Function in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			} else if (// isWindow(obj)
>, <Line: +			obj.window === obj) {
>, <Line: +				throw $parseMinErr('isecwindow',
>, <Line: +					'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			} else if (// isElement(obj)
>, <Line: +			obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
>, <Line: +				throw $parseMinErr('isecdom',
>, <Line: +					'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			} else if (// block Object so that we can't get hold of dangerous Object.* methods
>, <Line: +			obj === Object) {
>, <Line: +				throw $parseMinErr('isecobj',
>, <Line: +					'Referencing Object in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return obj;
>, <Line: +	}
>, <Line: +	var CALL = Function.prototype.call;
>, <Line: +	var APPLY = Function.prototype.apply;
>, <Line: +	var BIND = Function.prototype.bind;
>, <Line: +	function ensureSafeFunction(obj, fullExpression) {
>, <Line: +		if (obj) {
>, <Line: +			if (obj.constructor === obj) {
>, <Line: +				throw $parseMinErr('isecfn',
>, <Line: +					'Referencing Function in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			} else if (obj === CALL || obj === APPLY || obj === BIND) {
>, <Line: +				throw $parseMinErr('isecff',
>, <Line: +					'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',
>, <Line: +					fullExpression);
>, <Line: +			}
>, <Line: +		}
>, <Line: +	}
>, <Line: +//Keyword constants
>, <Line: +	var CONSTANTS = createMap();
>, <Line: +	forEach({
>, <Line: +		'null': function () {
>, <Line: +			return null;
>, <Line: +		},
>, <Line: +		'true': function () {
>, <Line: +			return true;
>, <Line: +		},
>, <Line: +		'false': function () {
>, <Line: +			return false;
>, <Line: +		},
>, <Line: +		'undefined': function () {
>, <Line: +		}
>, <Line: +	}, function (constantGetter, name) {
>, <Line: +		constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;
>, <Line: +		CONSTANTS[name] = constantGetter;
>, <Line: +	});
>, <Line: +//Not quite a constant, but can be lex/parsed the same
>, <Line: +	CONSTANTS['this'] = function (self) {
>, <Line: +		return self;
>, <Line: +	};
>, <Line: +	CONSTANTS['this'].sharedGetter = true;
>, <Line: +//Operators - will be wrapped by binaryFn/unaryFn/assignment/filter
>, <Line: +	var OPERATORS = extend(createMap(), {
>, <Line: +		'+': function (self, locals, a, b) {
>, <Line: +			a = a(self, locals);
>, <Line: +			b = b(self, locals);
>, <Line: +			if (isDefined(a)) {
>, <Line: +				if (isDefined(b)) {
>, <Line: +					return a + b;
>, <Line: +				}
>, <Line: +				return a;
>, <Line: +			}
>, <Line: +			return isDefined(b) ? b : undefined;
>, <Line: +		},
>, <Line: +		'-': function (self, locals, a, b) {
>, <Line: +			a = a(self, locals);
>, <Line: +			b = b(self, locals);
>, <Line: +			return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
>, <Line: +		},
>, <Line: +		'*': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) * b(self, locals);
>, <Line: +		},
>, <Line: +		'/': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) / b(self, locals);
>, <Line: +		},
>, <Line: +		'%': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) % b(self, locals);
>, <Line: +		},
>, <Line: +		'===': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) === b(self, locals);
>, <Line: +		},
>, <Line: +		'!==': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) !== b(self, locals);
>, <Line: +		},
>, <Line: +		'==': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) == b(self, locals);
>, <Line: +		},
>, <Line: +		'!=': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) != b(self, locals);
>, <Line: +		},
>, <Line: +		'<': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) < b(self, locals);
>, <Line: +		},
>, <Line: +		'>': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) > b(self, locals);
>, <Line: +		},
>, <Line: +		'<=': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) <= b(self, locals);
>, <Line: +		},
>, <Line: +		'>=': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) >= b(self, locals);
>, <Line: +		},
>, <Line: +		'&&': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) && b(self, locals);
>, <Line: +		},
>, <Line: +		'||': function (self, locals, a, b) {
>, <Line: +			return a(self, locals) || b(self, locals);
>, <Line: +		},
>, <Line: +		'!': function (self, locals, a) {
>, <Line: +			return !a(self, locals);
>, <Line: +		},
>, <Line: +		//Tokenized as operators but parsed as assignment/filters
>, <Line: +		'=': true,
>, <Line: +		'|': true
>, <Line: +	});
>, <Line: +	var ESCAPE = {
>, <Line: +		"n": "\n",
>, <Line: +		"f": "\f",
>, <Line: +		"r": "\r",
>, <Line: +		"t": "\t",
>, <Line: +		"v": "\v",
>, <Line: +		"'": "'",
>, <Line: +		'"': '"'
>, <Line: +	};
>, <Line: +/////////////////////////////////////////
>, <Line: +	/**
>, <Line: +	 * @constructor
>, <Line: +	 */
>, <Line: +	var Lexer = function (options) {
>, <Line: +		this.options = options;
>, <Line: +	};
>, <Line: +	Lexer.prototype = {
>, <Line: +		constructor: Lexer,
>, <Line: +		lex: function (text) {
>, <Line: +			this.text = text;
>, <Line: +			this.index = 0;
>, <Line: +			this.tokens = [];
>, <Line: +			while (this.index < this.text.length) {
>, <Line: +				var ch = this.text.charAt(this.index);
>, <Line: +				if (ch === '"' || ch === "'") {
>, <Line: +					this.readString(ch);
>, <Line: +				} else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
>, <Line: +					this.readNumber();
>, <Line: +				} else if (this.isIdent(ch)) {
>, <Line: +					this.readIdent();
>, <Line: +				} else if (this.is(ch, '(){}[].,;:?')) {
>, <Line: +					this.tokens.push({index: this.index, text: ch});
>, <Line: +					this.index++;
>, <Line: +				} else if (this.isWhitespace(ch)) {
>, <Line: +					this.index++;
>, <Line: +				} else {
>, <Line: +					var ch2 = ch + this.peek();
>, <Line: +					var ch3 = ch2 + this.peek(2);
>, <Line: +					var op1 = OPERATORS[ch];
>, <Line: +					var op2 = OPERATORS[ch2];
>, <Line: +					var op3 = OPERATORS[ch3];
>, <Line: +					if (op1 || op2 || op3) {
>, <Line: +						var token = op3 ? ch3 : (op2 ? ch2 : ch);
>, <Line: +						this.tokens.push({
>, <Line: +							index: this.index,
>, <Line: +							text: token,
>, <Line: +							operator: true
>, <Line: +						});
>, <Line: +						this.index += token.length;
>, <Line: +					} else {
>, <Line: +						this.throwError('Unexpected next character ', this.index, this.index + 1);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return this.tokens;
>, <Line: +		},
>, <Line: +		is: function (ch, chars) {
>, <Line: +			return chars.indexOf(ch) !== -1;
>, <Line: +		},
>, <Line: +		peek: function (i) {
>, <Line: +			var num = i || 1;
>, <Line: +			return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
>, <Line: +		},
>, <Line: +		isNumber: function (ch) {
>, <Line: +			return ('0' <= ch && ch <= '9') && typeof ch === "string";
>, <Line: +		},
>, <Line: +		isWhitespace: function (ch) {
>, <Line: +			// IE treats non-breaking space as \u00A0
>, <Line: +			return (ch === ' ' || ch === '\r' || ch === '\t' ||
>, <Line: +			ch === '\n' || ch === '\v' || ch === '\u00A0');
>, <Line: +		},
>, <Line: +		isIdent: function (ch) {
>, <Line: +			return ('a' <= ch && ch <= 'z' ||
>, <Line: +			'A' <= ch && ch <= 'Z' ||
>, <Line: +			'_' === ch || ch === '$');
>, <Line: +		},
>, <Line: +		isExpOperator: function (ch) {
>, <Line: +			return (ch === '-' || ch === '+' || this.isNumber(ch));
>, <Line: +		},
>, <Line: +		throwError: function (error, start, end) {
>, <Line: +			end = end || this.index;
>, <Line: +			var colStr = (isDefined(start)
>, <Line: +				? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']'
>, <Line: +				: ' ' + end);
>, <Line: +			throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
>, <Line: +				error, colStr, this.text);
>, <Line: +		},
>, <Line: +		readNumber: function () {
>, <Line: +			var number = '';
>, <Line: +			var start = this.index;
>, <Line: +			while (this.index < this.text.length) {
>, <Line: +				var ch = lowercase(this.text.charAt(this.index));
>, <Line: +				if (ch == '.' || this.isNumber(ch)) {
>, <Line: +					number += ch;
>, <Line: +				} else {
>, <Line: +					var peekCh = this.peek();
>, <Line: +					if (ch == 'e' && this.isExpOperator(peekCh)) {
>, <Line: +						number += ch;
>, <Line: +					} else if (this.isExpOperator(ch) &&
>, <Line: +						peekCh && this.isNumber(peekCh) &&
>, <Line: +						number.charAt(number.length - 1) == 'e') {
>, <Line: +						number += ch;
>, <Line: +					} else if (this.isExpOperator(ch) &&
>, <Line: +						(!peekCh || !this.isNumber(peekCh)) &&
>, <Line: +						number.charAt(number.length - 1) == 'e') {
>, <Line: +						this.throwError('Invalid exponent');
>, <Line: +					} else {
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				this.index++;
>, <Line: +			}
>, <Line: +			this.tokens.push({
>, <Line: +				index: start,
>, <Line: +				text: number,
>, <Line: +				constant: true,
>, <Line: +				value: Number(number)
>, <Line: +			});
>, <Line: +		},
>, <Line: +		readIdent: function () {
>, <Line: +			var start = this.index;
>, <Line: +			while (this.index < this.text.length) {
>, <Line: +				var ch = this.text.charAt(this.index);
>, <Line: +				if (!(this.isIdent(ch) || this.isNumber(ch))) {
>, <Line: +					break;
>, <Line: +				}
>, <Line: +				this.index++;
>, <Line: +			}
>, <Line: +			this.tokens.push({
>, <Line: +				index: start,
>, <Line: +				text: this.text.slice(start, this.index),
>, <Line: +				identifier: true
>, <Line: +			});
>, <Line: +		},
>, <Line: +		readString: function (quote) {
>, <Line: +			var start = this.index;
>, <Line: +			this.index++;
>, <Line: +			var string = '';
>, <Line: +			var rawString = quote;
>, <Line: +			var escape = false;
>, <Line: +			while (this.index < this.text.length) {
>, <Line: +				var ch = this.text.charAt(this.index);
>, <Line: +				rawString += ch;
>, <Line: +				if (escape) {
>, <Line: +					if (ch === 'u') {
>, <Line: +						var hex = this.text.substring(this.index + 1, this.index + 5);
>, <Line: +						if (!hex.match(/[\da-f]{4}/i))
>, <Line: +							this.throwError('Invalid unicode escape [\\u' + hex + ']');
>, <Line: +						this.index += 4;
>, <Line: +						string += String.fromCharCode(parseInt(hex, 16));
>, <Line: +					} else {
>, <Line: +						var rep = ESCAPE[ch];
>, <Line: +						string = string + (rep || ch);
>, <Line: +					}
>, <Line: +					escape = false;
>, <Line: +				} else if (ch === '\\') {
>, <Line: +					escape = true;
>, <Line: +				} else if (ch === quote) {
>, <Line: +					this.index++;
>, <Line: +					this.tokens.push({
>, <Line: +						index: start,
>, <Line: +						text: rawString,
>, <Line: +						constant: true,
>, <Line: +						value: string
>, <Line: +					});
>, <Line: +					return;
>, <Line: +				} else {
>, <Line: +					string += ch;
>, <Line: +				}
>, <Line: +				this.index++;
>, <Line: +			}
>, <Line: +			this.throwError('Unterminated quote', start);
>, <Line: +		}
>, <Line: +	};
>, <Line: +	function isConstant(exp) {
>, <Line: +		return exp.constant;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @constructor
>, <Line: +	 */
>, <Line: +	var Parser = function (lexer, $filter, options) {
>, <Line: +		this.lexer = lexer;
>, <Line: +		this.$filter = $filter;
>, <Line: +		this.options = options;
>, <Line: +	};
>, <Line: +	Parser.ZERO = extend(function () {
>, <Line: +		return 0;
>, <Line: +	}, {
>, <Line: +		sharedGetter: true,
>, <Line: +		constant: true
>, <Line: +	});
>, <Line: +	Parser.prototype = {
>, <Line: +		constructor: Parser,
>, <Line: +		parse: function (text) {
>, <Line: +			this.text = text;
>, <Line: +			this.tokens = this.lexer.lex(text);
>, <Line: +			var value = this.statements();
>, <Line: +			if (this.tokens.length !== 0) {
>, <Line: +				this.throwError('is an unexpected token', this.tokens[0]);
>, <Line: +			}
>, <Line: +			value.literal = !!value.literal;
>, <Line: +			value.constant = !!value.constant;
>, <Line: +			return value;
>, <Line: +		},
>, <Line: +		primary: function () {
>, <Line: +			var primary;
>, <Line: +			if (this.expect('(')) {
>, <Line: +				primary = this.filterChain();
>, <Line: +				this.consume(')');
>, <Line: +			} else if (this.expect('[')) {
>, <Line: +				primary = this.arrayDeclaration();
>, <Line: +			} else if (this.expect('{')) {
>, <Line: +				primary = this.object();
>, <Line: +			} else if (this.peek().identifier) {
>, <Line: +				primary = this.identifier();
>, <Line: +			} else if (this.peek().constant) {
>, <Line: +				primary = this.constant();
>, <Line: +			} else {
>, <Line: +				this.throwError('not a primary expression', this.peek());
>, <Line: +			}
>, <Line: +			var next, context;
>, <Line: +			while ((next = this.expect('(', '[', '.'))) {
>, <Line: +				if (next.text === '(') {
>, <Line: +					primary = this.functionCall(primary, context);
>, <Line: +					context = null;
>, <Line: +				} else if (next.text === '[') {
>, <Line: +					context = primary;
>, <Line: +					primary = this.objectIndex(primary);
>, <Line: +				} else if (next.text === '.') {
>, <Line: +					context = primary;
>, <Line: +					primary = this.fieldAccess(primary);
>, <Line: +				} else {
>, <Line: +					this.throwError('IMPOSSIBLE');
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return primary;
>, <Line: +		},
>, <Line: +		throwError: function (msg, token) {
>, <Line: +			throw $parseMinErr('syntax',
>, <Line: +				'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
>, <Line: +				token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
>, <Line: +		},
>, <Line: +		peekToken: function () {
>, <Line: +			if (this.tokens.length === 0)
>, <Line: +				throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
>, <Line: +			return this.tokens[0];
>, <Line: +		},
>, <Line: +		peek: function (e1, e2, e3, e4) {
>, <Line: +			return this.peekAhead(0, e1, e2, e3, e4);
>, <Line: +		},
>, <Line: +		peekAhead: function (i, e1, e2, e3, e4) {
>, <Line: +			if (this.tokens.length > i) {
>, <Line: +				var token = this.tokens[i];
>, <Line: +				var t = token.text;
>, <Line: +				if (t === e1 || t === e2 || t === e3 || t === e4 ||
>, <Line: +					(!e1 && !e2 && !e3 && !e4)) {
>, <Line: +					return token;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		},
>, <Line: +		expect: function (e1, e2, e3, e4) {
>, <Line: +			var token = this.peek(e1, e2, e3, e4);
>, <Line: +			if (token) {
>, <Line: +				this.tokens.shift();
>, <Line: +				return token;
>, <Line: +			}
>, <Line: +			return false;
>, <Line: +		},
>, <Line: +		consume: function (e1) {
>, <Line: +			if (this.tokens.length === 0) {
>, <Line: +				throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
>, <Line: +			}
>, <Line: +			var token = this.expect(e1);
>, <Line: +			if (!token) {
>, <Line: +				this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
>, <Line: +			}
>, <Line: +			return token;
>, <Line: +		},
>, <Line: +		unaryFn: function (op, right) {
>, <Line: +			var fn = OPERATORS[op];
>, <Line: +			return extend(function $parseUnaryFn(self, locals) {
>, <Line: +				return fn(self, locals, right);
>, <Line: +			}, {
>, <Line: +				constant: right.constant,
>, <Line: +				inputs: [right]
>, <Line: +			});
>, <Line: +		},
>, <Line: +		binaryFn: function (left, op, right, isBranching) {
>, <Line: +			var fn = OPERATORS[op];
>, <Line: +			return extend(function $parseBinaryFn(self, locals) {
>, <Line: +				return fn(self, locals, left, right);
>, <Line: +			}, {
>, <Line: +				constant: left.constant && right.constant,
>, <Line: +				inputs: !isBranching && [left, right]
>, <Line: +			});
>, <Line: +		},
>, <Line: +		identifier: function () {
>, <Line: +			var id = this.consume().text;
>, <Line: +			//Continue reading each `.identifier` unless it is a method invocation
>, <Line: +			while (this.peek('.') && this.peekAhead(1).identifier && !this.peekAhead(2, '(')) {
>, <Line: +				id += this.consume().text + this.consume().text;
>, <Line: +			}
>, <Line: +			return CONSTANTS[id] || getterFn(id, this.options, this.text);
>, <Line: +		},
>, <Line: +		constant: function () {
>, <Line: +			var value = this.consume().value;
>, <Line: +			return extend(function $parseConstant() {
>, <Line: +				return value;
>, <Line: +			}, {
>, <Line: +				constant: true,
>, <Line: +				literal: true
>, <Line: +			});
>, <Line: +		},
>, <Line: +		statements: function () {
>, <Line: +			var statements = [];
>, <Line: +			while (true) {
>, <Line: +				if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
>, <Line: +					statements.push(this.filterChain());
>, <Line: +				if (!this.expect(';')) {
>, <Line: +					// optimize for the common case where there is only one statement.
>, <Line: +					// TODO(size): maybe we should not support multiple statements?
>, <Line: +					return (statements.length === 1)
>, <Line: +						? statements[0]
>, <Line: +						: function $parseStatements(self, locals) {
>, <Line: +						var value;
>, <Line: +						for (var i = 0, ii = statements.length; i < ii; i++) {
>, <Line: +							value = statements[i](self, locals);
>, <Line: +						}
>, <Line: +						return value;
>, <Line: +					};
>, <Line: +				}
>, <Line: +			}
>, <Line: +		},
>, <Line: +		filterChain: function () {
>, <Line: +			var left = this.expression();
>, <Line: +			var token;
>, <Line: +			while ((token = this.expect('|'))) {
>, <Line: +				left = this.filter(left);
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		filter: function (inputFn) {
>, <Line: +			var fn = this.$filter(this.consume().text);
>, <Line: +			var argsFn;
>, <Line: +			var args;
>, <Line: +			if (this.peek(':')) {
>, <Line: +				argsFn = [];
>, <Line: +				args = []; // we can safely reuse the array
>, <Line: +				while (this.expect(':')) {
>, <Line: +					argsFn.push(this.expression());
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var inputs = [inputFn].concat(argsFn || []);
>, <Line: +			return extend(function $parseFilter(self, locals) {
>, <Line: +				var input = inputFn(self, locals);
>, <Line: +				if (args) {
>, <Line: +					args[0] = input;
>, <Line: +					var i = argsFn.length;
>, <Line: +					while (i--) {
>, <Line: +						args[i + 1] = argsFn[i](self, locals);
>, <Line: +					}
>, <Line: +					return fn.apply(undefined, args);
>, <Line: +				}
>, <Line: +				return fn(input);
>, <Line: +			}, {
>, <Line: +				constant: !fn.$stateful && inputs.every(isConstant),
>, <Line: +				inputs: !fn.$stateful && inputs
>, <Line: +			});
>, <Line: +		},
>, <Line: +		expression: function () {
>, <Line: +			return this.assignment();
>, <Line: +		},
>, <Line: +		assignment: function () {
>, <Line: +			var left = this.ternary();
>, <Line: +			var right;
>, <Line: +			var token;
>, <Line: +			if ((token = this.expect('='))) {
>, <Line: +				if (!left.assign) {
>, <Line: +					this.throwError('implies assignment but [' +
>, <Line: +						this.text.substring(0, token.index) + '] can not be assigned to', token);
>, <Line: +				}
>, <Line: +				right = this.ternary();
>, <Line: +				return extend(function $parseAssignment(scope, locals) {
>, <Line: +					return left.assign(scope, right(scope, locals), locals);
>, <Line: +				}, {
>, <Line: +					inputs: [left, right]
>, <Line: +				});
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		ternary: function () {
>, <Line: +			var left = this.logicalOR();
>, <Line: +			var middle;
>, <Line: +			var token;
>, <Line: +			if ((token = this.expect('?'))) {
>, <Line: +				middle = this.assignment();
>, <Line: +				if (this.consume(':')) {
>, <Line: +					var right = this.assignment();
>, <Line: +					return extend(function $parseTernary(self, locals) {
>, <Line: +						return left(self, locals) ? middle(self, locals) : right(self, locals);
>, <Line: +					}, {
>, <Line: +						constant: left.constant && middle.constant && right.constant
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		logicalOR: function () {
>, <Line: +			var left = this.logicalAND();
>, <Line: +			var token;
>, <Line: +			while ((token = this.expect('||'))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.logicalAND(), true);
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		logicalAND: function () {
>, <Line: +			var left = this.equality();
>, <Line: +			var token;
>, <Line: +			if ((token = this.expect('&&'))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.logicalAND(), true);
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		equality: function () {
>, <Line: +			var left = this.relational();
>, <Line: +			var token;
>, <Line: +			if ((token = this.expect('==', '!=', '===', '!=='))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.equality());
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		relational: function () {
>, <Line: +			var left = this.additive();
>, <Line: +			var token;
>, <Line: +			if ((token = this.expect('<', '>', '<=', '>='))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.relational());
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		additive: function () {
>, <Line: +			var left = this.multiplicative();
>, <Line: +			var token;
>, <Line: +			while ((token = this.expect('+', '-'))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.multiplicative());
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		multiplicative: function () {
>, <Line: +			var left = this.unary();
>, <Line: +			var token;
>, <Line: +			while ((token = this.expect('*', '/', '%'))) {
>, <Line: +				left = this.binaryFn(left, token.text, this.unary());
>, <Line: +			}
>, <Line: +			return left;
>, <Line: +		},
>, <Line: +		unary: function () {
>, <Line: +			var token;
>, <Line: +			if (this.expect('+')) {
>, <Line: +				return this.primary();
>, <Line: +			} else if ((token = this.expect('-'))) {
>, <Line: +				return this.binaryFn(Parser.ZERO, token.text, this.unary());
>, <Line: +			} else if ((token = this.expect('!'))) {
>, <Line: +				return this.unaryFn(token.text, this.unary());
>, <Line: +			} else {
>, <Line: +				return this.primary();
>, <Line: +			}
>, <Line: +		},
>, <Line: +		fieldAccess: function (object) {
>, <Line: +			var expression = this.text;
>, <Line: +			var field = this.consume().text;
>, <Line: +			var getter = getterFn(field, this.options, expression);
>, <Line: +			return extend(function $parseFieldAccess(scope, locals, self) {
>, <Line: +				return getter(self || object(scope, locals));
>, <Line: +			}, {
>, <Line: +				assign: function (scope, value, locals) {
>, <Line: +					var o = object(scope, locals);
>, <Line: +					if (!o) object.assign(scope, o = {});
>, <Line: +					return setter(o, field, value, expression);
>, <Line: +				}
>, <Line: +			});
>, <Line: +		},
>, <Line: +		objectIndex: function (obj) {
>, <Line: +			var expression = this.text;
>, <Line: +			var indexFn = this.expression();
>, <Line: +			this.consume(']');
>, <Line: +			return extend(function $parseObjectIndex(self, locals) {
>, <Line: +				var o = obj(self, locals),
>, <Line: +					i = indexFn(self, locals),
>, <Line: +					v;
>, <Line: +				ensureSafeMemberName(i, expression);
>, <Line: +				if (!o) return undefined;
>, <Line: +				v = ensureSafeObject(o[i], expression);
>, <Line: +				return v;
>, <Line: +			}, {
>, <Line: +				assign: function (self, value, locals) {
>, <Line: +					var key = ensureSafeMemberName(indexFn(self, locals), expression);
>, <Line: +					// prevent overwriting of Function.constructor which would break ensureSafeObject check
>, <Line: +					var o = ensureSafeObject(obj(self, locals), expression);
>, <Line: +					if (!o) obj.assign(self, o = {});
>, <Line: +					return o[key] = value;
>, <Line: +				}
>, <Line: +			});
>, <Line: +		},
>, <Line: +		functionCall: function (fnGetter, contextGetter) {
>, <Line: +			var argsFn = [];
>, <Line: +			if (this.peekToken().text !== ')') {
>, <Line: +				do {
>, <Line: +					argsFn.push(this.expression());
>, <Line: +				} while (this.expect(','));
>, <Line: +			}
>, <Line: +			this.consume(')');
>, <Line: +			var expressionText = this.text;
>, <Line: +			// we can safely reuse the array across invocations
>, <Line: +			var args = argsFn.length ? [] : null;
>, <Line: +			return function $parseFunctionCall(scope, locals) {
>, <Line: +				var context = contextGetter ? contextGetter(scope, locals) : scope;
>, <Line: +				var fn = fnGetter(scope, locals, context) || noop;
>, <Line: +				if (args) {
>, <Line: +					var i = argsFn.length;
>, <Line: +					while (i--) {
>, <Line: +						args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				ensureSafeObject(context, expressionText);
>, <Line: +				ensureSafeFunction(fn, expressionText);
>, <Line: +				// IE stupidity! (IE doesn't have apply for some native functions)
>, <Line: +				var v = fn.apply
>, <Line: +					? fn.apply(context, args)
>, <Line: +					: fn(args[0], args[1], args[2], args[3], args[4]);
>, <Line: +				return ensureSafeObject(v, expressionText);
>, <Line: +			};
>, <Line: +		},
>, <Line: +		// This is used with json array declaration
>, <Line: +		arrayDeclaration: function () {
>, <Line: +			var elementFns = [];
>, <Line: +			if (this.peekToken().text !== ']') {
>, <Line: +				do {
>, <Line: +					if (this.peek(']')) {
>, <Line: +						// Support trailing commas per ES5.1.
>, <Line: +						break;
>, <Line: +					}
>, <Line: +					elementFns.push(this.expression());
>, <Line: +				} while (this.expect(','));
>, <Line: +			}
>, <Line: +			this.consume(']');
>, <Line: +			return extend(function $parseArrayLiteral(self, locals) {
>, <Line: +				var array = [];
>, <Line: +				for (var i = 0, ii = elementFns.length; i < ii; i++) {
>, <Line: +					array.push(elementFns[i](self, locals));
>, <Line: +				}
>, <Line: +				return array;
>, <Line: +			}, {
>, <Line: +				literal: true,
>, <Line: +				constant: elementFns.every(isConstant),
>, <Line: +				inputs: elementFns
>, <Line: +			});
>, <Line: +		},
>, <Line: +		object: function () {
>, <Line: +			var keys = [], valueFns = [];
>, <Line: +			if (this.peekToken().text !== '}') {
>, <Line: +				do {
>, <Line: +					if (this.peek('}')) {
>, <Line: +						// Support trailing commas per ES5.1.
>, <Line: +						break;
>, <Line: +					}
>, <Line: +					var token = this.consume();
>, <Line: +					if (token.constant) {
>, <Line: +						keys.push(token.value);
>, <Line: +					} else if (token.identifier) {
>, <Line: +						keys.push(token.text);
>, <Line: +					} else {
>, <Line: +						this.throwError("invalid key", token);
>, <Line: +					}
>, <Line: +					this.consume(':');
>, <Line: +					valueFns.push(this.expression());
>, <Line: +				} while (this.expect(','));
>, <Line: +			}
>, <Line: +			this.consume('}');
>, <Line: +			return extend(function $parseObjectLiteral(self, locals) {
>, <Line: +				var object = {};
>, <Line: +				for (var i = 0, ii = valueFns.length; i < ii; i++) {
>, <Line: +					object[keys[i]] = valueFns[i](self, locals);
>, <Line: +				}
>, <Line: +				return object;
>, <Line: +			}, {
>, <Line: +				literal: true,
>, <Line: +				constant: valueFns.every(isConstant),
>, <Line: +				inputs: valueFns
>, <Line: +			});
>, <Line: +		}
>, <Line: +	};
>, <Line: +//////////////////////////////////////////////////
>, <Line: +// Parser helper functions
>, <Line: +//////////////////////////////////////////////////
>, <Line: +	function setter(obj, path, setValue, fullExp) {
>, <Line: +		ensureSafeObject(obj, fullExp);
>, <Line: +		var element = path.split('.'), key;
>, <Line: +		for (var i = 0; element.length > 1; i++) {
>, <Line: +			key = ensureSafeMemberName(element.shift(), fullExp);
>, <Line: +			var propertyObj = ensureSafeObject(obj[key], fullExp);
>, <Line: +			if (!propertyObj) {
>, <Line: +				propertyObj = {};
>, <Line: +				obj[key] = propertyObj;
>, <Line: +			}
>, <Line: +			obj = propertyObj;
>, <Line: +		}
>, <Line: +		key = ensureSafeMemberName(element.shift(), fullExp);
>, <Line: +		ensureSafeObject(obj[key], fullExp);
>, <Line: +		obj[key] = setValue;
>, <Line: +		return setValue;
>, <Line: +	}
>, <Line: +	var getterFnCacheDefault = createMap();
>, <Line: +	var getterFnCacheExpensive = createMap();
>, <Line: +	function isPossiblyDangerousMemberName(name) {
>, <Line: +		return name == 'constructor';
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Implementation of the "Black Hole" variant from:
>, <Line: +	 * - http://jsperf.com/angularjs-parse-getter/4
>, <Line: +	 * - http://jsperf.com/path-evaluation-simplified/7
>, <Line: +	 */
>, <Line: +	function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
>, <Line: +		ensureSafeMemberName(key0, fullExp);
>, <Line: +		ensureSafeMemberName(key1, fullExp);
>, <Line: +		ensureSafeMemberName(key2, fullExp);
>, <Line: +		ensureSafeMemberName(key3, fullExp);
>, <Line: +		ensureSafeMemberName(key4, fullExp);
>, <Line: +		var eso = function (o) {
>, <Line: +			return ensureSafeObject(o, fullExp);
>, <Line: +		};
>, <Line: +		var eso0 = (expensiveChecks || isPossiblyDangerousMemberName(key0)) ? eso : identity;
>, <Line: +		var eso1 = (expensiveChecks || isPossiblyDangerousMemberName(key1)) ? eso : identity;
>, <Line: +		var eso2 = (expensiveChecks || isPossiblyDangerousMemberName(key2)) ? eso : identity;
>, <Line: +		var eso3 = (expensiveChecks || isPossiblyDangerousMemberName(key3)) ? eso : identity;
>, <Line: +		var eso4 = (expensiveChecks || isPossiblyDangerousMemberName(key4)) ? eso : identity;
>, <Line: +		return function cspSafeGetter(scope, locals) {
>, <Line: +			var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;
>, <Line: +			if (pathVal == null) return pathVal;
>, <Line: +			pathVal = eso0(pathVal[key0]);
>, <Line: +			if (!key1) return pathVal;
>, <Line: +			if (pathVal == null) return undefined;
>, <Line: +			pathVal = eso1(pathVal[key1]);
>, <Line: +			if (!key2) return pathVal;
>, <Line: +			if (pathVal == null) return undefined;
>, <Line: +			pathVal = eso2(pathVal[key2]);
>, <Line: +			if (!key3) return pathVal;
>, <Line: +			if (pathVal == null) return undefined;
>, <Line: +			pathVal = eso3(pathVal[key3]);
>, <Line: +			if (!key4) return pathVal;
>, <Line: +			if (pathVal == null) return undefined;
>, <Line: +			pathVal = eso4(pathVal[key4]);
>, <Line: +			return pathVal;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function getterFnWithEnsureSafeObject(fn, fullExpression) {
>, <Line: +		return function (s, l) {
>, <Line: +			return fn(s, l, ensureSafeObject, fullExpression);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function getterFn(path, options, fullExp) {
>, <Line: +		var expensiveChecks = options.expensiveChecks;
>, <Line: +		var getterFnCache = (expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault);
>, <Line: +		var fn = getterFnCache[path];
>, <Line: +		if (fn) return fn;
>, <Line: +		var pathKeys = path.split('.'),
>, <Line: +			pathKeysLength = pathKeys.length;
>, <Line: +		// http://jsperf.com/angularjs-parse-getter/6
>, <Line: +		if (options.csp) {
>, <Line: +			if (pathKeysLength < 6) {
>, <Line: +				fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
>, <Line: +			} else {
>, <Line: +				fn = function cspSafeGetter(scope, locals) {
>, <Line: +					var i = 0, val;
>, <Line: +					do {
>, <Line: +						val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++],
>, <Line: +							pathKeys[i++], fullExp, expensiveChecks)(scope, locals);
>, <Line: +						locals = undefined; // clear after first iteration
>, <Line: +						scope = val;
>, <Line: +					} while (i < pathKeysLength);
>, <Line: +					return val;
>, <Line: +				};
>, <Line: +			}
>, <Line: +		} else {
>, <Line: +			var code = '';
>, <Line: +			if (expensiveChecks) {
>, <Line: +				code += 's = eso(s, fe);\nl = eso(l, fe);\n';
>, <Line: +			}
>, <Line: +			var needsEnsureSafeObject = expensiveChecks;
>, <Line: +			forEach(pathKeys, function (key, index) {
>, <Line: +				ensureSafeMemberName(key, fullExp);
>, <Line: +				var lookupJs = (index
>, <Line: +						// we simply dereference 's' on any .dot notation
>, <Line: +						? 's'
>, <Line: +						// but if we are first then we check locals first, and if so read it first
>, <Line: +						: '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + '.' + key;
>, <Line: +				if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
>, <Line: +					lookupJs = 'eso(' + lookupJs + ', fe)';
>, <Line: +					needsEnsureSafeObject = true;
>, <Line: +				}
>, <Line: +				code += 'if(s == null) return undefined;\n' +
>, <Line: +					's=' + lookupJs + ';\n';
>, <Line: +			});
>, <Line: +			code += 'return s;';
>, <Line: +			/* jshint -W054 */
>, <Line: +			var evaledFnGetter = new Function('s', 'l', 'eso', 'fe', code); // s=scope, l=locals, eso=ensureSafeObject
>, <Line: +			/* jshint +W054 */
>, <Line: +			evaledFnGetter.toString = valueFn(code);
>, <Line: +			if (needsEnsureSafeObject) {
>, <Line: +				evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
>, <Line: +			}
>, <Line: +			fn = evaledFnGetter;
>, <Line: +		}
>, <Line: +		fn.sharedGetter = true;
>, <Line: +		fn.assign = function (self, value) {
>, <Line: +			return setter(self, path, value, path);
>, <Line: +		};
>, <Line: +		getterFnCache[path] = fn;
>, <Line: +		return fn;
>, <Line: +	}
>, <Line: +	var objectValueOf = Object.prototype.valueOf;
>, <Line: +	function getValueOf(value) {
>, <Line: +		return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
>, <Line: +	}
>, <Line: +///////////////////////////////////
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $parse
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Converts Angular {@link guide/expression expression} into a function.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   var getter = $parse('user.name');
>, <Line: +	 *   var setter = getter.assign;
>, <Line: +	 *   var context = {user:{name:'angular'}};
>, <Line: +	 *   var locals = {user:{name:'local'}};
>, <Line: +	 *
>, <Line: +	 *   expect(getter(context)).toEqual('angular');
>, <Line: +	 *   setter(context, 'newValue');
>, <Line: +	 *   expect(context.user.name).toEqual('newValue');
>, <Line: +	 *   expect(getter(context, locals)).toEqual('local');
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @param {string} expression String expression to compile.
>, <Line: +	 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +	 *
>, <Line: +	 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +	 *      are evaluated against (typically a scope object).
>, <Line: +	 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +	 *      `context`.
>, <Line: +	 *
>, <Line: +	 *    The returned function also has the following properties:
>, <Line: +	 *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript
>, <Line: +	 *        literal.
>, <Line: +	 *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript
>, <Line: +	 *        constant literals.
>, <Line: +	 *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be
>, <Line: +	 *        set to a function to change its value on the given context.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $parseProvider
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
>, <Line: +	 *  service.
>, <Line: +	 */
>, <Line: +	function $ParseProvider() {
>, <Line: +		var cacheDefault = createMap();
>, <Line: +		var cacheExpensive = createMap();
>, <Line: +		this.$get = ['$filter', '$sniffer', function ($filter, $sniffer) {
>, <Line: +			var $parseOptions = {
>, <Line: +					csp: $sniffer.csp,
>, <Line: +					expensiveChecks: false
>, <Line: +				},
>, <Line: +				$parseOptionsExpensive = {
>, <Line: +					csp: $sniffer.csp,
>, <Line: +					expensiveChecks: true
>, <Line: +				};
>, <Line: +			function wrapSharedExpression(exp) {
>, <Line: +				var wrapped = exp;
>, <Line: +				if (exp.sharedGetter) {
>, <Line: +					wrapped = function $parseWrapper(self, locals) {
>, <Line: +						return exp(self, locals);
>, <Line: +					};
>, <Line: +					wrapped.literal = exp.literal;
>, <Line: +					wrapped.constant = exp.constant;
>, <Line: +					wrapped.assign = exp.assign;
>, <Line: +				}
>, <Line: +				return wrapped;
>, <Line: +			}
>, <Line: +			return function $parse(exp, interceptorFn, expensiveChecks) {
>, <Line: +				var parsedExpression, oneTime, cacheKey;
>, <Line: +				switch (typeof exp) {
>, <Line: +					case 'string':
>, <Line: +						cacheKey = exp = exp.trim();
>, <Line: +						var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
>, <Line: +						parsedExpression = cache[cacheKey];
>, <Line: +						if (!parsedExpression) {
>, <Line: +							if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
>, <Line: +								oneTime = true;
>, <Line: +								exp = exp.substring(2);
>, <Line: +							}
>, <Line: +							var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
>, <Line: +							var lexer = new Lexer(parseOptions);
>, <Line: +							var parser = new Parser(lexer, $filter, parseOptions);
>, <Line: +							parsedExpression = parser.parse(exp);
>, <Line: +							if (parsedExpression.constant) {
>, <Line: +								parsedExpression.$$watchDelegate = constantWatchDelegate;
>, <Line: +							} else if (oneTime) {
>, <Line: +								//oneTime is not part of the exp passed to the Parser so we may have to
>, <Line: +								//wrap the parsedExpression before adding a $$watchDelegate
>, <Line: +								parsedExpression = wrapSharedExpression(parsedExpression);
>, <Line: +								parsedExpression.$$watchDelegate = parsedExpression.literal ?
>, <Line: +									oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
>, <Line: +							} else if (parsedExpression.inputs) {
>, <Line: +								parsedExpression.$$watchDelegate = inputsWatchDelegate;
>, <Line: +							}
>, <Line: +							cache[cacheKey] = parsedExpression;
>, <Line: +						}
>, <Line: +						return addInterceptor(parsedExpression, interceptorFn);
>, <Line: +					case 'function':
>, <Line: +						return addInterceptor(exp, interceptorFn);
>, <Line: +					default:
>, <Line: +						return addInterceptor(noop, interceptorFn);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			function collectExpressionInputs(inputs, list) {
>, <Line: +				for (var i = 0, ii = inputs.length; i < ii; i++) {
>, <Line: +					var input = inputs[i];
>, <Line: +					if (!input.constant) {
>, <Line: +						if (input.inputs) {
>, <Line: +							collectExpressionInputs(input.inputs, list);
>, <Line: +						} else if (list.indexOf(input) === -1) { // TODO(perf) can we do better?
>, <Line: +							list.push(input);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return list;
>, <Line: +			}
>, <Line: +			function expressionInputDirtyCheck(newValue, oldValueOfValue) {
>, <Line: +				if (newValue == null || oldValueOfValue == null) { // null/undefined
>, <Line: +					return newValue === oldValueOfValue;
>, <Line: +				}
>, <Line: +				if (typeof newValue === 'object') {
>, <Line: +					// attempt to convert the value to a primitive type
>, <Line: +					// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
>, <Line: +					//             be cheaply dirty-checked
>, <Line: +					newValue = getValueOf(newValue);
>, <Line: +					if (typeof newValue === 'object') {
>, <Line: +						// objects/arrays are not supported - deep-watching them would be too expensive
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +					// fall-through to the primitive equality check
>, <Line: +				}
>, <Line: +				//Primitive or NaN
>, <Line: +				return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
>, <Line: +			}
>, <Line: +			function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: +				var inputExpressions = parsedExpression.$$inputs ||
>, <Line: +					(parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
>, <Line: +				var lastResult;
>, <Line: +				if (inputExpressions.length === 1) {
>, <Line: +					var oldInputValue = expressionInputDirtyCheck; // init to something unique so that equals check fails
>, <Line: +					inputExpressions = inputExpressions[0];
>, <Line: +					return scope.$watch(function expressionInputWatch(scope) {
>, <Line: +						var newInputValue = inputExpressions(scope);
>, <Line: +						if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {
>, <Line: +							lastResult = parsedExpression(scope);
>, <Line: +							oldInputValue = newInputValue && getValueOf(newInputValue);
>, <Line: +						}
>, <Line: +						return lastResult;
>, <Line: +					}, listener, objectEquality);
>, <Line: +				}
>, <Line: +				var oldInputValueOfValues = [];
>, <Line: +				for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
>, <Line: +					oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails
>, <Line: +				}
>, <Line: +				return scope.$watch(function expressionInputsWatch(scope) {
>, <Line: +					var changed = false;
>, <Line: +					for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
>, <Line: +						var newInputValue = inputExpressions[i](scope);
>, <Line: +						if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
>, <Line: +							oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					if (changed) {
>, <Line: +						lastResult = parsedExpression(scope);
>, <Line: +					}
>, <Line: +					return lastResult;
>, <Line: +				}, listener, objectEquality);
>, <Line: +			}
>, <Line: +			function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: +				var unwatch, lastValue;
>, <Line: +				return unwatch = scope.$watch(function oneTimeWatch(scope) {
>, <Line: +					return parsedExpression(scope);
>, <Line: +				}, function oneTimeListener(value, old, scope) {
>, <Line: +					lastValue = value;
>, <Line: +					if (isFunction(listener)) {
>, <Line: +						listener.apply(this, arguments);
>, <Line: +					}
>, <Line: +					if (isDefined(value)) {
>, <Line: +						scope.$$postDigest(function () {
>, <Line: +							if (isDefined(lastValue)) {
>, <Line: +								unwatch();
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}, objectEquality);
>, <Line: +			}
>, <Line: +			function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: +				var unwatch, lastValue;
>, <Line: +				return unwatch = scope.$watch(function oneTimeWatch(scope) {
>, <Line: +					return parsedExpression(scope);
>, <Line: +				}, function oneTimeListener(value, old, scope) {
>, <Line: +					lastValue = value;
>, <Line: +					if (isFunction(listener)) {
>, <Line: +						listener.call(this, value, old, scope);
>, <Line: +					}
>, <Line: +					if (isAllDefined(value)) {
>, <Line: +						scope.$$postDigest(function () {
>, <Line: +							if (isAllDefined(lastValue)) unwatch();
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}, objectEquality);
>, <Line: +				function isAllDefined(value) {
>, <Line: +					var allDefined = true;
>, <Line: +					forEach(value, function (val) {
>, <Line: +						if (!isDefined(val)) allDefined = false;
>, <Line: +					});
>, <Line: +					return allDefined;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: +				var unwatch;
>, <Line: +				return unwatch = scope.$watch(function constantWatch(scope) {
>, <Line: +					return parsedExpression(scope);
>, <Line: +				}, function constantListener(value, old, scope) {
>, <Line: +					if (isFunction(listener)) {
>, <Line: +						listener.apply(this, arguments);
>, <Line: +					}
>, <Line: +					unwatch();
>, <Line: +				}, objectEquality);
>, <Line: +			}
>, <Line: +			function addInterceptor(parsedExpression, interceptorFn) {
>, <Line: +				if (!interceptorFn) return parsedExpression;
>, <Line: +				var watchDelegate = parsedExpression.$$watchDelegate;
>, <Line: +				var regularWatch =
>, <Line: +					watchDelegate !== oneTimeLiteralWatchDelegate &&
>, <Line: +					watchDelegate !== oneTimeWatchDelegate;
>, <Line: +				var fn = regularWatch ? function regularInterceptedExpression(scope, locals) {
>, <Line: +					var value = parsedExpression(scope, locals);
>, <Line: +					return interceptorFn(value, scope, locals);
>, <Line: +				} : function oneTimeInterceptedExpression(scope, locals) {
>, <Line: +					var value = parsedExpression(scope, locals);
>, <Line: +					var result = interceptorFn(value, scope, locals);
>, <Line: +					// we only return the interceptor's result if the
>, <Line: +					// initial value is defined (for bind-once)
>, <Line: +					return isDefined(value) ? result : value;
>, <Line: +				};
>, <Line: +				// Propagate $$watchDelegates other then inputsWatchDelegate
>, <Line: +				if (parsedExpression.$$watchDelegate &&
>, <Line: +					parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
>, <Line: +					fn.$$watchDelegate = parsedExpression.$$watchDelegate;
>, <Line: +				} else if (!interceptorFn.$stateful) {
>, <Line: +					// If there is an interceptor, but no watchDelegate then treat the interceptor like
>, <Line: +					// we treat filters - it is assumed to be a pure function unless flagged with $stateful
>, <Line: +					fn.$$watchDelegate = inputsWatchDelegate;
>, <Line: +					fn.inputs = [parsedExpression];
>, <Line: +				}
>, <Line: +				return fn;
>, <Line: +			}
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $q
>, <Line: +	 * @requires $rootScope
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A service that helps you run functions asynchronously, and use their return values (or exceptions)
>, <Line: +	 * when they are done processing.
>, <Line: +	 *
>, <Line: +	 * This is an implementation of promises/deferred objects inspired by
>, <Line: +	 * [Kris Kowal's Q](https://github.com/kriskowal/q).
>, <Line: +	 *
>, <Line: +	 * $q can be used in two fashions --- one which is more similar to Kris Kowal's Q or jQuery's Deferred
>, <Line: +	 * implementations, and the other which resembles ES6 promises to some degree.
>, <Line: +	 *
>, <Line: +	 * # $q constructor
>, <Line: +	 *
>, <Line: +	 * The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver`
>, <Line: +	 * function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,
>, <Line: +	 * see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
>, <Line: +	 *
>, <Line: +	 * While the constructor-style use is supported, not all of the supporting methods from ES6 Harmony promises are
>, <Line: +	 * available yet.
>, <Line: +	 *
>, <Line: +	 * It can be used like so:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
>, <Line: +	 *   // are available in the current lexical scope (they could have been injected or passed in).
>, <Line: +	 *
>, <Line: +	 *   function asyncGreet(name) {
>, <Line: + *     // perform some asynchronous operation, resolve or reject the promise when appropriate.
>, <Line: + *     return $q(function(resolve, reject) {
>, <Line: + *       setTimeout(function() {
>, <Line: + *         if (okToGreet(name)) {
>, <Line: + *           resolve('Hello, ' + name + '!');
>, <Line: + *         } else {
>, <Line: + *           reject('Greeting ' + name + ' is not allowed.');
>, <Line: + *         }
>, <Line: + *       }, 1000);
>, <Line: + *     });
>, <Line: + *   }
>, <Line: +	 *
>, <Line: +	 *   var promise = asyncGreet('Robin Hood');
>, <Line: +	 *   promise.then(function(greeting) {
>, <Line: + *     alert('Success: ' + greeting);
>, <Line: + *   }, function(reason) {
>, <Line: + *     alert('Failed: ' + reason);
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Note: progress/notify callbacks are not currently supported via the ES6-style interface.
>, <Line: +	 *
>, <Line: +	 * However, the more traditional CommonJS-style usage is still available, and documented below.
>, <Line: +	 *
>, <Line: +	 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
>, <Line: +	 * interface for interacting with an object that represents the result of an action that is
>, <Line: +	 * performed asynchronously, and may or may not be finished at any given point in time.
>, <Line: +	 *
>, <Line: +	 * From the perspective of dealing with error handling, deferred and promise APIs are to
>, <Line: +	 * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
>, <Line: +	 *   // are available in the current lexical scope (they could have been injected or passed in).
>, <Line: +	 *
>, <Line: +	 *   function asyncGreet(name) {
>, <Line: + *     var deferred = $q.defer();
>, <Line: + *
>, <Line: + *     setTimeout(function() {
>, <Line: + *       deferred.notify('About to greet ' + name + '.');
>, <Line: + *
>, <Line: + *       if (okToGreet(name)) {
>, <Line: + *         deferred.resolve('Hello, ' + name + '!');
>, <Line: + *       } else {
>, <Line: + *         deferred.reject('Greeting ' + name + ' is not allowed.');
>, <Line: + *       }
>, <Line: + *     }, 1000);
>, <Line: + *
>, <Line: + *     return deferred.promise;
>, <Line: + *   }
>, <Line: +	 *
>, <Line: +	 *   var promise = asyncGreet('Robin Hood');
>, <Line: +	 *   promise.then(function(greeting) {
>, <Line: + *     alert('Success: ' + greeting);
>, <Line: + *   }, function(reason) {
>, <Line: + *     alert('Failed: ' + reason);
>, <Line: + *   }, function(update) {
>, <Line: + *     alert('Got notification: ' + update);
>, <Line: + *   });
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
>, <Line: +	 * comes in the way of guarantees that promise and deferred APIs make, see
>, <Line: +	 * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.
>, <Line: +	 *
>, <Line: +	 * Additionally the promise api allows for composition that is very hard to do with the
>, <Line: +	 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
>, <Line: +	 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
>, <Line: +	 * section on serial or parallel joining of promises.
>, <Line: +	 *
>, <Line: +	 * # The Deferred API
>, <Line: +	 *
>, <Line: +	 * A new instance of deferred is constructed by calling `$q.defer()`.
>, <Line: +	 *
>, <Line: +	 * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
>, <Line: +	 * that can be used for signaling the successful or unsuccessful completion, as well as the status
>, <Line: +	 * of the task.
>, <Line: +	 *
>, <Line: +	 * **Methods**
>, <Line: +	 *
>, <Line: +	 * - `resolve(value)`  resolves the derived promise with the `value`. If the value is a rejection
>, <Line: +	 *   constructed via `$q.reject`, the promise will be rejected instead.
>, <Line: +	 * - `reject(reason)`  rejects the derived promise with the `reason`. This is equivalent to
>, <Line: +	 *   resolving it with a rejection constructed via `$q.reject`.
>, <Line: +	 * - `notify(value)` - provides updates on the status of the promise's execution. This may be called
>, <Line: +	 *   multiple times before the promise is either resolved or rejected.
>, <Line: +	 *
>, <Line: +	 * **Properties**
>, <Line: +	 *
>, <Line: +	 * - promise  `{Promise}`  promise object associated with this deferred.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # The Promise API
>, <Line: +	 *
>, <Line: +	 * A new promise instance is created when a deferred instance is created and can be retrieved by
>, <Line: +	 * calling `deferred.promise`.
>, <Line: +	 *
>, <Line: +	 * The purpose of the promise object is to allow for interested parties to get access to the result
>, <Line: +	 * of the deferred task when it completes.
>, <Line: +	 *
>, <Line: +	 * **Methods**
>, <Line: +	 *
>, <Line: +	 * - `then(successCallback, errorCallback, notifyCallback)`  regardless of when the promise was or
>, <Line: +	 *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
>, <Line: +	 *   as soon as the result is available. The callbacks are called with a single argument: the result
>, <Line: +	 *   or rejection reason. Additionally, the notify callback may be called zero or more times to
>, <Line: +	 *   provide a progress indication, before the promise is resolved or rejected.
>, <Line: +	 *
>, <Line: +	 *   This method *returns a new promise* which is resolved or rejected via the return value of the
>, <Line: +	 *   `successCallback`, `errorCallback`. It also notifies via the return value of the
>, <Line: +	 *   `notifyCallback` method. The promise cannot be resolved or rejected from the notifyCallback
>, <Line: +	 *   method.
>, <Line: +	 *
>, <Line: +	 * - `catch(errorCallback)`  shorthand for `promise.then(null, errorCallback)`
>, <Line: +	 *
>, <Line: +	 * - `finally(callback, notifyCallback)`  allows you to observe either the fulfillment or rejection of a promise,
>, <Line: +	 *   but to do so without modifying the final value. This is useful to release resources or do some
>, <Line: +	 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
>, <Line: +	 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
>, <Line: +	 *   more information.
>, <Line: +	 *
>, <Line: +	 * # Chaining promises
>, <Line: +	 *
>, <Line: +	 * Because calling the `then` method of a promise returns a new derived promise, it is easily
>, <Line: +	 * possible to create a chain of promises:
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   promiseB = promiseA.then(function(result) {
>, <Line: + *     return result + 1;
>, <Line: + *   });
>, <Line: +	 *
>, <Line: +	 *   // promiseB will be resolved immediately after promiseA is resolved and its value
>, <Line: +	 *   // will be the result of promiseA incremented by 1
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * It is possible to create chains of any length and since a promise can be resolved with another
>, <Line: +	 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
>, <Line: +	 * the promises at any point in the chain. This makes it possible to implement powerful APIs like
>, <Line: +	 * $http's response interceptors.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # Differences between Kris Kowal's Q and $q
>, <Line: +	 *
>, <Line: +	 *  There are two main differences:
>, <Line: +	 *
>, <Line: +	 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
>, <Line: +	 *   mechanism in angular, which means faster propagation of resolution or rejection into your
>, <Line: +	 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
>, <Line: +	 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
>, <Line: +	 *   all the important functionality needed for common async tasks.
>, <Line: +	 *
>, <Line: +	 *  # Testing
>, <Line: +	 *
>, <Line: +	 *  ```js
>, <Line: +	 *    it('should simulate promise', inject(function($q, $rootScope) {
>, <Line: + *      var deferred = $q.defer();
>, <Line: + *      var promise = deferred.promise;
>, <Line: + *      var resolvedValue;
>, <Line: + *
>, <Line: + *      promise.then(function(value) { resolvedValue = value; });
>, <Line: + *      expect(resolvedValue).toBeUndefined();
>, <Line: + *
>, <Line: + *      // Simulate resolving of promise
>, <Line: + *      deferred.resolve(123);
>, <Line: + *      // Note that the 'then' function does not get called synchronously.
>, <Line: + *      // This is because we want the promise API to always be async, whether or not
>, <Line: + *      // it got called synchronously or asynchronously.
>, <Line: + *      expect(resolvedValue).toBeUndefined();
>, <Line: + *
>, <Line: + *      // Propagate promise resolution to 'then' functions using $apply().
>, <Line: + *      $rootScope.$apply();
>, <Line: + *      expect(resolvedValue).toEqual(123);
>, <Line: + *    }));
>, <Line: +	 *  ```
>, <Line: +	 *
>, <Line: +	 * @param {function(function, function)} resolver Function which is responsible for resolving or
>, <Line: +	 *   rejecting the newly created promise. The first parameter is a function which resolves the
>, <Line: +	 *   promise, the second parameter is a function which rejects the promise.
>, <Line: +	 *
>, <Line: +	 * @returns {Promise} The newly created promise.
>, <Line: +	 */
>, <Line: +	function $QProvider() {
>, <Line: +		this.$get = ['$rootScope', '$exceptionHandler', function ($rootScope, $exceptionHandler) {
>, <Line: +			return qFactory(function (callback) {
>, <Line: +				$rootScope.$evalAsync(callback);
>, <Line: +			}, $exceptionHandler);
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	function $$QProvider() {
>, <Line: +		this.$get = ['$browser', '$exceptionHandler', function ($browser, $exceptionHandler) {
>, <Line: +			return qFactory(function (callback) {
>, <Line: +				$browser.defer(callback);
>, <Line: +			}, $exceptionHandler);
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Constructs a promise manager.
>, <Line: +	 *
>, <Line: +	 * @param {function(function)} nextTick Function for executing functions in the next turn.
>, <Line: +	 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
>, <Line: +	 *     debugging purposes.
>, <Line: +	 * @returns {object} Promise manager.
>, <Line: +	 */
>, <Line: +	function qFactory(nextTick, exceptionHandler) {
>, <Line: +		var $qMinErr = minErr('$q', TypeError);
>, <Line: +		function callOnce(self, resolveFn, rejectFn) {
>, <Line: +			var called = false;
>, <Line: +			function wrap(fn) {
>, <Line: +				return function (value) {
>, <Line: +					if (called) return;
>, <Line: +					called = true;
>, <Line: +					fn.call(self, value);
>, <Line: +				};
>, <Line: +			}
>, <Line: +			return [wrap(resolveFn), wrap(rejectFn)];
>, <Line: +		}
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name ng.$q#defer
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Creates a `Deferred` object which represents a task which will finish in the future.
>, <Line: +		 *
>, <Line: +		 * @returns {Deferred} Returns a new instance of deferred.
>, <Line: +		 */
>, <Line: +		var defer = function () {
>, <Line: +			return new Deferred();
>, <Line: +		};
>, <Line: +		function Promise() {
>, <Line: +			this.$$state = {status: 0};
>, <Line: +		}
>, <Line: +		Promise.prototype = {
>, <Line: +			then: function (onFulfilled, onRejected, progressBack) {
>, <Line: +				var result = new Deferred();
>, <Line: +				this.$$state.pending = this.$$state.pending || [];
>, <Line: +				this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
>, <Line: +				if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
>, <Line: +				return result.promise;
>, <Line: +			},
>, <Line: +			"catch": function (callback) {
>, <Line: +				return this.then(null, callback);
>, <Line: +			},
>, <Line: +			"finally": function (callback, progressBack) {
>, <Line: +				return this.then(function (value) {
>, <Line: +					return handleCallback(value, true, callback);
>, <Line: +				}, function (error) {
>, <Line: +					return handleCallback(error, false, callback);
>, <Line: +				}, progressBack);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		//Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native
>, <Line: +		function simpleBind(context, fn) {
>, <Line: +			return function (value) {
>, <Line: +				fn.call(context, value);
>, <Line: +			};
>, <Line: +		}
>, <Line: +		function processQueue(state) {
>, <Line: +			var fn, promise, pending;
>, <Line: +			pending = state.pending;
>, <Line: +			state.processScheduled = false;
>, <Line: +			state.pending = undefined;
>, <Line: +			for (var i = 0, ii = pending.length; i < ii; ++i) {
>, <Line: +				promise = pending[i][0];
>, <Line: +				fn = pending[i][state.status];
>, <Line: +				try {
>, <Line: +					if (isFunction(fn)) {
>, <Line: +						promise.resolve(fn(state.value));
>, <Line: +					} else if (state.status === 1) {
>, <Line: +						promise.resolve(state.value);
>, <Line: +					} else {
>, <Line: +						promise.reject(state.value);
>, <Line: +					}
>, <Line: +				} catch (e) {
>, <Line: +					promise.reject(e);
>, <Line: +					exceptionHandler(e);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function scheduleProcessQueue(state) {
>, <Line: +			if (state.processScheduled || !state.pending) return;
>, <Line: +			state.processScheduled = true;
>, <Line: +			nextTick(function () {
>, <Line: +				processQueue(state);
>, <Line: +			});
>, <Line: +		}
>, <Line: +		function Deferred() {
>, <Line: +			this.promise = new Promise();
>, <Line: +			//Necessary to support unbound execution :/
>, <Line: +			this.resolve = simpleBind(this, this.resolve);
>, <Line: +			this.reject = simpleBind(this, this.reject);
>, <Line: +			this.notify = simpleBind(this, this.notify);
>, <Line: +		}
>, <Line: +		Deferred.prototype = {
>, <Line: +			resolve: function (val) {
>, <Line: +				if (this.promise.$$state.status) return;
>, <Line: +				if (val === this.promise) {
>, <Line: +					this.$$reject($qMinErr(
>, <Line: +						'qcycle',
>, <Line: +						"Expected promise to be resolved with value other than itself '{0}'",
>, <Line: +						val));
>, <Line: +				}
>, <Line: +				else {
>, <Line: +					this.$$resolve(val);
>, <Line: +				}
>, <Line: +			},
>, <Line: +			$$resolve: function (val) {
>, <Line: +				var then, fns;
>, <Line: +				fns = callOnce(this, this.$$resolve, this.$$reject);
>, <Line: +				try {
>, <Line: +					if ((isObject(val) || isFunction(val))) then = val && val.then;
>, <Line: +					if (isFunction(then)) {
>, <Line: +						this.promise.$$state.status = -1;
>, <Line: +						then.call(val, fns[0], fns[1], this.notify);
>, <Line: +					} else {
>, <Line: +						this.promise.$$state.value = val;
>, <Line: +						this.promise.$$state.status = 1;
>, <Line: +						scheduleProcessQueue(this.promise.$$state);
>, <Line: +					}
>, <Line: +				} catch (e) {
>, <Line: +					fns[1](e);
>, <Line: +					exceptionHandler(e);
>, <Line: +				}
>, <Line: +			},
>, <Line: +			reject: function (reason) {
>, <Line: +				if (this.promise.$$state.status) return;
>, <Line: +				this.$$reject(reason);
>, <Line: +			},
>, <Line: +			$$reject: function (reason) {
>, <Line: +				this.promise.$$state.value = reason;
>, <Line: +				this.promise.$$state.status = 2;
>, <Line: +				scheduleProcessQueue(this.promise.$$state);
>, <Line: +			},
>, <Line: +			notify: function (progress) {
>, <Line: +				var callbacks = this.promise.$$state.pending;
>, <Line: +				if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
>, <Line: +					nextTick(function () {
>, <Line: +						var callback, result;
>, <Line: +						for (var i = 0, ii = callbacks.length; i < ii; i++) {
>, <Line: +							result = callbacks[i][0];
>, <Line: +							callback = callbacks[i][3];
>, <Line: +							try {
>, <Line: +								result.notify(isFunction(callback) ? callback(progress) : progress);
>, <Line: +							} catch (e) {
>, <Line: +								exceptionHandler(e);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					});
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $q#reject
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
>, <Line: +		 * used to forward rejection in a chain of promises. If you are dealing with the last promise in
>, <Line: +		 * a promise chain, you don't need to worry about it.
>, <Line: +		 *
>, <Line: +		 * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
>, <Line: +		 * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
>, <Line: +		 * a promise error callback and you want to forward the error to the promise derived from the
>, <Line: +		 * current promise, you have to "rethrow" the error by returning a rejection constructed via
>, <Line: +		 * `reject`.
>, <Line: +		 *
>, <Line: +		 * ```js
>, <Line: +		 *   promiseB = promiseA.then(function(result) {
>, <Line: +   *     // success: do something and resolve promiseB
>, <Line: +   *     //          with the old or a new result
>, <Line: +   *     return result;
>, <Line: +   *   }, function(reason) {
>, <Line: +   *     // error: handle the error if possible and
>, <Line: +   *     //        resolve promiseB with newPromiseOrValue,
>, <Line: +   *     //        otherwise forward the rejection to promiseB
>, <Line: +   *     if (canHandle(reason)) {
>, <Line: +   *      // handle the error and recover
>, <Line: +   *      return newPromiseOrValue;
>, <Line: +   *     }
>, <Line: +   *     return $q.reject(reason);
>, <Line: +   *   });
>, <Line: +		 * ```
>, <Line: +		 *
>, <Line: +		 * @param {*} reason Constant, message, exception or an object representing the rejection reason.
>, <Line: +		 * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
>, <Line: +		 */
>, <Line: +		var reject = function (reason) {
>, <Line: +			var result = new Deferred();
>, <Line: +			result.reject(reason);
>, <Line: +			return result.promise;
>, <Line: +		};
>, <Line: +		var makePromise = function makePromise(value, resolved) {
>, <Line: +			var result = new Deferred();
>, <Line: +			if (resolved) {
>, <Line: +				result.resolve(value);
>, <Line: +			} else {
>, <Line: +				result.reject(value);
>, <Line: +			}
>, <Line: +			return result.promise;
>, <Line: +		};
>, <Line: +		var handleCallback = function handleCallback(value, isResolved, callback) {
>, <Line: +			var callbackOutput = null;
>, <Line: +			try {
>, <Line: +				if (isFunction(callback)) callbackOutput = callback();
>, <Line: +			} catch (e) {
>, <Line: +				return makePromise(e, false);
>, <Line: +			}
>, <Line: +			if (isPromiseLike(callbackOutput)) {
>, <Line: +				return callbackOutput.then(function () {
>, <Line: +					return makePromise(value, isResolved);
>, <Line: +				}, function (error) {
>, <Line: +					return makePromise(error, false);
>, <Line: +				});
>, <Line: +			} else {
>, <Line: +				return makePromise(value, isResolved);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $q#when
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
>, <Line: +		 * This is useful when you are dealing with an object that might or might not be a promise, or if
>, <Line: +		 * the promise comes from a source that can't be trusted.
>, <Line: +		 *
>, <Line: +		 * @param {*} value Value or a promise
>, <Line: +		 * @returns {Promise} Returns a promise of the passed value or promise
>, <Line: +		 */
>, <Line: +		var when = function (value, callback, errback, progressBack) {
>, <Line: +			var result = new Deferred();
>, <Line: +			result.resolve(value);
>, <Line: +			return result.promise.then(callback, errback, progressBack);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $q#all
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Combines multiple promises into a single promise that is resolved when all of the input
>, <Line: +		 * promises are resolved.
>, <Line: +		 *
>, <Line: +		 * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
>, <Line: +		 * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
>, <Line: +		 *   each value corresponding to the promise at the same index/key in the `promises` array/hash.
>, <Line: +		 *   If any of the promises is resolved with a rejection, this resulting promise will be rejected
>, <Line: +		 *   with the same rejection value.
>, <Line: +		 */
>, <Line: +		function all(promises) {
>, <Line: +			var deferred = new Deferred(),
>, <Line: +				counter = 0,
>, <Line: +				results = isArray(promises) ? [] : {};
>, <Line: +			forEach(promises, function (promise, key) {
>, <Line: +				counter++;
>, <Line: +				when(promise).then(function (value) {
>, <Line: +					if (results.hasOwnProperty(key)) return;
>, <Line: +					results[key] = value;
>, <Line: +					if (!(--counter)) deferred.resolve(results);
>, <Line: +				}, function (reason) {
>, <Line: +					if (results.hasOwnProperty(key)) return;
>, <Line: +					deferred.reject(reason);
>, <Line: +				});
>, <Line: +			});
>, <Line: +			if (counter === 0) {
>, <Line: +				deferred.resolve(results);
>, <Line: +			}
>, <Line: +			return deferred.promise;
>, <Line: +		}
>, <Line: +		var $Q = function Q(resolver) {
>, <Line: +			if (!isFunction(resolver)) {
>, <Line: +				throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
>, <Line: +			}
>, <Line: +			if (!(this instanceof Q)) {
>, <Line: +				// More useful when $Q is the Promise itself.
>, <Line: +				return new Q(resolver);
>, <Line: +			}
>, <Line: +			var deferred = new Deferred();
>, <Line: +			function resolveFn(value) {
>, <Line: +				deferred.resolve(value);
>, <Line: +			}
>, <Line: +			function rejectFn(reason) {
>, <Line: +				deferred.reject(reason);
>, <Line: +			}
>, <Line: +			resolver(resolveFn, rejectFn);
>, <Line: +			return deferred.promise;
>, <Line: +		};
>, <Line: +		$Q.defer = defer;
>, <Line: +		$Q.reject = reject;
>, <Line: +		$Q.when = when;
>, <Line: +		$Q.all = all;
>, <Line: +		return $Q;
>, <Line: +	}
>, <Line: +	function $$RAFProvider() { //rAF
>, <Line: +		this.$get = ['$window', '$timeout', function ($window, $timeout) {
>, <Line: +			var requestAnimationFrame = $window.requestAnimationFrame ||
>, <Line: +				$window.webkitRequestAnimationFrame ||
>, <Line: +				$window.mozRequestAnimationFrame;
>, <Line: +			var cancelAnimationFrame = $window.cancelAnimationFrame ||
>, <Line: +				$window.webkitCancelAnimationFrame ||
>, <Line: +				$window.mozCancelAnimationFrame ||
>, <Line: +				$window.webkitCancelRequestAnimationFrame;
>, <Line: +			var rafSupported = !!requestAnimationFrame;
>, <Line: +			var raf = rafSupported
>, <Line: +				? function (fn) {
>, <Line: +				var id = requestAnimationFrame(fn);
>, <Line: +				return function () {
>, <Line: +					cancelAnimationFrame(id);
>, <Line: +				};
>, <Line: +			}
>, <Line: +				: function (fn) {
>, <Line: +				var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666
>, <Line: +				return function () {
>, <Line: +					$timeout.cancel(timer);
>, <Line: +				};
>, <Line: +			};
>, <Line: +			raf.supported = rafSupported;
>, <Line: +			return raf;
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * DESIGN NOTES
>, <Line: +	 *
>, <Line: +	 * The design decisions behind the scope are heavily favored for speed and memory consumption.
>, <Line: +	 *
>, <Line: +	 * The typical use of scope is to watch the expressions, which most of the time return the same
>, <Line: +	 * value as last time so we optimize the operation.
>, <Line: +	 *
>, <Line: +	 * Closures construction is expensive in terms of speed as well as memory:
>, <Line: +	 *   - No closures, instead use prototypical inheritance for API
>, <Line: +	 *   - Internal state needs to be stored on scope directly, which means that private state is
>, <Line: +	 *     exposed as $$____ properties
>, <Line: +	 *
>, <Line: +	 * Loop operations are optimized by using while(count--) { ... }
>, <Line: +	 *   - this means that in order to keep the same order of execution as addition we have to add
>, <Line: +	 *     items to the array at the beginning (unshift) instead of at the end (push)
>, <Line: +	 *
>, <Line: +	 * Child scopes are created and removed often
>, <Line: +	 *   - Using an array would be slow since inserts in middle are expensive so we use linked list
>, <Line: +	 *
>, <Line: +	 * There are few watches then a lot of observers. This is why you don't want the observer to be
>, <Line: +	 * implemented in the same way as watch. Watch requires return of initialization function which
>, <Line: +	 * are expensive to construct.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $rootScopeProvider
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Provider for the $rootScope service.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc method
>, <Line: +	 * @name $rootScopeProvider#digestTtl
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and
>, <Line: +	 * assuming that the model is unstable.
>, <Line: +	 *
>, <Line: +	 * The current default is 10 iterations.
>, <Line: +	 *
>, <Line: +	 * In complex applications it's possible that the dependencies between `$watch`s will result in
>, <Line: +	 * several digest iterations. However if an application needs more than the default 10 digest
>, <Line: +	 * iterations for its model to stabilize then you should investigate what is causing the model to
>, <Line: +	 * continuously change during the digest.
>, <Line: +	 *
>, <Line: +	 * Increasing the TTL could have performance implications, so you should not change it without
>, <Line: +	 * proper justification.
>, <Line: +	 *
>, <Line: +	 * @param {number} limit The number of digest iterations.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $rootScope
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Every application has a single root {@link ng.$rootScope.Scope scope}.
>, <Line: +	 * All other scopes are descendant scopes of the root scope. Scopes provide separation
>, <Line: +	 * between the model and the view, via a mechanism for watching the model for changes.
>, <Line: +	 * They also provide an event emission/broadcast and subscription facility. See the
>, <Line: +	 * {@link guide/scope developer guide on scopes}.
>, <Line: +	 */
>, <Line: +	function $RootScopeProvider() {
>, <Line: +		var TTL = 10;
>, <Line: +		var $rootScopeMinErr = minErr('$rootScope');
>, <Line: +		var lastDirtyWatch = null;
>, <Line: +		var applyAsyncId = null;
>, <Line: +		this.digestTtl = function (value) {
>, <Line: +			if (arguments.length) {
>, <Line: +				TTL = value;
>, <Line: +			}
>, <Line: +			return TTL;
>, <Line: +		};
>, <Line: +		this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
>, <Line: +			function ($injector, $exceptionHandler, $parse, $browser) {
>, <Line: +				/**
>, <Line: +				 * @ngdoc type
>, <Line: +				 * @name $rootScope.Scope
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
>, <Line: +				 * {@link auto.$injector $injector}. Child scopes are created using the
>, <Line: +				 * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
>, <Line: +				 * compiled HTML template is executed.)
>, <Line: +				 *
>, <Line: +				 * Here is a simple scope snippet to show how you can interact with the scope.
>, <Line: +				 * ```html
>, <Line: +				 * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * # Inheritance
>, <Line: +				 * A scope can inherit from a parent scope, as in this example:
>, <Line: +				 * ```js
>, <Line: +				 var parent = $rootScope;
>, <Line: +				 var child = parent.$new();
>, <Line: +				 parent.salutation = "Hello";
>, <Line: +				 child.name = "World";
>, <Line: +				 expect(child.salutation).toEqual('Hello');
>, <Line: +				 child.salutation = "Welcome";
>, <Line: +				 expect(child.salutation).toEqual('Welcome');
>, <Line: +				 expect(parent.salutation).toEqual('Hello');
>, <Line: +				 * ```
>, <Line: +				 *
>, <Line: +				 * When interacting with `Scope` in tests, additional helper methods are available on the
>, <Line: +				 * instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional
>, <Line: +				 * details.
>, <Line: +				 *
>, <Line: +				 *
>, <Line: +				 * @param {Object.<string, function()>=} providers Map of service factory which need to be
>, <Line: +				 *                                       provided for the current scope. Defaults to {@link ng}.
>, <Line: +				 * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
>, <Line: +				 *                              append/override services provided by `providers`. This is handy
>, <Line: +				 *                              when unit-testing and having the need to override a default
>, <Line: +				 *                              service.
>, <Line: +				 * @returns {Object} Newly created scope.
>, <Line: +				 *
>, <Line: +				 */
>, <Line: +				function Scope() {
>, <Line: +					this.$id = nextUid();
>, <Line: +					this.$$phase = this.$parent = this.$$watchers =
>, <Line: +						this.$$nextSibling = this.$$prevSibling =
>, <Line: +							this.$$childHead = this.$$childTail = null;
>, <Line: +					this.$root = this;
>, <Line: +					this.$$destroyed = false;
>, <Line: +					this.$$listeners = {};
>, <Line: +					this.$$listenerCount = {};
>, <Line: +					this.$$isolateBindings = null;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $rootScope.Scope#$id
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Unique scope ID (monotonically increasing) useful for debugging.
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $rootScope.Scope#$parent
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Reference to the parent scope.
>, <Line: +				 */
>, <Line: +				/**
>, <Line: +				 * @ngdoc property
>, <Line: +				 * @name $rootScope.Scope#$root
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Reference to the root scope.
>, <Line: +				 */
>, <Line: +				Scope.prototype = {
>, <Line: +					constructor: Scope,
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$new
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Creates a new child {@link ng.$rootScope.Scope scope}.
>, <Line: +					 *
>, <Line: +					 * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} event.
>, <Line: +					 * The scope can be removed from the scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
>, <Line: +					 *
>, <Line: +					 * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is
>, <Line: +					 * desired for the scope and its child scopes to be permanently detached from the parent and
>, <Line: +					 * thus stop participating in model change detection and listener notification by invoking.
>, <Line: +					 *
>, <Line: +					 * @param {boolean} isolate If true, then the scope does not prototypically inherit from the
>, <Line: +					 *         parent scope. The scope is isolated, as it can not see parent scope properties.
>, <Line: +					 *         When creating widgets, it is useful for the widget to not accidentally read parent
>, <Line: +					 *         state.
>, <Line: +					 *
>, <Line: +					 * @param {Scope} [parent=this] The {@link ng.$rootScope.Scope `Scope`} that will be the `$parent`
>, <Line: +					 *                              of the newly created scope. Defaults to `this` scope if not provided.
>, <Line: +					 *                              This is used when creating a transclude scope to correctly place it
>, <Line: +					 *                              in the scope hierarchy while maintaining the correct prototypical
>, <Line: +					 *                              inheritance.
>, <Line: +					 *
>, <Line: +					 * @returns {Object} The newly created child scope.
>, <Line: +					 *
>, <Line: +					 */
>, <Line: +					$new: function (isolate, parent) {
>, <Line: +						var child;
>, <Line: +						parent = parent || this;
>, <Line: +						if (isolate) {
>, <Line: +							child = new Scope();
>, <Line: +							child.$root = this.$root;
>, <Line: +						} else {
>, <Line: +							// Only create a child scope class if somebody asks for one,
>, <Line: +							// but cache it to allow the VM to optimize lookups.
>, <Line: +							if (!this.$$ChildScope) {
>, <Line: +								this.$$ChildScope = function ChildScope() {
>, <Line: +									this.$$watchers = this.$$nextSibling =
>, <Line: +										this.$$childHead = this.$$childTail = null;
>, <Line: +									this.$$listeners = {};
>, <Line: +									this.$$listenerCount = {};
>, <Line: +									this.$id = nextUid();
>, <Line: +									this.$$ChildScope = null;
>, <Line: +								};
>, <Line: +								this.$$ChildScope.prototype = this;
>, <Line: +							}
>, <Line: +							child = new this.$$ChildScope();
>, <Line: +						}
>, <Line: +						child.$parent = parent;
>, <Line: +						child.$$prevSibling = parent.$$childTail;
>, <Line: +						if (parent.$$childHead) {
>, <Line: +							parent.$$childTail.$$nextSibling = child;
>, <Line: +							parent.$$childTail = child;
>, <Line: +						} else {
>, <Line: +							parent.$$childHead = parent.$$childTail = child;
>, <Line: +						}
>, <Line: +						// When the new scope is not isolated or we inherit from `this`, and
>, <Line: +						// the parent scope is destroyed, the property `$$destroyed` is inherited
>, <Line: +						// prototypically. In all other cases, this property needs to be set
>, <Line: +						// when the parent scope is destroyed.
>, <Line: +						// The listener needs to be added after the parent is set
>, <Line: +						if (isolate || parent != this) child.$on('$destroy', destroyChild);
>, <Line: +						return child;
>, <Line: +						function destroyChild() {
>, <Line: +							child.$$destroyed = true;
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$watch
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
>, <Line: +					 *
>, <Line: +					 * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest
>, <Line: +       *   $digest()} and should return the value that will be watched. (Since
>, <Line: +					 *   {@link ng.$rootScope.Scope#$digest $digest()} reruns when it detects changes the
>, <Line: +					 *   `watchExpression` can execute multiple times per
>, <Line: +					 *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
>, <Line: +					 * - The `listener` is called only when the value from the current `watchExpression` and the
>, <Line: +					 *   previous call to `watchExpression` are not equal (with the exception of the initial run,
>, <Line: +					 *   see below). Inequality is determined according to reference inequality,
>, <Line: +					 *   [strict comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
>, <Line: +					 *    via the `!==` Javascript operator, unless `objectEquality == true`
>, <Line: +					 *   (see next point)
>, <Line: +					 * - When `objectEquality == true`, inequality of the `watchExpression` is determined
>, <Line: +					 *   according to the {@link angular.equals} function. To save the value of the object for
>, <Line: +					 *   later comparison, the {@link angular.copy} function is used. This therefore means that
>, <Line: +					 *   watching complex objects will have adverse memory and performance implications.
>, <Line: +					 * - The watch `listener` may change the model, which may trigger other `listener`s to fire.
>, <Line: +					 *   This is achieved by rerunning the watchers until no changes are detected. The rerun
>, <Line: +					 *   iteration limit is 10 to prevent an infinite loop deadlock.
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
>, <Line: +					 * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
>, <Line: +					 * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a
>, <Line: +					 * change is detected, be prepared for multiple calls to your listener.)
>, <Line: +					 *
>, <Line: +					 * After a watcher is registered with the scope, the `listener` fn is called asynchronously
>, <Line: +					 * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
>, <Line: +					 * watcher. In rare cases, this is undesirable because the listener is called when the result
>, <Line: +					 * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
>, <Line: +					 * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
>, <Line: +					 * listener was called due to initialization.
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * # Example
>, <Line: +					 * ```js
>, <Line: +					 // let's assume that scope was dependency injected as the $rootScope
>, <Line: +					 var scope = $rootScope;
>, <Line: +					 scope.name = 'misko';
>, <Line: +					 scope.counter = 0;
>, <Line: +					 expect(scope.counter).toEqual(0);
>, <Line: +					 scope.$watch('name', function(newValue, oldValue) {
>, <Line: +             scope.counter = scope.counter + 1;
>, <Line: +           });
>, <Line: +					 expect(scope.counter).toEqual(0);
>, <Line: +					 scope.$digest();
>, <Line: +					 // the listener is always called during the first $digest loop after it was registered
>, <Line: +					 expect(scope.counter).toEqual(1);
>, <Line: +					 scope.$digest();
>, <Line: +					 // but now it will not be called unless the value changes
>, <Line: +					 expect(scope.counter).toEqual(1);
>, <Line: +					 scope.name = 'adam';
>, <Line: +					 scope.$digest();
>, <Line: +					 expect(scope.counter).toEqual(2);
>, <Line: +					 // Using a function as a watchExpression
>, <Line: +					 var food;
>, <Line: +					 scope.foodCounter = 0;
>, <Line: +					 expect(scope.foodCounter).toEqual(0);
>, <Line: +					 scope.$watch(
>, <Line: +					 // This function returns the value being watched. It is called for each turn of the $digest loop
>, <Line: +					 function() { return food; },
>, <Line: +					 // This is the change listener, called when the value returned from the above function changes
>, <Line: +					 function(newValue, oldValue) {
>, <Line: +               if ( newValue !== oldValue ) {
>, <Line: +                 // Only increment the counter if the value changed
>, <Line: +                 scope.foodCounter = scope.foodCounter + 1;
>, <Line: +               }
>, <Line: +             }
>, <Line: +					 );
>, <Line: +					 // No digest has been run so the counter will be zero
>, <Line: +					 expect(scope.foodCounter).toEqual(0);
>, <Line: +					 // Run the digest but since food has not changed count will still be zero
>, <Line: +					 scope.$digest();
>, <Line: +					 expect(scope.foodCounter).toEqual(0);
>, <Line: +					 // Update food and run digest.  Now the counter will increment
>, <Line: +					 food = 'cheeseburger';
>, <Line: +					 scope.$digest();
>, <Line: +					 expect(scope.foodCounter).toEqual(1);
>, <Line: +					 * ```
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * @param {(function()|string)} watchExpression Expression that is evaluated on each
>, <Line: +					 *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers
>, <Line: +					 *    a call to the `listener`.
>, <Line: +					 *
>, <Line: +					 *    - `string`: Evaluated as {@link guide/expression expression}
>, <Line: +					 *    - `function(scope)`: called with current `scope` as a parameter.
>, <Line: +					 * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value
>, <Line: +					 *    of `watchExpression` changes.
>, <Line: +					 *
>, <Line: +					 *    - `newVal` contains the current value of the `watchExpression`
>, <Line: +					 *    - `oldVal` contains the previous value of the `watchExpression`
>, <Line: +					 *    - `scope` refers to the current scope
>, <Line: +					 * @param {boolean=} objectEquality Compare for object equality using {@link angular.equals} instead of
>, <Line: +					 *     comparing for reference equality.
>, <Line: +					 * @returns {function()} Returns a deregistration function for this listener.
>, <Line: +					 */
>, <Line: +					$watch: function (watchExp, listener, objectEquality) {
>, <Line: +						var get = $parse(watchExp);
>, <Line: +						if (get.$$watchDelegate) {
>, <Line: +							return get.$$watchDelegate(this, listener, objectEquality, get);
>, <Line: +						}
>, <Line: +						var scope = this,
>, <Line: +							array = scope.$$watchers,
>, <Line: +							watcher = {
>, <Line: +								fn: listener,
>, <Line: +								last: initWatchVal,
>, <Line: +								get: get,
>, <Line: +								exp: watchExp,
>, <Line: +								eq: !!objectEquality
>, <Line: +							};
>, <Line: +						lastDirtyWatch = null;
>, <Line: +						if (!isFunction(listener)) {
>, <Line: +							watcher.fn = noop;
>, <Line: +						}
>, <Line: +						if (!array) {
>, <Line: +							array = scope.$$watchers = [];
>, <Line: +						}
>, <Line: +						// we use unshift since we use a while loop in $digest for speed.
>, <Line: +						// the while loop reads in reverse order.
>, <Line: +						array.unshift(watcher);
>, <Line: +						return function deregisterWatch() {
>, <Line: +							arrayRemove(array, watcher);
>, <Line: +							lastDirtyWatch = null;
>, <Line: +						};
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$watchGroup
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`.
>, <Line: +					 * If any one expression in the collection changes the `listener` is executed.
>, <Line: +					 *
>, <Line: +					 * - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every
>, <Line: +					 *   call to $digest() to see if any items changes.
>, <Line: +					 * - The `listener` is called whenever any expression in the `watchExpressions` array changes.
>, <Line: +					 *
>, <Line: +					 * @param {Array.<string|Function(scope)>} watchExpressions Array of expressions that will be individually
>, <Line: +					 * watched using {@link ng.$rootScope.Scope#$watch $watch()}
>, <Line: +					 *
>, <Line: +					 * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any
>, <Line: +					 *    expression in `watchExpressions` changes
>, <Line: +					 *    The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching
>, <Line: +					 *    those of `watchExpression`
>, <Line: +					 *    and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching
>, <Line: +					 *    those of `watchExpression`
>, <Line: +					 *    The `scope` refers to the current scope.
>, <Line: +					 * @returns {function()} Returns a de-registration function for all listeners.
>, <Line: +					 */
>, <Line: +					$watchGroup: function (watchExpressions, listener) {
>, <Line: +						var oldValues = new Array(watchExpressions.length);
>, <Line: +						var newValues = new Array(watchExpressions.length);
>, <Line: +						var deregisterFns = [];
>, <Line: +						var self = this;
>, <Line: +						var changeReactionScheduled = false;
>, <Line: +						var firstRun = true;
>, <Line: +						if (!watchExpressions.length) {
>, <Line: +							// No expressions means we call the listener ASAP
>, <Line: +							var shouldCall = true;
>, <Line: +							self.$evalAsync(function () {
>, <Line: +								if (shouldCall) listener(newValues, newValues, self);
>, <Line: +							});
>, <Line: +							return function deregisterWatchGroup() {
>, <Line: +								shouldCall = false;
>, <Line: +							};
>, <Line: +						}
>, <Line: +						if (watchExpressions.length === 1) {
>, <Line: +							// Special case size of one
>, <Line: +							return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
>, <Line: +								newValues[0] = value;
>, <Line: +								oldValues[0] = oldValue;
>, <Line: +								listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
>, <Line: +							});
>, <Line: +						}
>, <Line: +						forEach(watchExpressions, function (expr, i) {
>, <Line: +							var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
>, <Line: +								newValues[i] = value;
>, <Line: +								oldValues[i] = oldValue;
>, <Line: +								if (!changeReactionScheduled) {
>, <Line: +									changeReactionScheduled = true;
>, <Line: +									self.$evalAsync(watchGroupAction);
>, <Line: +								}
>, <Line: +							});
>, <Line: +							deregisterFns.push(unwatchFn);
>, <Line: +						});
>, <Line: +						function watchGroupAction() {
>, <Line: +							changeReactionScheduled = false;
>, <Line: +							if (firstRun) {
>, <Line: +								firstRun = false;
>, <Line: +								listener(newValues, newValues, self);
>, <Line: +							} else {
>, <Line: +								listener(newValues, oldValues, self);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						return function deregisterWatchGroup() {
>, <Line: +							while (deregisterFns.length) {
>, <Line: +								deregisterFns.shift()();
>, <Line: +							}
>, <Line: +						};
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$watchCollection
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Shallow watches the properties of an object and fires whenever any of the properties change
>, <Line: +					 * (for arrays, this implies watching the array items; for object maps, this implies watching
>, <Line: +					 * the properties). If a change is detected, the `listener` callback is fired.
>, <Line: +					 *
>, <Line: +					 * - The `obj` collection is observed via standard $watch operation and is examined on every
>, <Line: +					 *   call to $digest() to see if any items have been added, removed, or moved.
>, <Line: +					 * - The `listener` is called whenever anything within the `obj` has changed. Examples include
>, <Line: +					 *   adding, removing, and moving items belonging to an object or array.
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * # Example
>, <Line: +					 * ```js
>, <Line: +					 $scope.names = ['igor', 'matias', 'misko', 'james'];
>, <Line: +					 $scope.dataCount = 4;
>, <Line: +					 $scope.$watchCollection('names', function(newNames, oldNames) {
>, <Line: +            $scope.dataCount = newNames.length;
>, <Line: +          });
>, <Line: +					 expect($scope.dataCount).toEqual(4);
>, <Line: +					 $scope.$digest();
>, <Line: +					 //still at 4 ... no changes
>, <Line: +					 expect($scope.dataCount).toEqual(4);
>, <Line: +					 $scope.names.pop();
>, <Line: +					 $scope.$digest();
>, <Line: +					 //now there's been a change
>, <Line: +					 expect($scope.dataCount).toEqual(3);
>, <Line: +					 * ```
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The
>, <Line: +					 *    expression value should evaluate to an object or an array which is observed on each
>, <Line: +					 *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the
>, <Line: +					 *    collection will trigger a call to the `listener`.
>, <Line: +					 *
>, <Line: +					 * @param {function(newCollection, oldCollection, scope)} listener a callback function called
>, <Line: +					 *    when a change is detected.
>, <Line: +					 *    - The `newCollection` object is the newly modified data obtained from the `obj` expression
>, <Line: +					 *    - The `oldCollection` object is a copy of the former collection data.
>, <Line: +					 *      Due to performance considerations, the`oldCollection` value is computed only if the
>, <Line: +					 *      `listener` function declares two or more arguments.
>, <Line: +					 *    - The `scope` argument refers to the current scope.
>, <Line: +					 *
>, <Line: +					 * @returns {function()} Returns a de-registration function for this listener. When the
>, <Line: +					 *    de-registration function is executed, the internal watch operation is terminated.
>, <Line: +					 */
>, <Line: +					$watchCollection: function (obj, listener) {
>, <Line: +						$watchCollectionInterceptor.$stateful = true;
>, <Line: +						var self = this;
>, <Line: +						// the current value, updated on each dirty-check run
>, <Line: +						var newValue;
>, <Line: +						// a shallow copy of the newValue from the last dirty-check run,
>, <Line: +						// updated to match newValue during dirty-check run
>, <Line: +						var oldValue;
>, <Line: +						// a shallow copy of the newValue from when the last change happened
>, <Line: +						var veryOldValue;
>, <Line: +						// only track veryOldValue if the listener is asking for it
>, <Line: +						var trackVeryOldValue = (listener.length > 1);
>, <Line: +						var changeDetected = 0;
>, <Line: +						var changeDetector = $parse(obj, $watchCollectionInterceptor);
>, <Line: +						var internalArray = [];
>, <Line: +						var internalObject = {};
>, <Line: +						var initRun = true;
>, <Line: +						var oldLength = 0;
>, <Line: +						function $watchCollectionInterceptor(_value) {
>, <Line: +							newValue = _value;
>, <Line: +							var newLength, key, bothNaN, newItem, oldItem;
>, <Line: +							// If the new value is undefined, then return undefined as the watch may be a one-time watch
>, <Line: +							if (isUndefined(newValue)) return;
>, <Line: +							if (!isObject(newValue)) { // if primitive
>, <Line: +								if (oldValue !== newValue) {
>, <Line: +									oldValue = newValue;
>, <Line: +									changeDetected++;
>, <Line: +								}
>, <Line: +							} else if (isArrayLike(newValue)) {
>, <Line: +								if (oldValue !== internalArray) {
>, <Line: +									// we are transitioning from something which was not an array into array.
>, <Line: +									oldValue = internalArray;
>, <Line: +									oldLength = oldValue.length = 0;
>, <Line: +									changeDetected++;
>, <Line: +								}
>, <Line: +								newLength = newValue.length;
>, <Line: +								if (oldLength !== newLength) {
>, <Line: +									// if lengths do not match we need to trigger change notification
>, <Line: +									changeDetected++;
>, <Line: +									oldValue.length = oldLength = newLength;
>, <Line: +								}
>, <Line: +								// copy the items to oldValue and look for changes.
>, <Line: +								for (var i = 0; i < newLength; i++) {
>, <Line: +									oldItem = oldValue[i];
>, <Line: +									newItem = newValue[i];
>, <Line: +									bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
>, <Line: +									if (!bothNaN && (oldItem !== newItem)) {
>, <Line: +										changeDetected++;
>, <Line: +										oldValue[i] = newItem;
>, <Line: +									}
>, <Line: +								}
>, <Line: +							} else {
>, <Line: +								if (oldValue !== internalObject) {
>, <Line: +									// we are transitioning from something which was not an object into object.
>, <Line: +									oldValue = internalObject = {};
>, <Line: +									oldLength = 0;
>, <Line: +									changeDetected++;
>, <Line: +								}
>, <Line: +								// copy the items to oldValue and look for changes.
>, <Line: +								newLength = 0;
>, <Line: +								for (key in newValue) {
>, <Line: +									if (newValue.hasOwnProperty(key)) {
>, <Line: +										newLength++;
>, <Line: +										newItem = newValue[key];
>, <Line: +										oldItem = oldValue[key];
>, <Line: +										if (key in oldValue) {
>, <Line: +											bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
>, <Line: +											if (!bothNaN && (oldItem !== newItem)) {
>, <Line: +												changeDetected++;
>, <Line: +												oldValue[key] = newItem;
>, <Line: +											}
>, <Line: +										} else {
>, <Line: +											oldLength++;
>, <Line: +											oldValue[key] = newItem;
>, <Line: +											changeDetected++;
>, <Line: +										}
>, <Line: +									}
>, <Line: +								}
>, <Line: +								if (oldLength > newLength) {
>, <Line: +									// we used to have more keys, need to find them and destroy them.
>, <Line: +									changeDetected++;
>, <Line: +									for (key in oldValue) {
>, <Line: +										if (!newValue.hasOwnProperty(key)) {
>, <Line: +											oldLength--;
>, <Line: +											delete oldValue[key];
>, <Line: +										}
>, <Line: +									}
>, <Line: +								}
>, <Line: +							}
>, <Line: +							return changeDetected;
>, <Line: +						}
>, <Line: +						function $watchCollectionAction() {
>, <Line: +							if (initRun) {
>, <Line: +								initRun = false;
>, <Line: +								listener(newValue, newValue, self);
>, <Line: +							} else {
>, <Line: +								listener(newValue, veryOldValue, self);
>, <Line: +							}
>, <Line: +							// make a copy for the next time a collection is changed
>, <Line: +							if (trackVeryOldValue) {
>, <Line: +								if (!isObject(newValue)) {
>, <Line: +									//primitive
>, <Line: +									veryOldValue = newValue;
>, <Line: +								} else if (isArrayLike(newValue)) {
>, <Line: +									veryOldValue = new Array(newValue.length);
>, <Line: +									for (var i = 0; i < newValue.length; i++) {
>, <Line: +										veryOldValue[i] = newValue[i];
>, <Line: +									}
>, <Line: +								} else { // if object
>, <Line: +									veryOldValue = {};
>, <Line: +									for (var key in newValue) {
>, <Line: +										if (hasOwnProperty.call(newValue, key)) {
>, <Line: +											veryOldValue[key] = newValue[key];
>, <Line: +										}
>, <Line: +									}
>, <Line: +								}
>, <Line: +							}
>, <Line: +						}
>, <Line: +						return this.$watch(changeDetector, $watchCollectionAction);
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$digest
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and
>, <Line: +					 * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change
>, <Line: +					 * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers}
>, <Line: +					 * until no more listeners are firing. This means that it is possible to get into an infinite
>, <Line: +					 * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of
>, <Line: +					 * iterations exceeds 10.
>, <Line: +					 *
>, <Line: +					 * Usually, you don't call `$digest()` directly in
>, <Line: +					 * {@link ng.directive:ngController controllers} or in
>, <Line: +					 * {@link ng.$compileProvider#directive directives}.
>, <Line: +					 * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within
>, <Line: +					 * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`.
>, <Line: +					 *
>, <Line: +					 * If you want to be notified whenever `$digest()` is called,
>, <Line: +					 * you can register a `watchExpression` function with
>, <Line: +					 * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.
>, <Line: +					 *
>, <Line: +					 * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.
>, <Line: +					 *
>, <Line: +					 * # Example
>, <Line: +					 * ```js
>, <Line: +					 var scope = ...;
>, <Line: +					 scope.name = 'misko';
>, <Line: +					 scope.counter = 0;
>, <Line: +					 expect(scope.counter).toEqual(0);
>, <Line: +					 scope.$watch('name', function(newValue, oldValue) {
>, <Line: +             scope.counter = scope.counter + 1;
>, <Line: +           });
>, <Line: +					 expect(scope.counter).toEqual(0);
>, <Line: +					 scope.$digest();
>, <Line: +					 // the listener is always called during the first $digest loop after it was registered
>, <Line: +					 expect(scope.counter).toEqual(1);
>, <Line: +					 scope.$digest();
>, <Line: +					 // but now it will not be called unless the value changes
>, <Line: +					 expect(scope.counter).toEqual(1);
>, <Line: +					 scope.name = 'adam';
>, <Line: +					 scope.$digest();
>, <Line: +					 expect(scope.counter).toEqual(2);
>, <Line: +					 * ```
>, <Line: +					 *
>, <Line: +					 */
>, <Line: +					$digest: function () {
>, <Line: +						var watch, value, last,
>, <Line: +							watchers,
>, <Line: +							length,
>, <Line: +							dirty, ttl = TTL,
>, <Line: +							next, current, target = this,
>, <Line: +							watchLog = [],
>, <Line: +							logIdx, logMsg, asyncTask;
>, <Line: +						beginPhase('$digest');
>, <Line: +						// Check for changes to browser url that happened in sync before the call to $digest
>, <Line: +						$browser.$$checkUrlChange();
>, <Line: +						if (this === $rootScope && applyAsyncId !== null) {
>, <Line: +							// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then
>, <Line: +							// cancel the scheduled $apply and flush the queue of expressions to be evaluated.
>, <Line: +							$browser.defer.cancel(applyAsyncId);
>, <Line: +							flushApplyAsync();
>, <Line: +						}
>, <Line: +						lastDirtyWatch = null;
>, <Line: +						do { // "while dirty" loop
>, <Line: +							dirty = false;
>, <Line: +							current = target;
>, <Line: +							while (asyncQueue.length) {
>, <Line: +								try {
>, <Line: +									asyncTask = asyncQueue.shift();
>, <Line: +									asyncTask.scope.$eval(asyncTask.expression);
>, <Line: +								} catch (e) {
>, <Line: +									$exceptionHandler(e);
>, <Line: +								}
>, <Line: +								lastDirtyWatch = null;
>, <Line: +							}
>, <Line: +							traverseScopesLoop:
>, <Line: +								do { // "traverse the scopes" loop
>, <Line: +									if ((watchers = current.$$watchers)) {
>, <Line: +										// process our watches
>, <Line: +										length = watchers.length;
>, <Line: +										while (length--) {
>, <Line: +											try {
>, <Line: +												watch = watchers[length];
>, <Line: +												// Most common watches are on primitives, in which case we can short
>, <Line: +												// circuit it with === operator, only when === fails do we use .equals
>, <Line: +												if (watch) {
>, <Line: +													if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq
>, <Line: +															? equals(value, last)
>, <Line: +															: (typeof value === 'number' && typeof last === 'number'
>, <Line: +														&& isNaN(value) && isNaN(last)))) {
>, <Line: +														dirty = true;
>, <Line: +														lastDirtyWatch = watch;
>, <Line: +														watch.last = watch.eq ? copy(value, null) : value;
>, <Line: +														watch.fn(value, ((last === initWatchVal) ? value : last), current);
>, <Line: +														if (ttl < 5) {
>, <Line: +															logIdx = 4 - ttl;
>, <Line: +															if (!watchLog[logIdx]) watchLog[logIdx] = [];
>, <Line: +															watchLog[logIdx].push({
>, <Line: +																msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
>, <Line: +																newVal: value,
>, <Line: +																oldVal: last
>, <Line: +															});
>, <Line: +														}
>, <Line: +													} else if (watch === lastDirtyWatch) {
>, <Line: +														// If the most recently dirty watcher is now clean, short circuit since the remaining watchers
>, <Line: +														// have already been tested.
>, <Line: +														dirty = false;
>, <Line: +														break traverseScopesLoop;
>, <Line: +													}
>, <Line: +												}
>, <Line: +											} catch (e) {
>, <Line: +												$exceptionHandler(e);
>, <Line: +											}
>, <Line: +										}
>, <Line: +									}
>, <Line: +									// Insanity Warning: scope depth-first traversal
>, <Line: +									// yes, this code is a bit crazy, but it works and we have tests to prove it!
>, <Line: +									// this piece should be kept in sync with the traversal in $broadcast
>, <Line: +									if (!(next = (current.$$childHead ||
>, <Line: +										(current !== target && current.$$nextSibling)))) {
>, <Line: +										while (current !== target && !(next = current.$$nextSibling)) {
>, <Line: +											current = current.$parent;
>, <Line: +										}
>, <Line: +									}
>, <Line: +								} while ((current = next));
>, <Line: +							// `break traverseScopesLoop;` takes us to here
>, <Line: +							if ((dirty || asyncQueue.length) && !(ttl--)) {
>, <Line: +								clearPhase();
>, <Line: +								throw $rootScopeMinErr('infdig',
>, <Line: +									'{0} $digest() iterations reached. Aborting!\n' +
>, <Line: +									'Watchers fired in the last 5 iterations: {1}',
>, <Line: +									TTL, watchLog);
>, <Line: +							}
>, <Line: +						} while (dirty || asyncQueue.length);
>, <Line: +						clearPhase();
>, <Line: +						while (postDigestQueue.length) {
>, <Line: +							try {
>, <Line: +								postDigestQueue.shift()();
>, <Line: +							} catch (e) {
>, <Line: +								$exceptionHandler(e);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc event
>, <Line: +					 * @name $rootScope.Scope#$destroy
>, <Line: +					 * @eventType broadcast on scope being destroyed
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Broadcasted when a scope and its children are being destroyed.
>, <Line: +					 *
>, <Line: +					 * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
>, <Line: +					 * clean up DOM bindings before an element is removed from the DOM.
>, <Line: +					 */
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$destroy
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Removes the current scope (and all of its children) from the parent scope. Removal implies
>, <Line: +					 * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
>, <Line: +					 * propagate to the current scope and its children. Removal also implies that the current
>, <Line: +					 * scope is eligible for garbage collection.
>, <Line: +					 *
>, <Line: +					 * The `$destroy()` is usually used by directives such as
>, <Line: +					 * {@link ng.directive:ngRepeat ngRepeat} for managing the
>, <Line: +					 * unrolling of the loop.
>, <Line: +					 *
>, <Line: +					 * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.
>, <Line: +					 * Application code can register a `$destroy` event handler that will give it a chance to
>, <Line: +					 * perform any necessary cleanup.
>, <Line: +					 *
>, <Line: +					 * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
>, <Line: +					 * clean up DOM bindings before an element is removed from the DOM.
>, <Line: +					 */
>, <Line: +					$destroy: function () {
>, <Line: +						// we can't destroy the root scope or a scope that has been already destroyed
>, <Line: +						if (this.$$destroyed) return;
>, <Line: +						var parent = this.$parent;
>, <Line: +						this.$broadcast('$destroy');
>, <Line: +						this.$$destroyed = true;
>, <Line: +						if (this === $rootScope) return;
>, <Line: +						for (var eventName in this.$$listenerCount) {
>, <Line: +							decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
>, <Line: +						}
>, <Line: +						// sever all the references to parent scopes (after this cleanup, the current scope should
>, <Line: +						// not be retained by any of our references and should be eligible for garbage collection)
>, <Line: +						if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
>, <Line: +						if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
>, <Line: +						if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
>, <Line: +						if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
>, <Line: +						// Disable listeners, watchers and apply/digest methods
>, <Line: +						this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
>, <Line: +						this.$on = this.$watch = this.$watchGroup = function () {
>, <Line: +							return noop;
>, <Line: +						};
>, <Line: +						this.$$listeners = {};
>, <Line: +						// All of the code below is bogus code that works around V8's memory leak via optimized code
>, <Line: +						// and inline caches.
>, <Line: +						//
>, <Line: +						// see:
>, <Line: +						// - https://code.google.com/p/v8/issues/detail?id=2073#c26
>, <Line: +						// - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909
>, <Line: +						// - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
>, <Line: +						this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
>, <Line: +							this.$$childTail = this.$root = this.$$watchers = null;
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$eval
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Executes the `expression` on the current scope and returns the result. Any exceptions in
>, <Line: +					 * the expression are propagated (uncaught). This is useful when evaluating Angular
>, <Line: +					 * expressions.
>, <Line: +					 *
>, <Line: +					 * # Example
>, <Line: +					 * ```js
>, <Line: +					 var scope = ng.$rootScope.Scope();
>, <Line: +					 scope.a = 1;
>, <Line: +					 scope.b = 2;
>, <Line: +					 expect(scope.$eval('a+b')).toEqual(3);
>, <Line: +					 expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
>, <Line: +					 * ```
>, <Line: +					 *
>, <Line: +					 * @param {(string|function())=} expression An angular expression to be executed.
>, <Line: +					 *
>, <Line: +					 *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
>, <Line: +					 *    - `function(scope)`: execute the function with the current `scope` parameter.
>, <Line: +					 *
>, <Line: +					 * @param {(object)=} locals Local variables object, useful for overriding values in scope.
>, <Line: +					 * @returns {*} The result of evaluating the expression.
>, <Line: +					 */
>, <Line: +					$eval: function (expr, locals) {
>, <Line: +						return $parse(expr)(this, locals);
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$evalAsync
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Executes the expression on the current scope at a later point in time.
>, <Line: +					 *
>, <Line: +					 * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
>, <Line: +					 * that:
>, <Line: +					 *
>, <Line: +					 *   - it will execute after the function that scheduled the evaluation (preferably before DOM
>, <Line: +					 *     rendering).
>, <Line: +					 *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after
>, <Line: +					 *     `expression` execution.
>, <Line: +					 *
>, <Line: +					 * Any exceptions from the execution of the expression are forwarded to the
>, <Line: +					 * {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: +					 *
>, <Line: +					 * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle
>, <Line: +					 * will be scheduled. However, it is encouraged to always call code that changes the model
>, <Line: +					 * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
>, <Line: +					 *
>, <Line: +					 * @param {(string|function())=} expression An angular expression to be executed.
>, <Line: +					 *
>, <Line: +					 *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: +					 *    - `function(scope)`: execute the function with the current `scope` parameter.
>, <Line: +					 *
>, <Line: +					 */
>, <Line: +					$evalAsync: function (expr) {
>, <Line: +						// if we are outside of an $digest loop and this is the first time we are scheduling async
>, <Line: +						// task also schedule async auto-flush
>, <Line: +						if (!$rootScope.$$phase && !asyncQueue.length) {
>, <Line: +							$browser.defer(function () {
>, <Line: +								if (asyncQueue.length) {
>, <Line: +									$rootScope.$digest();
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +						asyncQueue.push({scope: this, expression: expr});
>, <Line: +					},
>, <Line: +					$$postDigest: function (fn) {
>, <Line: +						postDigestQueue.push(fn);
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$apply
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * `$apply()` is used to execute an expression in angular from outside of the angular
>, <Line: +					 * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).
>, <Line: +					 * Because we are calling into the angular framework we need to perform proper scope life
>, <Line: +					 * cycle of {@link ng.$exceptionHandler exception handling},
>, <Line: +					 * {@link ng.$rootScope.Scope#$digest executing watches}.
>, <Line: +					 *
>, <Line: +					 * ## Life cycle
>, <Line: +					 *
>, <Line: +					 * # Pseudo-Code of `$apply()`
>, <Line: +					 * ```js
>, <Line: +					 function $apply(expr) {
>, <Line: +             try {
>, <Line: +               return $eval(expr);
>, <Line: +             } catch (e) {
>, <Line: +               $exceptionHandler(e);
>, <Line: +             } finally {
>, <Line: +               $root.$digest();
>, <Line: +             }
>, <Line: +           }
>, <Line: +					 * ```
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * Scope's `$apply()` method transitions through the following stages:
>, <Line: +					 *
>, <Line: +					 * 1. The {@link guide/expression expression} is executed using the
>, <Line: +					 *    {@link ng.$rootScope.Scope#$eval $eval()} method.
>, <Line: +					 * 2. Any exceptions from the execution of the expression are forwarded to the
>, <Line: +					 *    {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: +					 * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the
>, <Line: +					 *    expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
>, <Line: +					 *
>, <Line: +					 *
>, <Line: +					 * @param {(string|function())=} exp An angular expression to be executed.
>, <Line: +					 *
>, <Line: +					 *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: +					 *    - `function(scope)`: execute the function with current `scope` parameter.
>, <Line: +					 *
>, <Line: +					 * @returns {*} The result of evaluating the expression.
>, <Line: +					 */
>, <Line: +					$apply: function (expr) {
>, <Line: +						try {
>, <Line: +							beginPhase('$apply');
>, <Line: +							return this.$eval(expr);
>, <Line: +						} catch (e) {
>, <Line: +							$exceptionHandler(e);
>, <Line: +						} finally {
>, <Line: +							clearPhase();
>, <Line: +							try {
>, <Line: +								$rootScope.$digest();
>, <Line: +							} catch (e) {
>, <Line: +								$exceptionHandler(e);
>, <Line: +								throw e;
>, <Line: +							}
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$applyAsync
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Schedule the invokation of $apply to occur at a later time. The actual time difference
>, <Line: +					 * varies across browsers, but is typically around ~10 milliseconds.
>, <Line: +					 *
>, <Line: +					 * This can be used to queue up multiple expressions which need to be evaluated in the same
>, <Line: +					 * digest.
>, <Line: +					 *
>, <Line: +					 * @param {(string|function())=} exp An angular expression to be executed.
>, <Line: +					 *
>, <Line: +					 *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: +					 *    - `function(scope)`: execute the function with current `scope` parameter.
>, <Line: +					 */
>, <Line: +					$applyAsync: function (expr) {
>, <Line: +						var scope = this;
>, <Line: +						expr && applyAsyncQueue.push($applyAsyncExpression);
>, <Line: +						scheduleApplyAsync();
>, <Line: +						function $applyAsyncExpression() {
>, <Line: +							scope.$eval(expr);
>, <Line: +						}
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$on
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for
>, <Line: +					 * discussion of event life cycle.
>, <Line: +					 *
>, <Line: +					 * The event listener function format is: `function(event, args...)`. The `event` object
>, <Line: +					 * passed into the listener has the following attributes:
>, <Line: +					 *
>, <Line: +					 *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or
>, <Line: +					 *     `$broadcast`-ed.
>, <Line: +					 *   - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the
>, <Line: +					 *     event propagates through the scope hierarchy, this property is set to null.
>, <Line: +					 *   - `name` - `{string}`: name of the event.
>, <Line: +					 *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel
>, <Line: +					 *     further event propagation (available only for events that were `$emit`-ed).
>, <Line: +					 *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag
>, <Line: +					 *     to true.
>, <Line: +					 *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
>, <Line: +					 *
>, <Line: +					 * @param {string} name Event name to listen on.
>, <Line: +					 * @param {function(event, ...args)} listener Function to call when the event is emitted.
>, <Line: +					 * @returns {function()} Returns a deregistration function for this listener.
>, <Line: +					 */
>, <Line: +					$on: function (name, listener) {
>, <Line: +						var namedListeners = this.$$listeners[name];
>, <Line: +						if (!namedListeners) {
>, <Line: +							this.$$listeners[name] = namedListeners = [];
>, <Line: +						}
>, <Line: +						namedListeners.push(listener);
>, <Line: +						var current = this;
>, <Line: +						do {
>, <Line: +							if (!current.$$listenerCount[name]) {
>, <Line: +								current.$$listenerCount[name] = 0;
>, <Line: +							}
>, <Line: +							current.$$listenerCount[name]++;
>, <Line: +						} while ((current = current.$parent));
>, <Line: +						var self = this;
>, <Line: +						return function () {
>, <Line: +							var indexOfListener = namedListeners.indexOf(listener);
>, <Line: +							if (indexOfListener !== -1) {
>, <Line: +								namedListeners[indexOfListener] = null;
>, <Line: +								decrementListenerCount(self, 1, name);
>, <Line: +							}
>, <Line: +						};
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$emit
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Dispatches an event `name` upwards through the scope hierarchy notifying the
>, <Line: +					 * registered {@link ng.$rootScope.Scope#$on} listeners.
>, <Line: +					 *
>, <Line: +					 * The event life cycle starts at the scope on which `$emit` was called. All
>, <Line: +					 * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
>, <Line: +					 * notified. Afterwards, the event traverses upwards toward the root scope and calls all
>, <Line: +					 * registered listeners along the way. The event will stop propagating if one of the listeners
>, <Line: +					 * cancels it.
>, <Line: +					 *
>, <Line: +					 * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
>, <Line: +					 * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: +					 *
>, <Line: +					 * @param {string} name Event name to emit.
>, <Line: +					 * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
>, <Line: +					 * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).
>, <Line: +					 */
>, <Line: +					$emit: function (name, args) {
>, <Line: +						var empty = [],
>, <Line: +							namedListeners,
>, <Line: +							scope = this,
>, <Line: +							stopPropagation = false,
>, <Line: +							event = {
>, <Line: +								name: name,
>, <Line: +								targetScope: scope,
>, <Line: +								stopPropagation: function () {
>, <Line: +									stopPropagation = true;
>, <Line: +								},
>, <Line: +								preventDefault: function () {
>, <Line: +									event.defaultPrevented = true;
>, <Line: +								},
>, <Line: +								defaultPrevented: false
>, <Line: +							},
>, <Line: +							listenerArgs = concat([event], arguments, 1),
>, <Line: +							i, length;
>, <Line: +						do {
>, <Line: +							namedListeners = scope.$$listeners[name] || empty;
>, <Line: +							event.currentScope = scope;
>, <Line: +							for (i = 0, length = namedListeners.length; i < length; i++) {
>, <Line: +								// if listeners were deregistered, defragment the array
>, <Line: +								if (!namedListeners[i]) {
>, <Line: +									namedListeners.splice(i, 1);
>, <Line: +									i--;
>, <Line: +									length--;
>, <Line: +									continue;
>, <Line: +								}
>, <Line: +								try {
>, <Line: +									//allow all listeners attached to the current scope to run
>, <Line: +									namedListeners[i].apply(null, listenerArgs);
>, <Line: +								} catch (e) {
>, <Line: +									$exceptionHandler(e);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							//if any listener on the current scope stops propagation, prevent bubbling
>, <Line: +							if (stopPropagation) {
>, <Line: +								event.currentScope = null;
>, <Line: +								return event;
>, <Line: +							}
>, <Line: +							//traverse upwards
>, <Line: +							scope = scope.$parent;
>, <Line: +						} while (scope);
>, <Line: +						event.currentScope = null;
>, <Line: +						return event;
>, <Line: +					},
>, <Line: +					/**
>, <Line: +					 * @ngdoc method
>, <Line: +					 * @name $rootScope.Scope#$broadcast
>, <Line: +					 * @kind function
>, <Line: +					 *
>, <Line: +					 * @description
>, <Line: +					 * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
>, <Line: +					 * registered {@link ng.$rootScope.Scope#$on} listeners.
>, <Line: +					 *
>, <Line: +					 * The event life cycle starts at the scope on which `$broadcast` was called. All
>, <Line: +					 * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
>, <Line: +					 * notified. Afterwards, the event propagates to all direct and indirect scopes of the current
>, <Line: +					 * scope and calls all registered listeners along the way. The event cannot be canceled.
>, <Line: +					 *
>, <Line: +					 * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
>, <Line: +					 * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: +					 *
>, <Line: +					 * @param {string} name Event name to broadcast.
>, <Line: +					 * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
>, <Line: +					 * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
>, <Line: +					 */
>, <Line: +					$broadcast: function (name, args) {
>, <Line: +						var target = this,
>, <Line: +							current = target,
>, <Line: +							next = target,
>, <Line: +							event = {
>, <Line: +								name: name,
>, <Line: +								targetScope: target,
>, <Line: +								preventDefault: function () {
>, <Line: +									event.defaultPrevented = true;
>, <Line: +								},
>, <Line: +								defaultPrevented: false
>, <Line: +							};
>, <Line: +						if (!target.$$listenerCount[name]) return event;
>, <Line: +						var listenerArgs = concat([event], arguments, 1),
>, <Line: +							listeners, i, length;
>, <Line: +						//down while you can, then up and next sibling or up and next sibling until back at root
>, <Line: +						while ((current = next)) {
>, <Line: +							event.currentScope = current;
>, <Line: +							listeners = current.$$listeners[name] || [];
>, <Line: +							for (i = 0, length = listeners.length; i < length; i++) {
>, <Line: +								// if listeners were deregistered, defragment the array
>, <Line: +								if (!listeners[i]) {
>, <Line: +									listeners.splice(i, 1);
>, <Line: +									i--;
>, <Line: +									length--;
>, <Line: +									continue;
>, <Line: +								}
>, <Line: +								try {
>, <Line: +									listeners[i].apply(null, listenerArgs);
>, <Line: +								} catch (e) {
>, <Line: +									$exceptionHandler(e);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							// Insanity Warning: scope depth-first traversal
>, <Line: +							// yes, this code is a bit crazy, but it works and we have tests to prove it!
>, <Line: +							// this piece should be kept in sync with the traversal in $digest
>, <Line: +							// (though it differs due to having the extra check for $$listenerCount)
>, <Line: +							if (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
>, <Line: +								(current !== target && current.$$nextSibling)))) {
>, <Line: +								while (current !== target && !(next = current.$$nextSibling)) {
>, <Line: +									current = current.$parent;
>, <Line: +								}
>, <Line: +							}
>, <Line: +						}
>, <Line: +						event.currentScope = null;
>, <Line: +						return event;
>, <Line: +					}
>, <Line: +				};
>, <Line: +				var $rootScope = new Scope();
>, <Line: +				//The internal queues. Expose them on the $rootScope for debugging/testing purposes.
>, <Line: +				var asyncQueue = $rootScope.$$asyncQueue = [];
>, <Line: +				var postDigestQueue = $rootScope.$$postDigestQueue = [];
>, <Line: +				var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
>, <Line: +				return $rootScope;
>, <Line: +				function beginPhase(phase) {
>, <Line: +					if ($rootScope.$$phase) {
>, <Line: +						throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
>, <Line: +					}
>, <Line: +					$rootScope.$$phase = phase;
>, <Line: +				}
>, <Line: +				function clearPhase() {
>, <Line: +					$rootScope.$$phase = null;
>, <Line: +				}
>, <Line: +				function decrementListenerCount(current, count, name) {
>, <Line: +					do {
>, <Line: +						current.$$listenerCount[name] -= count;
>, <Line: +						if (current.$$listenerCount[name] === 0) {
>, <Line: +							delete current.$$listenerCount[name];
>, <Line: +						}
>, <Line: +					} while ((current = current.$parent));
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * function used as an initial value for watchers.
>, <Line: +				 * because it's unique we can easily tell it apart from other values
>, <Line: +				 */
>, <Line: +				function initWatchVal() {
>, <Line: +				}
>, <Line: +				function flushApplyAsync() {
>, <Line: +					while (applyAsyncQueue.length) {
>, <Line: +						try {
>, <Line: +							applyAsyncQueue.shift()();
>, <Line: +						} catch (e) {
>, <Line: +							$exceptionHandler(e);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					applyAsyncId = null;
>, <Line: +				}
>, <Line: +				function scheduleApplyAsync() {
>, <Line: +					if (applyAsyncId === null) {
>, <Line: +						applyAsyncId = $browser.defer(function () {
>, <Line: +							$rootScope.$apply(flushApplyAsync);
>, <Line: +						});
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @description
>, <Line: +	 * Private service to sanitize uris for links and images. Used by $compile and $sanitize.
>, <Line: +	 */
>, <Line: +	function $$SanitizeUriProvider() {
>, <Line: +		var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
>, <Line: +			imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
>, <Line: +		/**
>, <Line: +		 * @description
>, <Line: +		 * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: +		 * urls during a[href] sanitization.
>, <Line: +		 *
>, <Line: +		 * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: +		 *
>, <Line: +		 * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
>, <Line: +		 * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
>, <Line: +		 * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: +		 * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: +		 *
>, <Line: +		 * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: +		 * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: +		 *    chaining otherwise.
>, <Line: +		 */
>, <Line: +		this.aHrefSanitizationWhitelist = function (regexp) {
>, <Line: +			if (isDefined(regexp)) {
>, <Line: +				aHrefSanitizationWhitelist = regexp;
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +			return aHrefSanitizationWhitelist;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @description
>, <Line: +		 * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: +		 * urls during img[src] sanitization.
>, <Line: +		 *
>, <Line: +		 * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: +		 *
>, <Line: +		 * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
>, <Line: +		 * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
>, <Line: +		 * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: +		 * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: +		 *
>, <Line: +		 * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: +		 * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: +		 *    chaining otherwise.
>, <Line: +		 */
>, <Line: +		this.imgSrcSanitizationWhitelist = function (regexp) {
>, <Line: +			if (isDefined(regexp)) {
>, <Line: +				imgSrcSanitizationWhitelist = regexp;
>, <Line: +				return this;
>, <Line: +			}
>, <Line: +			return imgSrcSanitizationWhitelist;
>, <Line: +		};
>, <Line: +		this.$get = function () {
>, <Line: +			return function sanitizeUri(uri, isImage) {
>, <Line: +				var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
>, <Line: +				var normalizedVal;
>, <Line: +				normalizedVal = urlResolve(uri).href;
>, <Line: +				if (normalizedVal !== '' && !normalizedVal.match(regex)) {
>, <Line: +					return 'unsafe:' + normalizedVal;
>, <Line: +				}
>, <Line: +				return uri;
>, <Line: +			};
>, <Line: +		};
>, <Line: +	}
>, <Line: +	var $sceMinErr = minErr('$sce');
>, <Line: +	var SCE_CONTEXTS = {
>, <Line: +		HTML: 'html',
>, <Line: +		CSS: 'css',
>, <Line: +		URL: 'url',
>, <Line: +		// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
>, <Line: +		// url.  (e.g. ng-include, script src, templateUrl)
>, <Line: +		RESOURCE_URL: 'resourceUrl',
>, <Line: +		JS: 'js'
>, <Line: +	};
>, <Line: +	function adjustMatcher(matcher) {
>, <Line: +		if (matcher === 'self') {
>, <Line: +			return matcher;
>, <Line: +		} else if (isString(matcher)) {
>, <Line: +			// Strings match exactly except for 2 wildcards - '*' and '**'.
>, <Line: +			// '*' matches any character except those from the set ':/.?&'.
>, <Line: +			// '**' matches any character (like .* in a RegExp).
>, <Line: +			// More than 2 *'s raises an error as it's ill defined.
>, <Line: +			if (matcher.indexOf('***') > -1) {
>, <Line: +				throw $sceMinErr('iwcard',
>, <Line: +					'Illegal sequence *** in string matcher.  String: {0}', matcher);
>, <Line: +			}
>, <Line: +			matcher = escapeForRegexp(matcher).
>, <Line: +				replace('\\*\\*', '.*').
>, <Line: +				replace('\\*', '[^:/.?&;]*');
>, <Line: +			return new RegExp('^' + matcher + '$');
>, <Line: +		} else if (isRegExp(matcher)) {
>, <Line: +			// The only other type of matcher allowed is a Regexp.
>, <Line: +			// Match entire URL / disallow partial matches.
>, <Line: +			// Flags are reset (i.e. no global, ignoreCase or multiline)
>, <Line: +			return new RegExp('^' + matcher.source + '$');
>, <Line: +		} else {
>, <Line: +			throw $sceMinErr('imatcher',
>, <Line: +				'Matchers may only be "self", string patterns or RegExp objects');
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function adjustMatchers(matchers) {
>, <Line: +		var adjustedMatchers = [];
>, <Line: +		if (isDefined(matchers)) {
>, <Line: +			forEach(matchers, function (matcher) {
>, <Line: +				adjustedMatchers.push(adjustMatcher(matcher));
>, <Line: +			});
>, <Line: +		}
>, <Line: +		return adjustedMatchers;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $sceDelegate
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
>, <Line: +	 *
>, <Line: +	 * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
>, <Line: +	 * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
>, <Line: +	 * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
>, <Line: +	 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
>, <Line: +	 * work because `$sce` delegates to `$sceDelegate` for these operations.
>, <Line: +	 *
>, <Line: +	 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
>, <Line: +	 *
>, <Line: +	 * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
>, <Line: +	 * can override it completely to change the behavior of `$sce`, the common case would
>, <Line: +	 * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
>, <Line: +	 * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
>, <Line: +	 * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist
>, <Line: +		* ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $sceDelegateProvider
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
>, <Line: +	 * that the URLs used for sourcing Angular templates are safe.  Refer {@link
>, <Line: +		* ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
>, <Line: +	 * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
>, <Line: +	 *
>, <Line: +	 * For the general details about this service in Angular, read the main page for {@link ng.$sce
>, <Line: +	 *
>, <Line: +	 * **Example**:  Consider the following case. <a name="example"></a>
>, <Line: +	 *
>, <Line: +	 * - your app is hosted at url `http://myapp.example.com/`
>, <Line: +	 * - but some of your templates are hosted on other domains you control such as
>, <Line: +	 *   `http://srv01.assets.example.com/`, `http://srv02.assets.example.com/`, etc.
>, <Line: +	 * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
>, <Line: +	 *
>, <Line: +	 * Here is what a secure configuration for this scenario might look like:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 *  angular.module('myApp', []).config(function($sceDelegateProvider) {
>, <Line: +	 * ```
>, <Line: +	 */
>, <Line: +	function $SceDelegateProvider() {
>, <Line: +		this.SCE_CONTEXTS = SCE_CONTEXTS;
>, <Line: +		// Resource URLs can also be trusted by policy.
>, <Line: +		var resourceUrlWhitelist = ['self'],
>, <Line: +			resourceUrlBlacklist = [];
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $sceDelegateProvider#resourceUrlWhitelist
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
>, <Line: +		 *     provided.  This must be an array or null.  A snapshot of this array is used so further
>, <Line: +		 *     changes to the array are ignored.
>, <Line: +		 *
>, <Line: +		 *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
>, <Line: +		 *     allowed in this array.
>, <Line: +		 *
>, <Line: +		 *     Note: **an empty whitelist array will block all URLs**!
>, <Line: +		 *
>, <Line: +		 * @return {Array} the currently set whitelist array.
>, <Line: +		 *
>, <Line: +		 * The **default value** when no whitelist has been explicitly set is `['self']` allowing only
>, <Line: +		 * same origin resource requests.
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets/Gets the whitelist of trusted resource URLs.
>, <Line: +		 */
>, <Line: +		this.resourceUrlWhitelist = function (value) {
>, <Line: +			if (arguments.length) {
>, <Line: +				resourceUrlWhitelist = adjustMatchers(value);
>, <Line: +			}
>, <Line: +			return resourceUrlWhitelist;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $sceDelegateProvider#resourceUrlBlacklist
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
>, <Line: +		 *     provided.  This must be an array or null.  A snapshot of this array is used so further
>, <Line: +		 *     changes to the array are ignored.
>, <Line: +		 *
>, <Line: +		 *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
>, <Line: +		 *     allowed in this array.
>, <Line: +		 *
>, <Line: +		 *     The typical usage for the blacklist is to **block
>, <Line: +		 *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
>, <Line: +		 *     these would otherwise be trusted but actually return content from the redirected domain.
>, <Line: +		 *
>, <Line: +		 *     Finally, **the blacklist overrides the whitelist** and has the final say.
>, <Line: +		 *
>, <Line: +		 * @return {Array} the currently set blacklist array.
>, <Line: +		 *
>, <Line: +		 * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there
>, <Line: +		 * is no blacklist.)
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets/Gets the blacklist of trusted resource URLs.
>, <Line: +		 */
>, <Line: +		this.resourceUrlBlacklist = function (value) {
>, <Line: +			if (arguments.length) {
>, <Line: +				resourceUrlBlacklist = adjustMatchers(value);
>, <Line: +			}
>, <Line: +			return resourceUrlBlacklist;
>, <Line: +		};
>, <Line: +		this.$get = ['$injector', function ($injector) {
>, <Line: +			var htmlSanitizer = function htmlSanitizer(html) {
>, <Line: +				throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
>, <Line: +			};
>, <Line: +			if ($injector.has('$sanitize')) {
>, <Line: +				htmlSanitizer = $injector.get('$sanitize');
>, <Line: +			}
>, <Line: +			function matchUrl(matcher, parsedUrl) {
>, <Line: +				if (matcher === 'self') {
>, <Line: +					return urlIsSameOrigin(parsedUrl);
>, <Line: +				} else {
>, <Line: +					// definitely a regex.  See adjustMatchers()
>, <Line: +					return !!matcher.exec(parsedUrl.href);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			function isResourceUrlAllowedByPolicy(url) {
>, <Line: +				var parsedUrl = urlResolve(url.toString());
>, <Line: +				var i, n, allowed = false;
>, <Line: +				// Ensure that at least one item from the whitelist allows this url.
>, <Line: +				for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
>, <Line: +					if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
>, <Line: +						allowed = true;
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (allowed) {
>, <Line: +					// Ensure that no item from the blacklist blocked this url.
>, <Line: +					for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
>, <Line: +						if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
>, <Line: +							allowed = false;
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return allowed;
>, <Line: +			}
>, <Line: +			function generateHolderType(Base) {
>, <Line: +				var holderType = function TrustedValueHolderType(trustedValue) {
>, <Line: +					this.$$unwrapTrustedValue = function () {
>, <Line: +						return trustedValue;
>, <Line: +					};
>, <Line: +				};
>, <Line: +				if (Base) {
>, <Line: +					holderType.prototype = new Base();
>, <Line: +				}
>, <Line: +				holderType.prototype.valueOf = function sceValueOf() {
>, <Line: +					return this.$$unwrapTrustedValue();
>, <Line: +				};
>, <Line: +				holderType.prototype.toString = function sceToString() {
>, <Line: +					return this.$$unwrapTrustedValue().toString();
>, <Line: +				};
>, <Line: +				return holderType;
>, <Line: +			}
>, <Line: +			var trustedValueHolderBase = generateHolderType(),
>, <Line: +				byType = {};
>, <Line: +			byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
>, <Line: +			byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
>, <Line: +			byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
>, <Line: +			byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
>, <Line: +			byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sceDelegate#trustAs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Returns an object that is trusted by angular for use in specified strict
>, <Line: +			 * contextual escaping contexts (such as ng-bind-html, ng-include, any src
>, <Line: +			 * attribute interpolation, any dom event binding attribute interpolation
>, <Line: +			 * such as for onclick,  etc.) that uses the provided value.
>, <Line: +			 * See {@link ng.$sce $sce} for enabling strict contextual escaping.
>, <Line: +			 *
>, <Line: +			 * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
>, <Line: +			 *   resourceUrl, html, js and css.
>, <Line: +			 * @param {*} value The value that that should be considered trusted/safe.
>, <Line: +			 * @returns {*} A value that can be used to stand in for the provided `value` in places
>, <Line: +			 * where Angular expects a $sce.trustAs() return value.
>, <Line: +			 */
>, <Line: +			function trustAs(type, trustedValue) {
>, <Line: +				var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
>, <Line: +				if (!Constructor) {
>, <Line: +					throw $sceMinErr('icontext',
>, <Line: +						'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
>, <Line: +						type, trustedValue);
>, <Line: +				}
>, <Line: +				if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
>, <Line: +					return trustedValue;
>, <Line: +				}
>, <Line: +				// All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
>, <Line: +				// mutable objects, we ensure here that the value passed in is actually a string.
>, <Line: +				if (typeof trustedValue !== 'string') {
>, <Line: +					throw $sceMinErr('itype',
>, <Line: +						'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
>, <Line: +						type);
>, <Line: +				}
>, <Line: +				return new Constructor(trustedValue);
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sceDelegate#valueOf
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
>, <Line: +				* ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
>, <Line: +			 *
>, <Line: +			 * If the passed parameter is not a value that had been returned by {@link
>, <Line: +				* ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.
>, <Line: +			 *
>, <Line: +			 * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
>, <Line: +			 *      call or anything else.
>, <Line: +			 * @returns {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs
>, <Line: +			 *     `value` unchanged.
>, <Line: +			 */
>, <Line: +			function valueOf(maybeTrusted) {
>, <Line: +				if (maybeTrusted instanceof trustedValueHolderBase) {
>, <Line: +					return maybeTrusted.$$unwrapTrustedValue();
>, <Line: +				} else {
>, <Line: +					return maybeTrusted;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sceDelegate#getTrusted
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and
>, <Line: +			 * returns the originally supplied value if the queried context type is a supertype of the
>, <Line: +			 * created type.  If this condition isn't satisfied, throws an exception.
>, <Line: +			 *
>, <Line: +			 * @param {string} type The kind of context in which this value is to be used.
>, <Line: +			 * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
>, <Line: +			 * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
>, <Line: +			 */
>, <Line: +			function getTrusted(type, maybeTrusted) {
>, <Line: +				if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
>, <Line: +					return maybeTrusted;
>, <Line: +				}
>, <Line: +				var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
>, <Line: +				if (constructor && maybeTrusted instanceof constructor) {
>, <Line: +					return maybeTrusted.$$unwrapTrustedValue();
>, <Line: +				}
>, <Line: +				// If we get here, then we may only take one of two actions.
>, <Line: +				// 1. sanitize the value for the requested type, or
>, <Line: +				// 2. throw an exception.
>, <Line: +				if (type === SCE_CONTEXTS.RESOURCE_URL) {
>, <Line: +					if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
>, <Line: +						return maybeTrusted;
>, <Line: +					} else {
>, <Line: +						throw $sceMinErr('insecurl',
>, <Line: +							'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
>, <Line: +							maybeTrusted.toString());
>, <Line: +					}
>, <Line: +				} else if (type === SCE_CONTEXTS.HTML) {
>, <Line: +					return htmlSanitizer(maybeTrusted);
>, <Line: +				}
>, <Line: +				throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
>, <Line: +			}
>, <Line: +			return {
>, <Line: +				trustAs: trustAs,
>, <Line: +				getTrusted: getTrusted,
>, <Line: +				valueOf: valueOf
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $sceProvider
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
>, <Line: +	 * -   enable/disable Strict Contextual Escaping (SCE) in a module
>, <Line: +	 * -   override the default implementation with a custom delegate
>, <Line: +	 *
>, <Line: +	 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
>, <Line: +	 */
>, <Line: +	/* jshint maxlen: false*/
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $sce
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
>, <Line: +	 *
>, <Line: +	 * # Strict Contextual Escaping
>, <Line: +	 *
>, <Line: +	 * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
>, <Line: +	 * contexts to result in a value that is marked as safe to use for that context.  One example of
>, <Line: +	 * such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer
>, <Line: +	 * to these contexts as privileged or SCE contexts.
>, <Line: +	 *
>, <Line: +	 * As of version 1.2, Angular ships with SCE enabled by default.
>, <Line: +	 *
>, <Line: +	 * Note:  When enabled (the default), IE<11 in quirks mode is not supported.  In this mode, IE<11 allow
>, <Line: +	 * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
>, <Line: +	 * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
>, <Line: +	 * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
>, <Line: +	 * to the top of your HTML document.
>, <Line: +	 *
>, <Line: +	 * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
>, <Line: +	 * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
>, <Line: +	 *
>, <Line: +	 * Here's an example of a binding in a privileged context:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * <input ng-model="userHtml">
>, <Line: +	 * <div ng-bind-html="userHtml"></div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE
>, <Line: +	 * disabled, this application allows the user to render arbitrary HTML into the DIV.
>, <Line: +	 * In a more realistic example, one may be rendering user comments, blog articles, etc. via
>, <Line: +	 * bindings.  (HTML is just one example of a context where rendering user controlled input creates
>, <Line: +	 * security vulnerabilities.)
>, <Line: +	 *
>, <Line: +	 * For the case of HTML, you might use a library, either on the client side, or on the server side,
>, <Line: +	 * to sanitize unsafe HTML before binding to the value and rendering it in the document.
>, <Line: +	 *
>, <Line: +	 * How would you ensure that every place that used these types of bindings was bound to a value that
>, <Line: +	 * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
>, <Line: +	 * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
>, <Line: +	 * properties/fields and forgot to update the binding to the sanitized value?
>, <Line: +	 *
>, <Line: +	 * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
>, <Line: +	 * determine that something explicitly says it's safe to use a value for binding in that
>, <Line: +	 * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
>, <Line: +	 * for those values that you can easily tell are safe - because they were received from your server,
>, <Line: +	 * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
>, <Line: +	 * allowing only the files in a specific directory to do this.  Ensuring that the internal API
>, <Line: +	 * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
>, <Line: +	 *
>, <Line: +	 * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs}
>, <Line: +	 * (and shorthand methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to
>, <Line: +	 * obtain values that will be accepted by SCE / privileged contexts.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ## How does it work?
>, <Line: +	 *
>, <Line: +	 * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted
>, <Line: +		* ng.$sce#parseAs $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
>, <Line: +	 * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
>, <Line: +	 *
>, <Line: +	 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
>, <Line: +		* ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
>, <Line: +	 * simplified):
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * var ngBindHtmlDirective = ['$sce', function($sce) {
>, <Line: + *     });
>, <Line: + *   };
>, <Line: + * }];
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * ## Impact on loading templates
>, <Line: +	 *
>, <Line: +	 * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
>, <Line: +	 * `templateUrl`'s specified by {@link guide/directive directives}.
>, <Line: +	 *
>, <Line: +	 * By default, Angular only loads templates from the same domain and protocol as the application
>, <Line: +	 * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
>, <Line: + * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
>, <Line: +	 * protocols, you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist
>, <Line: + * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.
>, <Line: +	 *
>, <Line: +	 * *Please note*:
>, <Line: +	 * The browser's
>, <Line: +	 * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
>, <Line: +	 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
>, <Line: +	 * policy apply in addition to this and may further restrict whether the template is successfully
>, <Line: +	 * loaded.  This means that without the right CORS policy, loading templates from a different domain
>, <Line: +	 * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
>, <Line: +	 * browsers.
>, <Line: +	 *
>, <Line: +	 * ## This feels like too much overhead
>, <Line: +	 *
>, <Line: +	 * It's important to remember that SCE only applies to interpolation expressions.
>, <Line: +	 *
>, <Line: +	 * If your expressions are constant literals, they're automatically trusted and you don't need to
>, <Line: +	 * call `$sce.trustAs` on them (remember to include the `ngSanitize` module) (e.g.
>, <Line: +	 * `<div ng-bind-html="'<b>implicitly trusted</b>'"></div>`) just works.
>, <Line: +	 *
>, <Line: +	 * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
>, <Line: +	 * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
>, <Line: +	 *
>, <Line: +	 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
>, <Line: +	 * templates in `ng-include` from your application's domain without having to even know about SCE.
>, <Line: +	 * It blocks loading templates from other domains or loading templates over http from an https
>, <Line: +	 * served document.  You can change these by setting your own custom {@link
>, <Line: +		* ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link
>, <Line: +		* ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.
>, <Line: +	 *
>, <Line: +	 * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
>, <Line: +	 * application that's secure and can be audited to verify that with much more ease than bolting
>, <Line: +	 * security onto an application later.
>, <Line: +	 *
>, <Line: +	 * <a name="contexts"></a>
>, <Line: +	 * ## What trusted context types are supported?
>, <Line: +	 *
>, <Line: +	 * | Context             | Notes          |
>, <Line: +	 * |---------------------|----------------|
>, <Line: +	 * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. If an unsafe value is encountered and the {@link ngSanitize $sanitize} module is present this will sanitize the value instead of throwing an error. |
>, <Line: +	 * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
>, <Line: +	 * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't constitute an SCE context. |
>, <Line: +	 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contents are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
>, <Line: +	 * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
>, <Line: +	 *
>, <Line: +	 * ## Format of items in {@link ng.$sceDelegateProvider#resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>
>, <Line: +	 *
>, <Line: +	 *  Each element in these arrays must be one of the following:
>, <Line: +	 *
>, <Line: +	 *  - **'self'**
>, <Line: +	 *    - The special **string**, `'self'`, can be used to match against all URLs of the **same
>, <Line: +	 *      domain** as the application document using the **same protocol**.
>, <Line: +	 *  - **String** (except the special value `'self'`)
>, <Line: +	 *    - The string is matched against the full *normalized / absolute URL* of the resource
>, <Line: +	 *      being tested (substring matches are not good enough.)
>, <Line: +	 *    - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters
>, <Line: +	 *      match themselves.
>, <Line: +	 *    - `*`: matches zero or more occurrences of any character other than one of the following 6
>, <Line: +	 *      characters: '`:`', '`/`', '`.`', '`?`', '`&`' and ';'.  It's a useful wildcard for use
>, <Line: +	 *      in a whitelist.
>, <Line: +	 *    - `**`: matches zero or more occurrences of *any* character.  As such, it's not
>, <Line: +	 *      not appropriate to use in for a scheme, domain, etc. as it would match too much.  (e.g.
>, <Line: +	 *      http://**.example.com/ would match http://evil.com/?ignore=.example.com/ and that might
>, <Line: +	 *      not have been the intention.)  Its usage at the very end of the path is ok.  (e.g.
>, <Line: +	 *      http://foo.example.com/templates/**).
>, <Line: +	 *  - **RegExp** (*see caveat below*)
>, <Line: +	 *    - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax
>, <Line: +	 *      (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to
>, <Line: +	 *      accidentally introduce a bug when one updates a complex expression (imho, all regexes should
>, <Line: +	 *      have good test coverage.).  For instance, the use of `.` in the regex is correct only in a
>, <Line: +	 *      small number of cases.  A `.` character in the regex used when matching the scheme or a
>, <Line: +	 *      subdomain could be matched against a `:` or literal `.` that was likely not intended.   It
>, <Line: +	 *      is highly recommended to use the string patterns and only fall back to regular expressions
>, <Line: +	 *      if they as a last resort.
>, <Line: +	 *    - The regular expression must be an instance of RegExp (i.e. not a string.)  It is
>, <Line: +	 *      matched against the **entire** *normalized / absolute URL* of the resource being tested
>, <Line: +	 *      (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags
>, <Line: +	 *      present on the RegExp (such as multiline, global, ignoreCase) are ignored.
>, <Line: +	 *    - If you are generating your JavaScript from some other templating engine (not
>, <Line: +	 *      recommended, e.g. in issue [#4006](https://github.com/angular/angular.js/issues/4006)),
>, <Line: +	 *      remember to escape your regular expression (and be aware that you might need more than
>, <Line: +	 *      one level of escaping depending on your templating engine and the way you interpolated
>, <Line: +	 *      the value.)  Do make use of your platform's escaping mechanism as it might be good
>, <Line: +	 *      enough before coding your own.  e.g. Ruby has
>, <Line: +	 *      [Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)
>, <Line: +	 *      and Python has [re.escape](http://docs.python.org/library/re.html#re.escape).
>, <Line: +	 *      Javascript lacks a similar built in function for escaping.  Take a look at Google
>, <Line: +	 *      Closure library's [goog.string.regExpEscape(s)](
>, <Line: +	 *      http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).
>, <Line: +	 *
>, <Line: +	 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an example.
>, <Line: +	 *
>, <Line: +	 * ## Show me an example using SCE.
>, <Line: +	 *
>, <Line: +	 * <example module="mySceApp" deps="angular-sanitize.js">
>, <Line: +	 * <file name="index.html">
>, <Line: +	 *   <div ng-controller="AppController as myCtrl">
>, <Line: +	 *     <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
>, <Line: +	 *     <b>User comments</b><br>
>, <Line: +	 *     By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when
>, <Line: +	 *     $sanitize is available.  If $sanitize isn't available, this results in an error instead of an
>, <Line: +	 *     exploit.
>, <Line: +	 *     <div class="well">
>, <Line: +	 *       <div ng-repeat="userComment in myCtrl.userComments">
>, <Line: +	 *         <b>{{userComment.name}}</b>:
>, <Line: +	 *         <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
>, <Line: +	 *         <br>
>, <Line: +	 *       </div>
>, <Line: +	 *     </div>
>, <Line: +	 *   </div>
>, <Line: +	 * </file>
>, <Line: +	 *
>, <Line: +	 * <file name="script.js">
>, <Line: +	 *   angular.module('mySceApp', ['ngSanitize'])
>, <Line: +	 *     .controller('AppController', ['$http', '$templateCache', '$sce',
>, <Line: +	 *       function($http, $templateCache, $sce) {
>, <Line: +	 * </file>
>, <Line: +	 *
>, <Line: +	 * <file name="test_data.json">
>, <Line: +	 * [
>, <Line: +	 *   { "name": "Alice",
>, <Line: +	 *   { "name": "Bob",
>, <Line: +	 * ]
>, <Line: +	 * </file>
>, <Line: +	 *
>, <Line: +	 * <file name="protractor.js" type="protractor">
>, <Line: +	 *   describe('SCE doc demo', function() {
>, <Line: +	 * </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * ## Can I disable SCE completely?
>, <Line: +	 *
>, <Line: +	 * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
>, <Line: +	 * for little coding overhead.  It will be much harder to take an SCE disabled application and
>, <Line: +	 * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
>, <Line: +	 * for cases where you have a lot of existing code that was written before SCE was introduced and
>, <Line: +	 * you're migrating them a module at a time.
>, <Line: +	 *
>, <Line: +	 * That said, here's how you can completely disable SCE:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	/* jshint maxlen: 100 */
>, <Line: +	function $SceProvider() {
>, <Line: +		var enabled = true;
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $sceProvider#enabled
>, <Line: +		 * @kind function
>, <Line: +		 *
>, <Line: +		 * @param {boolean=} value If provided, then enables/disables SCE.
>, <Line: +		 * @return {boolean} true if SCE is enabled, false otherwise.
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Enables/disables SCE and returns the current value.
>, <Line: +		 */
>, <Line: +		this.enabled = function (value) {
>, <Line: +			if (arguments.length) {
>, <Line: +				enabled = !!value;
>, <Line: +			}
>, <Line: +			return enabled;
>, <Line: +		};
>, <Line: +		/* Design notes on the default implementation for SCE.
>, <Line: +		 *
>, <Line: +		 * The API contract for the SCE delegate
>, <Line: +		 * -------------------------------------
>, <Line: +		 * The SCE delegate object must provide the following 3 methods:
>, <Line: +		 *
>, <Line: +		 * - trustAs(contextEnum, value)
>, <Line: +		 *     This method is used to tell the SCE service that the provided value is OK to use in the
>, <Line: +		 *     contexts specified by contextEnum.  It must return an object that will be accepted by
>, <Line: +		 *     getTrusted() for a compatible contextEnum and return this value.
>, <Line: +		 *
>, <Line: +		 * - valueOf(value)
>, <Line: +		 *     For values that were not produced by trustAs(), return them as is.  For values that were
>, <Line: +		 *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
>, <Line: +		 *     trustAs is wrapping the given values into some type, this operation unwraps it when given
>, <Line: +		 *     such a value.
>, <Line: +		 *
>, <Line: +		 * - getTrusted(contextEnum, value)
>, <Line: +		 *     This function should return the a value that is safe to use in the context specified by
>, <Line: +		 *     contextEnum or throw and exception otherwise.
>, <Line: +		 *
>, <Line: +		 * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be
>, <Line: +		 * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For
>, <Line: +		 * instance, an implementation could maintain a registry of all trusted objects by context.  In
>, <Line: +		 * such a case, trustAs() would return the same object that was passed in.  getTrusted() would
>, <Line: +		 * return the same object passed in if it was found in the registry under a compatible context or
>, <Line: +		 * throw an exception otherwise.  An implementation might only wrap values some of the time based
>, <Line: +		 * on some criteria.  getTrusted() might return a value and not throw an exception for special
>, <Line: +		 * constants or objects even if not wrapped.  All such implementations fulfill this contract.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * A note on the inheritance model for SCE contexts
>, <Line: +		 * ------------------------------------------------
>, <Line: +		 * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
>, <Line: +		 * is purely an implementation details.
>, <Line: +		 *
>, <Line: +		 * The contract is simply this:
>, <Line: +		 *
>, <Line: +		 *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
>, <Line: +		 *     will also succeed.
>, <Line: +		 *
>, <Line: +		 * Inheritance happens to capture this in a natural way.  In some future, we
>, <Line: +		 * may not use inheritance anymore.  That is OK because no code outside of
>, <Line: +		 * sce.js and sceSpecs.js would need to be aware of this detail.
>, <Line: +		 */
>, <Line: +		this.$get = ['$parse', '$sceDelegate', function ($parse, $sceDelegate) {
>, <Line: +			// Prereq: Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow
>, <Line: +			// the "expression(javascript expression)" syntax which is insecure.
>, <Line: +			if (enabled && msie < 8) {
>, <Line: +				throw $sceMinErr('iequirks',
>, <Line: +					'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' +
>, <Line: +					'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
>, <Line: +					'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
>, <Line: +			}
>, <Line: +			var sce = shallowCopy(SCE_CONTEXTS);
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#isEnabled
>, <Line: +			 * @kind function
>, <Line: +			 *
>, <Line: +			 * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
>, <Line: +			 * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Returns a boolean indicating if SCE is enabled.
>, <Line: +			 */
>, <Line: +			sce.isEnabled = function () {
>, <Line: +				return enabled;
>, <Line: +			};
>, <Line: +			sce.trustAs = $sceDelegate.trustAs;
>, <Line: +			sce.getTrusted = $sceDelegate.getTrusted;
>, <Line: +			sce.valueOf = $sceDelegate.valueOf;
>, <Line: +			if (!enabled) {
>, <Line: +				sce.trustAs = sce.getTrusted = function (type, value) {
>, <Line: +					return value;
>, <Line: +				};
>, <Line: +				sce.valueOf = identity;
>, <Line: +			}
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
>, <Line: +				* ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
>, <Line: +			 * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
>, <Line: +			 *
>, <Line: +			 * @param {string} type The kind of SCE context in which this result will be used.
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			sce.parseAs = function sceParseAs(type, expr) {
>, <Line: +				var parsed = $parse(expr);
>, <Line: +				if (parsed.literal && parsed.constant) {
>, <Line: +					return parsed;
>, <Line: +				} else {
>, <Line: +					return $parse(expr, function (value) {
>, <Line: +						return sce.getTrusted(type, value);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#trustAs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,
>, <Line: +			 * returns an object that is trusted by angular for use in specified strict contextual
>, <Line: +			 * escaping contexts (such as ng-bind-html, ng-include, any src attribute
>, <Line: +			 * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)
>, <Line: +			 * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual
>, <Line: +			 * escaping.
>, <Line: +			 *
>, <Line: +			 * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
>, <Line: +			 *   resource_url, html, js and css.
>, <Line: +			 * @param {*} value The value that that should be considered trusted/safe.
>, <Line: +			 * @returns {*} A value that can be used to stand in for the provided `value` in places
>, <Line: +			 * where Angular expects a $sce.trustAs() return value.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#trustAsHtml
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.trustAsHtml(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to trustAs.
>, <Line: +			 * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
>, <Line: +			 *     only accept expressions that are either literal constants or are the
>, <Line: +			 *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#trustAsUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.trustAsUrl(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to trustAs.
>, <Line: +			 * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
>, <Line: +			 *     only accept expressions that are either literal constants or are the
>, <Line: +			 *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#trustAsResourceUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.trustAsResourceUrl(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to trustAs.
>, <Line: +			 * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
>, <Line: +			 *     only accept expressions that are either literal constants or are the return
>, <Line: +			 *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#trustAsJs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.trustAsJs(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to trustAs.
>, <Line: +			 * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
>, <Line: +			 *     only accept expressions that are either literal constants or are the
>, <Line: +			 *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrusted
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
>, <Line: +			 * takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the
>, <Line: +			 * originally supplied value if the queried context type is a supertype of the created type.
>, <Line: +			 * If this condition isn't satisfied, throws an exception.
>, <Line: +			 *
>, <Line: +			 * @param {string} type The kind of context in which this value is to be used.
>, <Line: +			 * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`}
>, <Line: +			 *                         call.
>, <Line: +			 * @returns {*} The value the was originally provided to
>, <Line: +			 *              {@link ng.$sce#trustAs `$sce.trustAs`} if valid in this context.
>, <Line: +			 *              Otherwise, throws an exception.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrustedHtml
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.getTrustedHtml(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: +			 * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrustedCss
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.getTrustedCss(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: +			 * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrustedUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.getTrustedUrl(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: +			 * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrustedResourceUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.getTrustedResourceUrl(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
>, <Line: +			 * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#getTrustedJs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.getTrustedJs(value)` 
>, <Line: +			 *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: +			 * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAsHtml
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.parseAsHtml(expression string)` 
>, <Line: +			 *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAsCss
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.parseAsCss(value)` 
>, <Line: +			 *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAsUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.parseAsUrl(value)` 
>, <Line: +			 *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAsResourceUrl
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.parseAsResourceUrl(value)` 
>, <Line: +			 *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name $sce#parseAsJs
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Shorthand method.  `$sce.parseAsJs(value)` 
>, <Line: +			 *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}
>, <Line: +			 *
>, <Line: +			 * @param {string} expression String expression to compile.
>, <Line: +			 * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: +			 *
>, <Line: +			 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: +			 *      are evaluated against (typically a scope object).
>, <Line: +			 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: +			 *      `context`.
>, <Line: +			 */
>, <Line: +			// Shorthand delegations.
>, <Line: +			var parse = sce.parseAs,
>, <Line: +				getTrusted = sce.getTrusted,
>, <Line: +				trustAs = sce.trustAs;
>, <Line: +			forEach(SCE_CONTEXTS, function (enumValue, name) {
>, <Line: +				var lName = lowercase(name);
>, <Line: +				sce[camelCase("parse_as_" + lName)] = function (expr) {
>, <Line: +					return parse(enumValue, expr);
>, <Line: +				};
>, <Line: +				sce[camelCase("get_trusted_" + lName)] = function (value) {
>, <Line: +					return getTrusted(enumValue, value);
>, <Line: +				};
>, <Line: +				sce[camelCase("trust_as_" + lName)] = function (value) {
>, <Line: +					return trustAs(enumValue, value);
>, <Line: +				};
>, <Line: +			});
>, <Line: +			return sce;
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * !!! This is an undocumented "private" service !!!
>, <Line: +	 *
>, <Line: +	 * @name $sniffer
>, <Line: +	 * @requires $window
>, <Line: +	 * @requires $document
>, <Line: +	 *
>, <Line: +	 * @property {boolean} history Does the browser support html5 history api ?
>, <Line: +	 * @property {boolean} transitions Does the browser support CSS transition events ?
>, <Line: +	 * @property {boolean} animations Does the browser support CSS animation events ?
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * This is very simple implementation of testing browser's features.
>, <Line: +	 */
>, <Line: +	function $SnifferProvider() {
>, <Line: +		this.$get = ['$window', '$document', function ($window, $document) {
>, <Line: +			var eventSupport = {},
>, <Line: +				android =
>, <Line: +					int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
>, <Line: +				boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
>, <Line: +				document = $document[0] || {},
>, <Line: +				vendorPrefix,
>, <Line: +				vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
>, <Line: +				bodyStyle = document.body && document.body.style,
>, <Line: +				transitions = false,
>, <Line: +				animations = false,
>, <Line: +				match;
>, <Line: +			if (bodyStyle) {
>, <Line: +				for (var prop in bodyStyle) {
>, <Line: +					if (match = vendorRegex.exec(prop)) {
>, <Line: +						vendorPrefix = match[0];
>, <Line: +						vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (!vendorPrefix) {
>, <Line: +					vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
>, <Line: +				}
>, <Line: +				transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
>, <Line: +				animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
>, <Line: +				if (android && (!transitions || !animations)) {
>, <Line: +					transitions = isString(document.body.style.webkitTransition);
>, <Line: +					animations = isString(document.body.style.webkitAnimation);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return {
>, <Line: +				// Android has history.pushState, but it does not update location correctly
>, <Line: +				// so let's not use the history API at all.
>, <Line: +				// http://code.google.com/p/android/issues/detail?id=17471
>, <Line: +				// https://github.com/angular/angular.js/issues/904
>, <Line: +				// older webkit browser (533.9) on Boxee box has exactly the same problem as Android has
>, <Line: +				// so let's not use the history API also
>, <Line: +				// We are purposefully using `!(android < 4)` to cover the case when `android` is undefined
>, <Line: +				// jshint -W018
>, <Line: +				history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
>, <Line: +				// jshint +W018
>, <Line: +				hasEvent: function (event) {
>, <Line: +					// IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
>, <Line: +					// it. In particular the event is not fired when backspace or delete key are pressed or
>, <Line: +					// when cut operation is performed.
>, <Line: +					if (event == 'input' && msie == 9) return false;
>, <Line: +					if (isUndefined(eventSupport[event])) {
>, <Line: +						var divElm = document.createElement('div');
>, <Line: +						eventSupport[event] = 'on' + event in divElm;
>, <Line: +					}
>, <Line: +					return eventSupport[event];
>, <Line: +				},
>, <Line: +				csp: csp(),
>, <Line: +				vendorPrefix: vendorPrefix,
>, <Line: +				transitions: transitions,
>, <Line: +				animations: animations,
>, <Line: +				android: android
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	var $compileMinErr = minErr('$compile');
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $templateRequest
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `$templateRequest` service downloads the provided template using `$http` and, upon success,
>, <Line: +	 * stores the contents inside of `$templateCache`. If the HTTP request fails or the response data
>, <Line: +	 * of the HTTP request is empty then a `$compile` error will be thrown (the exception can be thwarted
>, <Line: +	 * by setting the 2nd parameter of the function to true).
>, <Line: +	 *
>, <Line: +	 * @param {string} tpl The HTTP request template URL
>, <Line: +	 * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty
>, <Line: +	 *
>, <Line: +	 * @return {Promise} the HTTP Promise for the given.
>, <Line: +	 *
>, <Line: +	 * @property {number} totalPendingRequests total amount of pending template requests being downloaded.
>, <Line: +	 */
>, <Line: +	function $TemplateRequestProvider() {
>, <Line: +		this.$get = ['$templateCache', '$http', '$q', function ($templateCache, $http, $q) {
>, <Line: +			function handleRequestFn(tpl, ignoreRequestError) {
>, <Line: +				var self = handleRequestFn;
>, <Line: +				self.totalPendingRequests++;
>, <Line: +				var transformResponse = $http.defaults && $http.defaults.transformResponse;
>, <Line: +				if (isArray(transformResponse)) {
>, <Line: +					var original = transformResponse;
>, <Line: +					transformResponse = [];
>, <Line: +					for (var i = 0; i < original.length; ++i) {
>, <Line: +						var transformer = original[i];
>, <Line: +						if (transformer !== defaultHttpResponseTransform) {
>, <Line: +							transformResponse.push(transformer);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				} else if (transformResponse === defaultHttpResponseTransform) {
>, <Line: +					transformResponse = null;
>, <Line: +				}
>, <Line: +				var httpOptions = {
>, <Line: +					cache: $templateCache,
>, <Line: +					transformResponse: transformResponse
>, <Line: +				};
>, <Line: +				return $http.get(tpl, httpOptions)
>, <Line: +					.then(function (response) {
>, <Line: +						var html = response.data;
>, <Line: +						self.totalPendingRequests--;
>, <Line: +						$templateCache.put(tpl, html);
>, <Line: +						return html;
>, <Line: +					}, handleError);
>, <Line: +				function handleError() {
>, <Line: +					self.totalPendingRequests--;
>, <Line: +					if (!ignoreRequestError) {
>, <Line: +						throw $compileMinErr('tpload', 'Failed to load template: {0}', tpl);
>, <Line: +					}
>, <Line: +					return $q.reject();
>, <Line: +				}
>, <Line: +			}
>, <Line: +			handleRequestFn.totalPendingRequests = 0;
>, <Line: +			return handleRequestFn;
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	function $$TestabilityProvider() {
>, <Line: +		this.$get = ['$rootScope', '$browser', '$location',
>, <Line: +			function ($rootScope, $browser, $location) {
>, <Line: +				/**
>, <Line: +				 * @name $testability
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * The private $$testability service provides a collection of methods for use when debugging
>, <Line: +				 * or by automated test and debugging tools.
>, <Line: +				 */
>, <Line: +				var testability = {};
>, <Line: +				/**
>, <Line: +				 * @name $$testability#findBindings
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Returns an array of elements that are bound (via ng-bind or {{}})
>, <Line: +				 * to expressions matching the input.
>, <Line: +				 *
>, <Line: +				 * @param {Element} element The element root to search from.
>, <Line: +				 * @param {string} expression The binding expression to match.
>, <Line: +				 * @param {boolean} opt_exactMatch If true, only returns exact matches
>, <Line: +				 *     for the expression. Filters and whitespace are ignored.
>, <Line: +				 */
>, <Line: +				testability.findBindings = function (element, expression, opt_exactMatch) {
>, <Line: +					var bindings = element.getElementsByClassName('ng-binding');
>, <Line: +					var matches = [];
>, <Line: +					forEach(bindings, function (binding) {
>, <Line: +						var dataBinding = angular.element(binding).data('$binding');
>, <Line: +						if (dataBinding) {
>, <Line: +							forEach(dataBinding, function (bindingName) {
>, <Line: +								if (opt_exactMatch) {
>, <Line: +									var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
>, <Line: +									if (matcher.test(bindingName)) {
>, <Line: +										matches.push(binding);
>, <Line: +									}
>, <Line: +								} else {
>, <Line: +									if (bindingName.indexOf(expression) != -1) {
>, <Line: +										matches.push(binding);
>, <Line: +									}
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +					});
>, <Line: +					return matches;
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @name $$testability#findModels
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Returns an array of elements that are two-way found via ng-model to
>, <Line: +				 * expressions matching the input.
>, <Line: +				 *
>, <Line: +				 * @param {Element} element The element root to search from.
>, <Line: +				 * @param {string} expression The model expression to match.
>, <Line: +				 * @param {boolean} opt_exactMatch If true, only returns exact matches
>, <Line: +				 *     for the expression.
>, <Line: +				 */
>, <Line: +				testability.findModels = function (element, expression, opt_exactMatch) {
>, <Line: +					var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
>, <Line: +					for (var p = 0; p < prefixes.length; ++p) {
>, <Line: +						var attributeEquals = opt_exactMatch ? '=' : '*=';
>, <Line: +						var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
>, <Line: +						var elements = element.querySelectorAll(selector);
>, <Line: +						if (elements.length) {
>, <Line: +							return elements;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @name $$testability#getLocation
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut for getting the location in a browser agnostic way. Returns
>, <Line: +				 *     the path, search, and hash. (e.g. /path?a=b#hash)
>, <Line: +				 */
>, <Line: +				testability.getLocation = function () {
>, <Line: +					return $location.url();
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @name $$testability#setLocation
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Shortcut for navigating to a location without doing a full page reload.
>, <Line: +				 *
>, <Line: +				 * @param {string} url The location url (path, search and hash,
>, <Line: +				 *     e.g. /path?a=b#hash) to go to.
>, <Line: +				 */
>, <Line: +				testability.setLocation = function (url) {
>, <Line: +					if (url !== $location.url()) {
>, <Line: +						$location.url(url);
>, <Line: +						$rootScope.$digest();
>, <Line: +					}
>, <Line: +				};
>, <Line: +				/**
>, <Line: +				 * @name $$testability#whenStable
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Calls the callback when $timeout and $http requests are completed.
>, <Line: +				 *
>, <Line: +				 * @param {function} callback
>, <Line: +				 */
>, <Line: +				testability.whenStable = function (callback) {
>, <Line: +					$browser.notifyWhenNoOutstandingRequests(callback);
>, <Line: +				};
>, <Line: +				return testability;
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	function $TimeoutProvider() {
>, <Line: +		this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler',
>, <Line: +			function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
>, <Line: +				var deferreds = {};
>, <Line: +				/**
>, <Line: +				 * @ngdoc service
>, <Line: +				 * @name $timeout
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
>, <Line: +				 * block and delegates any exceptions to
>, <Line: +				 * {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: +				 *
>, <Line: +				 * The return value of registering a timeout function is a promise, which will be resolved when
>, <Line: +				 * the timeout is reached and the timeout function is executed.
>, <Line: +				 *
>, <Line: +				 * To cancel a timeout request, call `$timeout.cancel(promise)`.
>, <Line: +				 *
>, <Line: +				 * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
>, <Line: +				 * synchronously flush the queue of deferred functions.
>, <Line: +				 *
>, <Line: +				 * @param {function()} fn A function, whose execution should be delayed.
>, <Line: +				 * @param {number=} [delay=0] Delay in milliseconds.
>, <Line: +				 * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: +				 *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: +				 * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
>, <Line: +				 *   promise will be resolved with is the return value of the `fn` function.
>, <Line: +				 *
>, <Line: +				 */
>, <Line: +				function timeout(fn, delay, invokeApply) {
>, <Line: +					var skipApply = (isDefined(invokeApply) && !invokeApply),
>, <Line: +						deferred = (skipApply ? $$q : $q).defer(),
>, <Line: +						promise = deferred.promise,
>, <Line: +						timeoutId;
>, <Line: +					timeoutId = $browser.defer(function () {
>, <Line: +						try {
>, <Line: +							deferred.resolve(fn());
>, <Line: +						} catch (e) {
>, <Line: +							deferred.reject(e);
>, <Line: +							$exceptionHandler(e);
>, <Line: +						}
>, <Line: +						finally {
>, <Line: +							delete deferreds[promise.$$timeoutId];
>, <Line: +						}
>, <Line: +						if (!skipApply) $rootScope.$apply();
>, <Line: +					}, delay);
>, <Line: +					promise.$$timeoutId = timeoutId;
>, <Line: +					deferreds[timeoutId] = deferred;
>, <Line: +					return promise;
>, <Line: +				}
>, <Line: +				/**
>, <Line: +				 * @ngdoc method
>, <Line: +				 * @name $timeout#cancel
>, <Line: +				 *
>, <Line: +				 * @description
>, <Line: +				 * Cancels a task associated with the `promise`. As a result of this, the promise will be
>, <Line: +				 * resolved with a rejection.
>, <Line: +				 *
>, <Line: +				 * @param {Promise=} promise Promise returned by the `$timeout` function.
>, <Line: +				 * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
>, <Line: +				 *   canceled.
>, <Line: +				 */
>, <Line: +				timeout.cancel = function (promise) {
>, <Line: +					if (promise && promise.$$timeoutId in deferreds) {
>, <Line: +						deferreds[promise.$$timeoutId].reject('canceled');
>, <Line: +						delete deferreds[promise.$$timeoutId];
>, <Line: +						return $browser.defer.cancel(promise.$$timeoutId);
>, <Line: +					}
>, <Line: +					return false;
>, <Line: +				};
>, <Line: +				return timeout;
>, <Line: +			}];
>, <Line: +	}
>, <Line: +	var urlParsingNode = document.createElement("a");
>, <Line: +	var originUrl = urlResolve(window.location.href);
>, <Line: +	/**
>, <Line: +	 *
>, <Line: +	 * Implementation Notes for non-IE browsers
>, <Line: +	 * ----------------------------------------
>, <Line: +	 * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
>, <Line: +	 * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
>, <Line: +	 * URL will be resolved into an absolute URL in the context of the application document.
>, <Line: +	 * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
>, <Line: +	 * properties are all populated to reflect the normalized URL.  This approach has wide
>, <Line: +	 * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
>, <Line: +	 * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
>, <Line: +	 *
>, <Line: +	 * Implementation Notes for IE
>, <Line: +	 * ---------------------------
>, <Line: +	 * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
>, <Line: +	 * browsers.  However, the parsed components will not be set if the URL assigned did not specify
>, <Line: +	 * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
>, <Line: +	 * work around that by performing the parsing in a 2nd step by taking a previously normalized
>, <Line: +	 * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the
>, <Line: +	 * properties such as protocol, hostname, port, etc.
>, <Line: +	 *
>, <Line: +	 * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
>, <Line: +	 * uses the inner HTML approach to assign the URL as part of an HTML snippet -
>, <Line: +	 * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
>, <Line: +	 * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
>, <Line: +	 * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
>, <Line: +	 * method and IE < 8 is unsupported.
>, <Line: +	 *
>, <Line: +	 * References:
>, <Line: +	 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
>, <Line: +	 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
>, <Line: +	 *   http://url.spec.whatwg.org/#urlutils
>, <Line: +	 *   https://github.com/angular/angular.js/pull/2902
>, <Line: +	 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
>, <Line: +	 *
>, <Line: +	 * @kind function
>, <Line: +	 * @param {string} url The URL to be parsed.
>, <Line: +	 * @description Normalizes and parses a URL.
>, <Line: +	 * @returns {object} Returns the normalized URL as a dictionary.
>, <Line: +	 *
>, <Line: +	 *   | member name   | Description    |
>, <Line: +	 *   |---------------|----------------|
>, <Line: +	 *   | href          | A normalized version of the provided URL if it was not an absolute URL |
>, <Line: +	 *   | protocol      | The protocol including the trailing colon                              |
>, <Line: +	 *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
>, <Line: +	 *   | search        | The search params, minus the question mark                             |
>, <Line: +	 *   | hash          | The hash string, minus the hash symbol
>, <Line: +	 *   | hostname      | The hostname
>, <Line: +	 *   | port          | The port, without ":"
>, <Line: +	 *   | pathname      | The pathname, beginning with "/"
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	function urlResolve(url) {
>, <Line: +		var href = url;
>, <Line: +		if (msie) {
>, <Line: +			// Normalize before parse.  Refer Implementation Notes on why this is
>, <Line: +			// done in two steps on IE.
>, <Line: +			urlParsingNode.setAttribute("href", href);
>, <Line: +			href = urlParsingNode.href;
>, <Line: +		}
>, <Line: +		urlParsingNode.setAttribute('href', href);
>, <Line: +		// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
>, <Line: +		return {
>, <Line: +			href: urlParsingNode.href,
>, <Line: +			protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
>, <Line: +			host: urlParsingNode.host,
>, <Line: +			search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
>, <Line: +			hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
>, <Line: +			hostname: urlParsingNode.hostname,
>, <Line: +			port: urlParsingNode.port,
>, <Line: +			pathname: (urlParsingNode.pathname.charAt(0) === '/')
>, <Line: +				? urlParsingNode.pathname
>, <Line: +				: '/' + urlParsingNode.pathname
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * Parse a request URL and determine whether this is a same-origin request as the application document.
>, <Line: +	 *
>, <Line: +	 * @param {string|object} requestUrl The url of the request as a string that will be resolved
>, <Line: +	 * or a parsed URL object.
>, <Line: +	 * @returns {boolean} Whether the request is for the same origin as the application document.
>, <Line: +	 */
>, <Line: +	function urlIsSameOrigin(requestUrl) {
>, <Line: +		var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
>, <Line: +		return (parsed.protocol === originUrl.protocol &&
>, <Line: +		parsed.host === originUrl.host);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $window
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * A reference to the browser's `window` object. While `window`
>, <Line: +	 * is globally available in JavaScript, it causes testability problems, because
>, <Line: +	 * it is a global variable. In angular we always refer to it through the
>, <Line: +	 * `$window` service, so it may be overridden, removed or mocked for testing.
>, <Line: +	 *
>, <Line: +	 * Expressions, like the one defined for the `ngClick` directive in the example
>, <Line: +	 * below, are evaluated with respect to the current scope.  Therefore, there is
>, <Line: +	 * no risk of inadvertently coding in a dependency on a global value in such an
>, <Line: +	 * expression.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="windowExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('windowExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', '$window', function($scope, $window) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <input type="text" ng-model="greeting" />
>, <Line: +	 <button ng-click="doGreeting(greeting)">ALERT</button>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should display the greeting in the input box', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function $WindowProvider() {
>, <Line: +		this.$get = valueFn(window);
>, <Line: +	}
>, <Line: +	/* global currencyFilter: true,
>, <Line: +	 dateFilter: true,
>, <Line: +	 filterFilter: true,
>, <Line: +	 jsonFilter: true,
>, <Line: +	 limitToFilter: true,
>, <Line: +	 lowercaseFilter: true,
>, <Line: +	 numberFilter: true,
>, <Line: +	 orderByFilter: true,
>, <Line: +	 uppercaseFilter: true,
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc provider
>, <Line: +	 * @name $filterProvider
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * Filters are just functions which transform input to an output. However filters need to be
>, <Line: +	 * Dependency Injected. To achieve this a filter definition consists of a factory function which is
>, <Line: +	 * annotated with dependencies and is responsible for creating a filter function.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   // Filter registration
>, <Line: +	 *   function MyModule($provide, $filterProvider) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The filter function is registered with the `$injector` under the filter name suffix with
>, <Line: +	 * `Filter`.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 *   it('should be the same instance', inject(
>, <Line: +	 *     function($filterProvider) {
>, <Line: +	 *     function($filter, reverseFilter) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * For more information about how angular filters work, and how to create your own filters, see
>, <Line: +	 * {@link guide/filter Filters} in the Angular Developer Guide.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc service
>, <Line: +	 * @name $filter
>, <Line: +	 * @kind function
>, <Line: +	 * @description
>, <Line: +	 * Filters are used for formatting data displayed to the user.
>, <Line: +	 *
>, <Line: +	 * The general syntax in templates is as follows:
>, <Line: +	 *
>, <Line: +	 *         {{ expression [| filter_name[:parameter_value] ... ] }}
>, <Line: +	 *
>, <Line: +	 * @param {String} name Name of the filter function to retrieve
>, <Line: +	 * @return {Function} the filter function
>, <Line: +	 * @example
>, <Line: +	 <example name="$filter" module="filterExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="MainCtrl">
>, <Line: +	 <h3>{{ originalText }}</h3>
>, <Line: +	 <h3>{{ filteredText }}</h3>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('filterExample', [])
>, <Line: +	 .controller('MainCtrl', function($scope, $filter) {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	$FilterProvider.$inject = ['$provide'];
>, <Line: +	function $FilterProvider($provide) {
>, <Line: +		var suffix = 'Filter';
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name $filterProvider#register
>, <Line: +		 * @param {string|Object} name Name of the filter function, or an object map of filters where
>, <Line: +		 *    the keys are the filter names and the values are the filter factories.
>, <Line: +		 * @returns {Object} Registered filter instance, or if a map of filters was provided then a map
>, <Line: +		 *    of the registered filter instances.
>, <Line: +		 */
>, <Line: +		function register(name, factory) {
>, <Line: +			if (isObject(name)) {
>, <Line: +				var filters = {};
>, <Line: +				forEach(name, function (filter, key) {
>, <Line: +					filters[key] = register(key, filter);
>, <Line: +				});
>, <Line: +				return filters;
>, <Line: +			} else {
>, <Line: +				return $provide.factory(name + suffix, factory);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		this.register = register;
>, <Line: +		this.$get = ['$injector', function ($injector) {
>, <Line: +			return function (name) {
>, <Line: +				return $injector.get(name + suffix);
>, <Line: +			};
>, <Line: +		}];
>, <Line: +		////////////////////////////////////////
>, <Line: +		/* global
>, <Line: +		 currencyFilter: false,
>, <Line: +		 dateFilter: false,
>, <Line: +		 filterFilter: false,
>, <Line: +		 jsonFilter: false,
>, <Line: +		 limitToFilter: false,
>, <Line: +		 lowercaseFilter: false,
>, <Line: +		 numberFilter: false,
>, <Line: +		 orderByFilter: false,
>, <Line: +		 uppercaseFilter: false,
>, <Line: +		 */
>, <Line: +		register('currency', currencyFilter);
>, <Line: +		register('date', dateFilter);
>, <Line: +		register('filter', filterFilter);
>, <Line: +		register('json', jsonFilter);
>, <Line: +		register('limitTo', limitToFilter);
>, <Line: +		register('lowercase', lowercaseFilter);
>, <Line: +		register('number', numberFilter);
>, <Line: +		register('orderBy', orderByFilter);
>, <Line: +		register('uppercase', uppercaseFilter);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name filter
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Selects a subset of items from `array` and returns it as a new array.
>, <Line: +	 *
>, <Line: +	 * @param {Array} array The source array.
>, <Line: +	 * @param {string|Object|function()} expression The predicate to be used for selecting items from
>, <Line: +	 *   `array`.
>, <Line: +	 *
>, <Line: +	 *   Can be one of:
>, <Line: +	 *
>, <Line: +	 *   - `string`: The string is evaluated as an expression and the resulting value is used for substring match against
>, <Line: +	 *     the contents of the `array`. All strings or objects with string properties in `array` that contain this string
>, <Line: +	 *     will be returned. The predicate can be negated by prefixing the string with `!`.
>, <Line: +	 *
>, <Line: +	 *   - `Object`: A pattern object can be used to filter specific properties on objects contained
>, <Line: +	 *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
>, <Line: +	 *     which have property `name` containing "M" and property `phone` containing "1". A special
>, <Line: +	 *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
>, <Line: +	 *     property of the object. That's equivalent to the simple substring match with a `string`
>, <Line: +	 *     as described above. The predicate can be negated by prefixing the string with `!`.
>, <Line: +	 *     For Example `{name: "!M"}` predicate will return an array of items which have property `name`
>, <Line: +	 *     not containing "M".
>, <Line: +	 *
>, <Line: +	 *   - `function(value, index)`: A predicate function can be used to write arbitrary filters. The
>, <Line: +	 *     function is called for each element of `array`. The final result is an array of those
>, <Line: +	 *     elements that the predicate returned true for.
>, <Line: +	 *
>, <Line: +	 * @param {function(actual, expected)|true|undefined} comparator Comparator which is used in
>, <Line: +	 *     determining if the expected value (from the filter expression) and actual value (from
>, <Line: +	 *     the object in the array) should be considered a match.
>, <Line: +	 *
>, <Line: +	 *   Can be one of:
>, <Line: +	 *
>, <Line: +	 *   - `function(actual, expected)`:
>, <Line: +	 *     The function will be given the object value and the predicate value to compare and
>, <Line: +	 *     should return true if the item should be included in filtered result.
>, <Line: +	 *
>, <Line: +	 *   - `true`: A shorthand for `function(actual, expected) { return angular.equals(expected, actual)}`.
>, <Line: +	 *     this is essentially strict comparison of expected and actual.
>, <Line: +	 *
>, <Line: +	 *   - `false|undefined`: A short hand for a function which will look for a substring match in case
>, <Line: +	 *     insensitive way.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-init="friends = [{name:'John', phone:'555-1276'},
>, <Line: +	 {name:'Mary', phone:'800-BIG-MARY'},
>, <Line: +	 {name:'Mike', phone:'555-4321'},
>, <Line: +	 {name:'Adam', phone:'555-5678'},
>, <Line: +	 {name:'Julie', phone:'555-8765'},
>, <Line: +	 {name:'Juliette', phone:'555-5678'}]"></div>
>, <Line: +	 Search: <input ng-model="searchText">
>, <Line: +	 <table id="searchTextResults">
>, <Line: +	 <tr><th>Name</th><th>Phone</th></tr>
>, <Line: +	 <tr ng-repeat="friend in friends | filter:searchText">
>, <Line: +	 <td>{{friend.name}}</td>
>, <Line: +	 <td>{{friend.phone}}</td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 <hr>
>, <Line: +	 Any: <input ng-model="search.$"> <br>
>, <Line: +	 Name only <input ng-model="search.name"><br>
>, <Line: +	 Phone only <input ng-model="search.phone"><br>
>, <Line: +	 Equality <input type="checkbox" ng-model="strict"><br>
>, <Line: +	 <table id="searchObjResults">
>, <Line: +	 <tr><th>Name</th><th>Phone</th></tr>
>, <Line: +	 <tr ng-repeat="friendObj in friends | filter:search:strict">
>, <Line: +	 <td>{{friendObj.name}}</td>
>, <Line: +	 <td>{{friendObj.phone}}</td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var expectFriendNames = function(expectedNames, key) {
>, <Line: +	 it('should search across all fields when filtering with a string', function() {
>, <Line: +         searchText.sendKeys('76');
>, <Line: +         expectFriendNames(['John', 'Julie'], 'friend');
>, <Line: +       });
>, <Line: +	 it('should search in specific fields when filtering with a predicate object', function() {
>, <Line: +         var searchAny = element(by.model('search.$'));
>, <Line: +         searchAny.clear();
>, <Line: +         searchAny.sendKeys('i');
>, <Line: +         expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], 'friendObj');
>, <Line: +       });
>, <Line: +	 it('should use a equal comparison when comparator is true', function() {
>, <Line: +         var searchName = element(by.model('search.name'));
>, <Line: +         var strict = element(by.model('strict'));
>, <Line: +         searchName.clear();
>, <Line: +         searchName.sendKeys('Julie');
>, <Line: +         strict.click();
>, <Line: +         expectFriendNames(['Julie'], 'friendObj');
>, <Line: +       });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function filterFilter() {
>, <Line: +		return function (array, expression, comparator) {
>, <Line: +			if (!isArray(array)) return array;
>, <Line: +			var comparatorType = typeof(comparator),
>, <Line: +				predicates = [];
>, <Line: +			predicates.check = function (value, index) {
>, <Line: +				for (var j = 0; j < predicates.length; j++) {
>, <Line: +					if (!predicates[j](value, index)) {
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return true;
>, <Line: +			};
>, <Line: +			if (comparatorType !== 'function') {
>, <Line: +				if (comparatorType === 'boolean' && comparator) {
>, <Line: +					comparator = function (obj, text) {
>, <Line: +						return angular.equals(obj, text);
>, <Line: +					};
>, <Line: +				} else {
>, <Line: +					comparator = function (obj, text) {
>, <Line: +						if (obj && text && typeof obj === 'object' && typeof text === 'object') {
>, <Line: +							for (var objKey in obj) {
>, <Line: +								if (objKey.charAt(0) !== '$' && hasOwnProperty.call(obj, objKey) &&
>, <Line: +									comparator(obj[objKey], text[objKey])) {
>, <Line: +									return true;
>, <Line: +								}
>, <Line: +							}
>, <Line: +							return false;
>, <Line: +						}
>, <Line: +						text = ('' + text).toLowerCase();
>, <Line: +						return ('' + obj).toLowerCase().indexOf(text) > -1;
>, <Line: +					};
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var search = function (obj, text) {
>, <Line: +				if (typeof text === 'string' && text.charAt(0) === '!') {
>, <Line: +					return !search(obj, text.substr(1));
>, <Line: +				}
>, <Line: +				switch (typeof obj) {
>, <Line: +					case 'boolean':
>, <Line: +					case 'number':
>, <Line: +					case 'string':
>, <Line: +						return comparator(obj, text);
>, <Line: +					case 'object':
>, <Line: +						switch (typeof text) {
>, <Line: +							case 'object':
>, <Line: +								return comparator(obj, text);
>, <Line: +							default:
>, <Line: +								for (var objKey in obj) {
>, <Line: +									if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
>, <Line: +										return true;
>, <Line: +									}
>, <Line: +								}
>, <Line: +								break;
>, <Line: +						}
>, <Line: +						return false;
>, <Line: +					case 'array':
>, <Line: +						for (var i = 0; i < obj.length; i++) {
>, <Line: +							if (search(obj[i], text)) {
>, <Line: +								return true;
>, <Line: +							}
>, <Line: +						}
>, <Line: +						return false;
>, <Line: +					default:
>, <Line: +						return false;
>, <Line: +				}
>, <Line: +			};
>, <Line: +			switch (typeof expression) {
>, <Line: +				case 'boolean':
>, <Line: +				case 'number':
>, <Line: +				case 'string':
>, <Line: +					// Set up expression object and fall through
>, <Line: +					expression = {$: expression};
>, <Line: +				// jshint -W086
>, <Line: +				case 'object':
>, <Line: +					// jshint +W086
>, <Line: +					for (var key in expression) {
>, <Line: +						(function (path) {
>, <Line: +							if (typeof expression[path] === 'undefined') return;
>, <Line: +							predicates.push(function (value) {
>, <Line: +								return search(path == '$' ? value : (value && value[path]), expression[path]);
>, <Line: +							});
>, <Line: +						})(key);
>, <Line: +					}
>, <Line: +					break;
>, <Line: +				case 'function':
>, <Line: +					predicates.push(expression);
>, <Line: +					break;
>, <Line: +				default:
>, <Line: +					return array;
>, <Line: +			}
>, <Line: +			var filtered = [];
>, <Line: +			for (var j = 0; j < array.length; j++) {
>, <Line: +				var value = array[j];
>, <Line: +				if (predicates.check(value, j)) {
>, <Line: +					filtered.push(value);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return filtered;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name currency
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
>, <Line: +	 * symbol for current locale is used.
>, <Line: +	 *
>, <Line: +	 * @param {number} amount Input to filter.
>, <Line: +	 * @param {string=} symbol Currency symbol or identifier to be displayed.
>, <Line: +	 * @param {number=} fractionSize Number of decimal places to round the amount to, defaults to default max fraction size for current locale
>, <Line: +	 * @returns {string} Formatted number.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="currencyExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('currencyExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <input type="number" ng-model="amount"> <br>
>, <Line: +	 default currency symbol ($): <span id="currency-default">{{amount | currency}}</span><br>
>, <Line: +	 custom currency identifier (USD$): <span id="currency-custom">{{amount | currency:"USD$"}}</span>
>, <Line: +	 no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should init with 1234.56', function() {
>, <Line: +	 it('should update', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	currencyFilter.$inject = ['$locale'];
>, <Line: +	function currencyFilter($locale) {
>, <Line: +		var formats = $locale.NUMBER_FORMATS;
>, <Line: +		return function (amount, currencySymbol, fractionSize) {
>, <Line: +			if (isUndefined(currencySymbol)) {
>, <Line: +				currencySymbol = formats.CURRENCY_SYM;
>, <Line: +			}
>, <Line: +			if (isUndefined(fractionSize)) {
>, <Line: +				fractionSize = formats.PATTERNS[1].maxFrac;
>, <Line: +			}
>, <Line: +			// if null or undefined pass it through
>, <Line: +			return (amount == null)
>, <Line: +				? amount
>, <Line: +				: formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
>, <Line: +				replace(/\u00A4/g, currencySymbol);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name number
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Formats a number as text.
>, <Line: +	 *
>, <Line: +	 * If the input is not a number an empty string is returned.
>, <Line: +	 *
>, <Line: +	 * @param {number|string} number Number to format.
>, <Line: +	 * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
>, <Line: +	 * If this is not provided then the fraction size is computed from the current locale's number
>, <Line: +	 * formatting pattern. In the case of the default locale, it will be 3.
>, <Line: +	 * @returns {string} Number rounded to decimalPlaces and places a , after each third digit.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="numberFilterExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('numberFilterExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Enter number: <input ng-model='val'><br>
>, <Line: +	 Default formatting: <span id='number-default'>{{val | number}}</span><br>
>, <Line: +	 No fractions: <span>{{val | number:0}}</span><br>
>, <Line: +	 Negative number: <span>{{-val | number:4}}</span>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should format numbers', function() {
>, <Line: +	 it('should update', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	numberFilter.$inject = ['$locale'];
>, <Line: +	function numberFilter($locale) {
>, <Line: +		var formats = $locale.NUMBER_FORMATS;
>, <Line: +		return function (number, fractionSize) {
>, <Line: +			// if null or undefined pass it through
>, <Line: +			return (number == null)
>, <Line: +				? number
>, <Line: +				: formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
>, <Line: +				fractionSize);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	var DECIMAL_SEP = '.';
>, <Line: +	function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
>, <Line: +		if (!isFinite(number) || isObject(number)) return '';
>, <Line: +		var isNegative = number < 0;
>, <Line: +		number = Math.abs(number);
>, <Line: +		var numStr = number + '',
>, <Line: +			formatedText = '',
>, <Line: +			parts = [];
>, <Line: +		var hasExponent = false;
>, <Line: +		if (numStr.indexOf('e') !== -1) {
>, <Line: +			var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
>, <Line: +			if (match && match[2] == '-' && match[3] > fractionSize + 1) {
>, <Line: +				numStr = '0';
>, <Line: +				number = 0;
>, <Line: +			} else {
>, <Line: +				formatedText = numStr;
>, <Line: +				hasExponent = true;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		if (!hasExponent) {
>, <Line: +			var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
>, <Line: +			// determine fractionSize if it is not specified
>, <Line: +			if (isUndefined(fractionSize)) {
>, <Line: +				fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
>, <Line: +			}
>, <Line: +			// safely round numbers in JS without hitting imprecisions of floating-point arithmetics
>, <Line: +			// inspired by:
>, <Line: +			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
>, <Line: +			number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
>, <Line: +			if (number === 0) {
>, <Line: +				isNegative = false;
>, <Line: +			}
>, <Line: +			var fraction = ('' + number).split(DECIMAL_SEP);
>, <Line: +			var whole = fraction[0];
>, <Line: +			fraction = fraction[1] || '';
>, <Line: +			var i, pos = 0,
>, <Line: +				lgroup = pattern.lgSize,
>, <Line: +				group = pattern.gSize;
>, <Line: +			if (whole.length >= (lgroup + group)) {
>, <Line: +				pos = whole.length - lgroup;
>, <Line: +				for (i = 0; i < pos; i++) {
>, <Line: +					if ((pos - i) % group === 0 && i !== 0) {
>, <Line: +						formatedText += groupSep;
>, <Line: +					}
>, <Line: +					formatedText += whole.charAt(i);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			for (i = pos; i < whole.length; i++) {
>, <Line: +				if ((whole.length - i) % lgroup === 0 && i !== 0) {
>, <Line: +					formatedText += groupSep;
>, <Line: +				}
>, <Line: +				formatedText += whole.charAt(i);
>, <Line: +			}
>, <Line: +			// format fraction part.
>, <Line: +			while (fraction.length < fractionSize) {
>, <Line: +				fraction += '0';
>, <Line: +			}
>, <Line: +			if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
>, <Line: +		} else {
>, <Line: +			if (fractionSize > 0 && number > -1 && number < 1) {
>, <Line: +				formatedText = number.toFixed(fractionSize);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		parts.push(isNegative ? pattern.negPre : pattern.posPre,
>, <Line: +			formatedText,
>, <Line: +			isNegative ? pattern.negSuf : pattern.posSuf);
>, <Line: +		return parts.join('');
>, <Line: +	}
>, <Line: +	function padNumber(num, digits, trim) {
>, <Line: +		var neg = '';
>, <Line: +		if (num < 0) {
>, <Line: +			neg = '-';
>, <Line: +			num = -num;
>, <Line: +		}
>, <Line: +		num = '' + num;
>, <Line: +		while (num.length < digits) num = '0' + num;
>, <Line: +		if (trim)
>, <Line: +			num = num.substr(num.length - digits);
>, <Line: +		return neg + num;
>, <Line: +	}
>, <Line: +	function dateGetter(name, size, offset, trim) {
>, <Line: +		offset = offset || 0;
>, <Line: +		return function (date) {
>, <Line: +			var value = date['get' + name]();
>, <Line: +			if (offset > 0 || value > -offset)
>, <Line: +				value += offset;
>, <Line: +			if (value === 0 && offset == -12) value = 12;
>, <Line: +			return padNumber(value, size, trim);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function dateStrGetter(name, shortForm) {
>, <Line: +		return function (date, formats) {
>, <Line: +			var value = date['get' + name]();
>, <Line: +			var get = uppercase(shortForm ? ('SHORT' + name) : name);
>, <Line: +			return formats[get][value];
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function timeZoneGetter(date) {
>, <Line: +		var zone = -1 * date.getTimezoneOffset();
>, <Line: +		var paddedZone = (zone >= 0) ? "+" : "";
>, <Line: +		paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
>, <Line: +			padNumber(Math.abs(zone % 60), 2);
>, <Line: +		return paddedZone;
>, <Line: +	}
>, <Line: +	function getFirstThursdayOfYear(year) {
>, <Line: +		// 0 = index of January
>, <Line: +		var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
>, <Line: +		// 4 = index of Thursday (+1 to account for 1st = 5)
>, <Line: +		// 11 = index of *next* Thursday (+1 account for 1st = 12)
>, <Line: +		return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
>, <Line: +	}
>, <Line: +	function getThursdayThisWeek(datetime) {
>, <Line: +		return new Date(datetime.getFullYear(), datetime.getMonth(),
>, <Line: +			// 4 = index of Thursday
>, <Line: +			datetime.getDate() + (4 - datetime.getDay()));
>, <Line: +	}
>, <Line: +	function weekGetter(size) {
>, <Line: +		return function (date) {
>, <Line: +			var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
>, <Line: +				thisThurs = getThursdayThisWeek(date);
>, <Line: +			var diff = +thisThurs - +firstThurs,
>, <Line: +				result = 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per week
>, <Line: +			return padNumber(result, size);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function ampmGetter(date, formats) {
>, <Line: +		return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
>, <Line: +	}
>, <Line: +	var DATE_FORMATS = {
>, <Line: +		yyyy: dateGetter('FullYear', 4),
>, <Line: +		yy: dateGetter('FullYear', 2, 0, true),
>, <Line: +		y: dateGetter('FullYear', 1),
>, <Line: +		MMMM: dateStrGetter('Month'),
>, <Line: +		MMM: dateStrGetter('Month', true),
>, <Line: +		MM: dateGetter('Month', 2, 1),
>, <Line: +		M: dateGetter('Month', 1, 1),
>, <Line: +		dd: dateGetter('Date', 2),
>, <Line: +		d: dateGetter('Date', 1),
>, <Line: +		HH: dateGetter('Hours', 2),
>, <Line: +		H: dateGetter('Hours', 1),
>, <Line: +		hh: dateGetter('Hours', 2, -12),
>, <Line: +		h: dateGetter('Hours', 1, -12),
>, <Line: +		mm: dateGetter('Minutes', 2),
>, <Line: +		m: dateGetter('Minutes', 1),
>, <Line: +		ss: dateGetter('Seconds', 2),
>, <Line: +		s: dateGetter('Seconds', 1),
>, <Line: +		// while ISO 8601 requires fractions to be prefixed with `.` or `,`
>, <Line: +		// we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
>, <Line: +		sss: dateGetter('Milliseconds', 3),
>, <Line: +		EEEE: dateStrGetter('Day'),
>, <Line: +		EEE: dateStrGetter('Day', true),
>, <Line: +		a: ampmGetter,
>, <Line: +		Z: timeZoneGetter,
>, <Line: +		ww: weekGetter(2),
>, <Line: +		w: weekGetter(1)
>, <Line: +	};
>, <Line: +	var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/,
>, <Line: +		NUMBER_STRING = /^\-?\d+$/;
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name date
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *   Formats `date` to a string based on the requested `format`.
>, <Line: +	 *
>, <Line: +	 *   `format` string can be composed of the following elements:
>, <Line: +	 *
>, <Line: +	 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
>, <Line: +	 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
>, <Line: +	 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
>, <Line: +	 *   * `'MMMM'`: Month in year (January-December)
>, <Line: +	 *   * `'MMM'`: Month in year (Jan-Dec)
>, <Line: +	 *   * `'MM'`: Month in year, padded (01-12)
>, <Line: +	 *   * `'M'`: Month in year (1-12)
>, <Line: +	 *   * `'dd'`: Day in month, padded (01-31)
>, <Line: +	 *   * `'d'`: Day in month (1-31)
>, <Line: +	 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
>, <Line: +	 *   * `'EEE'`: Day in Week, (Sun-Sat)
>, <Line: +	 *   * `'HH'`: Hour in day, padded (00-23)
>, <Line: +	 *   * `'H'`: Hour in day (0-23)
>, <Line: +	 *   * `'hh'`: Hour in AM/PM, padded (01-12)
>, <Line: +	 *   * `'h'`: Hour in AM/PM, (1-12)
>, <Line: +	 *   * `'mm'`: Minute in hour, padded (00-59)
>, <Line: +	 *   * `'m'`: Minute in hour (0-59)
>, <Line: +	 *   * `'ss'`: Second in minute, padded (00-59)
>, <Line: +	 *   * `'s'`: Second in minute (0-59)
>, <Line: +	 *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
>, <Line: +	 *   * `'a'`: AM/PM marker
>, <Line: +	 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
>, <Line: +	 *   * `'ww'`: ISO-8601 week of year (00-53)
>, <Line: +	 *   * `'w'`: ISO-8601 week of year (0-53)
>, <Line: +	 *
>, <Line: +	 *   `format` string can also be one of the following predefined
>, <Line: +	 *   {@link guide/i18n localizable formats}:
>, <Line: +	 *
>, <Line: +	 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
>, <Line: +	 *     (e.g. Sep 3, 2010 12:05:08 PM)
>, <Line: +	 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 PM)
>, <Line: +	 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` for en_US  locale
>, <Line: +	 *     (e.g. Friday, September 3, 2010)
>, <Line: +	 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
>, <Line: +	 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
>, <Line: +	 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
>, <Line: +	 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 PM)
>, <Line: +	 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 PM)
>, <Line: +	 *
>, <Line: +	 *   `format` string can contain literal values. These need to be escaped by surrounding with single quotes (e.g.
>, <Line: +	 *   `"h 'in the morning'"`). In order to output a single quote, escape it - i.e., two single quotes in a sequence
>, <Line: +	 *   (e.g. `"h 'o''clock'"`).
>, <Line: +	 *
>, <Line: +	 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
>, <Line: +	 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.sssZ and its
>, <Line: +	 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
>, <Line: +	 *    specified in the string input, the time is considered to be in the local timezone.
>, <Line: +	 * @param {string=} format Formatting rules (see Description). If not specified,
>, <Line: +	 *    `mediumDate` is used.
>, <Line: +	 * @param {string=} timezone Timezone to be used for formatting. Right now, only `'UTC'` is supported.
>, <Line: +	 *    If not specified, the timezone of the browser will be used.
>, <Line: +	 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
>, <Line: +	 <span>{{1288323623006 | date:'medium'}}</span><br>
>, <Line: +	 <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
>, <Line: +	 <span>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span><br>
>, <Line: +	 <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
>, <Line: +	 <span>{{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}</span><br>
>, <Line: +	 <span ng-non-bindable>{{1288323623006 | date:"MM/dd/yyyy 'at' h:mma"}}</span>:
>, <Line: +	 <span>{{'1288323623006' | date:"MM/dd/yyyy 'at' h:mma"}}</span><br>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should format date', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	dateFilter.$inject = ['$locale'];
>, <Line: +	function dateFilter($locale) {
>, <Line: +		var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
>, <Line: +		// 1        2       3         4          5          6          7          8  9     10      11
>, <Line: +		function jsonStringToDate(string) {
>, <Line: +			var match;
>, <Line: +			if (match = string.match(R_ISO8601_STR)) {
>, <Line: +				var date = new Date(0),
>, <Line: +					tzHour = 0,
>, <Line: +					tzMin = 0,
>, <Line: +					dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
>, <Line: +					timeSetter = match[8] ? date.setUTCHours : date.setHours;
>, <Line: +				if (match[9]) {
>, <Line: +					tzHour = int(match[9] + match[10]);
>, <Line: +					tzMin = int(match[9] + match[11]);
>, <Line: +				}
>, <Line: +				dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
>, <Line: +				var h = int(match[4] || 0) - tzHour;
>, <Line: +				var m = int(match[5] || 0) - tzMin;
>, <Line: +				var s = int(match[6] || 0);
>, <Line: +				var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
>, <Line: +				timeSetter.call(date, h, m, s, ms);
>, <Line: +				return date;
>, <Line: +			}
>, <Line: +			return string;
>, <Line: +		}
>, <Line: +		return function (date, format, timezone) {
>, <Line: +			var text = '',
>, <Line: +				parts = [],
>, <Line: +				fn, match;
>, <Line: +			format = format || 'mediumDate';
>, <Line: +			format = $locale.DATETIME_FORMATS[format] || format;
>, <Line: +			if (isString(date)) {
>, <Line: +				date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
>, <Line: +			}
>, <Line: +			if (isNumber(date)) {
>, <Line: +				date = new Date(date);
>, <Line: +			}
>, <Line: +			if (!isDate(date)) {
>, <Line: +				return date;
>, <Line: +			}
>, <Line: +			while (format) {
>, <Line: +				match = DATE_FORMATS_SPLIT.exec(format);
>, <Line: +				if (match) {
>, <Line: +					parts = concat(parts, match, 1);
>, <Line: +					format = parts.pop();
>, <Line: +				} else {
>, <Line: +					parts.push(format);
>, <Line: +					format = null;
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (timezone && timezone === 'UTC') {
>, <Line: +				date = new Date(date.getTime());
>, <Line: +				date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
>, <Line: +			}
>, <Line: +			forEach(parts, function (value) {
>, <Line: +				fn = DATE_FORMATS[value];
>, <Line: +				text += fn ? fn(date, $locale.DATETIME_FORMATS)
>, <Line: +					: value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
>, <Line: +			});
>, <Line: +			return text;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name json
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *   Allows you to convert a JavaScript object into JSON string.
>, <Line: +	 *
>, <Line: +	 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
>, <Line: +	 *   the binding is automatically converted to JSON.
>, <Line: +	 *
>, <Line: +	 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
>, <Line: +	 * @returns {string} JSON string.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <pre>{{ {'name':'value'} | json }}</pre>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should jsonify filtered objects', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	function jsonFilter() {
>, <Line: +		return function (object) {
>, <Line: +			return toJson(object, true);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name lowercase
>, <Line: +	 * @kind function
>, <Line: +	 * @description
>, <Line: +	 * Converts string to lowercase.
>, <Line: +	 * @see angular.lowercase
>, <Line: +	 */
>, <Line: +	var lowercaseFilter = valueFn(lowercase);
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name uppercase
>, <Line: +	 * @kind function
>, <Line: +	 * @description
>, <Line: +	 * Converts string to uppercase.
>, <Line: +	 * @see angular.uppercase
>, <Line: +	 */
>, <Line: +	var uppercaseFilter = valueFn(uppercase);
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name limitTo
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Creates a new array or string containing only a specified number of elements. The elements
>, <Line: +	 * are taken from either the beginning or the end of the source array, string or number, as specified by
>, <Line: +	 * the value and sign (positive or negative) of `limit`. If a number is used as input, it is
>, <Line: +	 * converted to a string.
>, <Line: +	 *
>, <Line: +	 * @param {Array|string|number} input Source array, string or number to be limited.
>, <Line: +	 * @param {string|number} limit The length of the returned array or string. If the `limit` number
>, <Line: +	 *     is positive, `limit` number of items from the beginning of the source array/string are copied.
>, <Line: +	 *     If the number is negative, `limit` number  of items from the end of the source array/string
>, <Line: +	 *     are copied. The `limit` will be trimmed if it exceeds `array.length`
>, <Line: +	 * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
>, <Line: +	 *     had less than `limit` elements.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="limitToExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('limitToExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Limit {{numbers}} to: <input type="number" step="1" ng-model="numLimit">
>, <Line: +	 <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
>, <Line: +	 Limit {{letters}} to: <input type="number" step="1" ng-model="letterLimit">
>, <Line: +	 <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
>, <Line: +	 Limit {{longNumber}} to: <input type="number" step="1" ng-model="longNumberLimit">
>, <Line: +	 <p>Output long number: {{ longNumber | limitTo:longNumberLimit }}</p>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var numLimitInput = element(by.model('numLimit'));
>, <Line: +	 var letterLimitInput = element(by.model('letterLimit'));
>, <Line: +	 var longNumberLimitInput = element(by.model('longNumberLimit'));
>, <Line: +	 var limitedNumbers = element(by.binding('numbers | limitTo:numLimit'));
>, <Line: +	 var limitedLetters = element(by.binding('letters | limitTo:letterLimit'));
>, <Line: +	 var limitedLongNumber = element(by.binding('longNumber | limitTo:longNumberLimit'));
>, <Line: +	 it('should limit the number array to first three items', function() {
>, <Line: +	 // There is a bug in safari and protractor that doesn't like the minus key
>, <Line: +	 // it('should update the output when -3 is entered', function() {
>, <Line: +	 it('should not exceed the maximum size of input array', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	function limitToFilter() {
>, <Line: +		return function (input, limit) {
>, <Line: +			if (isNumber(input)) input = input.toString();
>, <Line: +			if (!isArray(input) && !isString(input)) return input;
>, <Line: +			if (Math.abs(Number(limit)) === Infinity) {
>, <Line: +				limit = Number(limit);
>, <Line: +			} else {
>, <Line: +				limit = int(limit);
>, <Line: +			}
>, <Line: +			if (isString(input)) {
>, <Line: +				//NaN check on limit
>, <Line: +				if (limit) {
>, <Line: +					return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
>, <Line: +				} else {
>, <Line: +					return "";
>, <Line: +				}
>, <Line: +			}
>, <Line: +			var out = [],
>, <Line: +				i, n;
>, <Line: +			// if abs(limit) exceeds maximum length, trim it
>, <Line: +			if (limit > input.length)
>, <Line: +				limit = input.length;
>, <Line: +			else if (limit < -input.length)
>, <Line: +				limit = -input.length;
>, <Line: +			if (limit > 0) {
>, <Line: +				i = 0;
>, <Line: +				n = limit;
>, <Line: +			} else {
>, <Line: +				i = input.length + limit;
>, <Line: +				n = input.length;
>, <Line: +			}
>, <Line: +			for (; i < n; i++) {
>, <Line: +				out.push(input[i]);
>, <Line: +			}
>, <Line: +			return out;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc filter
>, <Line: +	 * @name orderBy
>, <Line: +	 * @kind function
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Orders a specified `array` by the `expression` predicate. It is ordered alphabetically
>, <Line: +	 * for strings and numerically for numbers. Note: if you notice numbers are not being sorted
>, <Line: +	 * correctly, make sure they are actually being saved as numbers and not strings.
>, <Line: +	 *
>, <Line: +	 * @param {Array} array The array to sort.
>, <Line: +	 * @param {function(*)|string|Array.<(function(*)|string)>=} expression A predicate to be
>, <Line: +	 *    used by the comparator to determine the order of elements.
>, <Line: +	 *
>, <Line: +	 *    Can be one of:
>, <Line: +	 *
>, <Line: +	 *    - `function`: Getter function. The result of this function will be sorted using the
>, <Line: +	 *      `<`, `=`, `>` operator.
>, <Line: +	 *    - `string`: An Angular expression. The result of this expression is used to compare elements
>, <Line: +	 *      (for example `name` to sort by a property called `name` or `name.substr(0, 3)` to sort by
>, <Line: +	 *      3 first characters of a property called `name`). The result of a constant expression
>, <Line: +	 *      is interpreted as a property name to be used in comparisons (for example `"special name"`
>, <Line: +	 *      to sort object by the value of their `special name` property). An expression can be
>, <Line: +	 *      optionally prefixed with `+` or `-` to control ascending or descending sort order
>, <Line: +	 *      (for example, `+name` or `-name`). If no property is provided, (e.g. `'+'`) then the array
>, <Line: +	 *      element itself is used to compare where sorting.
>, <Line: +	 *    - `Array`: An array of function or string predicates. The first predicate in the array
>, <Line: +	 *      is used for sorting, but when two items are equivalent, the next predicate is used.
>, <Line: +	 *
>, <Line: +	 *    If the predicate is missing or empty then it defaults to `'+'`.
>, <Line: +	 *
>, <Line: +	 * @param {boolean=} reverse Reverse the order of the array.
>, <Line: +	 * @returns {Array} Sorted copy of the source array.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="orderByExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('orderByExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
>, <Line: +	 <hr/>
>, <Line: +	 [ <a href="" ng-click="predicate=''">unsorted</a> ]
>, <Line: +	 <table class="friend">
>, <Line: +	 <tr>
>, <Line: +	 <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
>, <Line: +	 (<a href="" ng-click="predicate = '-name'; reverse=false">^</a>)</th>
>, <Line: +	 <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
>, <Line: +	 <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
>, <Line: +	 </tr>
>, <Line: +	 <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
>, <Line: +	 <td>{{friend.name}}</td>
>, <Line: +	 <td>{{friend.phone}}</td>
>, <Line: +	 <td>{{friend.age}}</td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * It's also possible to call the orderBy filter manually, by injecting `$filter`, retrieving the
>, <Line: +	 * filter routine with `$filter('orderBy')`, and calling the returned filter routine with the
>, <Line: +	 * desired parameters.
>, <Line: +	 *
>, <Line: +	 * Example:
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="orderByExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <table class="friend">
>, <Line: +	 <tr>
>, <Line: +	 <th><a href="" ng-click="reverse=false;order('name', false)">Name</a>
>, <Line: +	 (<a href="" ng-click="order('-name',false)">^</a>)</th>
>, <Line: +	 <th><a href="" ng-click="reverse=!reverse;order('phone', reverse)">Phone Number</a></th>
>, <Line: +	 <th><a href="" ng-click="reverse=!reverse;order('age',reverse)">Age</a></th>
>, <Line: +	 </tr>
>, <Line: +	 <tr ng-repeat="friend in friends">
>, <Line: +	 <td>{{friend.name}}</td>
>, <Line: +	 <td>{{friend.phone}}</td>
>, <Line: +	 <td>{{friend.age}}</td>
>, <Line: +	 </tr>
>, <Line: +	 </table>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('orderByExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', '$filter', function($scope, $filter) {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	orderByFilter.$inject = ['$parse'];
>, <Line: +	function orderByFilter($parse) {
>, <Line: +		return function (array, sortPredicate, reverseOrder) {
>, <Line: +			if (!(isArrayLike(array))) return array;
>, <Line: +			sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
>, <Line: +			if (sortPredicate.length === 0) {
>, <Line: +				sortPredicate = ['+'];
>, <Line: +			}
>, <Line: +			sortPredicate = sortPredicate.map(function (predicate) {
>, <Line: +				var descending = false, get = predicate || identity;
>, <Line: +				if (isString(predicate)) {
>, <Line: +					if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
>, <Line: +						descending = predicate.charAt(0) == '-';
>, <Line: +						predicate = predicate.substring(1);
>, <Line: +					}
>, <Line: +					if (predicate === '') {
>, <Line: +						// Effectively no predicate was passed so we compare identity
>, <Line: +						return reverseComparator(function (a, b) {
>, <Line: +							return compare(a, b);
>, <Line: +						}, descending);
>, <Line: +					}
>, <Line: +					get = $parse(predicate);
>, <Line: +					if (get.constant) {
>, <Line: +						var key = get();
>, <Line: +						return reverseComparator(function (a, b) {
>, <Line: +							return compare(a[key], b[key]);
>, <Line: +						}, descending);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return reverseComparator(function (a, b) {
>, <Line: +					return compare(get(a), get(b));
>, <Line: +				}, descending);
>, <Line: +			});
>, <Line: +			return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
>, <Line: +			function comparator(o1, o2) {
>, <Line: +				for (var i = 0; i < sortPredicate.length; i++) {
>, <Line: +					var comp = sortPredicate[i](o1, o2);
>, <Line: +					if (comp !== 0) return comp;
>, <Line: +				}
>, <Line: +				return 0;
>, <Line: +			}
>, <Line: +			function reverseComparator(comp, descending) {
>, <Line: +				return descending
>, <Line: +					? function (a, b) {
>, <Line: +					return comp(b, a);
>, <Line: +				}
>, <Line: +					: comp;
>, <Line: +			}
>, <Line: +			function compare(v1, v2) {
>, <Line: +				var t1 = typeof v1;
>, <Line: +				var t2 = typeof v2;
>, <Line: +				if (t1 == t2) {
>, <Line: +					if (isDate(v1) && isDate(v2)) {
>, <Line: +						v1 = v1.valueOf();
>, <Line: +						v2 = v2.valueOf();
>, <Line: +					}
>, <Line: +					if (t1 == "string") {
>, <Line: +						v1 = v1.toLowerCase();
>, <Line: +						v2 = v2.toLowerCase();
>, <Line: +					}
>, <Line: +					if (v1 === v2) return 0;
>, <Line: +					return v1 < v2 ? -1 : 1;
>, <Line: +				} else {
>, <Line: +					return t1 < t2 ? -1 : 1;
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function ngDirective(directive) {
>, <Line: +		if (isFunction(directive)) {
>, <Line: +			directive = {
>, <Line: +				link: directive
>, <Line: +			};
>, <Line: +		}
>, <Line: +		directive.restrict = directive.restrict || 'AC';
>, <Line: +		return valueFn(directive);
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name a
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Modifies the default behavior of the html A tag so that the default action is prevented when
>, <Line: +	 * the href attribute is empty.
>, <Line: +	 *
>, <Line: +	 * This change permits the easy creation of action links with the `ngClick` directive
>, <Line: +	 * without changing the location or causing page reloads, e.g.:
>, <Line: +	 * `<a href="" ng-click="list.addItem()">Add Item</a>`
>, <Line: +	 */
>, <Line: +	var htmlAnchorDirective = valueFn({
>, <Line: +		restrict: 'E',
>, <Line: +		compile: function (element, attr) {
>, <Line: +			if (!attr.href && !attr.xlinkHref && !attr.name) {
>, <Line: +				return function (scope, element) {
>, <Line: +					// SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
>, <Line: +					var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
>, <Line: +						'xlink:href' : 'href';
>, <Line: +					element.on('click', function (event) {
>, <Line: +						// if we have no href url, then don't navigate anywhere.
>, <Line: +						if (!element.attr(href)) {
>, <Line: +							event.preventDefault();
>, <Line: +						}
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngHref
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 99
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Using Angular markup like `{{hash}}` in an href attribute will
>, <Line: +	 * make the link go to the wrong URL if the user clicks it before
>, <Line: +	 * Angular has a chance to replace the `{{hash}}` markup with its
>, <Line: +	 * value. Until Angular replaces the markup the link will be broken
>, <Line: +	 * and will most likely return a 404 error.
>, <Line: +	 *
>, <Line: +	 * The `ngHref` directive solves this problem.
>, <Line: +	 *
>, <Line: +	 * The wrong way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <a href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The correct way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <a ng-href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @element A
>, <Line: +	 * @param {template} ngHref any string which can contain `{{}}` markup.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
>, <Line: +	 * in links and their different behaviors:
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-model="value" /><br />
>, <Line: +	 <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
>, <Line: +	 <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
>, <Line: +	 <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
>, <Line: +	 <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
>, <Line: +	 <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
>, <Line: +	 <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should execute ng-click but not reload when href without value', function() {
>, <Line: +	 it('should execute ng-click but not reload when href empty string', function() {
>, <Line: +	 it('should execute ng-click and change url when ng-href specified', function() {
>, <Line: +        });
>, <Line: +	 xit('should execute ng-click but not reload when href empty string and name specified', function() {
>, <Line: +          element(by.id('link-4')).click();
>, <Line: +          expect(element(by.model('value')).getAttribute('value')).toEqual('4');
>, <Line: +          expect(element(by.id('link-4')).getAttribute('href')).toBe('');
>, <Line: +        });
>, <Line: +	 it('should execute ng-click but not reload when no href but name specified', function() {
>, <Line: +          element(by.id('link-5')).click();
>, <Line: +          expect(element(by.model('value')).getAttribute('value')).toEqual('5');
>, <Line: +          expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
>, <Line: +        });
>, <Line: +	 it('should only change url when only ng-href', function() {
>, <Line: +          element(by.model('value')).clear();
>, <Line: +          element(by.model('value')).sendKeys('6');
>, <Line: +          expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);
>, <Line: +          element(by.id('link-6')).click();
>, <Line: +          // At this point, we navigate away from an Angular page, so we need
>, <Line: +          // to use browser.driver to get the base webdriver.
>, <Line: +          browser.wait(function() {
>, <Line: +            return browser.driver.getCurrentUrl().then(function(url) {
>, <Line: +              return url.match(/\/6$/);
>, <Line: +            });
>, <Line: +          }, 5000, 'page should navigate to /6');
>, <Line: +        });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngSrc
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 99
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
>, <Line: +	 * work right: The browser will fetch from the URL with the literal
>, <Line: +	 * text `{{hash}}` until Angular replaces the expression inside
>, <Line: +	 * `{{hash}}`. The `ngSrc` directive solves this problem.
>, <Line: +	 *
>, <Line: +	 * The buggy way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The correct way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @element IMG
>, <Line: +	 * @param {template} ngSrc any string which can contain `{{}}` markup.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngSrcset
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 99
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
>, <Line: +	 * work right: The browser will fetch from the URL with the literal
>, <Line: +	 * text `{{hash}}` until Angular replaces the expression inside
>, <Line: +	 * `{{hash}}`. The `ngSrcset` directive solves this problem.
>, <Line: +	 *
>, <Line: +	 * The buggy way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The correct way to write it:
>, <Line: +	 * ```html
>, <Line: +	 * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @element IMG
>, <Line: +	 * @param {template} ngSrcset any string which can contain `{{}}` markup.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngDisabled
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 100
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * We shouldn't do this, because it will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
>, <Line: +	 * ```html
>, <Line: +	 * <div ng-init="scope = { isDisabled: false }">
>, <Line: +	 *  <button disabled="{{scope.isDisabled}}">Disabled</button>
>, <Line: +	 * </div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: +	 * such as disabled. (Their presence means true and their absence means false.)
>, <Line: +	 * If we put an Angular interpolation expression into such an attribute then the
>, <Line: +	 * binding information would be lost when the browser removes the attribute.
>, <Line: +	 * The `ngDisabled` directive solves this problem for the `disabled` attribute.
>, <Line: +	 * This complementary directive is not removed by the browser and so provides
>, <Line: +	 * a permanent reliable place to store the binding information.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
>, <Line: +	 <button ng-model="button" ng-disabled="checked">Button</button>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should toggle button', function() {
>, <Line: +          expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
>, <Line: +          element(by.model('checked')).click();
>, <Line: +          expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();
>, <Line: +        });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @element INPUT
>, <Line: +	 * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy,
>, <Line: +	 *     then special attribute "disabled" will be set on the element
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngChecked
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 100
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: +	 * such as checked. (Their presence means true and their absence means false.)
>, <Line: +	 * If we put an Angular interpolation expression into such an attribute then the
>, <Line: +	 * binding information would be lost when the browser removes the attribute.
>, <Line: +	 * The `ngChecked` directive solves this problem for the `checked` attribute.
>, <Line: +	 * This complementary directive is not removed by the browser and so provides
>, <Line: +	 * a permanent reliable place to store the binding information.
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 Check me to check both: <input type="checkbox" ng-model="master"><br/>
>, <Line: +	 <input id="checkSlave" type="checkbox" ng-checked="master">
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check both checkBoxes', function() {
>, <Line: +          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
>, <Line: +          element(by.model('master')).click();
>, <Line: +          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy();
>, <Line: +        });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @element INPUT
>, <Line: +	 * @param {expression} ngChecked If the {@link guide/expression expression} is truthy,
>, <Line: +	 *     then special attribute "checked" will be set on the element
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngReadonly
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 100
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: +	 * such as readonly. (Their presence means true and their absence means false.)
>, <Line: +	 * If we put an Angular interpolation expression into such an attribute then the
>, <Line: +	 * binding information would be lost when the browser removes the attribute.
>, <Line: +	 * The `ngReadonly` directive solves this problem for the `readonly` attribute.
>, <Line: +	 * This complementary directive is not removed by the browser and so provides
>, <Line: +	 * a permanent reliable place to store the binding information.
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
>, <Line: +	 <input type="text" ng-readonly="checked" value="I'm Angular"/>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should toggle readonly attr', function() {
>, <Line: +          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeFalsy();
>, <Line: +          element(by.model('checked')).click();
>, <Line: +          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeTruthy();
>, <Line: +        });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @element INPUT
>, <Line: +	 * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy,
>, <Line: +	 *     then special attribute "readonly" will be set on the element
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngSelected
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 100
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: +	 * such as selected. (Their presence means true and their absence means false.)
>, <Line: +	 * If we put an Angular interpolation expression into such an attribute then the
>, <Line: +	 * binding information would be lost when the browser removes the attribute.
>, <Line: +	 * The `ngSelected` directive solves this problem for the `selected` attribute.
>, <Line: +	 * This complementary directive is not removed by the browser and so provides
>, <Line: +	 * a permanent reliable place to store the binding information.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 Check me to select: <input type="checkbox" ng-model="selected"><br/>
>, <Line: +	 <select>
>, <Line: +	 <option>Hello!</option>
>, <Line: +	 <option id="greet" ng-selected="selected">Greetings!</option>
>, <Line: +	 </select>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should select Greetings!', function() {
>, <Line: +          expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
>, <Line: +          element(by.model('selected')).click();
>, <Line: +          expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();
>, <Line: +        });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @element OPTION
>, <Line: +	 * @param {expression} ngSelected If the {@link guide/expression expression} is truthy,
>, <Line: +	 *     then special attribute "selected" will be set on the element
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngOpen
>, <Line: +	 * @restrict A
>, <Line: +	 * @priority 100
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: +	 * such as open. (Their presence means true and their absence means false.)
>, <Line: +	 * If we put an Angular interpolation expression into such an attribute then the
>, <Line: +	 * binding information would be lost when the browser removes the attribute.
>, <Line: +	 * The `ngOpen` directive solves this problem for the `open` attribute.
>, <Line: +	 * This complementary directive is not removed by the browser and so provides
>, <Line: +	 * a permanent reliable place to store the binding information.
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 Check me check multiple: <input type="checkbox" ng-model="open"><br/>
>, <Line: +	 <details id="details" ng-open="open">
>, <Line: +	 <summary>Show/Hide me</summary>
>, <Line: +	 </details>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should toggle open', function() {
>, <Line: +           expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
>, <Line: +           element(by.model('open')).click();
>, <Line: +           expect(element(by.id('details')).getAttribute('open')).toBeTruthy();
>, <Line: +         });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @element DETAILS
>, <Line: +	 * @param {expression} ngOpen If the {@link guide/expression expression} is truthy,
>, <Line: +	 *     then special attribute "open" will be set on the element
>, <Line: +	 */
>, <Line: +	var ngAttributeAliasDirectives = {};
>, <Line: +// boolean attrs are evaluated
>, <Line: +	forEach(BOOLEAN_ATTR, function (propName, attrName) {
>, <Line: +		// binding to multiple is not supported
>, <Line: +		if (propName == "multiple") return;
>, <Line: +		var normalized = directiveNormalize('ng-' + attrName);
>, <Line: +		ngAttributeAliasDirectives[normalized] = function () {
>, <Line: +			return {
>, <Line: +				restrict: 'A',
>, <Line: +				priority: 100,
>, <Line: +				link: function (scope, element, attr) {
>, <Line: +					scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
>, <Line: +						attr.$set(attrName, !!value);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +		};
>, <Line: +	});
>, <Line: +// aliased input attrs are evaluated
>, <Line: +	forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
>, <Line: +		ngAttributeAliasDirectives[ngAttr] = function () {
>, <Line: +			return {
>, <Line: +				priority: 100,
>, <Line: +				link: function (scope, element, attr) {
>, <Line: +					//special case ngPattern when a literal regular expression value
>, <Line: +					//is used as the expression (this way we don't have to watch anything).
>, <Line: +					if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
>, <Line: +						var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
>, <Line: +						if (match) {
>, <Line: +							attr.$set("ngPattern", new RegExp(match[1], match[2]));
>, <Line: +							return;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
>, <Line: +						attr.$set(ngAttr, value);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +		};
>, <Line: +	});
>, <Line: +// ng-src, ng-srcset, ng-href are interpolated
>, <Line: +	forEach(['src', 'srcset', 'href'], function (attrName) {
>, <Line: +		var normalized = directiveNormalize('ng-' + attrName);
>, <Line: +		ngAttributeAliasDirectives[normalized] = function () {
>, <Line: +			return {
>, <Line: +				priority: 99, // it needs to run after the attributes are interpolated
>, <Line: +				link: function (scope, element, attr) {
>, <Line: +					var propName = attrName,
>, <Line: +						name = attrName;
>, <Line: +					if (attrName === 'href' &&
>, <Line: +						toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
>, <Line: +						name = 'xlinkHref';
>, <Line: +						attr.$attr[name] = 'xlink:href';
>, <Line: +						propName = null;
>, <Line: +					}
>, <Line: +					attr.$observe(normalized, function (value) {
>, <Line: +						if (!value) {
>, <Line: +							if (attrName === 'href') {
>, <Line: +								attr.$set(name, null);
>, <Line: +							}
>, <Line: +							return;
>, <Line: +						}
>, <Line: +						attr.$set(name, value);
>, <Line: +						// on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
>, <Line: +						// then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
>, <Line: +						// to set the property as well to achieve the desired effect.
>, <Line: +						// we use attr[attrName] value since $set can sanitize the url.
>, <Line: +						if (msie && propName) element.prop(propName, attr[name]);
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +		};
>, <Line: +	});
>, <Line: +	/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true
>, <Line: +	 */
>, <Line: +	var nullFormCtrl = {
>, <Line: +			$addControl: noop,
>, <Line: +			$$renameControl: nullFormRenameControl,
>, <Line: +			$removeControl: noop,
>, <Line: +			$setValidity: noop,
>, <Line: +			$setDirty: noop,
>, <Line: +			$setPristine: noop,
>, <Line: +			$setSubmitted: noop
>, <Line: +		},
>, <Line: +		SUBMITTED_CLASS = 'ng-submitted';
>, <Line: +	function nullFormRenameControl(control, name) {
>, <Line: +		control.$name = name;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name form.FormController
>, <Line: +	 *
>, <Line: +	 * @property {boolean} $pristine True if user has not interacted with the form yet.
>, <Line: +	 * @property {boolean} $dirty True if user has already interacted with the form.
>, <Line: +	 * @property {boolean} $valid True if all of the containing forms and controls are valid.
>, <Line: +	 * @property {boolean} $invalid True if at least one containing control or form is invalid.
>, <Line: +	 * @property {boolean} $submitted True if user has submitted the form even if its invalid.
>, <Line: +	 *
>, <Line: +	 * @property {Object} $error Is an object hash, containing references to controls or
>, <Line: +	 *  forms with failing validators, where:
>, <Line: +	 *
>, <Line: +	 *  - keys are validation tokens (error names),
>, <Line: +	 *  - values are arrays of controls or forms that have a failing validator for given error name.
>, <Line: +	 *
>, <Line: +	 *  Built-in validation tokens:
>, <Line: +	 *
>, <Line: +	 *  - `email`
>, <Line: +	 *  - `max`
>, <Line: +	 *  - `maxlength`
>, <Line: +	 *  - `min`
>, <Line: +	 *  - `minlength`
>, <Line: +	 *  - `number`
>, <Line: +	 *  - `pattern`
>, <Line: +	 *  - `required`
>, <Line: +	 *  - `url`
>, <Line: +	 *  - `date`
>, <Line: +	 *  - `datetimelocal`
>, <Line: +	 *  - `time`
>, <Line: +	 *  - `week`
>, <Line: +	 *  - `month`
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * `FormController` keeps track of all its controls and nested forms as well as the state of them,
>, <Line: +	 * such as being valid/invalid or dirty/pristine.
>, <Line: +	 *
>, <Line: +	 * Each {@link ng.directive:form form} directive creates an instance
>, <Line: +	 * of `FormController`.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +//asks for $scope to fool the BC controller module
>, <Line: +	FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
>, <Line: +	function FormController(element, attrs, $scope, $animate, $interpolate) {
>, <Line: +		var form = this,
>, <Line: +			controls = [];
>, <Line: +		var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
>, <Line: +		// init state
>, <Line: +		form.$error = {};
>, <Line: +		form.$$success = {};
>, <Line: +		form.$pending = undefined;
>, <Line: +		form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
>, <Line: +		form.$dirty = false;
>, <Line: +		form.$pristine = true;
>, <Line: +		form.$valid = true;
>, <Line: +		form.$invalid = false;
>, <Line: +		form.$submitted = false;
>, <Line: +		parentForm.$addControl(form);
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$rollbackViewValue
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Rollback all form controls pending updates to the `$modelValue`.
>, <Line: +		 *
>, <Line: +		 * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: +		 * event defined in `ng-model-options`. This method is typically needed by the reset button of
>, <Line: +		 * a form that uses `ng-model-options` to pend updates.
>, <Line: +		 */
>, <Line: +		form.$rollbackViewValue = function () {
>, <Line: +			forEach(controls, function (control) {
>, <Line: +				control.$rollbackViewValue();
>, <Line: +			});
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$commitViewValue
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Commit all form controls pending updates to the `$modelValue`.
>, <Line: +		 *
>, <Line: +		 * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: +		 * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
>, <Line: +		 * usually handles calling this in response to input events.
>, <Line: +		 */
>, <Line: +		form.$commitViewValue = function () {
>, <Line: +			forEach(controls, function (control) {
>, <Line: +				control.$commitViewValue();
>, <Line: +			});
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$addControl
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Register a control with the form.
>, <Line: +		 *
>, <Line: +		 * Input elements using ngModelController do this automatically when they are linked.
>, <Line: +		 */
>, <Line: +		form.$addControl = function (control) {
>, <Line: +			// Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
>, <Line: +			// and not added to the scope.  Now we throw an error.
>, <Line: +			assertNotHasOwnProperty(control.$name, 'input');
>, <Line: +			controls.push(control);
>, <Line: +			if (control.$name) {
>, <Line: +				form[control.$name] = control;
>, <Line: +			}
>, <Line: +		};
>, <Line: +		// Private API: rename a form control
>, <Line: +		form.$$renameControl = function (control, newName) {
>, <Line: +			var oldName = control.$name;
>, <Line: +			if (form[oldName] === control) {
>, <Line: +				delete form[oldName];
>, <Line: +			}
>, <Line: +			form[newName] = control;
>, <Line: +			control.$name = newName;
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$removeControl
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Deregister a control from the form.
>, <Line: +		 *
>, <Line: +		 * Input elements using ngModelController do this automatically when they are destroyed.
>, <Line: +		 */
>, <Line: +		form.$removeControl = function (control) {
>, <Line: +			if (control.$name && form[control.$name] === control) {
>, <Line: +				delete form[control.$name];
>, <Line: +			}
>, <Line: +			forEach(form.$pending, function (value, name) {
>, <Line: +				form.$setValidity(name, null, control);
>, <Line: +			});
>, <Line: +			forEach(form.$error, function (value, name) {
>, <Line: +				form.$setValidity(name, null, control);
>, <Line: +			});
>, <Line: +			arrayRemove(controls, control);
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$setValidity
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the validity of a form control.
>, <Line: +		 *
>, <Line: +		 * This method will also propagate to parent forms.
>, <Line: +		 */
>, <Line: +		addSetValidityMethod({
>, <Line: +			ctrl: this,
>, <Line: +			$element: element,
>, <Line: +			set: function (object, property, control) {
>, <Line: +				var list = object[property];
>, <Line: +				if (!list) {
>, <Line: +					object[property] = [control];
>, <Line: +				} else {
>, <Line: +					var index = list.indexOf(control);
>, <Line: +					if (index === -1) {
>, <Line: +						list.push(control);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			},
>, <Line: +			unset: function (object, property, control) {
>, <Line: +				var list = object[property];
>, <Line: +				if (!list) {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				arrayRemove(list, control);
>, <Line: +				if (list.length === 0) {
>, <Line: +					delete object[property];
>, <Line: +				}
>, <Line: +			},
>, <Line: +			parentForm: parentForm,
>, <Line: +			$animate: $animate
>, <Line: +		});
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$setDirty
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the form to a dirty state.
>, <Line: +		 *
>, <Line: +		 * This method can be called to add the 'ng-dirty' class and set the form to a dirty
>, <Line: +		 * state (ng-dirty class). This method will also propagate to parent forms.
>, <Line: +		 */
>, <Line: +		form.$setDirty = function () {
>, <Line: +			$animate.removeClass(element, PRISTINE_CLASS);
>, <Line: +			$animate.addClass(element, DIRTY_CLASS);
>, <Line: +			form.$dirty = true;
>, <Line: +			form.$pristine = false;
>, <Line: +			parentForm.$setDirty();
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$setPristine
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the form to its pristine state.
>, <Line: +		 *
>, <Line: +		 * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
>, <Line: +		 * state (ng-pristine class). This method will also propagate to all the controls contained
>, <Line: +		 * in this form.
>, <Line: +		 *
>, <Line: +		 * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
>, <Line: +		 * saving or resetting it.
>, <Line: +		 */
>, <Line: +		form.$setPristine = function () {
>, <Line: +			$animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
>, <Line: +			form.$dirty = false;
>, <Line: +			form.$pristine = true;
>, <Line: +			form.$submitted = false;
>, <Line: +			forEach(controls, function (control) {
>, <Line: +				control.$setPristine();
>, <Line: +			});
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$setUntouched
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the form to its untouched state.
>, <Line: +		 *
>, <Line: +		 * This method can be called to remove the 'ng-touched' class and set the form controls to their
>, <Line: +		 * untouched state (ng-untouched class).
>, <Line: +		 *
>, <Line: +		 * Setting a form controls back to their untouched state is often useful when setting the form
>, <Line: +		 * back to its pristine state.
>, <Line: +		 */
>, <Line: +		form.$setUntouched = function () {
>, <Line: +			forEach(controls, function (control) {
>, <Line: +				control.$setUntouched();
>, <Line: +			});
>, <Line: +		};
>, <Line: +		/**
>, <Line: +		 * @ngdoc method
>, <Line: +		 * @name form.FormController#$setSubmitted
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Sets the form to its submitted state.
>, <Line: +		 */
>, <Line: +		form.$setSubmitted = function () {
>, <Line: +			$animate.addClass(element, SUBMITTED_CLASS);
>, <Line: +			form.$submitted = true;
>, <Line: +			parentForm.$setSubmitted();
>, <Line: +		};
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngForm
>, <Line: +	 * @restrict EAC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Nestable alias of {@link ng.directive:form `form`} directive. HTML
>, <Line: +	 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
>, <Line: +	 * sub-group of controls needs to be determined.
>, <Line: +	 *
>, <Line: +	 * Note: the purpose of `ngForm` is to group controls,
>, <Line: +	 * but not to be a replacement for the `<form>` tag with all of its capabilities
>, <Line: +	 * (e.g. posting to the server, ...).
>, <Line: +	 *
>, <Line: +	 * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into
>, <Line: +	 *                       related scope, under this name.
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name form
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Directive that instantiates
>, <Line: +	 * {@link form.FormController FormController}.
>, <Line: +	 *
>, <Line: +	 * If the `name` attribute is specified, the form controller is published onto the current scope under
>, <Line: +	 * this name.
>, <Line: +	 *
>, <Line: +	 * # Alias: {@link ng.directive:ngForm `ngForm`}
>, <Line: +	 *
>, <Line: +	 * In Angular forms can be nested. This means that the outer form is valid when all of the child
>, <Line: +	 * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
>, <Line: +	 * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to
>, <Line: +	 * `<form>` but can be nested.  This allows you to have nested forms, which is very useful when
>, <Line: +	 * using Angular validation directives in forms that are dynamically generated using the
>, <Line: +	 * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`
>, <Line: +	 * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
>, <Line: +	 * `ngForm` directive and nest these in an outer `form` element.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # CSS classes
>, <Line: +	 *  - `ng-valid` is set if the form is valid.
>, <Line: +	 *  - `ng-invalid` is set if the form is invalid.
>, <Line: +	 *  - `ng-pristine` is set if the form is pristine.
>, <Line: +	 *  - `ng-dirty` is set if the form is dirty.
>, <Line: +	 *  - `ng-submitted` is set if the form was submitted.
>, <Line: +	 *
>, <Line: +	 * Keep in mind that ngAnimate can detect each of these classes when added and removed.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * # Submitting a form and preventing the default action
>, <Line: +	 *
>, <Line: +	 * Since the role of forms in client-side Angular applications is different than in classical
>, <Line: +	 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
>, <Line: +	 * page reload that sends the data to the server. Instead some javascript logic should be triggered
>, <Line: +	 * to handle the form submission in an application-specific way.
>, <Line: +	 *
>, <Line: +	 * For this reason, Angular prevents the default action (form submission to the server) unless the
>, <Line: +	 * `<form>` element has an `action` attribute specified.
>, <Line: +	 *
>, <Line: +	 * You can use one of the following two ways to specify what javascript method should be called when
>, <Line: +	 * a form is submitted:
>, <Line: +	 *
>, <Line: +	 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
>, <Line: +	 * - {@link ng.directive:ngClick ngClick} directive on the first
>, <Line: +	 *  button or input field of type submit (input[type=submit])
>, <Line: +	 *
>, <Line: +	 * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
>, <Line: +	 * or {@link ng.directive:ngClick ngClick} directives.
>, <Line: +	 * This is because of the following form submission rules in the HTML specification:
>, <Line: +	 *
>, <Line: +	 * - If a form has only one input field then hitting enter in this field triggers form submit
>, <Line: +	 * (`ngSubmit`)
>, <Line: +	 * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
>, <Line: +	 * doesn't trigger submit
>, <Line: +	 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
>, <Line: +	 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
>, <Line: +	 * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
>, <Line: +	 *
>, <Line: +	 * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
>, <Line: +	 * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
>, <Line: +	 * to have access to the updated model.
>, <Line: +	 *
>, <Line: +	 * ## Animation Hooks
>, <Line: +	 *
>, <Line: +	 * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.
>, <Line: +	 * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any
>, <Line: +	 * other validations that are performed within the form. Animations in ngForm are similar to how
>, <Line: +	 * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well
>, <Line: +	 * as JS animations.
>, <Line: +	 *
>, <Line: +	 * The following example shows a simple way to utilize CSS transitions to style a form element
>, <Line: +	 * that has been rendered as invalid after it has been validated:
>, <Line: +	 *
>, <Line: +	 * <pre>
>, <Line: +	 * //be sure to include ngAnimate as a module to hook into more
>, <Line: +	 * //advanced animations
>, <Line: +	 * .my-form {
>, <Line: +	 * .my-form.ng-invalid {
>, <Line: +	 * </pre>
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example deps="angular-animate.js" animations="true" fixBase="true" module="formExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('formExample', [])
>, <Line: +	 .controller('FormController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <style>
>, <Line: +	 .my-form {
>, <Line: +	 .my-form.ng-invalid {
>, <Line: +	 </style>
>, <Line: +	 <form name="myForm" ng-controller="FormController" class="my-form">
>, <Line: +	 userType: <input name="input" ng-model="userType" required>
>, <Line: +	 <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
>, <Line: +	 <tt>userType = {{userType}}</tt><br>
>, <Line: +	 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
>, <Line: +	 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
>, <Line: +	 <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
>, <Line: +	 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
>, <Line: +	 </form>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should initialize to model', function() {
>, <Line: +	 it('should be invalid if empty', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 * @param {string=} name Name of the form. If specified, the form controller will be published into
>, <Line: +	 *                       related scope, under this name.
>, <Line: +	 */
>, <Line: +	var formDirectiveFactory = function (isNgForm) {
>, <Line: +		return ['$timeout', function ($timeout) {
>, <Line: +			var formDirective = {
>, <Line: +				name: 'form',
>, <Line: +				restrict: isNgForm ? 'EAC' : 'E',
>, <Line: +				controller: FormController,
>, <Line: +				compile: function ngFormCompile(formElement) {
>, <Line: +					// Setup initial state of the control
>, <Line: +					formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
>, <Line: +					return {
>, <Line: +						pre: function ngFormPreLink(scope, formElement, attr, controller) {
>, <Line: +							// if `action` attr is not present on the form, prevent the default action (submission)
>, <Line: +							if (!('action' in attr)) {
>, <Line: +								// we can't use jq events because if a form is destroyed during submission the default
>, <Line: +								// action is not prevented. see #1238
>, <Line: +								//
>, <Line: +								// IE 9 is not affected because it doesn't fire a submit event and try to do a full
>, <Line: +								// page reload if the form was destroyed by submission of the form via a click handler
>, <Line: +								// on a button in the form. Looks like an IE9 specific bug.
>, <Line: +								var handleFormSubmission = function (event) {
>, <Line: +									scope.$apply(function () {
>, <Line: +										controller.$commitViewValue();
>, <Line: +										controller.$setSubmitted();
>, <Line: +									});
>, <Line: +									event.preventDefault();
>, <Line: +								};
>, <Line: +								addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
>, <Line: +								// unregister the preventDefault listener so that we don't not leak memory but in a
>, <Line: +								// way that will achieve the prevention of the default action.
>, <Line: +								formElement.on('$destroy', function () {
>, <Line: +									$timeout(function () {
>, <Line: +										removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
>, <Line: +									}, 0, false);
>, <Line: +								});
>, <Line: +							}
>, <Line: +							var parentFormCtrl = controller.$$parentForm,
>, <Line: +								alias = controller.$name;
>, <Line: +							if (alias) {
>, <Line: +								setter(scope, alias, controller, alias);
>, <Line: +								attr.$observe(attr.name ? 'name' : 'ngForm', function (newValue) {
>, <Line: +									if (alias === newValue) return;
>, <Line: +									setter(scope, alias, undefined, alias);
>, <Line: +									alias = newValue;
>, <Line: +									setter(scope, alias, controller, alias);
>, <Line: +									parentFormCtrl.$$renameControl(controller, alias);
>, <Line: +								});
>, <Line: +							}
>, <Line: +							formElement.on('$destroy', function () {
>, <Line: +								parentFormCtrl.$removeControl(controller);
>, <Line: +								if (alias) {
>, <Line: +									setter(scope, alias, undefined, alias);
>, <Line: +								}
>, <Line: +								extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
>, <Line: +							});
>, <Line: +						}
>, <Line: +					};
>, <Line: +				}
>, <Line: +			};
>, <Line: +			return formDirective;
>, <Line: +		}];
>, <Line: +	};
>, <Line: +	var formDirective = formDirectiveFactory();
>, <Line: +	var ngFormDirective = formDirectiveFactory(true);
>, <Line: +	/* global VALID_CLASS: true,
>, <Line: +	 INVALID_CLASS: true,
>, <Line: +	 PRISTINE_CLASS: true,
>, <Line: +	 DIRTY_CLASS: true,
>, <Line: +	 UNTOUCHED_CLASS: true,
>, <Line: +	 TOUCHED_CLASS: true,
>, <Line: +	 */
>, <Line: +	var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
>, <Line: +	var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
>, <Line: +	var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
>, <Line: +	var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
>, <Line: +	var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
>, <Line: +	var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
>, <Line: +	var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
>, <Line: +	var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
>, <Line: +	var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
>, <Line: +	var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
>, <Line: +	var $ngModelMinErr = new minErr('ngModel');
>, <Line: +	var inputType = {
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[text]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Standard HTML text input with angular data binding, inherited by most of the `input` elements.
>, <Line: +		 *
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} required Adds `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +		 *    minlength.
>, <Line: +		 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +		 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: +		 *    any length.
>, <Line: +		 * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: +		 *    that contains the regular expression body that will be converted to a regular expression
>, <Line: +		 *    as in the ngPattern directive.
>, <Line: +		 * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: +		 *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: +		 *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: +		 *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: +		 *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: +		 *    This parameter is ignored for input[type=password] controls, which will never trim the
>, <Line: +		 *    input.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="text-input-directive" module="textInputExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('textInputExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 Single word: <input type="text" name="input" ng-model="text"
>, <Line: +		 ng-pattern="word" required ng-trim="false">
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.pattern">
>, <Line: +		 Single word only!</span>
>, <Line: +		 <tt>text = {{text}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var text = element(by.binding('text'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('text'));
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if multi word', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'text': textInputType,
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[date]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Input with date validation and transformation. In browsers that do not yet support
>, <Line: +		 * the HTML5 date input, a text element will be used. In that case, text must be entered in a valid ISO-8601
>, <Line: +		 * date format (yyyy-MM-dd), for example: `2009-01-06`. Since many
>, <Line: +		 * modern browsers do not yet support this input type, it is important to provide cues to users on the
>, <Line: +		 * expected input format via a placeholder or label.
>, <Line: +		 *
>, <Line: +		 * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: +		 * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: +		 *
>, <Line: +		 * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: +		 * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: +		 * valid ISO date string (yyyy-MM-dd).
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: +		 * a valid ISO date string (yyyy-MM-dd).
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="date-input-directive" module="dateInputExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('dateInputExample', [])
>, <Line: +		 .controller('DateController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: +		 Pick a date in 2013:
>, <Line: +		 <input type="date" id="exampleInput" name="input" ng-model="value"
>, <Line: +		 placeholder="yyyy-MM-dd" min="2013-01-01" max="2013-12-31" required />
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.date">
>, <Line: +		 Not a valid date!</span>
>, <Line: +		 <tt>value = {{value | date: "yyyy-MM-dd"}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value | date: "yyyy-MM-dd"'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 // currently protractor/webdriver does not support
>, <Line: +		 // sending keys to all known HTML5 input controls
>, <Line: +		 // for various browsers (see https://github.com/angular/protractor/issues/562).
>, <Line: +		 function setInput(val) {
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'date': createDateInputType('date', DATE_REGEXP,
>, <Line: +			createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),
>, <Line: +			'yyyy-MM-dd'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[datetime-local]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Input with datetime validation and transformation. In browsers that do not yet support
>, <Line: +		 * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: +		 * local datetime format (yyyy-MM-ddTHH:mm:ss), for example: `2010-12-28T14:57:00`.
>, <Line: +		 *
>, <Line: +		 * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: +		 * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: +		 *
>, <Line: +		 * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: +		 * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: +		 * valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: +		 * a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="datetimelocal-input-directive" module="dateExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('dateExample', [])
>, <Line: +		 .controller('DateController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: +		 Pick a date between in 2013:
>, <Line: +		 <input type="datetime-local" id="exampleInput" name="input" ng-model="value"
>, <Line: +		 placeholder="yyyy-MM-ddTHH:mm:ss" min="2001-01-01T00:00:00" max="2013-12-31T00:00:00" required />
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.datetimelocal">
>, <Line: +		 Not a valid date!</span>
>, <Line: +		 <tt>value = {{value | date: "yyyy-MM-ddTHH:mm:ss"}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value | date: "yyyy-MM-ddTHH:mm:ss"'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 // currently protractor/webdriver does not support
>, <Line: +		 // sending keys to all known HTML5 input controls
>, <Line: +		 // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: +		 function setInput(val) {
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP,
>, <Line: +			createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']),
>, <Line: +			'yyyy-MM-ddTHH:mm:ss.sss'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[time]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Input with time validation and transformation. In browsers that do not yet support
>, <Line: +		 * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: +		 * local time format (HH:mm:ss), for example: `14:57:00`. Model must be a Date object. This binding will always output a
>, <Line: +		 * Date object to the model of January 1, 1970, or local date `new Date(1970, 0, 1, HH, mm, ss)`.
>, <Line: +		 *
>, <Line: +		 * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: +		 * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: +		 *
>, <Line: +		 * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: +		 * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: +		 * valid ISO time format (HH:mm:ss).
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be a
>, <Line: +		 * valid ISO time format (HH:mm:ss).
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="time-input-directive" module="timeExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('timeExample', [])
>, <Line: +		 .controller('DateController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: +		 Pick a between 8am and 5pm:
>, <Line: +		 <input type="time" id="exampleInput" name="input" ng-model="value"
>, <Line: +		 placeholder="HH:mm:ss" min="08:00:00" max="17:00:00" required />
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.time">
>, <Line: +		 Not a valid date!</span>
>, <Line: +		 <tt>value = {{value | date: "HH:mm:ss"}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value | date: "HH:mm:ss"'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 // currently protractor/webdriver does not support
>, <Line: +		 // sending keys to all known HTML5 input controls
>, <Line: +		 // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: +		 function setInput(val) {
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'time': createDateInputType('time', TIME_REGEXP,
>, <Line: +			createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),
>, <Line: +			'HH:mm:ss.sss'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[week]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Input with week-of-the-year validation and transformation to Date. In browsers that do not yet support
>, <Line: +		 * the HTML5 week input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: +		 * week format (yyyy-W##), for example: `2013-W02`.
>, <Line: +		 *
>, <Line: +		 * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: +		 * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: +		 *
>, <Line: +		 * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: +		 * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: +		 * valid ISO week format (yyyy-W##).
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: +		 * a valid ISO week format (yyyy-W##).
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="week-input-directive" module="weekExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('weekExample', [])
>, <Line: +		 .controller('DateController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: +		 Pick a date between in 2013:
>, <Line: +		 <input id="exampleInput" type="week" name="input" ng-model="value"
>, <Line: +		 placeholder="YYYY-W##" min="2012-W32" max="2013-W52" required />
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.week">
>, <Line: +		 Not a valid date!</span>
>, <Line: +		 <tt>value = {{value | date: "yyyy-Www"}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value | date: "yyyy-Www"'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 // currently protractor/webdriver does not support
>, <Line: +		 // sending keys to all known HTML5 input controls
>, <Line: +		 // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: +		 function setInput(val) {
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[month]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Input with month validation and transformation. In browsers that do not yet support
>, <Line: +		 * the HTML5 month input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: +		 * month format (yyyy-MM), for example: `2009-01`.
>, <Line: +		 *
>, <Line: +		 * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: +		 * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: +		 * If the model is not set to the first of the month, the next view to model update will set it
>, <Line: +		 * to the first of the month.
>, <Line: +		 *
>, <Line: +		 * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: +		 * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be
>, <Line: +		 * a valid ISO month format (yyyy-MM).
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must
>, <Line: +		 * be a valid ISO month format (yyyy-MM).
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="month-input-directive" module="monthExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('monthExample', [])
>, <Line: +		 .controller('DateController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: +		 Pick a month int 2013:
>, <Line: +		 <input id="exampleInput" type="month" name="input" ng-model="value"
>, <Line: +		 placeholder="yyyy-MM" min="2013-01" max="2013-12" required />
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.month">
>, <Line: +		 Not a valid month!</span>
>, <Line: +		 <tt>value = {{value | date: "yyyy-MM"}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value | date: "yyyy-MM"'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 // currently protractor/webdriver does not support
>, <Line: +		 // sending keys to all known HTML5 input controls
>, <Line: +		 // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: +		 function setInput(val) {
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'month': createDateInputType('month', MONTH_REGEXP,
>, <Line: +			createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),
>, <Line: +			'yyyy-MM'),
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[number]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Text input with number validation and transformation. Sets the `number` validation
>, <Line: +		 * error if not a valid number.
>, <Line: +		 *
>, <Line: +		 * The model must always be a number, otherwise Angular will throw an error.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
>, <Line: +		 * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +		 *    minlength.
>, <Line: +		 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +		 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: +		 *    any length.
>, <Line: +		 * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: +		 *    that contains the regular expression body that will be converted to a regular expression
>, <Line: +		 *    as in the ngPattern directive.
>, <Line: +		 * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: +		 *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: +		 *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: +		 *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: +		 *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="number-input-directive" module="numberExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('numberExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 Number: <input type="number" name="input" ng-model="value"
>, <Line: +		 min="0" max="99" required>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.number">
>, <Line: +		 Not valid number!</span>
>, <Line: +		 <tt>value = {{value}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var value = element(by.binding('value'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('value'));
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if over max', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'number': numberInputType,
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[url]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Text input with URL validation. Sets the `url` validation error key if the content is not a
>, <Line: +		 * valid URL.
>, <Line: +		 *
>, <Line: +		 * <div class="alert alert-warning">
>, <Line: +		 * **Note:** `input[url]` uses a regex to validate urls that is derived from the regex
>, <Line: +		 * used in Chromium. If you need stricter validation, you can use `ng-pattern` or modify
>, <Line: +		 * the built-in validators (see the {@link guide/forms Forms guide})
>, <Line: +		 * </div>
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +		 *    minlength.
>, <Line: +		 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +		 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: +		 *    any length.
>, <Line: +		 * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: +		 *    that contains the regular expression body that will be converted to a regular expression
>, <Line: +		 *    as in the ngPattern directive.
>, <Line: +		 * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: +		 *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: +		 *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: +		 *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: +		 *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="url-input-directive" module="urlExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('urlExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 URL: <input type="url" name="input" ng-model="text" required>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.url">
>, <Line: +		 Not valid url!</span>
>, <Line: +		 <tt>text = {{text}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var text = element(by.binding('text'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('text'));
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +		 it('should be invalid if not url', function() {
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'url': urlInputType,
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[email]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * Text input with email validation. Sets the `email` validation error key if not a valid email
>, <Line: +		 * address.
>, <Line: +		 *
>, <Line: +		 * <div class="alert alert-warning">
>, <Line: +		 * **Note:** `input[email]` uses a regex to validate email addresses that is derived from the regex
>, <Line: +		 * used in Chromium. If you need stricter validation (e.g. requiring a top-level domain), you can
>, <Line: +		 * use `ng-pattern` or modify the built-in validators (see the {@link guide/forms Forms guide})
>, <Line: +		 * </div>
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +		 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +		 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +		 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +		 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +		 *    minlength.
>, <Line: +		 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +		 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: +		 *    any length.
>, <Line: +		 * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: +		 *    that contains the regular expression body that will be converted to a regular expression
>, <Line: +		 *    as in the ngPattern directive.
>, <Line: +		 * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: +		 *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: +		 *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: +		 *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: +		 *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="email-input-directive" module="emailExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('emailExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 Email: <input type="email" name="input" ng-model="text" required>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.required">
>, <Line: +		 Required!</span>
>, <Line: +		 <span class="error" ng-show="myForm.input.$error.email">
>, <Line: +		 Not valid email!</span>
>, <Line: +		 <tt>text = {{text}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: +		 <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +		 <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 var text = element(by.binding('text'));
>, <Line: +		 var valid = element(by.binding('myForm.input.$valid'));
>, <Line: +		 var input = element(by.model('text'));
>, <Line: +		 it('should initialize to model', function() {
>, <Line: +		 it('should be invalid if empty', function() {
>, <Line: +            expect(text.getText()).toEqual('text =');
>, <Line: +            expect(valid.getText()).toContain('false');
>, <Line: +          });
>, <Line: +		 it('should be invalid if not email', function() {
>, <Line: +            input.clear();
>, <Line: +            input.sendKeys('xxx');
>, <Line: +            expect(valid.getText()).toContain('false');
>, <Line: +          });
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'email': emailInputType,
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[radio]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * HTML radio button.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string} value The value to which the expression should be set when selected.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 * @param {string} ngValue Angular expression which sets the value to which the expression should
>, <Line: +		 *    be set when selected.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="radio-input-directive" module="radioExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('radioExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +               $scope.color = 'blue';
>, <Line: +               $scope.specialValue = {
>, <Line: +                 "id": "12345",
>, <Line: +                 "value": "green"
>, <Line: +               };
>, <Line: +             }]);
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 <input type="radio" ng-model="color" value="red">  Red <br/>
>, <Line: +		 <input type="radio" ng-model="color" ng-value="specialValue"> Green <br/>
>, <Line: +		 <input type="radio" ng-model="color" value="blue"> Blue <br/>
>, <Line: +		 <tt>color = {{color | json}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 Note that `ng-value="specialValue"` sets radio item's value to be the value of `$scope.specialValue`.
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 it('should change state', function() {
>, <Line: +            var color = element(by.binding('color'));
>, <Line: +            expect(color.getText()).toContain('blue');
>, <Line: +            element.all(by.model('color')).get(0).click();
>, <Line: +            expect(color.getText()).toContain('red');
>, <Line: +          });
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'radio': radioInputType,
>, <Line: +		/**
>, <Line: +		 * @ngdoc input
>, <Line: +		 * @name input[checkbox]
>, <Line: +		 *
>, <Line: +		 * @description
>, <Line: +		 * HTML checkbox.
>, <Line: +		 *
>, <Line: +		 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +		 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +		 * @param {expression=} ngTrueValue The value to which the expression should be set when selected.
>, <Line: +		 * @param {expression=} ngFalseValue The value to which the expression should be set when not selected.
>, <Line: +		 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +		 *    interaction with the input element.
>, <Line: +		 *
>, <Line: +		 * @example
>, <Line: +		 <example name="checkbox-input-directive" module="checkboxExample">
>, <Line: +		 <file name="index.html">
>, <Line: +		 <script>
>, <Line: +		 angular.module('checkboxExample', [])
>, <Line: +		 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +               $scope.value1 = true;
>, <Line: +               $scope.value2 = 'YES'
>, <Line: +             }]);
>, <Line: +		 </script>
>, <Line: +		 <form name="myForm" ng-controller="ExampleController">
>, <Line: +		 Value1: <input type="checkbox" ng-model="value1"> <br/>
>, <Line: +		 Value2: <input type="checkbox" ng-model="value2"
>, <Line: +		 ng-true-value="'YES'" ng-false-value="'NO'"> <br/>
>, <Line: +		 <tt>value1 = {{value1}}</tt><br/>
>, <Line: +		 <tt>value2 = {{value2}}</tt><br/>
>, <Line: +		 </form>
>, <Line: +		 </file>
>, <Line: +		 <file name="protractor.js" type="protractor">
>, <Line: +		 it('should change state', function() {
>, <Line: +            var value1 = element(by.binding('value1'));
>, <Line: +            var value2 = element(by.binding('value2'));
>, <Line: +            expect(value1.getText()).toContain('true');
>, <Line: +            expect(value2.getText()).toContain('YES');
>, <Line: +            element(by.model('value1')).click();
>, <Line: +            element(by.model('value2')).click();
>, <Line: +            expect(value1.getText()).toContain('false');
>, <Line: +            expect(value2.getText()).toContain('NO');
>, <Line: +          });
>, <Line: +		 </file>
>, <Line: +		 </example>
>, <Line: +		 */
>, <Line: +		'checkbox': checkboxInputType,
>, <Line: +		'hidden': noop,
>, <Line: +		'button': noop,
>, <Line: +		'submit': noop,
>, <Line: +		'reset': noop,
>, <Line: +		'file': noop
>, <Line: +	};
>, <Line: +	function stringBasedInputType(ctrl) {
>, <Line: +		ctrl.$formatters.push(function (value) {
>, <Line: +			return ctrl.$isEmpty(value) ? value : value.toString();
>, <Line: +		});
>, <Line: +	}
>, <Line: +	function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: +		baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: +		stringBasedInputType(ctrl);
>, <Line: +	}
>, <Line: +	function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: +		var placeholder = element[0].placeholder, noevent = {};
>, <Line: +		var type = lowercase(element[0].type);
>, <Line: +		// In composition mode, users are still inputing intermediate text buffer,
>, <Line: +		// hold the listener until composition is done.
>, <Line: +		// More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
>, <Line: +		if (!$sniffer.android) {
>, <Line: +			var composing = false;
>, <Line: +			element.on('compositionstart', function (data) {
>, <Line: +				composing = true;
>, <Line: +			});
>, <Line: +			element.on('compositionend', function () {
>, <Line: +				composing = false;
>, <Line: +				listener();
>, <Line: +			});
>, <Line: +		}
>, <Line: +		var listener = function (ev) {
>, <Line: +			if (composing) return;
>, <Line: +			var value = element.val(),
>, <Line: +				event = ev && ev.type;
>, <Line: +			// IE (11 and under) seem to emit an 'input' event if the placeholder value changes.
>, <Line: +			// We don't want to dirty the value when this happens, so we abort here. Unfortunately,
>, <Line: +			// IE also sends input events for other non-input-related things, (such as focusing on a
>, <Line: +			// form control), so this change is not entirely enough to solve this.
>, <Line: +			if (msie && (ev || noevent).type === 'input' && element[0].placeholder !== placeholder) {
>, <Line: +				placeholder = element[0].placeholder;
>, <Line: +				return;
>, <Line: +			}
>, <Line: +			// By default we will trim the value
>, <Line: +			// If the attribute ng-trim exists we will avoid trimming
>, <Line: +			// If input type is 'password', the value is never trimmed
>, <Line: +			if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
>, <Line: +				value = trim(value);
>, <Line: +			}
>, <Line: +			// If a control is suffering from bad input (due to native validators), browsers discard its
>, <Line: +			// value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
>, <Line: +			// control's value is the same empty value twice in a row.
>, <Line: +			if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
>, <Line: +				ctrl.$setViewValue(value, event);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		// if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
>, <Line: +		// input event on backspace, delete or cut
>, <Line: +		if ($sniffer.hasEvent('input')) {
>, <Line: +			element.on('input', listener);
>, <Line: +		} else {
>, <Line: +			var timeout;
>, <Line: +			var deferListener = function (ev) {
>, <Line: +				if (!timeout) {
>, <Line: +					timeout = $browser.defer(function () {
>, <Line: +						listener(ev);
>, <Line: +						timeout = null;
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +			element.on('keydown', function (event) {
>, <Line: +				var key = event.keyCode;
>, <Line: +				// ignore
>, <Line: +				//    command            modifiers                   arrows
>, <Line: +				if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;
>, <Line: +				deferListener(event);
>, <Line: +			});
>, <Line: +			// if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
>, <Line: +			if ($sniffer.hasEvent('paste')) {
>, <Line: +				element.on('paste cut', deferListener);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		// if user paste into input using mouse on older browser
>, <Line: +		// or form autocomplete on newer browser, we need "change" event to catch it
>, <Line: +		element.on('change', listener);
>, <Line: +		ctrl.$render = function () {
>, <Line: +			element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function weekParser(isoWeek, existingDate) {
>, <Line: +		if (isDate(isoWeek)) {
>, <Line: +			return isoWeek;
>, <Line: +		}
>, <Line: +		if (isString(isoWeek)) {
>, <Line: +			WEEK_REGEXP.lastIndex = 0;
>, <Line: +			var parts = WEEK_REGEXP.exec(isoWeek);
>, <Line: +			if (parts) {
>, <Line: +				var year = +parts[1],
>, <Line: +					week = +parts[2],
>, <Line: +					hours = 0,
>, <Line: +					minutes = 0,
>, <Line: +					seconds = 0,
>, <Line: +					milliseconds = 0,
>, <Line: +					firstThurs = getFirstThursdayOfYear(year),
>, <Line: +					addDays = (week - 1) * 7;
>, <Line: +				if (existingDate) {
>, <Line: +					hours = existingDate.getHours();
>, <Line: +					minutes = existingDate.getMinutes();
>, <Line: +					seconds = existingDate.getSeconds();
>, <Line: +					milliseconds = existingDate.getMilliseconds();
>, <Line: +				}
>, <Line: +				return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return NaN;
>, <Line: +	}
>, <Line: +	function createDateParser(regexp, mapping) {
>, <Line: +		return function (iso, date) {
>, <Line: +			var parts, map;
>, <Line: +			if (isDate(iso)) {
>, <Line: +				return iso;
>, <Line: +			}
>, <Line: +			if (isString(iso)) {
>, <Line: +				// When a date is JSON'ified to wraps itself inside of an extra
>, <Line: +				// set of double quotes. This makes the date parsing code unable
>, <Line: +				// to match the date string and parse it as a date.
>, <Line: +				if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
>, <Line: +					iso = iso.substring(1, iso.length - 1);
>, <Line: +				}
>, <Line: +				if (ISO_DATE_REGEXP.test(iso)) {
>, <Line: +					return new Date(iso);
>, <Line: +				}
>, <Line: +				regexp.lastIndex = 0;
>, <Line: +				parts = regexp.exec(iso);
>, <Line: +				if (parts) {
>, <Line: +					parts.shift();
>, <Line: +					if (date) {
>, <Line: +						map = {
>, <Line: +							yyyy: date.getFullYear(),
>, <Line: +							MM: date.getMonth() + 1,
>, <Line: +							dd: date.getDate(),
>, <Line: +							HH: date.getHours(),
>, <Line: +							mm: date.getMinutes(),
>, <Line: +							ss: date.getSeconds(),
>, <Line: +							sss: date.getMilliseconds() / 1000
>, <Line: +						};
>, <Line: +					} else {
>, <Line: +						map = {
>, <Line: +							yyyy: 1970,
>, <Line: +							MM: 1,
>, <Line: +							dd: 1,
>, <Line: +							HH: 0,
>, <Line: +							mm: 0,
>, <Line: +							ss: 0,
>, <Line: +							sss: 0
>, <Line: +						};
>, <Line: +					}
>, <Line: +					forEach(parts, function (part, index) {
>, <Line: +						if (index < mapping.length) {
>, <Line: +							map[mapping[index]] = +part;
>, <Line: +						}
>, <Line: +					});
>, <Line: +					return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			return NaN;
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function createDateInputType(type, regexp, parseDate, format) {
>, <Line: +		return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
>, <Line: +			badInputChecker(scope, element, attr, ctrl);
>, <Line: +			baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: +			var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
>, <Line: +			var previousDate;
>, <Line: +			ctrl.$$parserName = type;
>, <Line: +			ctrl.$parsers.push(function (value) {
>, <Line: +				if (ctrl.$isEmpty(value)) return null;
>, <Line: +				if (regexp.test(value)) {
>, <Line: +					// Note: We cannot read ctrl.$modelValue, as there might be a different
>, <Line: +					// parser/formatter in the processing chain so that the model
>, <Line: +					// contains some different data format!
>, <Line: +					var parsedDate = parseDate(value, previousDate);
>, <Line: +					if (timezone === 'UTC') {
>, <Line: +						parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
>, <Line: +					}
>, <Line: +					return parsedDate;
>, <Line: +				}
>, <Line: +				return undefined;
>, <Line: +			});
>, <Line: +			ctrl.$formatters.push(function (value) {
>, <Line: +				if (value && !isDate(value)) {
>, <Line: +					throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
>, <Line: +				}
>, <Line: +				if (isValidDate(value)) {
>, <Line: +					previousDate = value;
>, <Line: +					if (previousDate && timezone === 'UTC') {
>, <Line: +						var timezoneOffset = 60000 * previousDate.getTimezoneOffset();
>, <Line: +						previousDate = new Date(previousDate.getTime() + timezoneOffset);
>, <Line: +					}
>, <Line: +					return $filter('date')(value, format, timezone);
>, <Line: +				} else {
>, <Line: +					previousDate = null;
>, <Line: +					return '';
>, <Line: +				}
>, <Line: +			});
>, <Line: +			if (isDefined(attr.min) || attr.ngMin) {
>, <Line: +				var minVal;
>, <Line: +				ctrl.$validators.min = function (value) {
>, <Line: +					return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
>, <Line: +				};
>, <Line: +				attr.$observe('min', function (val) {
>, <Line: +					minVal = parseObservedDateValue(val);
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +			}
>, <Line: +			if (isDefined(attr.max) || attr.ngMax) {
>, <Line: +				var maxVal;
>, <Line: +				ctrl.$validators.max = function (value) {
>, <Line: +					return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
>, <Line: +				};
>, <Line: +				attr.$observe('max', function (val) {
>, <Line: +					maxVal = parseObservedDateValue(val);
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +			}
>, <Line: +			function isValidDate(value) {
>, <Line: +				// Invalid Date: getTime() returns NaN
>, <Line: +				return value && !(value.getTime && value.getTime() !== value.getTime());
>, <Line: +			}
>, <Line: +			function parseObservedDateValue(val) {
>, <Line: +				return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function badInputChecker(scope, element, attr, ctrl) {
>, <Line: +		var node = element[0];
>, <Line: +		var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
>, <Line: +		if (nativeValidation) {
>, <Line: +			ctrl.$parsers.push(function (value) {
>, <Line: +				var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
>, <Line: +				// Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):
>, <Line: +				// - also sets validity.badInput (should only be validity.typeMismatch).
>, <Line: +				// - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)
>, <Line: +				// - can ignore this case as we can still read out the erroneous email...
>, <Line: +				return validity.badInput && !validity.typeMismatch ? undefined : value;
>, <Line: +			});
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: +		badInputChecker(scope, element, attr, ctrl);
>, <Line: +		baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: +		ctrl.$$parserName = 'number';
>, <Line: +		ctrl.$parsers.push(function (value) {
>, <Line: +			if (ctrl.$isEmpty(value))      return null;
>, <Line: +			if (NUMBER_REGEXP.test(value)) return parseFloat(value);
>, <Line: +			return undefined;
>, <Line: +		});
>, <Line: +		ctrl.$formatters.push(function (value) {
>, <Line: +			if (!ctrl.$isEmpty(value)) {
>, <Line: +				if (!isNumber(value)) {
>, <Line: +					throw $ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
>, <Line: +				}
>, <Line: +				value = value.toString();
>, <Line: +			}
>, <Line: +			return value;
>, <Line: +		});
>, <Line: +		if (attr.min || attr.ngMin) {
>, <Line: +			var minVal;
>, <Line: +			ctrl.$validators.min = function (value) {
>, <Line: +				return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
>, <Line: +			};
>, <Line: +			attr.$observe('min', function (val) {
>, <Line: +				if (isDefined(val) && !isNumber(val)) {
>, <Line: +					val = parseFloat(val, 10);
>, <Line: +				}
>, <Line: +				minVal = isNumber(val) && !isNaN(val) ? val : undefined;
>, <Line: +				// TODO(matsko): implement validateLater to reduce number of validations
>, <Line: +				ctrl.$validate();
>, <Line: +			});
>, <Line: +		}
>, <Line: +		if (attr.max || attr.ngMax) {
>, <Line: +			var maxVal;
>, <Line: +			ctrl.$validators.max = function (value) {
>, <Line: +				return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
>, <Line: +			};
>, <Line: +			attr.$observe('max', function (val) {
>, <Line: +				if (isDefined(val) && !isNumber(val)) {
>, <Line: +					val = parseFloat(val, 10);
>, <Line: +				}
>, <Line: +				maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
>, <Line: +				// TODO(matsko): implement validateLater to reduce number of validations
>, <Line: +				ctrl.$validate();
>, <Line: +			});
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: +		// Note: no badInputChecker here by purpose as `url` is only a validation
>, <Line: +		// in browsers, i.e. we can always read out input.value even if it is not valid!
>, <Line: +		baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: +		stringBasedInputType(ctrl);
>, <Line: +		ctrl.$$parserName = 'url';
>, <Line: +		ctrl.$validators.url = function (modelValue, viewValue) {
>, <Line: +			var value = modelValue || viewValue;
>, <Line: +			return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: +		// Note: no badInputChecker here by purpose as `url` is only a validation
>, <Line: +		// in browsers, i.e. we can always read out input.value even if it is not valid!
>, <Line: +		baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: +		stringBasedInputType(ctrl);
>, <Line: +		ctrl.$$parserName = 'email';
>, <Line: +		ctrl.$validators.email = function (modelValue, viewValue) {
>, <Line: +			var value = modelValue || viewValue;
>, <Line: +			return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
>, <Line: +		};
>, <Line: +	}
>, <Line: +	function radioInputType(scope, element, attr, ctrl) {
>, <Line: +		// make the name unique, if not defined
>, <Line: +		if (isUndefined(attr.name)) {
>, <Line: +			element.attr('name', nextUid());
>, <Line: +		}
>, <Line: +		var listener = function (ev) {
>, <Line: +			if (element[0].checked) {
>, <Line: +				ctrl.$setViewValue(attr.value, ev && ev.type);
>, <Line: +			}
>, <Line: +		};
>, <Line: +		element.on('click', listener);
>, <Line: +		ctrl.$render = function () {
>, <Line: +			var value = attr.value;
>, <Line: +			element[0].checked = (value == ctrl.$viewValue);
>, <Line: +		};
>, <Line: +		attr.$observe('value', ctrl.$render);
>, <Line: +	}
>, <Line: +	function parseConstantExpr($parse, context, name, expression, fallback) {
>, <Line: +		var parseFn;
>, <Line: +		if (isDefined(expression)) {
>, <Line: +			parseFn = $parse(expression);
>, <Line: +			if (!parseFn.constant) {
>, <Line: +				throw minErr('ngModel')('constexpr', 'Expected constant expression for `{0}`, but saw ' +
>, <Line: +					'`{1}`.', name, expression);
>, <Line: +			}
>, <Line: +			return parseFn(context);
>, <Line: +		}
>, <Line: +		return fallback;
>, <Line: +	}
>, <Line: +	function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
>, <Line: +		var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
>, <Line: +		var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
>, <Line: +		var listener = function (ev) {
>, <Line: +			ctrl.$setViewValue(element[0].checked, ev && ev.type);
>, <Line: +		};
>, <Line: +		element.on('click', listener);
>, <Line: +		ctrl.$render = function () {
>, <Line: +			element[0].checked = ctrl.$viewValue;
>, <Line: +		};
>, <Line: +		// Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
>, <Line: +		// This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
>, <Line: +		// it to a boolean.
>, <Line: +		ctrl.$isEmpty = function (value) {
>, <Line: +			return value === false;
>, <Line: +		};
>, <Line: +		ctrl.$formatters.push(function (value) {
>, <Line: +			return equals(value, trueValue);
>, <Line: +		});
>, <Line: +		ctrl.$parsers.push(function (value) {
>, <Line: +			return value ? trueValue : falseValue;
>, <Line: +		});
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name textarea
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * HTML textarea element control with angular data-binding. The data-binding and validation
>, <Line: +	 * properties of this element are exactly the same as those of the
>, <Line: +	 * {@link ng.directive:input input element}.
>, <Line: +	 *
>, <Line: +	 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +	 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +	 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +	 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +	 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +	 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +	 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +	 *    minlength.
>, <Line: +	 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +	 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
>, <Line: +	 *    length.
>, <Line: +	 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
>, <Line: +	 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
>, <Line: +	 *    patterns defined as scope expressions.
>, <Line: +	 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +	 *    interaction with the input element.
>, <Line: +	 * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name input
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * HTML input element control. When used together with {@link ngModel `ngModel`}, it provides data-binding,
>, <Line: +	 * input state control, and validation.
>, <Line: +	 * Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** Not every feature offered is available for all input types.
>, <Line: +	 * Specifically, data binding and event handling via `ng-model` is unsupported for `input[file]`.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +	 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +	 * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: +	 * @param {boolean=} ngRequired Sets `required` attribute if set to true
>, <Line: +	 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: +	 *    minlength.
>, <Line: +	 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: +	 *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
>, <Line: +	 *    length.
>, <Line: +	 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
>, <Line: +	 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
>, <Line: +	 *    patterns defined as scope expressions.
>, <Line: +	 * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: +	 *    interaction with the input element.
>, <Line: +	 * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: +	 *    This parameter is ignored for input[type=password] controls, which will never trim the
>, <Line: +	 *    input.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example name="input-directive" module="inputExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('inputExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form name="myForm">
>, <Line: +	 User name: <input type="text" name="userName" ng-model="user.name" required>
>, <Line: +	 <span class="error" ng-show="myForm.userName.$error.required">
>, <Line: +	 Required!</span><br>
>, <Line: +	 Last name: <input type="text" name="lastName" ng-model="user.last"
>, <Line: +	 ng-minlength="3" ng-maxlength="10">
>, <Line: +	 <span class="error" ng-show="myForm.lastName.$error.minlength">
>, <Line: +	 Too short!</span>
>, <Line: +	 <span class="error" ng-show="myForm.lastName.$error.maxlength">
>, <Line: +	 Too long!</span><br>
>, <Line: +	 </form>
>, <Line: +	 <hr>
>, <Line: +	 <tt>user = {{user}}</tt><br/>
>, <Line: +	 <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
>, <Line: +	 <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
>, <Line: +	 <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
>, <Line: +	 <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
>, <Line: +	 <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
>, <Line: +	 <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
>, <Line: +	 <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
>, <Line: +	 <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var user = element(by.exactBinding('user'));
>, <Line: +	 var userNameValid = element(by.binding('myForm.userName.$valid'));
>, <Line: +	 var lastNameValid = element(by.binding('myForm.lastName.$valid'));
>, <Line: +	 var lastNameError = element(by.binding('myForm.lastName.$error'));
>, <Line: +	 var formValid = element(by.binding('myForm.$valid'));
>, <Line: +	 var userNameInput = element(by.model('user.name'));
>, <Line: +	 var userLastInput = element(by.model('user.last'));
>, <Line: +	 it('should initialize to model', function() {
>, <Line: +	 it('should be invalid if empty when required', function() {
>, <Line: +	 it('should be valid if empty when min length is set', function() {
>, <Line: +	 it('should be invalid if less than required min length', function() {
>, <Line: +	 it('should be invalid if longer than max length', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
>, <Line: +		function ($browser, $sniffer, $filter, $parse) {
>, <Line: +			return {
>, <Line: +				restrict: 'E',
>, <Line: +				require: ['?ngModel'],
>, <Line: +				link: {
>, <Line: +					pre: function (scope, element, attr, ctrls) {
>, <Line: +						if (ctrls[0]) {
>, <Line: +							(inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
>, <Line: +								$browser, $filter, $parse);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	var VALID_CLASS = 'ng-valid',
>, <Line: +		INVALID_CLASS = 'ng-invalid',
>, <Line: +		PRISTINE_CLASS = 'ng-pristine',
>, <Line: +		DIRTY_CLASS = 'ng-dirty',
>, <Line: +		UNTOUCHED_CLASS = 'ng-untouched',
>, <Line: +		TOUCHED_CLASS = 'ng-touched',
>, <Line: +		PENDING_CLASS = 'ng-pending';
>, <Line: +	/**
>, <Line: +	 * @ngdoc type
>, <Line: +	 * @name ngModel.NgModelController
>, <Line: +	 *
>, <Line: +	 * @property {string} $viewValue Actual string value in the view.
>, <Line: +	 * @property {*} $modelValue The value in the model that the control is bound to.
>, <Line: +	 * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
>, <Line: +	 the control reads value from the DOM. The functions are called in array order, each passing
>, <Line: +	 its return value through to the next. The last return value is forwarded to the
>, <Line: +	 {@link ngModel.NgModelController#$validators `$validators`} collection.
>, <Line: +	 Parsers are used to sanitize / convert the {@link ngModel.NgModelController#$viewValue
>, <Line: +	 Returning `undefined` from a parser means a parse error occurred. In that case,
>, <Line: +	 no {@link ngModel.NgModelController#$validators `$validators`} will run and the `ngModel`
>, <Line: +	 will be set to `undefined` unless {@link ngModelOptions `ngModelOptions.allowInvalid`}
>, <Line: +	 is set to `true`. The parse error is stored in `ngModel.$error.parse`.
>, <Line: +	 *
>, <Line: +	 * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
>, <Line: +	 the model value changes. The functions are called in reverse array order, each passing the value through to the
>, <Line: +	 next. The last return value is used as the actual DOM value.
>, <Line: +	 Used to format / convert values for display in the control.
>, <Line: +	 * ```js
>, <Line: +	 * function formatter(value) {
>, <Line: +	 * ngModel.$formatters.push(formatter);
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @property {Object.<string, function>} $validators A collection of validators that are applied
>, <Line: +	 *      whenever the model value changes. The key value within the object refers to the name of the
>, <Line: +	 *      validator while the function refers to the validation operation. The validation operation is
>, <Line: +	 *      provided with the model value as an argument and must return a true or false value depending
>, <Line: +	 *      on the response of that validation.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * ngModel.$validators.validCharacters = function(modelValue, viewValue) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @property {Object.<string, function>} $asyncValidators A collection of validations that are expected to
>, <Line: +	 *      perform an asynchronous validation (e.g. a HTTP request). The validation function that is provided
>, <Line: +	 *      is expected to return a promise when it is run during the model validation process. Once the promise
>, <Line: +	 *      is delivered then the validation status will be set to true when fulfilled and false when rejected.
>, <Line: +	 *      When the asynchronous validators are triggered, each of the validators will run in parallel and the model
>, <Line: +	 *      value will only be updated once all validators have been fulfilled. As long as an asynchronous validator
>, <Line: +	 *      is unfulfilled, its key will be added to the controllers `$pending` property. Also, all asynchronous validators
>, <Line: +	 *      will only run once all synchronous validators have passed.
>, <Line: +	 *
>, <Line: +	 * Please note that if $http is used then it is important that the server returns a success HTTP response code
>, <Line: +	 * in order to fulfill the validation and a status level of `4xx` in order to reject the validation.
>, <Line: +	 *
>, <Line: +	 * ```js
>, <Line: +	 * ngModel.$asyncValidators.uniqueUsername = function(modelValue, viewValue) {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever the
>, <Line: +	 *     view value has changed. It is called with no arguments, and its return value is ignored.
>, <Line: +	 *     This can be used in place of additional $watches against the model value.
>, <Line: +	 *
>, <Line: +	 * @property {Object} $error An object hash with all failing validator ids as keys.
>, <Line: +	 * @property {Object} $pending An object hash with all pending validator ids as keys.
>, <Line: +	 *
>, <Line: +	 * @property {boolean} $untouched True if control has not lost focus yet.
>, <Line: +	 * @property {boolean} $touched True if control has lost focus.
>, <Line: +	 * @property {boolean} $pristine True if user has not interacted with the control yet.
>, <Line: +	 * @property {boolean} $dirty True if user has already interacted with the control.
>, <Line: +	 * @property {boolean} $valid True if there is no error.
>, <Line: +	 * @property {boolean} $invalid True if at least one error on the control.
>, <Line: +	 * @property {string} $name The name attribute of the control.
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 *
>, <Line: +	 * `NgModelController` provides API for the {@link ngModel `ngModel`} directive.
>, <Line: +	 * The controller contains services for data-binding, validation, CSS updates, and value formatting
>, <Line: +	 * and parsing. It purposefully does not contain any logic which deals with DOM rendering or
>, <Line: +	 * listening to DOM events.
>, <Line: +	 * Such DOM related logic should be provided by other directives which make use of
>, <Line: +	 * `NgModelController` for data-binding to control elements.
>, <Line: +	 * Angular provides this DOM logic for most {@link input `input`} elements.
>, <Line: +	 * At the end of this page you can find a {@link ngModel.NgModelController#custom-control-example
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * ### Custom Control Example
>, <Line: +	 * This example shows how to use `NgModelController` with a custom control to achieve
>, <Line: +	 * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
>, <Line: +	 * collaborate together to achieve the desired result.
>, <Line: +	 *
>, <Line: +	 * Note that `contenteditable` is an HTML5 attribute, which tells the browser to let the element
>, <Line: +	 * contents be edited in place by the user.  This will not work on older browsers.
>, <Line: +	 *
>, <Line: +	 * We are using the {@link ng.service:$sce $sce} service here and include the {@link ngSanitize $sanitize}
>, <Line: +	 * module to automatically remove "bad" content like inline event listener (e.g. `<span onclick="...">`).
>, <Line: +	 * However, as we are using `$sce` the model can still decide to provide unsafe content if it marks
>, <Line: +	 * that content using the `$sce` service.
>, <Line: +	 *
>, <Line: +	 * <example name="NgModelController" module="customControl" deps="angular-sanitize.js">
>, <Line: +	 <file name="style.css">
>, <Line: +	 [contenteditable] {
>, <Line: +	 .ng-invalid {
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('customControl', ['ngSanitize']).
>, <Line: +	 directive('contenteditable', ['$sce', function($sce) {
>, <Line: +	 </file>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <form name="myForm">
>, <Line: +	 <div contenteditable
>, <Line: +	 name="myWidget" ng-model="userContent"
>, <Line: +	 strip-br="true"
>, <Line: +	 required>Change me!</div>
>, <Line: +	 <span ng-show="myForm.myWidget.$error.required">Required!</span>
>, <Line: +	 <hr>
>, <Line: +	 <textarea ng-model="userContent"></textarea>
>, <Line: +	 </form>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should data-bind and become invalid', function() {
>, <Line: +	 </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate',
>, <Line: +		function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
>, <Line: +			this.$viewValue = Number.NaN;
>, <Line: +			this.$modelValue = Number.NaN;
>, <Line: +			this.$$rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.
>, <Line: +			this.$validators = {};
>, <Line: +			this.$asyncValidators = {};
>, <Line: +			this.$parsers = [];
>, <Line: +			this.$formatters = [];
>, <Line: +			this.$viewChangeListeners = [];
>, <Line: +			this.$untouched = true;
>, <Line: +			this.$touched = false;
>, <Line: +			this.$pristine = true;
>, <Line: +			this.$dirty = false;
>, <Line: +			this.$valid = true;
>, <Line: +			this.$invalid = false;
>, <Line: +			this.$error = {}; // keep invalid keys here
>, <Line: +			this.$$success = {}; // keep valid keys here
>, <Line: +			this.$pending = undefined; // keep pending keys here
>, <Line: +			this.$name = $interpolate($attr.name || '', false)($scope);
>, <Line: +			var parsedNgModel = $parse($attr.ngModel),
>, <Line: +				parsedNgModelAssign = parsedNgModel.assign,
>, <Line: +				ngModelGet = parsedNgModel,
>, <Line: +				ngModelSet = parsedNgModelAssign,
>, <Line: +				pendingDebounce = null,
>, <Line: +				ctrl = this;
>, <Line: +			this.$$setOptions = function (options) {
>, <Line: +				ctrl.$options = options;
>, <Line: +				if (options && options.getterSetter) {
>, <Line: +					var invokeModelGetter = $parse($attr.ngModel + '()'),
>, <Line: +						invokeModelSetter = $parse($attr.ngModel + '($$$p)');
>, <Line: +					ngModelGet = function ($scope) {
>, <Line: +						var modelValue = parsedNgModel($scope);
>, <Line: +						if (isFunction(modelValue)) {
>, <Line: +							modelValue = invokeModelGetter($scope);
>, <Line: +						}
>, <Line: +						return modelValue;
>, <Line: +					};
>, <Line: +					ngModelSet = function ($scope, newValue) {
>, <Line: +						if (isFunction(parsedNgModel($scope))) {
>, <Line: +							invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
>, <Line: +						} else {
>, <Line: +							parsedNgModelAssign($scope, ctrl.$modelValue);
>, <Line: +						}
>, <Line: +					};
>, <Line: +				} else if (!parsedNgModel.assign) {
>, <Line: +					throw $ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
>, <Line: +						$attr.ngModel, startingTag($element));
>, <Line: +				}
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$render
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Called when the view needs to be updated. It is expected that the user of the ng-model
>, <Line: +			 * directive will implement this method.
>, <Line: +			 *
>, <Line: +			 * The `$render()` method is invoked in the following situations:
>, <Line: +			 *
>, <Line: +			 * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
>, <Line: +			 *   committed value then `$render()` is called to update the input control.
>, <Line: +			 * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
>, <Line: +			 *   the `$viewValue` are different to last time.
>, <Line: +			 *
>, <Line: +			 * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
>, <Line: +			 * `$modelValue` and `$viewValue` are actually different to their previous value. If `$modelValue`
>, <Line: +			 * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
>, <Line: +			 * invoked if you only change a property on the objects.
>, <Line: +			 */
>, <Line: +			this.$render = noop;
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$isEmpty
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * This is called when we need to determine if the value of an input is empty.
>, <Line: +			 *
>, <Line: +			 * For instance, the required directive does this to work out if the input has data or not.
>, <Line: +			 *
>, <Line: +			 * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
>, <Line: +			 *
>, <Line: +			 * You can override this for input directives whose concept of being empty is different to the
>, <Line: +			 * default. The `checkboxInputType` directive does this because in its case a value of `false`
>, <Line: +			 * implies empty.
>, <Line: +			 *
>, <Line: +			 * @param {*} value The value of the input to check for emptiness.
>, <Line: +			 * @returns {boolean} True if `value` is "empty".
>, <Line: +			 */
>, <Line: +			this.$isEmpty = function (value) {
>, <Line: +				return isUndefined(value) || value === '' || value === null || value !== value;
>, <Line: +			};
>, <Line: +			var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
>, <Line: +				currentValidationRunId = 0;
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setValidity
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Change the validity state, and notify the form.
>, <Line: +			 *
>, <Line: +			 * This method can be called within $parsers/$formatters or a custom validation implementation.
>, <Line: +			 * However, in most cases it should be sufficient to use the `ngModel.$validators` and
>, <Line: +			 * `ngModel.$asyncValidators` collections which will call `$setValidity` automatically.
>, <Line: +			 *
>, <Line: +			 * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be assigned
>, <Line: +			 *        to either `$error[validationErrorKey]` or `$pending[validationErrorKey]`
>, <Line: +			 *        (for unfulfilled `$asyncValidators`), so that it is available for data-binding.
>, <Line: +			 *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
>, <Line: +			 *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
>, <Line: +			 *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
>, <Line: +			 * @param {boolean} isValid Whether the current state is valid (true), invalid (false), pending (undefined),
>, <Line: +			 *                          or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
>, <Line: +			 *                          Skipped is used by Angular when validators do not run because of parse errors and
>, <Line: +			 *                          when `$asyncValidators` do not run because any of the `$validators` failed.
>, <Line: +			 */
>, <Line: +			addSetValidityMethod({
>, <Line: +				ctrl: this,
>, <Line: +				$element: $element,
>, <Line: +				set: function (object, property) {
>, <Line: +					object[property] = true;
>, <Line: +				},
>, <Line: +				unset: function (object, property) {
>, <Line: +					delete object[property];
>, <Line: +				},
>, <Line: +				parentForm: parentForm,
>, <Line: +				$animate: $animate
>, <Line: +			});
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setPristine
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Sets the control to its pristine state.
>, <Line: +			 *
>, <Line: +			 * This method can be called to remove the `ng-dirty` class and set the control to its pristine
>, <Line: +			 * state (`ng-pristine` class). A model is considered to be pristine when the control
>, <Line: +			 * has not been changed from when first compiled.
>, <Line: +			 */
>, <Line: +			this.$setPristine = function () {
>, <Line: +				ctrl.$dirty = false;
>, <Line: +				ctrl.$pristine = true;
>, <Line: +				$animate.removeClass($element, DIRTY_CLASS);
>, <Line: +				$animate.addClass($element, PRISTINE_CLASS);
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setDirty
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Sets the control to its dirty state.
>, <Line: +			 *
>, <Line: +			 * This method can be called to remove the `ng-pristine` class and set the control to its dirty
>, <Line: +			 * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
>, <Line: +			 * from when first compiled.
>, <Line: +			 */
>, <Line: +			this.$setDirty = function () {
>, <Line: +				ctrl.$dirty = true;
>, <Line: +				ctrl.$pristine = false;
>, <Line: +				$animate.removeClass($element, PRISTINE_CLASS);
>, <Line: +				$animate.addClass($element, DIRTY_CLASS);
>, <Line: +				parentForm.$setDirty();
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setUntouched
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Sets the control to its untouched state.
>, <Line: +			 *
>, <Line: +			 * This method can be called to remove the `ng-touched` class and set the control to its
>, <Line: +			 * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
>, <Line: +			 * by default, however this function can be used to restore that state if the model has
>, <Line: +			 * already been touched by the user.
>, <Line: +			 */
>, <Line: +			this.$setUntouched = function () {
>, <Line: +				ctrl.$touched = false;
>, <Line: +				ctrl.$untouched = true;
>, <Line: +				$animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setTouched
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Sets the control to its touched state.
>, <Line: +			 *
>, <Line: +			 * This method can be called to remove the `ng-untouched` class and set the control to its
>, <Line: +			 * touched state (`ng-touched` class). A model is considered to be touched when the user has
>, <Line: +			 * first focused the control element and then shifted focus away from the control (blur event).
>, <Line: +			 */
>, <Line: +			this.$setTouched = function () {
>, <Line: +				ctrl.$touched = true;
>, <Line: +				ctrl.$untouched = false;
>, <Line: +				$animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$rollbackViewValue
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
>, <Line: +			 * which may be caused by a pending debounced event or because the input is waiting for a some
>, <Line: +			 * future event.
>, <Line: +			 *
>, <Line: +			 * If you have an input that uses `ng-model-options` to set up debounced events or events such
>, <Line: +			 * as blur you can have a situation where there is a period when the `$viewValue`
>, <Line: +			 * is out of synch with the ngModel's `$modelValue`.
>, <Line: +			 *
>, <Line: +			 * In this case, you can run into difficulties if you try to update the ngModel's `$modelValue`
>, <Line: +			 * programmatically before these debounced/future events have resolved/occurred, because Angular's
>, <Line: +			 * dirty checking mechanism is not able to tell whether the model has actually changed or not.
>, <Line: +			 *
>, <Line: +			 * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
>, <Line: +			 * input which may have such events pending. This is important in order to make sure that the
>, <Line: +			 * input field will be updated with the new model value and any pending operations are cancelled.
>, <Line: +			 *
>, <Line: +			 * <example name="ng-model-cancel-update" module="cancel-update-example">
>, <Line: +			 *   <file name="app.js">
>, <Line: +			 *     angular.module('cancel-update-example', [])
>, <Line: +			 *
>, <Line: +			 *     .controller('CancelUpdateController', ['$scope', function($scope) {
>, <Line: +			 *   </file>
>, <Line: +			 *   <file name="index.html">
>, <Line: +			 *     <div ng-controller="CancelUpdateController">
>, <Line: +			 *       <p>Try typing something in each input.  See that the model only updates when you
>, <Line: +			 *          blur off the input.
>, <Line: +			 *        </p>
>, <Line: +			 *        <p>Now see what happens if you start typing then press the Escape key</p>
>, <Line: +			 *
>, <Line: +			 *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
>, <Line: +			 *         <p>With $rollbackViewValue()</p>
>, <Line: +			 *         <input name="myInput1" ng-model="myValue" ng-keydown="resetWithCancel($event)"><br/>
>, <Line: +			 *         myValue: "{{ myValue }}"
>, <Line: +			 *
>, <Line: +			 *         <p>Without $rollbackViewValue()</p>
>, <Line: +			 *         <input name="myInput2" ng-model="myValue" ng-keydown="resetWithoutCancel($event)"><br/>
>, <Line: +			 *         myValue: "{{ myValue }}"
>, <Line: +			 *       </form>
>, <Line: +			 *     </div>
>, <Line: +			 *   </file>
>, <Line: +			 * </example>
>, <Line: +			 */
>, <Line: +			this.$rollbackViewValue = function () {
>, <Line: +				$timeout.cancel(pendingDebounce);
>, <Line: +				ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: +				ctrl.$render();
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$validate
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Runs each of the registered validators (first synchronous validators and then
>, <Line: +			 * asynchronous validators).
>, <Line: +			 * If the validity changes to invalid, the model will be set to `undefined`,
>, <Line: +			 * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
>, <Line: +			 * If the validity changes to valid, it will set the model to the last available valid
>, <Line: +			 * modelValue, i.e. either the last parsed value or the last value set from the scope.
>, <Line: +			 */
>, <Line: +			this.$validate = function () {
>, <Line: +				// ignore $validate before model is initialized
>, <Line: +				if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				var viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: +				// Note: we use the $$rawModelValue as $modelValue might have been
>, <Line: +				// set to undefined during a view -> model update that found validation
>, <Line: +				// errors. We can't parse the view here, since that could change
>, <Line: +				// the model although neither viewValue nor the model on the scope changed
>, <Line: +				var modelValue = ctrl.$$rawModelValue;
>, <Line: +				// Check if the there's a parse error, so we don't unset it accidentially
>, <Line: +				var parserName = ctrl.$$parserName || 'parse';
>, <Line: +				var parserValid = ctrl.$error[parserName] ? false : undefined;
>, <Line: +				var prevValid = ctrl.$valid;
>, <Line: +				var prevModelValue = ctrl.$modelValue;
>, <Line: +				var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
>, <Line: +				ctrl.$$runValidators(parserValid, modelValue, viewValue, function (allValid) {
>, <Line: +					// If there was no change in validity, don't update the model
>, <Line: +					// This prevents changing an invalid modelValue to undefined
>, <Line: +					if (!allowInvalid && prevValid !== allValid) {
>, <Line: +						// Note: Don't check ctrl.$valid here, as we could have
>, <Line: +						// external validators (e.g. calculated on the server),
>, <Line: +						// that just call $setValidity and need the model value
>, <Line: +						// to calculate their validity.
>, <Line: +						ctrl.$modelValue = allValid ? modelValue : undefined;
>, <Line: +						if (ctrl.$modelValue !== prevModelValue) {
>, <Line: +							ctrl.$$writeModelToScope();
>, <Line: +						}
>, <Line: +					}
>, <Line: +				});
>, <Line: +			};
>, <Line: +			this.$$runValidators = function (parseValid, modelValue, viewValue, doneCallback) {
>, <Line: +				currentValidationRunId++;
>, <Line: +				var localValidationRunId = currentValidationRunId;
>, <Line: +				// check parser error
>, <Line: +				if (!processParseErrors(parseValid)) {
>, <Line: +					validationDone(false);
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				if (!processSyncValidators()) {
>, <Line: +					validationDone(false);
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				processAsyncValidators();
>, <Line: +				function processParseErrors(parseValid) {
>, <Line: +					var errorKey = ctrl.$$parserName || 'parse';
>, <Line: +					if (parseValid === undefined) {
>, <Line: +						setValidity(errorKey, null);
>, <Line: +					} else {
>, <Line: +						setValidity(errorKey, parseValid);
>, <Line: +						if (!parseValid) {
>, <Line: +							forEach(ctrl.$validators, function (v, name) {
>, <Line: +								setValidity(name, null);
>, <Line: +							});
>, <Line: +							forEach(ctrl.$asyncValidators, function (v, name) {
>, <Line: +								setValidity(name, null);
>, <Line: +							});
>, <Line: +							return false;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					return true;
>, <Line: +				}
>, <Line: +				function processSyncValidators() {
>, <Line: +					var syncValidatorsValid = true;
>, <Line: +					forEach(ctrl.$validators, function (validator, name) {
>, <Line: +						var result = validator(modelValue, viewValue);
>, <Line: +						syncValidatorsValid = syncValidatorsValid && result;
>, <Line: +						setValidity(name, result);
>, <Line: +					});
>, <Line: +					if (!syncValidatorsValid) {
>, <Line: +						forEach(ctrl.$asyncValidators, function (v, name) {
>, <Line: +							setValidity(name, null);
>, <Line: +						});
>, <Line: +						return false;
>, <Line: +					}
>, <Line: +					return true;
>, <Line: +				}
>, <Line: +				function processAsyncValidators() {
>, <Line: +					var validatorPromises = [];
>, <Line: +					var allValid = true;
>, <Line: +					forEach(ctrl.$asyncValidators, function (validator, name) {
>, <Line: +						var promise = validator(modelValue, viewValue);
>, <Line: +						if (!isPromiseLike(promise)) {
>, <Line: +							throw $ngModelMinErr("$asyncValidators",
>, <Line: +								"Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
>, <Line: +						}
>, <Line: +						setValidity(name, undefined);
>, <Line: +						validatorPromises.push(promise.then(function () {
>, <Line: +							setValidity(name, true);
>, <Line: +						}, function (error) {
>, <Line: +							allValid = false;
>, <Line: +							setValidity(name, false);
>, <Line: +						}));
>, <Line: +					});
>, <Line: +					if (!validatorPromises.length) {
>, <Line: +						validationDone(true);
>, <Line: +					} else {
>, <Line: +						$q.all(validatorPromises).then(function () {
>, <Line: +							validationDone(allValid);
>, <Line: +						}, noop);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function setValidity(name, isValid) {
>, <Line: +					if (localValidationRunId === currentValidationRunId) {
>, <Line: +						ctrl.$setValidity(name, isValid);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				function validationDone(allValid) {
>, <Line: +					if (localValidationRunId === currentValidationRunId) {
>, <Line: +						doneCallback(allValid);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$commitViewValue
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Commit a pending update to the `$modelValue`.
>, <Line: +			 *
>, <Line: +			 * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: +			 * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
>, <Line: +			 * usually handles calling this in response to input events.
>, <Line: +			 */
>, <Line: +			this.$commitViewValue = function () {
>, <Line: +				var viewValue = ctrl.$viewValue;
>, <Line: +				$timeout.cancel(pendingDebounce);
>, <Line: +				// If the view value has not changed then we should just exit, except in the case where there is
>, <Line: +				// a native validator on the element. In this case the validation state may have changed even though
>, <Line: +				// the viewValue has stayed empty.
>, <Line: +				if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
>, <Line: +					return;
>, <Line: +				}
>, <Line: +				ctrl.$$lastCommittedViewValue = viewValue;
>, <Line: +				// change to dirty
>, <Line: +				if (ctrl.$pristine) {
>, <Line: +					this.$setDirty();
>, <Line: +				}
>, <Line: +				this.$$parseAndValidate();
>, <Line: +			};
>, <Line: +			this.$$parseAndValidate = function () {
>, <Line: +				var viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: +				var modelValue = viewValue;
>, <Line: +				var parserValid = isUndefined(modelValue) ? undefined : true;
>, <Line: +				if (parserValid) {
>, <Line: +					for (var i = 0; i < ctrl.$parsers.length; i++) {
>, <Line: +						modelValue = ctrl.$parsers[i](modelValue);
>, <Line: +						if (isUndefined(modelValue)) {
>, <Line: +							parserValid = false;
>, <Line: +							break;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +				if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
>, <Line: +					// ctrl.$modelValue has not been touched yet...
>, <Line: +					ctrl.$modelValue = ngModelGet($scope);
>, <Line: +				}
>, <Line: +				var prevModelValue = ctrl.$modelValue;
>, <Line: +				var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
>, <Line: +				ctrl.$$rawModelValue = modelValue;
>, <Line: +				if (allowInvalid) {
>, <Line: +					ctrl.$modelValue = modelValue;
>, <Line: +					writeToModelIfNeeded();
>, <Line: +				}
>, <Line: +				ctrl.$$runValidators(parserValid, modelValue, viewValue, function (allValid) {
>, <Line: +					if (!allowInvalid) {
>, <Line: +						// Note: Don't check ctrl.$valid here, as we could have
>, <Line: +						// external validators (e.g. calculated on the server),
>, <Line: +						// that just call $setValidity and need the model value
>, <Line: +						// to calculate their validity.
>, <Line: +						ctrl.$modelValue = allValid ? modelValue : undefined;
>, <Line: +						writeToModelIfNeeded();
>, <Line: +					}
>, <Line: +				});
>, <Line: +				function writeToModelIfNeeded() {
>, <Line: +					if (ctrl.$modelValue !== prevModelValue) {
>, <Line: +						ctrl.$$writeModelToScope();
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			this.$$writeModelToScope = function () {
>, <Line: +				ngModelSet($scope, ctrl.$modelValue);
>, <Line: +				forEach(ctrl.$viewChangeListeners, function (listener) {
>, <Line: +					try {
>, <Line: +						listener();
>, <Line: +					} catch (e) {
>, <Line: +						$exceptionHandler(e);
>, <Line: +					}
>, <Line: +				});
>, <Line: +			};
>, <Line: +			/**
>, <Line: +			 * @ngdoc method
>, <Line: +			 * @name ngModel.NgModelController#$setViewValue
>, <Line: +			 *
>, <Line: +			 * @description
>, <Line: +			 * Update the view value.
>, <Line: +			 *
>, <Line: +			 * This method should be called when an input directive want to change the view value; typically,
>, <Line: +			 * this is done from within a DOM event handler.
>, <Line: +			 *
>, <Line: +			 * For example {@link ng.directive:input input} calls it when the value of the input changes and
>, <Line: +			 * {@link ng.directive:select select} calls it when an option is selected.
>, <Line: +			 *
>, <Line: +			 * If the new `value` is an object (rather than a string or a number), we should make a copy of the
>, <Line: +			 * object before passing it to `$setViewValue`.  This is because `ngModel` does not perform a deep
>, <Line: +			 * watch of objects, it only looks for a change of identity. If you only change the property of
>, <Line: +			 * the object then ngModel will not realise that the object has changed and will not invoke the
>, <Line: +			 * `$parsers` and `$validators` pipelines.
>, <Line: +			 *
>, <Line: +			 * For this reason, you should not change properties of the copy once it has been passed to
>, <Line: +			 * `$setViewValue`. Otherwise you may cause the model value on the scope to change incorrectly.
>, <Line: +			 *
>, <Line: +			 * When this method is called, the new `value` will be staged for committing through the `$parsers`
>, <Line: +			 * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
>, <Line: +			 * value sent directly for processing, finally to be applied to `$modelValue` and then the
>, <Line: +			 * **expression** specified in the `ng-model` attribute.
>, <Line: +			 *
>, <Line: +			 * Lastly, all the registered change listeners, in the `$viewChangeListeners` list, are called.
>, <Line: +			 *
>, <Line: +			 * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
>, <Line: +			 * and the `default` trigger is not listed, all those actions will remain pending until one of the
>, <Line: +			 * `updateOn` events is triggered on the DOM element.
>, <Line: +			 * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
>, <Line: +			 * directive is used with a custom debounce for this particular event.
>, <Line: +			 *
>, <Line: +			 * Note that calling this function does not trigger a `$digest`.
>, <Line: +			 *
>, <Line: +			 * @param {string} value Value from the view.
>, <Line: +			 * @param {string} trigger Event that triggered the update.
>, <Line: +			 */
>, <Line: +			this.$setViewValue = function (value, trigger) {
>, <Line: +				ctrl.$viewValue = value;
>, <Line: +				if (!ctrl.$options || ctrl.$options.updateOnDefault) {
>, <Line: +					ctrl.$$debounceViewValueCommit(trigger);
>, <Line: +				}
>, <Line: +			};
>, <Line: +			this.$$debounceViewValueCommit = function (trigger) {
>, <Line: +				var debounceDelay = 0,
>, <Line: +					options = ctrl.$options,
>, <Line: +					debounce;
>, <Line: +				if (options && isDefined(options.debounce)) {
>, <Line: +					debounce = options.debounce;
>, <Line: +					if (isNumber(debounce)) {
>, <Line: +						debounceDelay = debounce;
>, <Line: +					} else if (isNumber(debounce[trigger])) {
>, <Line: +						debounceDelay = debounce[trigger];
>, <Line: +					} else if (isNumber(debounce['default'])) {
>, <Line: +						debounceDelay = debounce['default'];
>, <Line: +					}
>, <Line: +				}
>, <Line: +				$timeout.cancel(pendingDebounce);
>, <Line: +				if (debounceDelay) {
>, <Line: +					pendingDebounce = $timeout(function () {
>, <Line: +						ctrl.$commitViewValue();
>, <Line: +					}, debounceDelay);
>, <Line: +				} else if ($rootScope.$$phase) {
>, <Line: +					ctrl.$commitViewValue();
>, <Line: +				} else {
>, <Line: +					$scope.$apply(function () {
>, <Line: +						ctrl.$commitViewValue();
>, <Line: +					});
>, <Line: +				}
>, <Line: +			};
>, <Line: +			// model -> value
>, <Line: +			// Note: we cannot use a normal scope.$watch as we want to detect the following:
>, <Line: +			// 1. scope value is 'a'
>, <Line: +			// 2. user enters 'b'
>, <Line: +			// 3. ng-change kicks in and reverts scope value to 'a'
>, <Line: +			//    -> scope value did not change since the last digest as
>, <Line: +			//       ng-change executes in apply phase
>, <Line: +			// 4. view should be changed back to 'a'
>, <Line: +			$scope.$watch(function ngModelWatch() {
>, <Line: +				var modelValue = ngModelGet($scope);
>, <Line: +				// if scope model value and ngModel value are out of sync
>, <Line: +				// TODO(perf): why not move this to the action fn?
>, <Line: +				if (modelValue !== ctrl.$modelValue) {
>, <Line: +					ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
>, <Line: +					var formatters = ctrl.$formatters,
>, <Line: +						idx = formatters.length;
>, <Line: +					var viewValue = modelValue;
>, <Line: +					while (idx--) {
>, <Line: +						viewValue = formatters[idx](viewValue);
>, <Line: +					}
>, <Line: +					if (ctrl.$viewValue !== viewValue) {
>, <Line: +						ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
>, <Line: +						ctrl.$render();
>, <Line: +						ctrl.$$runValidators(undefined, modelValue, viewValue, noop);
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return modelValue;
>, <Line: +			});
>, <Line: +		}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngModel
>, <Line: +	 *
>, <Line: +	 * @element input
>, <Line: +	 * @priority 1
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a
>, <Line: +	 * property on the scope using {@link ngModel.NgModelController NgModelController},
>, <Line: +	 * which is created and exposed by this directive.
>, <Line: +	 *
>, <Line: +	 * `ngModel` is responsible for:
>, <Line: +	 *
>, <Line: +	 * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`
>, <Line: +	 *   require.
>, <Line: +	 * - Providing validation behavior (i.e. required, number, email, url).
>, <Line: +	 * - Keeping the state of the control (valid/invalid, dirty/pristine, touched/untouched, validation errors).
>, <Line: +	 * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`, `ng-untouched`) including animations.
>, <Line: +	 * - Registering the control with its parent {@link ng.directive:form form}.
>, <Line: +	 *
>, <Line: +	 * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
>, <Line: +	 * current scope. If the property doesn't already exist on this scope, it will be created
>, <Line: +	 * implicitly and added to the scope.
>, <Line: +	 *
>, <Line: +	 * For best practices on using `ngModel`, see:
>, <Line: +	 *
>, <Line: +	 *  - [Understanding Scopes](https://github.com/angular/angular.js/wiki/Understanding-Scopes)
>, <Line: +	 *
>, <Line: +	 * For basic examples, how to use `ngModel`, see:
>, <Line: +	 *
>, <Line: +	 *  - {@link ng.directive:input input}
>, <Line: +	 *    - {@link input[text] text}
>, <Line: +	 *    - {@link input[checkbox] checkbox}
>, <Line: +	 *    - {@link input[radio] radio}
>, <Line: +	 *    - {@link input[number] number}
>, <Line: +	 *    - {@link input[email] email}
>, <Line: +	 *    - {@link input[url] url}
>, <Line: +	 *    - {@link input[date] date}
>, <Line: +	 *    - {@link input[datetime-local] datetime-local}
>, <Line: +	 *    - {@link input[time] time}
>, <Line: +	 *    - {@link input[month] month}
>, <Line: +	 *    - {@link input[week] week}
>, <Line: +	 *  - {@link ng.directive:select select}
>, <Line: +	 *  - {@link ng.directive:textarea textarea}
>, <Line: +	 *
>, <Line: +	 * # CSS classes
>, <Line: +	 * The following CSS classes are added and removed on the associated input/select/textarea element
>, <Line: +	 * depending on the validity of the model.
>, <Line: +	 *
>, <Line: +	 *  - `ng-valid`: the model is valid
>, <Line: +	 *  - `ng-invalid`: the model is invalid
>, <Line: +	 *  - `ng-valid-[key]`: for each valid key added by `$setValidity`
>, <Line: +	 *  - `ng-invalid-[key]`: for each invalid key added by `$setValidity`
>, <Line: +	 *  - `ng-pristine`: the control hasn't been interacted with yet
>, <Line: +	 *  - `ng-dirty`: the control has been interacted with
>, <Line: +	 *  - `ng-touched`: the control has been blurred
>, <Line: +	 *  - `ng-untouched`: the control hasn't been blurred
>, <Line: +	 *  - `ng-pending`: any `$asyncValidators` are unfulfilled
>, <Line: +	 *
>, <Line: +	 * Keep in mind that ngAnimate can detect each of these classes when added and removed.
>, <Line: +	 *
>, <Line: +	 * ## Animation Hooks
>, <Line: +	 *
>, <Line: +	 * Animations within models are triggered when any of the associated CSS classes are added and removed
>, <Line: +	 * on the input element which is attached to the model. These classes are: `.ng-pristine`, `.ng-dirty`,
>, <Line: +	 * `.ng-invalid` and `.ng-valid` as well as any other validations that are performed on the model itself.
>, <Line: +	 * The animations that are triggered within ngModel are similar to how they work in ngClass and
>, <Line: +	 * animations can be hooked into using CSS transitions, keyframes as well as JS animations.
>, <Line: +	 *
>, <Line: +	 * The following example shows a simple way to utilize CSS transitions to style an input element
>, <Line: +	 * that has been rendered as invalid after it has been validated:
>, <Line: +	 *
>, <Line: +	 * <pre>
>, <Line: +	 * //be sure to include ngAnimate as a module to hook into more
>, <Line: +	 * //advanced animations
>, <Line: +	 * .my-input {
>, <Line: +	 * .my-input.ng-invalid {
>, <Line: +	 * </pre>
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * <example deps="angular-animate.js" animations="true" fixBase="true" module="inputExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('inputExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <style>
>, <Line: +	 .my-input {
>, <Line: +	 .my-input.ng-invalid {
>, <Line: +	 </style>
>, <Line: +	 Update input to see transitions when valid/invalid.
>, <Line: +	 Integer is a valid value.
>, <Line: +	 <form name="testForm" ng-controller="ExampleController">
>, <Line: +	 <input ng-model="val" ng-pattern="/^\d+$/" name="anim" class="my-input" />
>, <Line: +	 </form>
>, <Line: +	 </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 * ## Binding to a getter/setter
>, <Line: +	 *
>, <Line: +	 * Sometimes it's helpful to bind `ngModel` to a getter/setter function.  A getter/setter is a
>, <Line: +	 * function that returns a representation of the model when called with zero arguments, and sets
>, <Line: +	 * the internal state of a model when called with an argument. It's sometimes useful to use this
>, <Line: +	 * for models that have an internal representation that's different than what the model exposes
>, <Line: +	 * to the view.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-success">
>, <Line: +	 * **Best Practice:** It's best to keep getters fast because Angular is likely to call them more
>, <Line: +	 * frequently than other parts of your code.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * You use this behavior by adding `ng-model-options="{ getterSetter: true }"` to an element that
>, <Line: +	 * has `ng-model` attached to it. You can also add `ng-model-options="{ getterSetter: true }"` to
>, <Line: +	 * a `<form>`, which will enable this behavior for all `<input>`s within it. See
>, <Line: +	 * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.
>, <Line: +	 *
>, <Line: +	 * The following example shows how to use `ngModel` with a getter/setter:
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * <example name="ngModel-getter-setter" module="getterSetterExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form name="userForm">
>, <Line: +	 Name:
>, <Line: +	 <input type="text" name="userName"
>, <Line: +	 ng-model="user.name"
>, <Line: +	 ng-model-options="{ getterSetter: true }" />
>, <Line: +	 </form>
>, <Line: +	 <pre>user.name = <span ng-bind="user.name()"></span></pre>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="app.js">
>, <Line: +	 angular.module('getterSetterExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 * </example>
>, <Line: +	 */
>, <Line: +	var ngModelDirective = ['$rootScope', function ($rootScope) {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			require: ['ngModel', '^?form', '^?ngModelOptions'],
>, <Line: +			controller: NgModelController,
>, <Line: +			// Prelink needs to run before any input directive
>, <Line: +			// so that we can set the NgModelOptions in NgModelController
>, <Line: +			// before anyone else uses it.
>, <Line: +			priority: 1,
>, <Line: +			compile: function ngModelCompile(element) {
>, <Line: +				// Setup initial state of the control
>, <Line: +				element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
>, <Line: +				return {
>, <Line: +					pre: function ngModelPreLink(scope, element, attr, ctrls) {
>, <Line: +						var modelCtrl = ctrls[0],
>, <Line: +							formCtrl = ctrls[1] || nullFormCtrl;
>, <Line: +						modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
>, <Line: +						// notify others, especially parent forms
>, <Line: +						formCtrl.$addControl(modelCtrl);
>, <Line: +						attr.$observe('name', function (newValue) {
>, <Line: +							if (modelCtrl.$name !== newValue) {
>, <Line: +								formCtrl.$$renameControl(modelCtrl, newValue);
>, <Line: +							}
>, <Line: +						});
>, <Line: +						scope.$on('$destroy', function () {
>, <Line: +							formCtrl.$removeControl(modelCtrl);
>, <Line: +						});
>, <Line: +					},
>, <Line: +					post: function ngModelPostLink(scope, element, attr, ctrls) {
>, <Line: +						var modelCtrl = ctrls[0];
>, <Line: +						if (modelCtrl.$options && modelCtrl.$options.updateOn) {
>, <Line: +							element.on(modelCtrl.$options.updateOn, function (ev) {
>, <Line: +								modelCtrl.$$debounceViewValueCommit(ev && ev.type);
>, <Line: +							});
>, <Line: +						}
>, <Line: +						element.on('blur', function (ev) {
>, <Line: +							if (modelCtrl.$touched) return;
>, <Line: +							if ($rootScope.$$phase) {
>, <Line: +								scope.$evalAsync(modelCtrl.$setTouched);
>, <Line: +							} else {
>, <Line: +								scope.$apply(modelCtrl.$setTouched);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngChange
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Evaluate the given expression when the user changes the input.
>, <Line: +	 * The expression is evaluated immediately, unlike the JavaScript onchange event
>, <Line: +	 * which only triggers at the end of a change (usually, when the user leaves the
>, <Line: +	 * form element or presses the return key).
>, <Line: +	 *
>, <Line: +	 * The `ngChange` expression is only evaluated when a change in the input value causes
>, <Line: +	 * a new value to be committed to the model.
>, <Line: +	 *
>, <Line: +	 * It will not be evaluated:
>, <Line: +	 * * if the value returned from the `$parsers` transformation pipeline has not changed
>, <Line: +	 * * if the input has continued to be invalid since the model will stay `null`
>, <Line: +	 * * if the model is changed programmatically and not by a change to the input value
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * Note, this directive requires `ngModel` to be present.
>, <Line: +	 *
>, <Line: +	 * @element input
>, <Line: +	 * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
>, <Line: +	 * in input value.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * <example name="ngChange-directive" module="changeExample">
>, <Line: +	 *   <file name="index.html">
>, <Line: +	 *     <script>
>, <Line: +	 *       angular.module('changeExample', [])
>, <Line: +	 *         .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 *     </script>
>, <Line: +	 *     <div ng-controller="ExampleController">
>, <Line: +	 *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
>, <Line: +	 *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
>, <Line: +	 *       <label for="ng-change-example2">Confirmed</label><br />
>, <Line: +	 *       <tt>debug = {{confirmed}}</tt><br/>
>, <Line: +	 *       <tt>counter = {{counter}}</tt><br/>
>, <Line: +	 *     </div>
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="protractor.js" type="protractor">
>, <Line: +	 *     var counter = element(by.binding('counter'));
>, <Line: +	 *     var debug = element(by.binding('confirmed'));
>, <Line: +	 *
>, <Line: +	 *     it('should evaluate the expression if changing from view', function() {
>, <Line: +	 *
>, <Line: +	 *     it('should not evaluate the expression if changing from model', function() {
>, <Line: +	 *   </file>
>, <Line: +	 * </example>
>, <Line: +	 */
>, <Line: +	var ngChangeDirective = valueFn({
>, <Line: +		restrict: 'A',
>, <Line: +		require: 'ngModel',
>, <Line: +		link: function (scope, element, attr, ctrl) {
>, <Line: +			ctrl.$viewChangeListeners.push(function () {
>, <Line: +				scope.$eval(attr.ngChange);
>, <Line: +			});
>, <Line: +		}
>, <Line: +	});
>, <Line: +	var requiredDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			require: '?ngModel',
>, <Line: +			link: function (scope, elm, attr, ctrl) {
>, <Line: +				if (!ctrl) return;
>, <Line: +				attr.required = true; // force truthy in case we are on non input element
>, <Line: +				ctrl.$validators.required = function (modelValue, viewValue) {
>, <Line: +					return !attr.required || !ctrl.$isEmpty(viewValue);
>, <Line: +				};
>, <Line: +				attr.$observe('required', function () {
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	var patternDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			require: '?ngModel',
>, <Line: +			link: function (scope, elm, attr, ctrl) {
>, <Line: +				if (!ctrl) return;
>, <Line: +				var regexp, patternExp = attr.ngPattern || attr.pattern;
>, <Line: +				attr.$observe('pattern', function (regex) {
>, <Line: +					if (isString(regex) && regex.length > 0) {
>, <Line: +						regex = new RegExp('^' + regex + '$');
>, <Line: +					}
>, <Line: +					if (regex && !regex.test) {
>, <Line: +						throw minErr('ngPattern')('noregexp',
>, <Line: +							'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp,
>, <Line: +							regex, startingTag(elm));
>, <Line: +					}
>, <Line: +					regexp = regex || undefined;
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +				ctrl.$validators.pattern = function (value) {
>, <Line: +					return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	var maxlengthDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			require: '?ngModel',
>, <Line: +			link: function (scope, elm, attr, ctrl) {
>, <Line: +				if (!ctrl) return;
>, <Line: +				var maxlength = -1;
>, <Line: +				attr.$observe('maxlength', function (value) {
>, <Line: +					var intVal = int(value);
>, <Line: +					maxlength = isNaN(intVal) ? -1 : intVal;
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +				ctrl.$validators.maxlength = function (modelValue, viewValue) {
>, <Line: +					return (maxlength < 0) || ctrl.$isEmpty(modelValue) || (viewValue.length <= maxlength);
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	var minlengthDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			require: '?ngModel',
>, <Line: +			link: function (scope, elm, attr, ctrl) {
>, <Line: +				if (!ctrl) return;
>, <Line: +				var minlength = 0;
>, <Line: +				attr.$observe('minlength', function (value) {
>, <Line: +					minlength = int(value) || 0;
>, <Line: +					ctrl.$validate();
>, <Line: +				});
>, <Line: +				ctrl.$validators.minlength = function (modelValue, viewValue) {
>, <Line: +					return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngList
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Text input that converts between a delimited string and an array of strings. The default
>, <Line: +	 * delimiter is a comma followed by a space - equivalent to `ng-list=", "`. You can specify a custom
>, <Line: +	 * delimiter as the value of the `ngList` attribute - for example, `ng-list=" | "`.
>, <Line: +	 *
>, <Line: +	 * The behaviour of the directive is affected by the use of the `ngTrim` attribute.
>, <Line: +	 * * If `ngTrim` is set to `"false"` then whitespace around both the separator and each
>, <Line: +	 *   list item is respected. This implies that the user of the directive is responsible for
>, <Line: +	 *   dealing with whitespace but also allows you to use whitespace as a delimiter, such as a
>, <Line: +	 *   tab or newline character.
>, <Line: +	 * * Otherwise whitespace around the delimiter is ignored when splitting (although it is respected
>, <Line: +	 *   when joining the list items back together) and whitespace around each list item is stripped
>, <Line: +	 *   before it is added to the model.
>, <Line: +	 *
>, <Line: +	 * ### Example with Validation
>, <Line: +	 *
>, <Line: +	 * <example name="ngList-directive" module="listExample">
>, <Line: +	 *   <file name="app.js">
>, <Line: +	 *      angular.module('listExample', [])
>, <Line: +	 *        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="index.html">
>, <Line: +	 *    <form name="myForm" ng-controller="ExampleController">
>, <Line: +	 *      List: <input name="namesInput" ng-model="names" ng-list required>
>, <Line: +	 *      <span class="error" ng-show="myForm.namesInput.$error.required">
>, <Line: +	 *        Required!</span>
>, <Line: +	 *      <br>
>, <Line: +	 *      <tt>names = {{names}}</tt><br/>
>, <Line: +	 *      <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
>, <Line: +	 *      <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
>, <Line: +	 *      <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: +	 *      <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: +	 *     </form>
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="protractor.js" type="protractor">
>, <Line: +	 *     var listInput = element(by.model('names'));
>, <Line: +	 *     var names = element(by.exactBinding('names'));
>, <Line: +	 *     var valid = element(by.binding('myForm.namesInput.$valid'));
>, <Line: +	 *     var error = element(by.css('span.error'));
>, <Line: +	 *
>, <Line: +	 *     it('should initialize to model', function() {
>, <Line: +	 *
>, <Line: +	 *     it('should be invalid if empty', function() {
>, <Line: +	 *   </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 * ### Example - splitting on whitespace
>, <Line: +	 * <example name="ngList-directive-newlines">
>, <Line: +	 *   <file name="index.html">
>, <Line: +	 *    <textarea ng-model="list" ng-list="&#10;" ng-trim="false"></textarea>
>, <Line: +	 *    <pre>{{ list | json }}</pre>
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="protractor.js" type="protractor">
>, <Line: +	 *     it("should split the text by newlines", function() {
>, <Line: + *       listInput.sendKeys('abc\ndef\nghi');
>, <Line: + *       expect(output.getText()).toContain('[\n  "abc",\n  "def",\n  "ghi"\n]');
>, <Line: + *     });
>, <Line: +	 *   </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 * @element input
>, <Line: +	 * @param {string=} ngList optional delimiter that should be used to split the value.
>, <Line: +	 */
>, <Line: +	var ngListDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			priority: 100,
>, <Line: +			require: 'ngModel',
>, <Line: +			link: function (scope, element, attr, ctrl) {
>, <Line: +				// We want to control whitespace trimming so we use this convoluted approach
>, <Line: +				// to access the ngList attribute, which doesn't pre-trim the attribute
>, <Line: +				var ngList = element.attr(attr.$attr.ngList) || ', ';
>, <Line: +				var trimValues = attr.ngTrim !== 'false';
>, <Line: +				var separator = trimValues ? trim(ngList) : ngList;
>, <Line: +				var parse = function (viewValue) {
>, <Line: +					// If the viewValue is invalid (say required but empty) it will be `undefined`
>, <Line: +					if (isUndefined(viewValue)) return;
>, <Line: +					var list = [];
>, <Line: +					if (viewValue) {
>, <Line: +						forEach(viewValue.split(separator), function (value) {
>, <Line: +							if (value) list.push(trimValues ? trim(value) : value);
>, <Line: +						});
>, <Line: +					}
>, <Line: +					return list;
>, <Line: +				};
>, <Line: +				ctrl.$parsers.push(parse);
>, <Line: +				ctrl.$formatters.push(function (value) {
>, <Line: +					if (isArray(value)) {
>, <Line: +						return value.join(ngList);
>, <Line: +					}
>, <Line: +					return undefined;
>, <Line: +				});
>, <Line: +				// Override the standard $isEmpty because an empty array means the input is empty.
>, <Line: +				ctrl.$isEmpty = function (value) {
>, <Line: +					return !value || !value.length;
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngValue
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Binds the given expression to the value of `<option>` or {@link input[radio] `input[radio]`},
>, <Line: +	 * so that when the element is selected, the {@link ngModel `ngModel`} of that element is set to
>, <Line: +	 * the bound value.
>, <Line: +	 *
>, <Line: +	 * `ngValue` is useful when dynamically generating lists of radio buttons using
>, <Line: +	 * {@link ngRepeat `ngRepeat`}, as shown below.
>, <Line: +	 *
>, <Line: +	 * Likewise, `ngValue` can be used to generate `<option>` elements for
>, <Line: +	 * the {@link select `select`} element. In that case however, only strings are supported
>, <Line: +	 * for the `value `attribute, so the resulting `ngModel` will always be a string.
>, <Line: +	 * Support for `select` models with non-string values is available via `ngOptions`.
>, <Line: +	 *
>, <Line: +	 * @element input
>, <Line: +	 * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute
>, <Line: +	 *   of the `input` element
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example name="ngValue-directive" module="valueExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('valueExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <form ng-controller="ExampleController">
>, <Line: +	 <h2>Which is your favorite?</h2>
>, <Line: +	 <label ng-repeat="name in names" for="{{name}}">
>, <Line: +	 {{name}}
>, <Line: +	 <input type="radio"
>, <Line: +	 ng-model="my.favorite"
>, <Line: +	 ng-value="name"
>, <Line: +	 id="{{name}}"
>, <Line: +	 name="favorite">
>, <Line: +	 </label>
>, <Line: +	 <div>You chose {{my.favorite}}</div>
>, <Line: +	 </form>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var favorite = element(by.binding('my.favorite'));
>, <Line: +	 it('should initialize to model', function() {
>, <Line: +	 it('should bind the values to the inputs', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngValueDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			priority: 100,
>, <Line: +			compile: function (tpl, tplAttr) {
>, <Line: +				if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
>, <Line: +					return function ngValueConstantLink(scope, elm, attr) {
>, <Line: +						attr.$set('value', scope.$eval(attr.ngValue));
>, <Line: +					};
>, <Line: +				} else {
>, <Line: +					return function ngValueLink(scope, elm, attr) {
>, <Line: +						scope.$watch(attr.ngValue, function valueWatchAction(value) {
>, <Line: +							attr.$set('value', value);
>, <Line: +						});
>, <Line: +					};
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	};
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngModelOptions
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Allows tuning how model updates are done. Using `ngModelOptions` you can specify a custom list of
>, <Line: +	 * events that will trigger a model update and/or a debouncing delay so that the actual update only
>, <Line: +	 * takes place when a timer expires; this timer will be reset after another change takes place.
>, <Line: +	 *
>, <Line: +	 * Given the nature of `ngModelOptions`, the value displayed inside input fields in the view might
>, <Line: +	 * be different than the value in the actual model. This means that if you update the model you
>, <Line: +	 * should also invoke {@link ngModel.NgModelController `$rollbackViewValue`} on the relevant input field in
>, <Line: +	 * order to make sure it is synchronized with the model and that any debounced action is canceled.
>, <Line: +	 *
>, <Line: +	 * The easiest way to reference the control's {@link ngModel.NgModelController `$rollbackViewValue`}
>, <Line: +	 * method is by making sure the input is placed inside a form that has a `name` attribute. This is
>, <Line: +	 * important because `form` controllers are published to the related scope under the name in their
>, <Line: +	 * `name` attribute.
>, <Line: +	 *
>, <Line: +	 * Any pending changes will take place immediately when an enclosing form is submitted via the
>, <Line: +	 * `submit` event. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
>, <Line: +	 * to have access to the updated model.
>, <Line: +	 *
>, <Line: +	 * `ngModelOptions` has an effect on the element it's declared on and its descendants.
>, <Line: +	 *
>, <Line: +	 * @param {Object} ngModelOptions options to apply to the current model. Valid keys are:
>, <Line: +	 *   - `updateOn`: string specifying which event should the input be bound to. You can set several
>, <Line: +	 *     events using an space delimited list. There is a special event called `default` that
>, <Line: +	 *     matches the default events belonging of the control.
>, <Line: +	 *   - `debounce`: integer value which contains the debounce model update value in milliseconds. A
>, <Line: +	 *     value of 0 triggers an immediate update. If an object is supplied instead, you can specify a
>, <Line: +	 *     custom value for each event. For example:
>, <Line: +	 *     `ng-model-options="{ updateOn: 'default blur', debounce: {'default': 500, 'blur': 0} }"`
>, <Line: +	 *   - `allowInvalid`: boolean value which indicates that the model can be set with values that did
>, <Line: +	 *     not validate correctly instead of the default behavior of setting the model to undefined.
>, <Line: +	 *   - `getterSetter`: boolean value which determines whether or not to treat functions bound to
>, <Line: +	 `ngModel` as getters/setters.
>, <Line: +	 *   - `timezone`: Defines the timezone to be used to read/write the `Date` instance in the model for
>, <Line: +	 *     `<input type="date">`, `<input type="time">`, ... . Right now, the only supported value is `'UTC'`,
>, <Line: +	 *     otherwise the default timezone of the browser will be used.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 The following example shows how to override immediate updates. Changes on the inputs within the
>, <Line: +	 form will update the model only when the control loses focus (blur event). If `escape` key is
>, <Line: +	 pressed while the input field is focused, the value is reset to the value in the current model.
>, <Line: +	 <example name="ngModelOptions-directive-blur" module="optionsExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form name="userForm">
>, <Line: +	 Name:
>, <Line: +	 <input type="text" name="userName"
>, <Line: +	 ng-model="user.name"
>, <Line: +	 ng-model-options="{ updateOn: 'blur' }"
>, <Line: +	 ng-keyup="cancel($event)" /><br />
>, <Line: +	 Other data:
>, <Line: +	 <input type="text" ng-model="user.data" /><br />
>, <Line: +	 </form>
>, <Line: +	 <pre>user.name = <span ng-bind="user.name"></span></pre>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="app.js">
>, <Line: +	 angular.module('optionsExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var model = element(by.binding('user.name'));
>, <Line: +	 var input = element(by.model('user.name'));
>, <Line: +	 var other = element(by.model('user.data'));
>, <Line: +	 it('should allow custom events', function() {
>, <Line: +	 it('should $rollbackViewValue when model changes', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 This one shows how to debounce model changes. Model will be updated only 1 sec after last change.
>, <Line: +	 If the `Clear` button is pressed, any debounced action is canceled and the value becomes empty.
>, <Line: +	 <example name="ngModelOptions-directive-debounce" module="optionsExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form name="userForm">
>, <Line: +	 Name:
>, <Line: +	 <input type="text" name="userName"
>, <Line: +	 ng-model="user.name"
>, <Line: +	 ng-model-options="{ debounce: 1000 }" />
>, <Line: +	 <button ng-click="userForm.userName.$rollbackViewValue(); user.name=''">Clear</button><br />
>, <Line: +	 </form>
>, <Line: +	 <pre>user.name = <span ng-bind="user.name"></span></pre>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="app.js">
>, <Line: +	 angular.module('optionsExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 This one shows how to bind to getter/setters:
>, <Line: +	 <example name="ngModelOptions-directive-getter-setter" module="getterSetterExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <form name="userForm">
>, <Line: +	 Name:
>, <Line: +	 <input type="text" name="userName"
>, <Line: +	 ng-model="user.name"
>, <Line: +	 ng-model-options="{ getterSetter: true }" />
>, <Line: +	 </form>
>, <Line: +	 <pre>user.name = <span ng-bind="user.name()"></span></pre>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="app.js">
>, <Line: +	 angular.module('getterSetterExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngModelOptionsDirective = function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			controller: ['$scope', '$attrs', function ($scope, $attrs) {
>, <Line: +				var that = this;
>, <Line: +				this.$options = $scope.$eval($attrs.ngModelOptions);
>, <Line: +				// Allow adding/overriding bound events
>, <Line: +				if (this.$options.updateOn !== undefined) {
>, <Line: +					this.$options.updateOnDefault = false;
>, <Line: +					// extract "default" pseudo-event from list of events that can trigger a model update
>, <Line: +					this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
>, <Line: +						that.$options.updateOnDefault = true;
>, <Line: +						return ' ';
>, <Line: +					}));
>, <Line: +				} else {
>, <Line: +					this.$options.updateOnDefault = true;
>, <Line: +				}
>, <Line: +			}]
>, <Line: +		};
>, <Line: +	};
>, <Line: +	function addSetValidityMethod(context) {
>, <Line: +		var ctrl = context.ctrl,
>, <Line: +			$element = context.$element,
>, <Line: +			classCache = {},
>, <Line: +			set = context.set,
>, <Line: +			unset = context.unset,
>, <Line: +			parentForm = context.parentForm,
>, <Line: +			$animate = context.$animate;
>, <Line: +		classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
>, <Line: +		ctrl.$setValidity = setValidity;
>, <Line: +		function setValidity(validationErrorKey, state, options) {
>, <Line: +			if (state === undefined) {
>, <Line: +				createAndSet('$pending', validationErrorKey, options);
>, <Line: +			} else {
>, <Line: +				unsetAndCleanup('$pending', validationErrorKey, options);
>, <Line: +			}
>, <Line: +			if (!isBoolean(state)) {
>, <Line: +				unset(ctrl.$error, validationErrorKey, options);
>, <Line: +				unset(ctrl.$$success, validationErrorKey, options);
>, <Line: +			} else {
>, <Line: +				if (state) {
>, <Line: +					unset(ctrl.$error, validationErrorKey, options);
>, <Line: +					set(ctrl.$$success, validationErrorKey, options);
>, <Line: +				} else {
>, <Line: +					set(ctrl.$error, validationErrorKey, options);
>, <Line: +					unset(ctrl.$$success, validationErrorKey, options);
>, <Line: +				}
>, <Line: +			}
>, <Line: +			if (ctrl.$pending) {
>, <Line: +				cachedToggleClass(PENDING_CLASS, true);
>, <Line: +				ctrl.$valid = ctrl.$invalid = undefined;
>, <Line: +				toggleValidationCss('', null);
>, <Line: +			} else {
>, <Line: +				cachedToggleClass(PENDING_CLASS, false);
>, <Line: +				ctrl.$valid = isObjectEmpty(ctrl.$error);
>, <Line: +				ctrl.$invalid = !ctrl.$valid;
>, <Line: +				toggleValidationCss('', ctrl.$valid);
>, <Line: +			}
>, <Line: +			// re-read the state as the set/unset methods could have
>, <Line: +			// combined state in ctrl.$error[validationError] (used for forms),
>, <Line: +			// where setting/unsetting only increments/decrements the value,
>, <Line: +			// and does not replace it.
>, <Line: +			var combinedState;
>, <Line: +			if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
>, <Line: +				combinedState = undefined;
>, <Line: +			} else if (ctrl.$error[validationErrorKey]) {
>, <Line: +				combinedState = false;
>, <Line: +			} else if (ctrl.$$success[validationErrorKey]) {
>, <Line: +				combinedState = true;
>, <Line: +			} else {
>, <Line: +				combinedState = null;
>, <Line: +			}
>, <Line: +			toggleValidationCss(validationErrorKey, combinedState);
>, <Line: +			parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
>, <Line: +		}
>, <Line: +		function createAndSet(name, value, options) {
>, <Line: +			if (!ctrl[name]) {
>, <Line: +				ctrl[name] = {};
>, <Line: +			}
>, <Line: +			set(ctrl[name], value, options);
>, <Line: +		}
>, <Line: +		function unsetAndCleanup(name, value, options) {
>, <Line: +			if (ctrl[name]) {
>, <Line: +				unset(ctrl[name], value, options);
>, <Line: +			}
>, <Line: +			if (isObjectEmpty(ctrl[name])) {
>, <Line: +				ctrl[name] = undefined;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function cachedToggleClass(className, switchValue) {
>, <Line: +			if (switchValue && !classCache[className]) {
>, <Line: +				$animate.addClass($element, className);
>, <Line: +				classCache[className] = true;
>, <Line: +			} else if (!switchValue && classCache[className]) {
>, <Line: +				$animate.removeClass($element, className);
>, <Line: +				classCache[className] = false;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		function toggleValidationCss(validationErrorKey, isValid) {
>, <Line: +			validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
>, <Line: +			cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
>, <Line: +			cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
>, <Line: +		}
>, <Line: +	}
>, <Line: +	function isObjectEmpty(obj) {
>, <Line: +		if (obj) {
>, <Line: +			for (var prop in obj) {
>, <Line: +				return false;
>, <Line: +			}
>, <Line: +		}
>, <Line: +		return true;
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngBind
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
>, <Line: +	 * with the value of a given expression, and to update the text content when the value of that
>, <Line: +	 * expression changes.
>, <Line: +	 *
>, <Line: +	 * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
>, <Line: +	 * `{{ expression }}` which is similar but less verbose.
>, <Line: +	 *
>, <Line: +	 * It is preferable to use `ngBind` instead of `{{ expression }}` if a template is momentarily
>, <Line: +	 * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an
>, <Line: +	 * element attribute, it makes the bindings invisible to the user while the page is loading.
>, <Line: +	 *
>, <Line: +	 * An alternative solution to this problem would be using the
>, <Line: +	 * {@link ng.directive:ngCloak ngCloak} directive.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
>, <Line: +	 <example module="bindExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('bindExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Enter name: <input type="text" ng-model="name"><br>
>, <Line: +	 Hello <span ng-bind="name"></span>!
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-bind', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngBindDirective = ['$compile', function ($compile) {
>, <Line: +		return {
>, <Line: +			restrict: 'AC',
>, <Line: +			compile: function ngBindCompile(templateElement) {
>, <Line: +				$compile.$$addBindingClass(templateElement);
>, <Line: +				return function ngBindLink(scope, element, attr) {
>, <Line: +					$compile.$$addBindingInfo(element, attr.ngBind);
>, <Line: +					element = element[0];
>, <Line: +					scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
>, <Line: +						element.textContent = value === undefined ? '' : value;
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngBindTemplate
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngBindTemplate` directive specifies that the element
>, <Line: +	 * text content should be replaced with the interpolation of the template
>, <Line: +	 * in the `ngBindTemplate` attribute.
>, <Line: +	 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
>, <Line: +	 * expressions. This directive is needed since some HTML elements
>, <Line: +	 * (such as TITLE and OPTION) cannot contain SPAN elements.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {string} ngBindTemplate template of form
>, <Line: +	 *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Try it here: enter text in text box and watch the greeting change.
>, <Line: +	 <example module="bindExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('bindExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Salutation: <input type="text" ng-model="salutation"><br>
>, <Line: +	 Name: <input type="text" ng-model="name"><br>
>, <Line: +	 <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-bind', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngBindTemplateDirective = ['$interpolate', '$compile', function ($interpolate, $compile) {
>, <Line: +		return {
>, <Line: +			compile: function ngBindTemplateCompile(templateElement) {
>, <Line: +				$compile.$$addBindingClass(templateElement);
>, <Line: +				return function ngBindTemplateLink(scope, element, attr) {
>, <Line: +					var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
>, <Line: +					$compile.$$addBindingInfo(element, interpolateFn.expressions);
>, <Line: +					element = element[0];
>, <Line: +					attr.$observe('ngBindTemplate', function (value) {
>, <Line: +						element.textContent = value === undefined ? '' : value;
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngBindHtml
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default,
>, <Line: +	 * the resulting HTML content will be sanitized using the {@link ngSanitize.$sanitize $sanitize} service.
>, <Line: +	 * To utilize this functionality, ensure that `$sanitize` is available, for example, by including {@link
>, <Line: +		* ngSanitize} in your module's dependencies (not in core Angular). In order to use {@link ngSanitize}
>, <Line: +	 * in your module's dependencies, you need to include "angular-sanitize.js" in your application.
>, <Line: +	 *
>, <Line: +	 * You may also bypass sanitization for values you know are safe. To do so, bind to
>, <Line: +	 * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example
>, <Line: +	 * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual Escaping (SCE)}.
>, <Line: +	 *
>, <Line: +	 * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
>, <Line: +	 * will have an exception (instead of an exploit.)
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="bindHtmlExample" deps="angular-sanitize.js">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <p ng-bind-html="myHTML"></p>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('bindHtmlExample', ['ngSanitize'])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-bind-html', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function ($sce, $parse, $compile) {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			compile: function ngBindHtmlCompile(tElement, tAttrs) {
>, <Line: +				var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
>, <Line: +				var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
>, <Line: +					return (value || '').toString();
>, <Line: +				});
>, <Line: +				$compile.$$addBindingClass(tElement);
>, <Line: +				return function ngBindHtmlLink(scope, element, attr) {
>, <Line: +					$compile.$$addBindingInfo(element, attr.ngBindHtml);
>, <Line: +					scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
>, <Line: +						// we re-evaluate the expr because we want a TrustedValueHolderType
>, <Line: +						// for $sce, not a string
>, <Line: +						element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	function classDirective(name, selector) {
>, <Line: +		name = 'ngClass' + name;
>, <Line: +		return ['$animate', function ($animate) {
>, <Line: +			return {
>, <Line: +				restrict: 'AC',
>, <Line: +				link: function (scope, element, attr) {
>, <Line: +					var oldVal;
>, <Line: +					scope.$watch(attr[name], ngClassWatchAction, true);
>, <Line: +					attr.$observe('class', function (value) {
>, <Line: +						ngClassWatchAction(scope.$eval(attr[name]));
>, <Line: +					});
>, <Line: +					if (name !== 'ngClass') {
>, <Line: +						scope.$watch('$index', function ($index, old$index) {
>, <Line: +							// jshint bitwise: false
>, <Line: +							var mod = $index & 1;
>, <Line: +							if (mod !== (old$index & 1)) {
>, <Line: +								var classes = arrayClasses(scope.$eval(attr[name]));
>, <Line: +								mod === selector ?
>, <Line: +									addClasses(classes) :
>, <Line: +									removeClasses(classes);
>, <Line: +							}
>, <Line: +						});
>, <Line: +					}
>, <Line: +					function addClasses(classes) {
>, <Line: +						var newClasses = digestClassCounts(classes, 1);
>, <Line: +						attr.$addClass(newClasses);
>, <Line: +					}
>, <Line: +					function removeClasses(classes) {
>, <Line: +						var newClasses = digestClassCounts(classes, -1);
>, <Line: +						attr.$removeClass(newClasses);
>, <Line: +					}
>, <Line: +					function digestClassCounts(classes, count) {
>, <Line: +						var classCounts = element.data('$classCounts') || {};
>, <Line: +						var classesToUpdate = [];
>, <Line: +						forEach(classes, function (className) {
>, <Line: +							if (count > 0 || classCounts[className]) {
>, <Line: +								classCounts[className] = (classCounts[className] || 0) + count;
>, <Line: +								if (classCounts[className] === +(count > 0)) {
>, <Line: +									classesToUpdate.push(className);
>, <Line: +								}
>, <Line: +							}
>, <Line: +						});
>, <Line: +						element.data('$classCounts', classCounts);
>, <Line: +						return classesToUpdate.join(' ');
>, <Line: +					}
>, <Line: +					function updateClasses(oldClasses, newClasses) {
>, <Line: +						var toAdd = arrayDifference(newClasses, oldClasses);
>, <Line: +						var toRemove = arrayDifference(oldClasses, newClasses);
>, <Line: +						toAdd = digestClassCounts(toAdd, 1);
>, <Line: +						toRemove = digestClassCounts(toRemove, -1);
>, <Line: +						if (toAdd && toAdd.length) {
>, <Line: +							$animate.addClass(element, toAdd);
>, <Line: +						}
>, <Line: +						if (toRemove && toRemove.length) {
>, <Line: +							$animate.removeClass(element, toRemove);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function ngClassWatchAction(newVal) {
>, <Line: +						if (selector === true || scope.$index % 2 === selector) {
>, <Line: +							var newClasses = arrayClasses(newVal || []);
>, <Line: +							if (!oldVal) {
>, <Line: +								addClasses(newClasses);
>, <Line: +							} else if (!equals(newVal, oldVal)) {
>, <Line: +								var oldClasses = arrayClasses(oldVal);
>, <Line: +								updateClasses(oldClasses, newClasses);
>, <Line: +							}
>, <Line: +						}
>, <Line: +						oldVal = shallowCopy(newVal);
>, <Line: +					}
>, <Line: +				}
>, <Line: +			};
>, <Line: +			function arrayDifference(tokens1, tokens2) {
>, <Line: +				var values = [];
>, <Line: +				outer:
>, <Line: +					for (var i = 0; i < tokens1.length; i++) {
>, <Line: +						var token = tokens1[i];
>, <Line: +						for (var j = 0; j < tokens2.length; j++) {
>, <Line: +							if (token == tokens2[j]) continue outer;
>, <Line: +						}
>, <Line: +						values.push(token);
>, <Line: +					}
>, <Line: +				return values;
>, <Line: +			}
>, <Line: +			function arrayClasses(classVal) {
>, <Line: +				if (isArray(classVal)) {
>, <Line: +					return classVal;
>, <Line: +				} else if (isString(classVal)) {
>, <Line: +					return classVal.split(' ');
>, <Line: +				} else if (isObject(classVal)) {
>, <Line: +					var classes = [];
>, <Line: +					forEach(classVal, function (v, k) {
>, <Line: +						if (v) {
>, <Line: +							classes = classes.concat(k.split(' '));
>, <Line: +						}
>, <Line: +					});
>, <Line: +					return classes;
>, <Line: +				}
>, <Line: +				return classVal;
>, <Line: +			}
>, <Line: +		}];
>, <Line: +	}
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngClass
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding
>, <Line: +	 * an expression that represents all classes to be added.
>, <Line: +	 *
>, <Line: +	 * The directive operates in three different ways, depending on which of three types the expression
>, <Line: +	 * evaluates to:
>, <Line: +	 *
>, <Line: +	 * 1. If the expression evaluates to a string, the string should be one or more space-delimited class
>, <Line: +	 * names.
>, <Line: +	 *
>, <Line: +	 * 2. If the expression evaluates to an array, each element of the array should be a string that is
>, <Line: +	 * one or more space-delimited class names.
>, <Line: +	 *
>, <Line: +	 * 3. If the expression evaluates to an object, then for each key-value pair of the
>, <Line: +	 * object with a truthy value the corresponding key is used as a class name.
>, <Line: +	 *
>, <Line: +	 * The directive won't add duplicate classes if a particular class was already set.
>, <Line: +	 *
>, <Line: +	 * When the expression changes, the previously added classes are removed and only then the
>, <Line: +	 * new classes are added.
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * add - happens just before the class is applied to the element
>, <Line: +	 * remove - happens just before the class is removed from the element
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
>, <Line: +	 *   of the evaluation can be a string representing space delimited class
>, <Line: +	 *   names, an array, or a map of class names to boolean values. In the case of a map, the
>, <Line: +	 *   names of the properties whose values are truthy will be added as css classes to the
>, <Line: +	 *   element.
>, <Line: +	 *
>, <Line: +	 * @example Example that demonstrates basic bindings via ngClass directive.
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <p ng-class="{strike: deleted, bold: important, red: error}">Map Syntax Example</p>
>, <Line: +	 <input type="checkbox" ng-model="deleted"> deleted (apply "strike" class)<br>
>, <Line: +	 <input type="checkbox" ng-model="important"> important (apply "bold" class)<br>
>, <Line: +	 <input type="checkbox" ng-model="error"> error (apply "red" class)
>, <Line: +	 <hr>
>, <Line: +	 <p ng-class="style">Using String Syntax</p>
>, <Line: +	 <input type="text" ng-model="style" placeholder="Type: bold strike red">
>, <Line: +	 <hr>
>, <Line: +	 <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
>, <Line: +	 <input ng-model="style1" placeholder="Type: bold, strike or red"><br>
>, <Line: +	 <input ng-model="style2" placeholder="Type: bold, strike or red"><br>
>, <Line: +	 <input ng-model="style3" placeholder="Type: bold, strike or red"><br>
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 .strike {
>, <Line: +	 .bold {
>, <Line: +	 .red {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var ps = element.all(by.css('p'));
>, <Line: +	 it('should let you toggle the class', function() {
>, <Line: +	 it('should let you toggle string example', function() {
>, <Line: +	 it('array example should have 3 classes', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 ## Animations
>, <Line: +	 The example below demonstrates how to perform animations using ngClass.
>, <Line: +	 <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input id="setbtn" type="button" value="set" ng-click="myVar='my-class'">
>, <Line: +	 <input id="clearbtn" type="button" value="clear" ng-click="myVar=''">
>, <Line: +	 <br>
>, <Line: +	 <span class="base-class" ng-class="myVar">Sample Text</span>
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 .base-class {
>, <Line: +	 .base-class.my-class {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-class', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 ## ngClass and pre-existing CSS3 Transitions/Animations
>, <Line: +	 The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
>, <Line: +	 Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder
>, <Line: +	 any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure
>, <Line: +	 to view the step by step details of {@link ng.$animate#addClass $animate.addClass} and
>, <Line: +	 {@link ng.$animate#removeClass $animate.removeClass}.
>, <Line: +	 */
>, <Line: +	var ngClassDirective = classDirective('', true);
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngClassOdd
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngClassOdd` and `ngClassEven` directives work exactly as
>, <Line: +	 * {@link ng.directive:ngClass ngClass}, except they work in
>, <Line: +	 * conjunction with `ngRepeat` and take effect only on odd (even) rows.
>, <Line: +	 *
>, <Line: +	 * This directive can be applied only within the scope of an
>, <Line: +	 * {@link ng.directive:ngRepeat ngRepeat}.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
>, <Line: +	 *   of the evaluation can be a string representing space delimited class names or an array.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
>, <Line: +	 <li ng-repeat="name in names">
>, <Line: +	 <span ng-class-odd="'odd'" ng-class-even="'even'">
>, <Line: +	 {{name}}
>, <Line: +	 </span>
>, <Line: +	 </li>
>, <Line: +	 </ol>
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 .odd {
>, <Line: +	 .even {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-class-odd and ng-class-even', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngClassOddDirective = classDirective('Odd', 0);
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngClassEven
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngClassOdd` and `ngClassEven` directives work exactly as
>, <Line: +	 * {@link ng.directive:ngClass ngClass}, except they work in
>, <Line: +	 * conjunction with `ngRepeat` and take effect only on odd (even) rows.
>, <Line: +	 *
>, <Line: +	 * This directive can be applied only within the scope of an
>, <Line: +	 * {@link ng.directive:ngRepeat ngRepeat}.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
>, <Line: +	 *   result of the evaluation can be a string representing space delimited class names or an array.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
>, <Line: +	 <li ng-repeat="name in names">
>, <Line: +	 <span ng-class-odd="'odd'" ng-class-even="'even'">
>, <Line: +	 {{name}} &nbsp; &nbsp; &nbsp;
>, <Line: +	 </span>
>, <Line: +	 </li>
>, <Line: +	 </ol>
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 .odd {
>, <Line: +	 .even {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-class-odd and ng-class-even', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngClassEvenDirective = classDirective('Even', 1);
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngCloak
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngCloak` directive is used to prevent the Angular html template from being briefly
>, <Line: +	 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
>, <Line: +	 * directive to avoid the undesirable flicker effect caused by the html template display.
>, <Line: +	 *
>, <Line: +	 * The directive can be applied to the `<body>` element, but the preferred usage is to apply
>, <Line: +	 * multiple `ngCloak` directives to small portions of the page to permit progressive rendering
>, <Line: +	 * of the browser view.
>, <Line: +	 *
>, <Line: +	 * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and
>, <Line: +	 * `angular.min.js`.
>, <Line: +	 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: +	 *
>, <Line: +	 * ```css
>, <Line: +	 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * When this css rule is loaded by the browser, all html elements (including their children) that
>, <Line: +	 * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive
>, <Line: +	 * during the compilation of the template it deletes the `ngCloak` element attribute, making
>, <Line: +	 * the compiled element visible.
>, <Line: +	 *
>, <Line: +	 * For the best result, the `angular.js` script must be loaded in the head section of the html
>, <Line: +	 * document; alternatively, the css rule above must be included in the external stylesheet of the
>, <Line: +	 * application.
>, <Line: +	 *
>, <Line: +	 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
>, <Line: +	 * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
>, <Line: +	 * class `ng-cloak` in addition to the `ngCloak` directive as shown in the example below.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div id="template1" ng-cloak>{{ 'hello' }}</div>
>, <Line: +	 <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should remove the template directive and css class', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	var ngCloakDirective = ngDirective({
>, <Line: +		compile: function (element, attr) {
>, <Line: +			attr.$set('ngCloak', undefined);
>, <Line: +			element.removeClass('ng-cloak');
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngController
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
>, <Line: +	 * supports the principles behind the Model-View-Controller design pattern.
>, <Line: +	 *
>, <Line: +	 * MVC components in angular:
>, <Line: +	 *
>, <Line: +	 * * Model  Models are the properties of a scope; scopes are attached to the DOM where scope properties
>, <Line: +	 *   are accessed through bindings.
>, <Line: +	 * * View  The template (HTML with data bindings) that is rendered into the View.
>, <Line: +	 * * Controller  The `ngController` directive specifies a Controller class; the class contains business
>, <Line: +	 *   logic behind the application to decorate the scope with functions and values
>, <Line: +	 *
>, <Line: +	 * Note that you can also attach controllers to the DOM by declaring it in a route definition
>, <Line: +	 * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller
>, <Line: +	 * again using `ng-controller` in the template itself.  This will cause the controller to be attached
>, <Line: +	 * and executed twice.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @scope
>, <Line: +	 * @priority 500
>, <Line: +	 * @param {expression} ngController Name of a constructor function registered with the current
>, <Line: +	 * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}
>, <Line: +	 * that on the current scope evaluates to a constructor function.
>, <Line: +	 *
>, <Line: +	 * The controller instance can be published into a scope property by specifying
>, <Line: +	 * `ng-controller="as propertyName"`.
>, <Line: +	 *
>, <Line: +	 * If the current `$controllerProvider` is configured to use globals (via
>, <Line: +	 * {@link ng.$controllerProvider#allowGlobals `$controllerProvider.allowGlobals()` }), this may
>, <Line: +	 * also be the name of a globally accessible constructor function (not recommended).
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * Here is a simple form for editing user contact information. Adding, removing, clearing, and
>, <Line: +	 * greeting are methods declared on the controller (see source tab). These methods can
>, <Line: +	 * easily be called from the angular markup. Any changes to the data are automatically reflected
>, <Line: +	 * in the View without the need for a manual update.
>, <Line: +	 *
>, <Line: +	 * Two different declaration styles are included below:
>, <Line: +	 *
>, <Line: +	 * * one binds methods and properties directly onto the controller using `this`:
>, <Line: +	 * `ng-controller="SettingsController1 as settings"`
>, <Line: +	 * * one injects `$scope` into the controller:
>, <Line: +	 * `ng-controller="SettingsController2"`
>, <Line: +	 *
>, <Line: +	 * The second option is more common in the Angular community, and is generally used in boilerplates
>, <Line: +	 * and in this guide. However, there are advantages to binding properties directly to the controller
>, <Line: +	 * and avoiding scope.
>, <Line: +	 *
>, <Line: +	 * * Using `controller as` makes it obvious which controller you are accessing in the template when
>, <Line: +	 * multiple controllers apply to an element.
>, <Line: +	 * * If you are writing your controllers as classes you have easier access to the properties and
>, <Line: +	 * methods, which will appear on the scope, from inside the controller code.
>, <Line: +	 * * Since there is always a `.` in the bindings, you don't have to worry about prototypal
>, <Line: +	 * inheritance masking primitives.
>, <Line: +	 *
>, <Line: +	 * This example demonstrates the `controller as` syntax.
>, <Line: +	 *
>, <Line: +	 * <example name="ngControllerAs" module="controllerAsExample">
>, <Line: +	 *   <file name="index.html">
>, <Line: +	 *    <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
>, <Line: +	 *      Name: <input type="text" ng-model="settings.name"/>
>, <Line: +	 *      [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
>, <Line: +	 *      Contact:
>, <Line: +	 *      <ul>
>, <Line: +	 *        <li ng-repeat="contact in settings.contacts">
>, <Line: +	 *          <select ng-model="contact.type">
>, <Line: +	 *             <option>phone</option>
>, <Line: +	 *             <option>email</option>
>, <Line: +	 *          </select>
>, <Line: +	 *          <input type="text" ng-model="contact.value"/>
>, <Line: +	 *          [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
>, <Line: +	 *          | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
>, <Line: +	 *        </li>
>, <Line: +	 *        <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
>, <Line: +	 *     </ul>
>, <Line: +	 *    </div>
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="app.js">
>, <Line: +	 *    angular.module('controllerAsExample', [])
>, <Line: +	 *      .controller('SettingsController1', SettingsController1);
>, <Line: +	 *
>, <Line: +	 *    function SettingsController1() {
>, <Line: +	 *
>, <Line: +	 *    SettingsController1.prototype.greet = function() {
>, <Line: +	 *
>, <Line: +	 *    SettingsController1.prototype.addContact = function() {
>, <Line: +	 *
>, <Line: +	 *    SettingsController1.prototype.removeContact = function(contactToRemove) {
>, <Line: +	 *
>, <Line: +	 *    SettingsController1.prototype.clearContact = function(contact) {
>, <Line: +	 *   </file>
>, <Line: +	 *   <file name="protractor.js" type="protractor">
>, <Line: +	 *     it('should check controller as', function() {
>, <Line: +	 *   </file>
>, <Line: +	 * </example>
>, <Line: +	 *
>, <Line: +	 * This example demonstrates the "attach to `$scope`" style of controller.
>, <Line: +	 *
>, <Line: +	 * <example name="ngController" module="controllerExample">
>, <Line: +	 *  <file name="index.html">
>, <Line: +	 *   <div id="ctrl-exmpl" ng-controller="SettingsController2">
>, <Line: +	 *     Name: <input type="text" ng-model="name"/>
>, <Line: +	 *     [ <a href="" ng-click="greet()">greet</a> ]<br/>
>, <Line: +	 *     Contact:
>, <Line: +	 *     <ul>
>, <Line: +	 *       <li ng-repeat="contact in contacts">
>, <Line: +	 *         <select ng-model="contact.type">
>, <Line: +	 *            <option>phone</option>
>, <Line: +	 *            <option>email</option>
>, <Line: +	 *         </select>
>, <Line: +	 *         <input type="text" ng-model="contact.value"/>
>, <Line: +	 *         [ <a href="" ng-click="clearContact(contact)">clear</a>
>, <Line: +	 *         | <a href="" ng-click="removeContact(contact)">X</a> ]
>, <Line: +	 *       </li>
>, <Line: +	 *       <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
>, <Line: +	 *    </ul>
>, <Line: +	 *   </div>
>, <Line: +	 *  </file>
>, <Line: +	 *  <file name="app.js">
>, <Line: +	 *   angular.module('controllerExample', [])
>, <Line: +	 *     .controller('SettingsController2', ['$scope', SettingsController2]);
>, <Line: +	 *
>, <Line: +	 *   function SettingsController2($scope) {
>, <Line: +	 *  </file>
>, <Line: +	 *  <file name="protractor.js" type="protractor">
>, <Line: +	 *    it('should check controller', function() {
>, <Line: +	 *  </file>
>, <Line: +	 *</example>
>, <Line: +	 */
>, <Line: +	var ngControllerDirective = [function () {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			scope: true,
>, <Line: +			controller: '@',
>, <Line: +			priority: 500
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngCsp
>, <Line: +	 *
>, <Line: +	 * @element html
>, <Line: +	 * @description
>, <Line: +	 * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
>, <Line: +	 *
>, <Line: +	 * This is necessary when developing things like Google Chrome Extensions or Universal Windows Apps.
>, <Line: +	 *
>, <Line: +	 * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
>, <Line: +	 * For Angular to be CSP compatible there are only two things that we need to do differently:
>, <Line: +	 *
>, <Line: +	 * - don't use `Function` constructor to generate optimized value getters
>, <Line: +	 * - don't inject custom stylesheet into the document
>, <Line: +	 *
>, <Line: +	 * AngularJS uses `Function(string)` generated functions as a speed optimization. Applying the `ngCsp`
>, <Line: +	 * directive will cause Angular to use CSP compatibility mode. When this mode is on AngularJS will
>, <Line: +	 * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
>, <Line: +	 * be raised.
>, <Line: +	 *
>, <Line: +	 * CSP forbids JavaScript to inline stylesheet rules. In non CSP mode Angular automatically
>, <Line: +	 * includes some CSS rules (e.g. {@link ng.directive:ngCloak ngCloak}).
>, <Line: +	 * To make those directives work in CSP mode, include the `angular-csp.css` manually.
>, <Line: +	 *
>, <Line: +	 * Angular tries to autodetect if CSP is active and automatically turn on the CSP-safe mode. This
>, <Line: +	 * autodetection however triggers a CSP error to be logged in the console:
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of
>, <Line: +	 * script in the following Content Security Policy directive: "default-src 'self'". Note that
>, <Line: +	 * 'script-src' was not explicitly set, so 'default-src' is used as a fallback.
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * This error is harmless but annoying. To prevent the error from showing up, put the `ngCsp`
>, <Line: +	 * directive on the root element of the application or on the `angular.js` script tag, whichever
>, <Line: +	 * appears first in the html document.
>, <Line: +	 *
>, <Line: +	 * *Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * This example shows how to apply the `ngCsp` directive to the `html` tag.
>, <Line: +	 ```html
>, <Line: +	 <!doctype html>
>, <Line: +	 <html ng-app ng-csp>
>, <Line: +	 ...
>, <Line: +	 ...
>, <Line: +	 </html>
>, <Line: +	 ```
>, <Line: +	 * @example
>, <Line: +	 // Note: the suffix `.csp` in the example name triggers
>, <Line: +	 // csp mode in our http server!
>, <Line: +	 <example name="example.csp" module="cspExample" ng-csp="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="MainController as ctrl">
>, <Line: +	 <div>
>, <Line: +	 <button ng-click="ctrl.inc()" id="inc">Increment</button>
>, <Line: +	 <span id="counter">
>, <Line: +	 {{ctrl.counter}}
>, <Line: +	 </span>
>, <Line: +	 </div>
>, <Line: +	 <div>
>, <Line: +	 <button ng-click="ctrl.evil()" id="evil">Evil</button>
>, <Line: +	 <span id="evilError">
>, <Line: +	 {{ctrl.evilError}}
>, <Line: +	 </span>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('cspExample', [])
>, <Line: +	 .controller('MainController', function() {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var util, webdriver;
>, <Line: +	 var incBtn = element(by.id('inc'));
>, <Line: +	 var counter = element(by.id('counter'));
>, <Line: +	 var evilBtn = element(by.id('evil'));
>, <Line: +	 var evilError = element(by.id('evilError'));
>, <Line: +	 function getAndClearSevereErrors() {
>, <Line: +	 function clearErrors() {
>, <Line: +	 function expectNoErrors() {
>, <Line: +	 function expectError(regex) {
>, <Line: +	 beforeEach(function() {
>, <Line: +	 // For now, we only test on Chrome,
>, <Line: +	 // as Safari does not load the page with Protractor's injected scripts,
>, <Line: +	 // and Firefox webdriver always disables content security policy (#6358)
>, <Line: +	 if (browser.params.browser !== 'chrome') {
>, <Line: +	 it('should not report errors when the page is loaded', function() {
>, <Line: +	 it('should evaluate expressions', function() {
>, <Line: +	 it('should throw and report an error when using "eval"', function() {
>, <Line: +            expectError(/Content Security Policy/);
>, <Line: +          });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +// ngCsp is not implemented as a proper directive any more, because we need it be processed while we
>, <Line: +// bootstrap the system (before $parse is instantiated), for this reason we just have
>, <Line: +// the csp.isActive() fn that looks for ng-csp attribute anywhere in the current doc
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngClick
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The ngClick directive allows you to specify custom behavior when
>, <Line: +	 * an element is clicked.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * click. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-click="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment
>, <Line: +	 </button>
>, <Line: +	 <span>
>, <Line: +	 count: {{count}}
>, <Line: +	 </span>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-click', function() {
>, <Line: +         expect(element(by.binding('count')).getText()).toMatch('0');
>, <Line: +         element(by.css('button')).click();
>, <Line: +         expect(element(by.binding('count')).getText()).toMatch('1');
>, <Line: +       });
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/*
>, <Line: +	 * A collection of directives that allows creation of custom event handlers that are defined as
>, <Line: +	 * angular expressions and are compiled and executed within the current scope.
>, <Line: +	 */
>, <Line: +	var ngEventDirectives = {};
>, <Line: +// For events that might fire synchronously during DOM manipulation
>, <Line: +// we need to execute their event handlers asynchronously using $evalAsync,
>, <Line: +// so that they are not executed in an inconsistent state.
>, <Line: +	var forceAsyncEvents = {
>, <Line: +		'blur': true,
>, <Line: +		'focus': true
>, <Line: +	};
>, <Line: +	forEach(
>, <Line: +		'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
>, <Line: +		function (eventName) {
>, <Line: +			var directiveName = directiveNormalize('ng-' + eventName);
>, <Line: +			ngEventDirectives[directiveName] = ['$parse', '$rootScope', function ($parse, $rootScope) {
>, <Line: +				return {
>, <Line: +					restrict: 'A',
>, <Line: +					compile: function ($element, attr) {
>, <Line: +						// We expose the powerful $event object on the scope that provides access to the Window,
>, <Line: +						// etc. that isn't protected by the fast paths in $parse.  We explicitly request better
>, <Line: +						// checks at the cost of speed since event handler expressions are not executed as
>, <Line: +						// frequently as regular change detection.
>, <Line: +						var fn = $parse(attr[directiveName], /* interceptorFn */ null, /* expensiveChecks */ true);
>, <Line: +						return function ngEventHandler(scope, element) {
>, <Line: +							element.on(eventName, function (event) {
>, <Line: +								var callback = function () {
>, <Line: +									fn(scope, {$event: event});
>, <Line: +								};
>, <Line: +								if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
>, <Line: +									scope.$evalAsync(callback);
>, <Line: +								} else {
>, <Line: +									scope.$apply(callback);
>, <Line: +								}
>, <Line: +							});
>, <Line: +						};
>, <Line: +					}
>, <Line: +				};
>, <Line: +			}];
>, <Line: +		}
>, <Line: +	);
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngDblclick
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * a dblclick. (The Event object is available as `$event`)
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-dblclick="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (on double click)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMousedown
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mousedown="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (on mouse down)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMouseup
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on mouseup event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mouseup="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (on mouse up)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMouseover
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on mouseover event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mouseover="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (when mouse is over)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMouseenter
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on mouseenter event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mouseenter="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (when mouse enters)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMouseleave
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on mouseleave event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mouseleave="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (when mouse leaves)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngMousemove
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on mousemove event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <button ng-mousemove="count = count + 1" ng-init="count=0">
>, <Line: +	 Increment (when mouse moves)
>, <Line: +	 </button>
>, <Line: +	 count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngKeydown
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on keydown event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-keydown="count = count + 1" ng-init="count=0">
>, <Line: +	 key down count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngKeyup
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on keyup event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <p>Typing in the input box below updates the key count</p>
>, <Line: +	 <input ng-keyup="count = count + 1" ng-init="count=0"> key up count: {{count}}
>, <Line: +	 <p>Typing in the input box below updates the keycode</p>
>, <Line: +	 <input ng-keyup="event=$event">
>, <Line: +	 <p>event keyCode: {{ event.keyCode }}</p>
>, <Line: +	 <p>event altKey: {{ event.altKey }}</p>
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngKeypress
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on keypress event.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
>, <Line: +	 * and can be interrogated for keyCode, altKey, etc.)
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-keypress="count = count + 1" ng-init="count=0">
>, <Line: +	 key press count: {{count}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngSubmit
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Enables binding angular expressions to onsubmit events.
>, <Line: +	 *
>, <Line: +	 * Additionally it prevents the default action (which for form means sending the request to the
>, <Line: +	 * server and reloading the current page), but only if the form does not contain `action`,
>, <Line: +	 * `data-action`, or `x-action` attributes.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Warning:** Be careful not to cause "double-submission" by using both the `ngClick` and
>, <Line: +	 * `ngSubmit` handlers together. See the
>, <Line: +	 * {@link form#submitting-a-form-and-preventing-the-default-action `form` directive documentation}
>, <Line: +	 * for a detailed discussion of when `ngSubmit` may be triggered.
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * @element form
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
>, <Line: +	 * ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="submitExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('submitExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <form ng-submit="submit()" ng-controller="ExampleController">
>, <Line: +	 Enter text and hit enter:
>, <Line: +	 <input type="text" ng-model="text" name="text" />
>, <Line: +	 <input type="submit" id="submit" value="Submit" />
>, <Line: +	 <pre>list={{list}}</pre>
>, <Line: +	 </form>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-submit', function() {
>, <Line: +	 it('should ignore empty strings', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngFocus
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on focus event.
>, <Line: +	 *
>, <Line: +	 * Note: As the `focus` event is executed synchronously when calling `input.focus()`
>, <Line: +	 * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
>, <Line: +	 * during an `$apply` to ensure a consistent state.
>, <Line: +	 *
>, <Line: +	 * @element window, input, select, textarea, a
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * focus. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * See {@link ng.directive:ngClick ngClick}
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngBlur
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on blur event.
>, <Line: +	 *
>, <Line: +	 * A [blur event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires when
>, <Line: +	 * an element has lost focus.
>, <Line: +	 *
>, <Line: +	 * Note: As the `blur` event is executed synchronously also during DOM manipulations
>, <Line: +	 * (e.g. removing a focussed input),
>, <Line: +	 * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
>, <Line: +	 * during an `$apply` to ensure a consistent state.
>, <Line: +	 *
>, <Line: +	 * @element window, input, select, textarea, a
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * blur. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * See {@link ng.directive:ngClick ngClick}
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngCopy
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on copy event.
>, <Line: +	 *
>, <Line: +	 * @element window, input, select, textarea, a
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * copy. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
>, <Line: +	 copied: {{copied}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngCut
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on cut event.
>, <Line: +	 *
>, <Line: +	 * @element window, input, select, textarea, a
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * cut. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
>, <Line: +	 cut: {{cut}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngPaste
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Specify custom behavior on paste event.
>, <Line: +	 *
>, <Line: +	 * @element window, input, select, textarea, a
>, <Line: +	 * @priority 0
>, <Line: +	 * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
>, <Line: +	 * paste. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
>, <Line: +	 pasted: {{paste}}
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngIf
>, <Line: +	 * @restrict A
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
>, <Line: +	 * {expression}. If the expression assigned to `ngIf` evaluates to a false
>, <Line: +	 * value then the element is removed from the DOM, otherwise a clone of the
>, <Line: +	 * element is reinserted into the DOM.
>, <Line: +	 *
>, <Line: +	 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
>, <Line: +	 * element in the DOM rather than changing its visibility via the `display` css property.  A common
>, <Line: +	 * case when this difference is significant is when using css selectors that rely on an element's
>, <Line: +	 * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.
>, <Line: +	 *
>, <Line: +	 * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope
>, <Line: +	 * is created when the element is restored.  The scope created within `ngIf` inherits from
>, <Line: +	 * its parent scope using
>, <Line: +	 * [prototypal inheritance](https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance).
>, <Line: +	 * An important implication of this is if `ngModel` is used within `ngIf` to bind to
>, <Line: +	 * a javascript primitive defined in the parent scope. In this case any modifications made to the
>, <Line: +	 * variable within the child scope will override (hide) the value in the parent scope.
>, <Line: +	 *
>, <Line: +	 * Also, `ngIf` recreates elements using their compiled state. An example of this behavior
>, <Line: +	 * is if an element's class attribute is directly modified after it's compiled, using something like
>, <Line: +	 * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
>, <Line: +	 * the added class will be lost because the original compiled state is used to regenerate the element.
>, <Line: +	 *
>, <Line: +	 * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
>, <Line: +	 * and `leave` effects.
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * enter - happens just after the `ngIf` contents change and a new DOM element is created and injected into the `ngIf` container
>, <Line: +	 * leave - happens just before the `ngIf` contents are removed from the DOM
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @scope
>, <Line: +	 * @priority 600
>, <Line: +	 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
>, <Line: +	 *     the element is removed from the DOM tree. If it is truthy a copy of the compiled
>, <Line: +	 *     element is added to the DOM tree.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
>, <Line: +	 Show when checked:
>, <Line: +	 <span ng-if="checked" class="animate-if">
>, <Line: +	 This is removed when the checkbox is unchecked.
>, <Line: +	 </span>
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .animate-if {
>, <Line: +	 .animate-if.ng-enter, .animate-if.ng-leave {
>, <Line: +	 .animate-if.ng-enter,
>, <Line: +	 .animate-if.ng-leave.ng-leave-active {
>, <Line: +	 .animate-if.ng-leave,
>, <Line: +	 .animate-if.ng-enter.ng-enter-active {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngIfDirective = ['$animate', function ($animate) {
>, <Line: +		return {
>, <Line: +			multiElement: true,
>, <Line: +			transclude: 'element',
>, <Line: +			priority: 600,
>, <Line: +			terminal: true,
>, <Line: +			restrict: 'A',
>, <Line: +			$$tlb: true,
>, <Line: +			link: function ($scope, $element, $attr, ctrl, $transclude) {
>, <Line: +				var block, childScope, previousElements;
>, <Line: +				$scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
>, <Line: +					if (value) {
>, <Line: +						if (!childScope) {
>, <Line: +							$transclude(function (clone, newScope) {
>, <Line: +								childScope = newScope;
>, <Line: +								clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
>, <Line: +								// Note: We only need the first/last node of the cloned nodes.
>, <Line: +								// However, we need to keep the reference to the jqlite wrapper as it might be changed later
>, <Line: +								// by a directive with templateUrl when its template arrives.
>, <Line: +								block = {
>, <Line: +									clone: clone
>, <Line: +								};
>, <Line: +								$animate.enter(clone, $element.parent(), $element);
>, <Line: +							});
>, <Line: +						}
>, <Line: +					} else {
>, <Line: +						if (previousElements) {
>, <Line: +							previousElements.remove();
>, <Line: +							previousElements = null;
>, <Line: +						}
>, <Line: +						if (childScope) {
>, <Line: +							childScope.$destroy();
>, <Line: +							childScope = null;
>, <Line: +						}
>, <Line: +						if (block) {
>, <Line: +							previousElements = getBlockNodes(block.clone);
>, <Line: +							$animate.leave(previousElements).then(function () {
>, <Line: +								previousElements = null;
>, <Line: +							});
>, <Line: +							block = null;
>, <Line: +						}
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngInclude
>, <Line: +	 * @restrict ECA
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Fetches, compiles and includes an external HTML fragment.
>, <Line: +	 *
>, <Line: +	 * By default, the template URL is restricted to the same domain and protocol as the
>, <Line: +	 * application document. This is done by calling {@link $sce#getTrustedResourceUrl
>, <Line: +	 * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
>, <Line: +	 * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link
>, <Line: +		* ng.$sce Strict Contextual Escaping}.
>, <Line: +	 *
>, <Line: +	 * In addition, the browser's
>, <Line: +	 * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
>, <Line: +	 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
>, <Line: +	 * policy may further restrict whether the template is successfully loaded.
>, <Line: +	 * For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`
>, <Line: +	 * access on some browsers.
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * enter - animation is used to bring new content into the browser.
>, <Line: +	 * leave - animation is used to animate existing content away.
>, <Line: +	 *
>, <Line: +	 * The enter and leave animation occur concurrently.
>, <Line: +	 *
>, <Line: +	 * @scope
>, <Line: +	 * @priority 400
>, <Line: +	 *
>, <Line: +	 * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
>, <Line: +	 *                 make sure you wrap it in **single** quotes, e.g. `src="'myPartialTemplate.html'"`.
>, <Line: +	 * @param {string=} onload Expression to evaluate when a new partial is loaded.
>, <Line: +	 *
>, <Line: +	 * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
>, <Line: +	 *
>, <Line: +	 *                  - If the attribute is not set, disable scrolling.
>, <Line: +	 *                  - If the attribute is set without value, enable scrolling.
>, <Line: +	 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="includeExample" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <select ng-model="template" ng-options="t.name for t in templates">
>, <Line: +	 <option value="">(blank)</option>
>, <Line: +	 </select>
>, <Line: +	 url of the template: <tt>{{template.url}}</tt>
>, <Line: +	 <hr/>
>, <Line: +	 <div class="slide-animate-container">
>, <Line: +	 <div class="slide-animate" ng-include="template.url"></div>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('includeExample', ['ngAnimate'])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 <file name="template1.html">
>, <Line: +	 Content of template1.html
>, <Line: +	 </file>
>, <Line: +	 <file name="template2.html">
>, <Line: +	 Content of template2.html
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .slide-animate-container {
>, <Line: +	 .slide-animate {
>, <Line: +	 .slide-animate.ng-enter, .slide-animate.ng-leave {
>, <Line: +	 .slide-animate.ng-enter {
>, <Line: +	 .slide-animate.ng-enter.ng-enter-active {
>, <Line: +	 .slide-animate.ng-leave {
>, <Line: +	 .slide-animate.ng-leave.ng-leave-active {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var templateSelect = element(by.model('template'));
>, <Line: +	 var includeElem = element(by.css('[ng-include]'));
>, <Line: +	 it('should load template1.html', function() {
>, <Line: +	 it('should load template2.html', function() {
>, <Line: +	 it('should change to blank', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc event
>, <Line: +	 * @name ngInclude#$includeContentRequested
>, <Line: +	 * @eventType emit on the scope ngInclude was declared in
>, <Line: +	 * @description
>, <Line: +	 * Emitted every time the ngInclude content is requested.
>, <Line: +	 *
>, <Line: +	 * @param {Object} angularEvent Synthetic event object.
>, <Line: +	 * @param {String} src URL of content to load.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc event
>, <Line: +	 * @name ngInclude#$includeContentLoaded
>, <Line: +	 * @eventType emit on the current ngInclude scope
>, <Line: +	 * @description
>, <Line: +	 * Emitted every time the ngInclude content is reloaded.
>, <Line: +	 *
>, <Line: +	 * @param {Object} angularEvent Synthetic event object.
>, <Line: +	 * @param {String} src URL of content to load.
>, <Line: +	 */
>, <Line: +	/**
>, <Line: +	 * @ngdoc event
>, <Line: +	 * @name ngInclude#$includeContentError
>, <Line: +	 * @eventType emit on the scope ngInclude was declared in
>, <Line: +	 * @description
>, <Line: +	 * Emitted when a template HTTP request yields an erronous response (status < 200 || status > 299)
>, <Line: +	 *
>, <Line: +	 * @param {Object} angularEvent Synthetic event object.
>, <Line: +	 * @param {String} src URL of content to load.
>, <Line: +	 */
>, <Line: +	var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', '$sce',
>, <Line: +		function ($templateRequest, $anchorScroll, $animate, $sce) {
>, <Line: +			return {
>, <Line: +				restrict: 'ECA',
>, <Line: +				priority: 400,
>, <Line: +				terminal: true,
>, <Line: +				transclude: 'element',
>, <Line: +				controller: angular.noop,
>, <Line: +				compile: function (element, attr) {
>, <Line: +					var srcExp = attr.ngInclude || attr.src,
>, <Line: +						onloadExp = attr.onload || '',
>, <Line: +						autoScrollExp = attr.autoscroll;
>, <Line: +					return function (scope, $element, $attr, ctrl, $transclude) {
>, <Line: +						var changeCounter = 0,
>, <Line: +							currentScope,
>, <Line: +							previousElement,
>, <Line: +							currentElement;
>, <Line: +						var cleanupLastIncludeContent = function () {
>, <Line: +							if (previousElement) {
>, <Line: +								previousElement.remove();
>, <Line: +								previousElement = null;
>, <Line: +							}
>, <Line: +							if (currentScope) {
>, <Line: +								currentScope.$destroy();
>, <Line: +								currentScope = null;
>, <Line: +							}
>, <Line: +							if (currentElement) {
>, <Line: +								$animate.leave(currentElement).then(function () {
>, <Line: +									previousElement = null;
>, <Line: +								});
>, <Line: +								previousElement = currentElement;
>, <Line: +								currentElement = null;
>, <Line: +							}
>, <Line: +						};
>, <Line: +						scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
>, <Line: +							var afterAnimation = function () {
>, <Line: +								if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
>, <Line: +									$anchorScroll();
>, <Line: +								}
>, <Line: +							};
>, <Line: +							var thisChangeId = ++changeCounter;
>, <Line: +							if (src) {
>, <Line: +								//set the 2nd param to true to ignore the template request error so that the inner
>, <Line: +								//contents and scope can be cleaned up.
>, <Line: +								$templateRequest(src, true).then(function (response) {
>, <Line: +									if (thisChangeId !== changeCounter) return;
>, <Line: +									var newScope = scope.$new();
>, <Line: +									ctrl.template = response;
>, <Line: +									// Note: This will also link all children of ng-include that were contained in the original
>, <Line: +									// html. If that content contains controllers, ... they could pollute/change the scope.
>, <Line: +									// However, using ng-include on an element with additional content does not make sense...
>, <Line: +									// Note: We can't remove them in the cloneAttchFn of $transclude as that
>, <Line: +									// function is called before linking the content, which would apply child
>, <Line: +									// directives to non existing elements.
>, <Line: +									var clone = $transclude(newScope, function (clone) {
>, <Line: +										cleanupLastIncludeContent();
>, <Line: +										$animate.enter(clone, null, $element).then(afterAnimation);
>, <Line: +									});
>, <Line: +									currentScope = newScope;
>, <Line: +									currentElement = clone;
>, <Line: +									currentScope.$emit('$includeContentLoaded', src);
>, <Line: +									scope.$eval(onloadExp);
>, <Line: +								}, function () {
>, <Line: +									if (thisChangeId === changeCounter) {
>, <Line: +										cleanupLastIncludeContent();
>, <Line: +										scope.$emit('$includeContentError', src);
>, <Line: +									}
>, <Line: +								});
>, <Line: +								scope.$emit('$includeContentRequested', src);
>, <Line: +							} else {
>, <Line: +								cleanupLastIncludeContent();
>, <Line: +								ctrl.template = null;
>, <Line: +							}
>, <Line: +						});
>, <Line: +					};
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	var ngIncludeFillContentDirective = ['$compile',
>, <Line: +		function ($compile) {
>, <Line: +			return {
>, <Line: +				restrict: 'ECA',
>, <Line: +				priority: -400,
>, <Line: +				require: 'ngInclude',
>, <Line: +				link: function (scope, $element, $attr, ctrl) {
>, <Line: +					if (/SVG/.test($element[0].toString())) {
>, <Line: +						// WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not
>, <Line: +						// support innerHTML, so detect this here and try to generate the contents
>, <Line: +						// specially.
>, <Line: +						$element.empty();
>, <Line: +						$compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
>, <Line: +							function namespaceAdaptedClone(clone) {
>, <Line: +								$element.append(clone);
>, <Line: +							}, {futureParentElement: $element});
>, <Line: +						return;
>, <Line: +					}
>, <Line: +					$element.html(ctrl.template);
>, <Line: +					$compile($element.contents())(scope);
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngInit
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngInit` directive allows you to evaluate an expression in the
>, <Line: +	 * current scope.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-error">
>, <Line: +	 * The only appropriate use of `ngInit` is for aliasing special properties of
>, <Line: +	 * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you
>, <Line: +	 * should use {@link guide/controller controllers} rather than `ngInit`
>, <Line: +	 * to initialize values on a scope.
>, <Line: +	 * </div>
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note**: If you have assignment in `ngInit` along with {@link ng.$filter `$filter`}, make
>, <Line: +	 * sure you have parenthesis for correct precedence:
>, <Line: +	 * <pre class="prettyprint">
>, <Line: +	 *   <div ng-init="test1 = (data | orderBy:'name')"></div>
>, <Line: +	 * </pre>
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * @priority 450
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngInit {@link guide/expression Expression} to eval.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="initExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('initExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <div ng-repeat="innerList in list" ng-init="outerIndex = $index">
>, <Line: +	 <div ng-repeat="value in innerList" ng-init="innerIndex = $index">
>, <Line: +	 <span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};</span>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should alias index positions', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngInitDirective = ngDirective({
>, <Line: +		priority: 450,
>, <Line: +		compile: function () {
>, <Line: +			return {
>, <Line: +				pre: function (scope, element, attrs) {
>, <Line: +					scope.$eval(attrs.ngInit);
>, <Line: +				}
>, <Line: +			};
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngNonBindable
>, <Line: +	 * @restrict AC
>, <Line: +	 * @priority 1000
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current
>, <Line: +	 * DOM element. This is useful if the element contains what appears to be Angular directives and
>, <Line: +	 * bindings but which should be ignored by Angular. This could be the case if you have a site that
>, <Line: +	 * displays snippets of code, for instance.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,
>, <Line: +	 * but the one wrapped in `ngNonBindable` is left alone.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div>Normal: {{1 + 2}}</div>
>, <Line: +	 <div ng-non-bindable>Ignored: {{1 + 2}}</div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-non-bindable', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngNonBindableDirective = ngDirective({terminal: true, priority: 1000});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngPluralize
>, <Line: +	 * @restrict EA
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * `ngPluralize` is a directive that displays messages according to en-US localization rules.
>, <Line: +	 * These rules are bundled with angular.js, but can be overridden
>, <Line: +	 * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
>, <Line: +	 * by specifying the mappings between
>, <Line: +	 * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
>, <Line: +	 * and the strings to be displayed.
>, <Line: +	 *
>, <Line: +	 * # Plural categories and explicit number rules
>, <Line: +	 * There are two
>, <Line: +	 * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
>, <Line: +	 * in Angular's default en-US locale: "one" and "other".
>, <Line: +	 *
>, <Line: +	 * While a plural category may match many numbers (for example, in en-US locale, "other" can match
>, <Line: +	 * any number that is not 1), an explicit number rule can only match one number. For example, the
>, <Line: +	 * explicit number rule for "3" matches the number 3. There are examples of plural categories
>, <Line: +	 * and explicit number rules throughout the rest of this documentation.
>, <Line: +	 *
>, <Line: +	 * # Configuring ngPluralize
>, <Line: +	 * You configure ngPluralize by providing 2 attributes: `count` and `when`.
>, <Line: +	 * You can also provide an optional attribute, `offset`.
>, <Line: +	 *
>, <Line: +	 * The value of the `count` attribute can be either a string or an {@link guide/expression
>, <Line: +	 *
>, <Line: +	 * The `when` attribute specifies the mappings between plural categories and the actual
>, <Line: +	 * string to be displayed. The value of the attribute should be a JSON object.
>, <Line: +	 *
>, <Line: +	 * The following example shows how to configure ngPluralize:
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <ng-pluralize count="personCount"
>, <Line: +	 when="{'0': 'Nobody is viewing.',
>, <Line: +	 * </ng-pluralize>
>, <Line: +	 *```
>, <Line: +	 *
>, <Line: +	 * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
>, <Line: +	 * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
>, <Line: +	 * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
>, <Line: +	 * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
>, <Line: +	 * show "a dozen people are viewing".
>, <Line: +	 *
>, <Line: +	 * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted
>, <Line: +	 * into pluralized strings. In the previous example, Angular will replace `{}` with
>, <Line: +	 * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
>, <Line: +	 * for <span ng-non-bindable>{{numberExpression}}</span>.
>, <Line: +	 *
>, <Line: +	 * # Configuring ngPluralize with offset
>, <Line: +	 * The `offset` attribute allows further customization of pluralized text, which can result in
>, <Line: +	 * a better user experience. For example, instead of the message "4 people are viewing this document",
>, <Line: +	 * you might display "John, Kate and 2 others are viewing this document".
>, <Line: +	 * The offset attribute allows you to offset a number by any desired value.
>, <Line: +	 * Let's take a look at an example:
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <ng-pluralize count="personCount" offset=2
>, <Line: +	 *               when="{'0': 'Nobody is viewing.',
>, <Line: +	 * </ng-pluralize>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Notice that we are still using two plural categories(one, other), but we added
>, <Line: +	 * three explicit number rules 0, 1 and 2.
>, <Line: +	 * When one person, perhaps John, views the document, "John is viewing" will be shown.
>, <Line: +	 * When three people view the document, no explicit number rule is found, so
>, <Line: +	 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
>, <Line: +	 * In this case, plural category 'one' is matched and "John, Mary and one other person are viewing"
>, <Line: +	 * is shown.
>, <Line: +	 *
>, <Line: +	 * Note that when you specify offsets, you must provide explicit number rules for
>, <Line: +	 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
>, <Line: +	 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
>, <Line: +	 * plural categories "one" and "other".
>, <Line: +	 *
>, <Line: +	 * @param {string|expression} count The variable to be bound to.
>, <Line: +	 * @param {string} when The mapping between plural category to its corresponding strings.
>, <Line: +	 * @param {number=} offset Offset to deduct from the total number.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="pluralizeExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('pluralizeExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
>, <Line: +	 Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
>, <Line: +	 Number of People:<input type="text" ng-model="personCount" value="1" /><br/>
>, <Line: +	 <!--- Example with simple pluralization rules for en locale --->
>, <Line: +	 Without Offset:
>, <Line: +	 <ng-pluralize count="personCount"
>, <Line: +	 when="{'0': 'Nobody is viewing.',
>, <Line: +	 </ng-pluralize><br>
>, <Line: +	 <!--- Example with offset --->
>, <Line: +	 With Offset(2):
>, <Line: +	 <ng-pluralize count="personCount" offset=2
>, <Line: +	 when="{'0': 'Nobody is viewing.',
>, <Line: +	 </ng-pluralize>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should show correct pluralized string', function() {
>, <Line: +	 it('should show data-bound names', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngPluralizeDirective = ['$locale', '$interpolate', function ($locale, $interpolate) {
>, <Line: +		var BRACE = /{}/g,
>, <Line: +			IS_WHEN = /^when(Minus)?(.+)$/;
>, <Line: +		return {
>, <Line: +			restrict: 'EA',
>, <Line: +			link: function (scope, element, attr) {
>, <Line: +				var numberExp = attr.count,
>, <Line: +					whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
>, <Line: +					offset = attr.offset || 0,
>, <Line: +					whens = scope.$eval(whenExp) || {},
>, <Line: +					whensExpFns = {},
>, <Line: +					startSymbol = $interpolate.startSymbol(),
>, <Line: +					endSymbol = $interpolate.endSymbol(),
>, <Line: +					braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
>, <Line: +					watchRemover = angular.noop,
>, <Line: +					lastCount;
>, <Line: +				forEach(attr, function (expression, attributeName) {
>, <Line: +					var tmpMatch = IS_WHEN.exec(attributeName);
>, <Line: +					if (tmpMatch) {
>, <Line: +						var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
>, <Line: +						whens[whenKey] = element.attr(attr.$attr[attributeName]);
>, <Line: +					}
>, <Line: +				});
>, <Line: +				forEach(whens, function (expression, key) {
>, <Line: +					whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
>, <Line: +				});
>, <Line: +				scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
>, <Line: +					var count = parseFloat(newVal);
>, <Line: +					var countIsNaN = isNaN(count);
>, <Line: +					if (!countIsNaN && !(count in whens)) {
>, <Line: +						// If an explicit number rule such as 1, 2, 3... is defined, just use it.
>, <Line: +						// Otherwise, check it against pluralization rules in $locale service.
>, <Line: +						count = $locale.pluralCat(count - offset);
>, <Line: +					}
>, <Line: +					// If both `count` and `lastCount` are NaN, we don't need to re-register a watch.
>, <Line: +					// In JS `NaN !== NaN`, so we have to exlicitly check.
>, <Line: +					if ((count !== lastCount) && !(countIsNaN && isNaN(lastCount))) {
>, <Line: +						watchRemover();
>, <Line: +						watchRemover = scope.$watch(whensExpFns[count], updateElementText);
>, <Line: +						lastCount = count;
>, <Line: +					}
>, <Line: +				});
>, <Line: +				function updateElementText(newText) {
>, <Line: +					element.text(newText || '');
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngRepeat
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
>, <Line: +	 * instance gets its own scope, where the given loop variable is set to the current collection item,
>, <Line: +	 * and `$index` is set to the item index or key.
>, <Line: +	 *
>, <Line: +	 * Special properties are exposed on the local scope of each template instance, including:
>, <Line: +	 *
>, <Line: +	 * | Variable  | Type            | Details                                                                     |
>, <Line: +	 * |-----------|-----------------|-----------------------------------------------------------------------------|
>, <Line: +	 * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
>, <Line: +	 * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
>, <Line: +	 * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
>, <Line: +	 * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
>, <Line: +	 * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
>, <Line: +	 * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
>, <Line: +	 *
>, <Line: +	 * Creating aliases for these properties is possible with {@link ng.directive:ngInit `ngInit`}.
>, <Line: +	 * This may be useful when, for instance, nesting ngRepeats.
>, <Line: +	 *
>, <Line: +	 * # Special repeat start and end points
>, <Line: +	 * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
>, <Line: +	 * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
>, <Line: +	 * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
>, <Line: +	 * up to and including the ending HTML tag where **ng-repeat-end** is placed.
>, <Line: +	 *
>, <Line: +	 * The example below makes use of this feature:
>, <Line: +	 * ```html
>, <Line: +	 *   <header ng-repeat-start="item in items">
>, <Line: +	 *     Header {{ item }}
>, <Line: +	 *   </header>
>, <Line: +	 *   <div class="body">
>, <Line: +	 *     Body {{ item }}
>, <Line: +	 *   </div>
>, <Line: +	 *   <footer ng-repeat-end>
>, <Line: +	 *     Footer {{ item }}
>, <Line: +	 *   </footer>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
>, <Line: +	 * ```html
>, <Line: +	 *   <header>
>, <Line: +	 *     Header A
>, <Line: +	 *   </header>
>, <Line: +	 *   <div class="body">
>, <Line: +	 *     Body A
>, <Line: +	 *   </div>
>, <Line: +	 *   <footer>
>, <Line: +	 *     Footer A
>, <Line: +	 *   </footer>
>, <Line: +	 *   <header>
>, <Line: +	 *     Header B
>, <Line: +	 *   </header>
>, <Line: +	 *   <div class="body">
>, <Line: +	 *     Body B
>, <Line: +	 *   </div>
>, <Line: +	 *   <footer>
>, <Line: +	 *     Footer B
>, <Line: +	 *   </footer>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
>, <Line: +	 * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * **.enter** - when a new item is added to the list or when an item is revealed after a filter
>, <Line: +	 *
>, <Line: +	 * **.leave** - when an item is removed from the list or when an item is filtered out
>, <Line: +	 *
>, <Line: +	 * **.move** - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @scope
>, <Line: +	 * @priority 1000
>, <Line: +	 * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
>, <Line: +	 *   formats are currently supported:
>, <Line: +	 *
>, <Line: +	 *   * `variable in expression`  where variable is the user defined loop variable and `expression`
>, <Line: +	 *     is a scope expression giving the collection to enumerate.
>, <Line: +	 *
>, <Line: +	 *     For example: `album in artist.albums`.
>, <Line: +	 *
>, <Line: +	 *   * `(key, value) in expression`  where `key` and `value` can be any user defined identifiers,
>, <Line: +	 *     and `expression` is the scope expression giving the collection to enumerate.
>, <Line: +	 *
>, <Line: +	 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
>, <Line: +	 *
>, <Line: +	 *   * `variable in expression track by tracking_expression`  You can also provide an optional tracking function
>, <Line: +	 *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function
>, <Line: +	 *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
>, <Line: +	 *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are
>, <Line: +	 *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,
>, <Line: +	 *     before specifying a tracking expression.
>, <Line: +	 *
>, <Line: +	 *     For example: `item in items` is equivalent to `item in items track by $id(item)`. This implies that the DOM elements
>, <Line: +	 *     will be associated by item identity in the array.
>, <Line: +	 *
>, <Line: +	 *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
>, <Line: +	 *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
>, <Line: +	 *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
>, <Line: +	 *     element in the same way in the DOM.
>, <Line: +	 *
>, <Line: +	 *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
>, <Line: +	 *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
>, <Line: +	 *     property is same.
>, <Line: +	 *
>, <Line: +	 *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
>, <Line: +	 *     to items in conjunction with a tracking expression.
>, <Line: +	 *
>, <Line: +	 *   * `variable in expression as alias_expression`  You can also provide an optional alias expression which will then store the
>, <Line: +	 *     intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message
>, <Line: +	 *     when a filter is active on the repeater, but the filtered result set is empty.
>, <Line: +	 *
>, <Line: +	 *     For example: `item in items | filter:x as results` will store the fragment of the repeated items as `results`, but only after
>, <Line: +	 *     the items have been processed through the filter.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 * This example initializes the scope to a list of names and
>, <Line: +	 * then uses `ngRepeat` to display every person:
>, <Line: +	 <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-init="friends = [
>, <Line: +	 {name:'John', age:25, gender:'boy'},
>, <Line: +	 {name:'Jessie', age:30, gender:'girl'},
>, <Line: +	 {name:'Johanna', age:28, gender:'girl'},
>, <Line: +	 {name:'Joy', age:15, gender:'girl'},
>, <Line: +	 {name:'Mary', age:28, gender:'girl'},
>, <Line: +	 {name:'Peter', age:95, gender:'boy'},
>, <Line: +	 {name:'Sebastian', age:50, gender:'boy'},
>, <Line: +	 {name:'Erika', age:27, gender:'girl'},
>, <Line: +	 {name:'Patrick', age:40, gender:'boy'},
>, <Line: +	 {name:'Samantha', age:60, gender:'girl'}
>, <Line: +	 ]">
>, <Line: +	 I have {{friends.length}} friends. They are:
>, <Line: +	 <input type="search" ng-model="q" placeholder="filter friends..." />
>, <Line: +	 <ul class="example-animate-container">
>, <Line: +	 <li class="animate-repeat" ng-repeat="friend in friends | filter:q as results">
>, <Line: +	 [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
>, <Line: +	 </li>
>, <Line: +	 <li class="animate-repeat" ng-if="results.length == 0">
>, <Line: +	 <strong>No results found...</strong>
>, <Line: +	 </li>
>, <Line: +	 </ul>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .example-animate-container {
>, <Line: +	 .animate-repeat {
>, <Line: +	 .animate-repeat.ng-move,
>, <Line: +	 .animate-repeat.ng-enter,
>, <Line: +	 .animate-repeat.ng-leave {
>, <Line: +	 .animate-repeat.ng-leave.ng-leave-active,
>, <Line: +	 .animate-repeat.ng-move,
>, <Line: +	 .animate-repeat.ng-enter {
>, <Line: +	 .animate-repeat.ng-leave,
>, <Line: +	 .animate-repeat.ng-move.ng-move-active,
>, <Line: +	 .animate-repeat.ng-enter.ng-enter-active {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var friends = element.all(by.repeater('friend in friends'));
>, <Line: +	 it('should render initial data set', function() {
>, <Line: +	 it('should update repeater when filter predicate changes', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngRepeatDirective = ['$parse', '$animate', function ($parse, $animate) {
>, <Line: +		var NG_REMOVED = '$$NG_REMOVED';
>, <Line: +		var ngRepeatMinErr = minErr('ngRepeat');
>, <Line: +		var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
>, <Line: +			// TODO(perf): generate setters to shave off ~40ms or 1-1.5%
>, <Line: +			scope[valueIdentifier] = value;
>, <Line: +			if (keyIdentifier) scope[keyIdentifier] = key;
>, <Line: +			scope.$index = index;
>, <Line: +			scope.$first = (index === 0);
>, <Line: +			scope.$last = (index === (arrayLength - 1));
>, <Line: +			scope.$middle = !(scope.$first || scope.$last);
>, <Line: +			// jshint bitwise: false
>, <Line: +			scope.$odd = !(scope.$even = (index & 1) === 0);
>, <Line: +			// jshint bitwise: true
>, <Line: +		};
>, <Line: +		var getBlockStart = function (block) {
>, <Line: +			return block.clone[0];
>, <Line: +		};
>, <Line: +		var getBlockEnd = function (block) {
>, <Line: +			return block.clone[block.clone.length - 1];
>, <Line: +		};
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			multiElement: true,
>, <Line: +			transclude: 'element',
>, <Line: +			priority: 1000,
>, <Line: +			terminal: true,
>, <Line: +			$$tlb: true,
>, <Line: +			compile: function ngRepeatCompile($element, $attr) {
>, <Line: +				var expression = $attr.ngRepeat;
>, <Line: +				var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
>, <Line: +				var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
>, <Line: +				if (!match) {
>, <Line: +					throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
>, <Line: +						expression);
>, <Line: +				}
>, <Line: +				var lhs = match[1];
>, <Line: +				var rhs = match[2];
>, <Line: +				var aliasAs = match[3];
>, <Line: +				var trackByExp = match[4];
>, <Line: +				match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
>, <Line: +				if (!match) {
>, <Line: +					throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
>, <Line: +						lhs);
>, <Line: +				}
>, <Line: +				var valueIdentifier = match[3] || match[1];
>, <Line: +				var keyIdentifier = match[2];
>, <Line: +				if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
>, <Line: +					/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent)$/.test(aliasAs))) {
>, <Line: +					throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
>, <Line: +						aliasAs);
>, <Line: +				}
>, <Line: +				var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
>, <Line: +				var hashFnLocals = {$id: hashKey};
>, <Line: +				if (trackByExp) {
>, <Line: +					trackByExpGetter = $parse(trackByExp);
>, <Line: +				} else {
>, <Line: +					trackByIdArrayFn = function (key, value) {
>, <Line: +						return hashKey(value);
>, <Line: +					};
>, <Line: +					trackByIdObjFn = function (key) {
>, <Line: +						return key;
>, <Line: +					};
>, <Line: +				}
>, <Line: +				return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
>, <Line: +					if (trackByExpGetter) {
>, <Line: +						trackByIdExpFn = function (key, value, index) {
>, <Line: +							// assign key, value, and $index to the locals so that they can be used in hash functions
>, <Line: +							if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
>, <Line: +							hashFnLocals[valueIdentifier] = value;
>, <Line: +							hashFnLocals.$index = index;
>, <Line: +							return trackByExpGetter($scope, hashFnLocals);
>, <Line: +						};
>, <Line: +					}
>, <Line: +					// Store a list of elements from previous run. This is a hash where key is the item from the
>, <Line: +					// iterator, and the value is objects with following properties.
>, <Line: +					//   - scope: bound scope
>, <Line: +					//   - element: previous element.
>, <Line: +					//   - index: position
>, <Line: +					//
>, <Line: +					// We are using no-proto object so that we don't need to guard against inherited props via
>, <Line: +					// hasOwnProperty.
>, <Line: +					var lastBlockMap = createMap();
>, <Line: +					//watch props
>, <Line: +					$scope.$watchCollection(rhs, function ngRepeatAction(collection) {
>, <Line: +						var index, length,
>, <Line: +							previousNode = $element[0],     // node that cloned nodes should be inserted after
>, <Line: +															// initialized to the comment node anchor
>, <Line: +							nextNode,
>, <Line: +						// Same as lastBlockMap but it has the current state. It will become the
>, <Line: +						// lastBlockMap on the next iteration.
>, <Line: +							nextBlockMap = createMap(),
>, <Line: +							collectionLength,
>, <Line: +							key, value, // key/value of iteration
>, <Line: +							trackById,
>, <Line: +							trackByIdFn,
>, <Line: +							collectionKeys,
>, <Line: +							block,       // last object information {scope, element, id}
>, <Line: +							nextBlockOrder,
>, <Line: +							elementsToRemove;
>, <Line: +						if (aliasAs) {
>, <Line: +							$scope[aliasAs] = collection;
>, <Line: +						}
>, <Line: +						if (isArrayLike(collection)) {
>, <Line: +							collectionKeys = collection;
>, <Line: +							trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
>, <Line: +						} else {
>, <Line: +							trackByIdFn = trackByIdExpFn || trackByIdObjFn;
>, <Line: +							// if object, extract keys, sort them and use to determine order of iteration over obj props
>, <Line: +							collectionKeys = [];
>, <Line: +							for (var itemKey in collection) {
>, <Line: +								if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
>, <Line: +									collectionKeys.push(itemKey);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							collectionKeys.sort();
>, <Line: +						}
>, <Line: +						collectionLength = collectionKeys.length;
>, <Line: +						nextBlockOrder = new Array(collectionLength);
>, <Line: +						// locate existing items
>, <Line: +						for (index = 0; index < collectionLength; index++) {
>, <Line: +							key = (collection === collectionKeys) ? index : collectionKeys[index];
>, <Line: +							value = collection[key];
>, <Line: +							trackById = trackByIdFn(key, value, index);
>, <Line: +							if (lastBlockMap[trackById]) {
>, <Line: +								// found previously seen block
>, <Line: +								block = lastBlockMap[trackById];
>, <Line: +								delete lastBlockMap[trackById];
>, <Line: +								nextBlockMap[trackById] = block;
>, <Line: +								nextBlockOrder[index] = block;
>, <Line: +							} else if (nextBlockMap[trackById]) {
>, <Line: +								// if collision detected. restore lastBlockMap and throw an error
>, <Line: +								forEach(nextBlockOrder, function (block) {
>, <Line: +									if (block && block.scope) lastBlockMap[block.id] = block;
>, <Line: +								});
>, <Line: +								throw ngRepeatMinErr('dupes',
>, <Line: +									"Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
>, <Line: +									expression, trackById, value);
>, <Line: +							} else {
>, <Line: +								// new never before seen block
>, <Line: +								nextBlockOrder[index] = {
>, <Line: +									id: trackById,
>, <Line: +									scope: undefined,
>, <Line: +									clone: undefined
>, <Line: +								};
>, <Line: +								nextBlockMap[trackById] = true;
>, <Line: +							}
>, <Line: +						}
>, <Line: +						// remove leftover items
>, <Line: +						for (var blockKey in lastBlockMap) {
>, <Line: +							block = lastBlockMap[blockKey];
>, <Line: +							elementsToRemove = getBlockNodes(block.clone);
>, <Line: +							$animate.leave(elementsToRemove);
>, <Line: +							if (elementsToRemove[0].parentNode) {
>, <Line: +								// if the element was not removed yet because of pending animation, mark it as deleted
>, <Line: +								// so that we can ignore it later
>, <Line: +								for (index = 0, length = elementsToRemove.length; index < length; index++) {
>, <Line: +									elementsToRemove[index][NG_REMOVED] = true;
>, <Line: +								}
>, <Line: +							}
>, <Line: +							block.scope.$destroy();
>, <Line: +						}
>, <Line: +						// we are not using forEach for perf reasons (trying to avoid #call)
>, <Line: +						for (index = 0; index < collectionLength; index++) {
>, <Line: +							key = (collection === collectionKeys) ? index : collectionKeys[index];
>, <Line: +							value = collection[key];
>, <Line: +							block = nextBlockOrder[index];
>, <Line: +							if (block.scope) {
>, <Line: +								// if we have already seen this object, then we need to reuse the
>, <Line: +								// associated scope/element
>, <Line: +								nextNode = previousNode;
>, <Line: +								// skip nodes that are already pending removal via leave animation
>, <Line: +								do {
>, <Line: +									nextNode = nextNode.nextSibling;
>, <Line: +								} while (nextNode && nextNode[NG_REMOVED]);
>, <Line: +								if (getBlockStart(block) != nextNode) {
>, <Line: +									// existing item which got moved
>, <Line: +									$animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
>, <Line: +								}
>, <Line: +								previousNode = getBlockEnd(block);
>, <Line: +								updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
>, <Line: +							} else {
>, <Line: +								// new item which we don't know about
>, <Line: +								$transclude(function ngRepeatTransclude(clone, scope) {
>, <Line: +									block.scope = scope;
>, <Line: +									// http://jsperf.com/clone-vs-createcomment
>, <Line: +									var endNode = ngRepeatEndComment.cloneNode(false);
>, <Line: +									clone[clone.length++] = endNode;
>, <Line: +									// TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?
>, <Line: +									$animate.enter(clone, null, jqLite(previousNode));
>, <Line: +									previousNode = endNode;
>, <Line: +									// Note: We only need the first/last node of the cloned nodes.
>, <Line: +									// However, we need to keep the reference to the jqlite wrapper as it might be changed later
>, <Line: +									// by a directive with templateUrl when its template arrives.
>, <Line: +									block.clone = clone;
>, <Line: +									nextBlockMap[block.id] = block;
>, <Line: +									updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
>, <Line: +								});
>, <Line: +							}
>, <Line: +						}
>, <Line: +						lastBlockMap = nextBlockMap;
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	var NG_HIDE_CLASS = 'ng-hide';
>, <Line: +	var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngShow
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngShow` directive shows or hides the given HTML element based on the expression
>, <Line: +	 * provided to the `ngShow` attribute. The element is shown or hidden by removing or adding
>, <Line: +	 * the `.ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
>, <Line: +	 * in AngularJS and sets the display style to none (using an !important flag).
>, <Line: +	 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <!-- when $scope.myValue is truthy (element is visible) -->
>, <Line: +	 * <div ng-show="myValue"></div>
>, <Line: +	 *
>, <Line: +	 * <!-- when $scope.myValue is falsy (element is hidden) -->
>, <Line: +	 * <div ng-show="myValue" class="ng-hide"></div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added to the class
>, <Line: +	 * attribute on the element causing it to become hidden. When truthy, the `.ng-hide` CSS class is removed
>, <Line: +	 * from the element causing the element not to appear hidden.
>, <Line: +	 *
>, <Line: +	 * ## Why is !important used?
>, <Line: +	 *
>, <Line: +	 * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
>, <Line: +	 * can be easily overridden by heavier selectors. For example, something as simple
>, <Line: +	 * as changing the display style on a HTML list item would make hidden elements appear visible.
>, <Line: +	 * This also becomes a bigger issue when dealing with CSS frameworks.
>, <Line: +	 *
>, <Line: +	 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
>, <Line: +	 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
>, <Line: +	 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
>, <Line: +	 *
>, <Line: +	 * ### Overriding `.ng-hide`
>, <Line: +	 *
>, <Line: +	 * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
>, <Line: +	 * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
>, <Line: +	 * class in CSS:
>, <Line: +	 *
>, <Line: +	 * ```css
>, <Line: +	 * .ng-hide {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * By default you don't need to override in CSS anything and the animations will work around the display style.
>, <Line: +	 *
>, <Line: +	 * ## A note about animations with `ngShow`
>, <Line: +	 *
>, <Line: +	 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
>, <Line: +	 * is true and false. This system works like the animation system present with ngClass except that
>, <Line: +	 * you must also include the !important flag to override the display property
>, <Line: +	 * so that you can perform an animation when the element is hidden during the time of the animation.
>, <Line: +	 *
>, <Line: +	 * ```css
>, <Line: +	 * //
>, <Line: +	 * //a working example can be found at the bottom of this page
>, <Line: +	 * //
>, <Line: +	 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
>, <Line: +	 *
>, <Line: +	 * .my-element.ng-hide-add-active,
>, <Line: +	 * .my-element.ng-hide-remove-active {
>, <Line: +	 *
>, <Line: +	 * .my-element.ng-hide-add { ... }
>, <Line: +	 * .my-element.ng-hide-add.ng-hide-add-active { ... }
>, <Line: +	 * .my-element.ng-hide-remove { ... }
>, <Line: +	 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
>, <Line: +	 * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * addClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a truthy value and the just before contents are set to visible
>, <Line: +	 * removeClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngShow If the {@link guide/expression expression} is truthy
>, <Line: +	 *     then the element is shown or hidden respectively.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 Click me: <input type="checkbox" ng-model="checked"><br/>
>, <Line: +	 <div>
>, <Line: +	 Show:
>, <Line: +	 <div class="check-element animate-show" ng-show="checked">
>, <Line: +	 <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 <div>
>, <Line: +	 Hide:
>, <Line: +	 <div class="check-element animate-show" ng-hide="checked">
>, <Line: +	 <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="glyphicons.css">
>, <Line: +	 @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .animate-show {
>, <Line: +	 .animate-show.ng-hide-add.ng-hide-add-active,
>, <Line: +	 .animate-show.ng-hide-remove.ng-hide-remove-active {
>, <Line: +	 .animate-show.ng-hide {
>, <Line: +	 .check-element {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
>, <Line: +	 var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
>, <Line: +	 it('should check ng-show / ng-hide', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngShowDirective = ['$animate', function ($animate) {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			multiElement: true,
>, <Line: +			link: function (scope, element, attr) {
>, <Line: +				scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
>, <Line: +					// we're adding a temporary, animation-specific class for ng-hide since this way
>, <Line: +					// we can control when the element is actually displayed on screen without having
>, <Line: +					// to have a global/greedy CSS selector that breaks when other animations are run.
>, <Line: +					// Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
>, <Line: +					$animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
>, <Line: +						tempClasses: NG_HIDE_IN_PROGRESS_CLASS
>, <Line: +					});
>, <Line: +				});
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngHide
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngHide` directive shows or hides the given HTML element based on the expression
>, <Line: +	 * provided to the `ngHide` attribute. The element is shown or hidden by removing or adding
>, <Line: +	 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
>, <Line: +	 * in AngularJS and sets the display style to none (using an !important flag).
>, <Line: +	 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: +	 *
>, <Line: +	 * ```html
>, <Line: +	 * <!-- when $scope.myValue is truthy (element is hidden) -->
>, <Line: +	 * <div ng-hide="myValue" class="ng-hide"></div>
>, <Line: +	 *
>, <Line: +	 * <!-- when $scope.myValue is falsy (element is visible) -->
>, <Line: +	 * <div ng-hide="myValue"></div>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class
>, <Line: +	 * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed
>, <Line: +	 * from the element causing the element not to appear hidden.
>, <Line: +	 *
>, <Line: +	 * ## Why is !important used?
>, <Line: +	 *
>, <Line: +	 * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
>, <Line: +	 * can be easily overridden by heavier selectors. For example, something as simple
>, <Line: +	 * as changing the display style on a HTML list item would make hidden elements appear visible.
>, <Line: +	 * This also becomes a bigger issue when dealing with CSS frameworks.
>, <Line: +	 *
>, <Line: +	 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
>, <Line: +	 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
>, <Line: +	 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
>, <Line: +	 *
>, <Line: +	 * ### Overriding `.ng-hide`
>, <Line: +	 *
>, <Line: +	 * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
>, <Line: +	 * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
>, <Line: +	 * class in CSS:
>, <Line: +	 *
>, <Line: +	 * ```css
>, <Line: +	 * .ng-hide {
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * By default you don't need to override in CSS anything and the animations will work around the display style.
>, <Line: +	 *
>, <Line: +	 * ## A note about animations with `ngHide`
>, <Line: +	 *
>, <Line: +	 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
>, <Line: +	 * is true and false. This system works like the animation system present with ngClass, except that the `.ng-hide`
>, <Line: +	 * CSS class is added and removed for you instead of your own CSS class.
>, <Line: +	 *
>, <Line: +	 * ```css
>, <Line: +	 * //
>, <Line: +	 * //a working example can be found at the bottom of this page
>, <Line: +	 * //
>, <Line: +	 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
>, <Line: +	 *
>, <Line: +	 * .my-element.ng-hide-add { ... }
>, <Line: +	 * .my-element.ng-hide-add.ng-hide-add-active { ... }
>, <Line: +	 * .my-element.ng-hide-remove { ... }
>, <Line: +	 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
>, <Line: +	 * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
>, <Line: +	 *
>, <Line: +	 * @animations
>, <Line: +	 * removeClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden
>, <Line: +	 * addClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a non truthy value and just before the contents are set to visible
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
>, <Line: +	 *     the element is shown or hidden respectively.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 Click me: <input type="checkbox" ng-model="checked"><br/>
>, <Line: +	 <div>
>, <Line: +	 Show:
>, <Line: +	 <div class="check-element animate-hide" ng-show="checked">
>, <Line: +	 <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 <div>
>, <Line: +	 Hide:
>, <Line: +	 <div class="check-element animate-hide" ng-hide="checked">
>, <Line: +	 <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="glyphicons.css">
>, <Line: +	 @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .animate-hide {
>, <Line: +	 .animate-hide.ng-hide {
>, <Line: +	 .check-element {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
>, <Line: +	 var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
>, <Line: +	 it('should check ng-show / ng-hide', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngHideDirective = ['$animate', function ($animate) {
>, <Line: +		return {
>, <Line: +			restrict: 'A',
>, <Line: +			multiElement: true,
>, <Line: +			link: function (scope, element, attr) {
>, <Line: +				scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
>, <Line: +					// The comment inside of the ngShowDirective explains why we add and
>, <Line: +					// remove a temporary class for the show/hide animation
>, <Line: +					$animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {
>, <Line: +						tempClasses: NG_HIDE_IN_PROGRESS_CLASS
>, <Line: +					});
>, <Line: +				});
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngStyle
>, <Line: +	 * @restrict AC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 * @param {expression} ngStyle
>, <Line: +	 *
>, <Line: +	 * {@link guide/expression Expression} which evals to an
>, <Line: +	 * object whose keys are CSS style names and values are corresponding values for those CSS
>, <Line: +	 * keys.
>, <Line: +	 *
>, <Line: +	 * Since some CSS style names are not valid keys for an object, they must be quoted.
>, <Line: +	 * See the 'background-color' style in the example below.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <input type="button" value="set color" ng-click="myStyle={color:'red'}">
>, <Line: +	 <input type="button" value="set background" ng-click="myStyle={'background-color':'blue'}">
>, <Line: +	 <input type="button" value="clear" ng-click="myStyle={}">
>, <Line: +	 <br/>
>, <Line: +	 <span ng-style="myStyle">Sample Text</span>
>, <Line: +	 <pre>myStyle={{myStyle}}</pre>
>, <Line: +	 </file>
>, <Line: +	 <file name="style.css">
>, <Line: +	 span {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var colorSpan = element(by.css('span'));
>, <Line: +	 it('should check ng-style', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngStyleDirective = ngDirective(function (scope, element, attr) {
>, <Line: +		scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
>, <Line: +			if (oldStyles && (newStyles !== oldStyles)) {
>, <Line: +				forEach(oldStyles, function (val, style) {
>, <Line: +					element.css(style, '');
>, <Line: +				});
>, <Line: +			}
>, <Line: +			if (newStyles) element.css(newStyles);
>, <Line: +		}, true);
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngSwitch
>, <Line: +	 * @restrict EA
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.
>, <Line: +	 * Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location
>, <Line: +	 * as specified in the template.
>, <Line: +	 *
>, <Line: +	 * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
>, <Line: +	 * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
>, <Line: +	 * matches the value obtained from the evaluated expression. In other words, you define a container element
>, <Line: +	 * (where you place the directive), place an expression on the **`on="..."` attribute**
>, <Line: +	 * (or the **`ng-switch="..."` attribute**), define any inner elements inside of the directive and place
>, <Line: +	 * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
>, <Line: +	 * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
>, <Line: +	 * attribute is displayed.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-info">
>, <Line: +	 * Be aware that the attribute values to match against cannot be expressions. They are interpreted
>, <Line: +	 * as literal string values to match against.
>, <Line: +	 * For example, **`ng-switch-when="someVal"`** will match against the string `"someVal"` not against the
>, <Line: +	 * value of the expression `$scope.someVal`.
>, <Line: +	 * </div>
>, <Line: +	 * @animations
>, <Line: +	 * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container
>, <Line: +	 * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
>, <Line: +	 *
>, <Line: +	 * @usage
>, <Line: +	 *
>, <Line: +	 * ```
>, <Line: +	 * <ANY ng-switch="expression">
>, <Line: +	 *   <ANY ng-switch-when="matchValue1">...</ANY>
>, <Line: +	 *   <ANY ng-switch-when="matchValue2">...</ANY>
>, <Line: +	 *   <ANY ng-switch-default>...</ANY>
>, <Line: +	 * </ANY>
>, <Line: +	 * ```
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @scope
>, <Line: +	 * @priority 1200
>, <Line: +	 * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
>, <Line: +	 * On child elements add:
>, <Line: +	 *
>, <Line: +	 * * `ngSwitchWhen`: the case statement to match against. If match then this
>, <Line: +	 *   case will be displayed. If the same match appears multiple times, all the
>, <Line: +	 *   elements will be displayed.
>, <Line: +	 * * `ngSwitchDefault`: the default case when no other case match. If there
>, <Line: +	 *   are multiple default cases, all of them will be displayed when no other
>, <Line: +	 *   case match.
>, <Line: +	 *
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="switchExample" deps="angular-animate.js" animations="true">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <select ng-model="selection" ng-options="item for item in items">
>, <Line: +	 </select>
>, <Line: +	 <tt>selection={{selection}}</tt>
>, <Line: +	 <hr/>
>, <Line: +	 <div class="animate-switch-container"
>, <Line: +	 ng-switch on="selection">
>, <Line: +	 <div class="animate-switch" ng-switch-when="settings">Settings Div</div>
>, <Line: +	 <div class="animate-switch" ng-switch-when="home">Home Span</div>
>, <Line: +	 <div class="animate-switch" ng-switch-default>default</div>
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="script.js">
>, <Line: +	 angular.module('switchExample', ['ngAnimate'])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </file>
>, <Line: +	 <file name="animations.css">
>, <Line: +	 .animate-switch-container {
>, <Line: +	 .animate-switch {
>, <Line: +	 .animate-switch.ng-animate {
>, <Line: +	 .animate-switch.ng-leave.ng-leave-active,
>, <Line: +	 .animate-switch.ng-enter {
>, <Line: +	 .animate-switch.ng-leave,
>, <Line: +	 .animate-switch.ng-enter.ng-enter-active {
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 var switchElem = element(by.css('[ng-switch]'));
>, <Line: +	 var select = element(by.model('selection'));
>, <Line: +	 it('should start in settings', function() {
>, <Line: +	 it('should change to home', function() {
>, <Line: +	 it('should select default', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngSwitchDirective = ['$animate', function ($animate) {
>, <Line: +		return {
>, <Line: +			restrict: 'EA',
>, <Line: +			require: 'ngSwitch',
>, <Line: +			// asks for $scope to fool the BC controller module
>, <Line: +			controller: ['$scope', function ngSwitchController() {
>, <Line: +				this.cases = {};
>, <Line: +			}],
>, <Line: +			link: function (scope, element, attr, ngSwitchController) {
>, <Line: +				var watchExpr = attr.ngSwitch || attr.on,
>, <Line: +					selectedTranscludes = [],
>, <Line: +					selectedElements = [],
>, <Line: +					previousLeaveAnimations = [],
>, <Line: +					selectedScopes = [];
>, <Line: +				var spliceFactory = function (array, index) {
>, <Line: +					return function () {
>, <Line: +						array.splice(index, 1);
>, <Line: +					};
>, <Line: +				};
>, <Line: +				scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
>, <Line: +					var i, ii;
>, <Line: +					for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
>, <Line: +						$animate.cancel(previousLeaveAnimations[i]);
>, <Line: +					}
>, <Line: +					previousLeaveAnimations.length = 0;
>, <Line: +					for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
>, <Line: +						var selected = getBlockNodes(selectedElements[i].clone);
>, <Line: +						selectedScopes[i].$destroy();
>, <Line: +						var promise = previousLeaveAnimations[i] = $animate.leave(selected);
>, <Line: +						promise.then(spliceFactory(previousLeaveAnimations, i));
>, <Line: +					}
>, <Line: +					selectedElements.length = 0;
>, <Line: +					selectedScopes.length = 0;
>, <Line: +					if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
>, <Line: +						forEach(selectedTranscludes, function (selectedTransclude) {
>, <Line: +							selectedTransclude.transclude(function (caseElement, selectedScope) {
>, <Line: +								selectedScopes.push(selectedScope);
>, <Line: +								var anchor = selectedTransclude.element;
>, <Line: +								caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
>, <Line: +								var block = {clone: caseElement};
>, <Line: +								selectedElements.push(block);
>, <Line: +								$animate.enter(caseElement, anchor.parent(), anchor);
>, <Line: +							});
>, <Line: +						});
>, <Line: +					}
>, <Line: +				});
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	var ngSwitchWhenDirective = ngDirective({
>, <Line: +		transclude: 'element',
>, <Line: +		priority: 1200,
>, <Line: +		require: '^ngSwitch',
>, <Line: +		multiElement: true,
>, <Line: +		link: function (scope, element, attrs, ctrl, $transclude) {
>, <Line: +			ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
>, <Line: +			ctrl.cases['!' + attrs.ngSwitchWhen].push({
>, <Line: +				transclude: $transclude,
>, <Line: +				element: element
>, <Line: +			});
>, <Line: +		}
>, <Line: +	});
>, <Line: +	var ngSwitchDefaultDirective = ngDirective({
>, <Line: +		transclude: 'element',
>, <Line: +		priority: 1200,
>, <Line: +		require: '^ngSwitch',
>, <Line: +		multiElement: true,
>, <Line: +		link: function (scope, element, attr, ctrl, $transclude) {
>, <Line: +			ctrl.cases['?'] = (ctrl.cases['?'] || []);
>, <Line: +			ctrl.cases['?'].push({transclude: $transclude, element: element});
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name ngTransclude
>, <Line: +	 * @restrict EAC
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
>, <Line: +	 *
>, <Line: +	 * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
>, <Line: +	 *
>, <Line: +	 * @element ANY
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="transcludeExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('transcludeExample', [])
>, <Line: +	 .directive('pane', function(){
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <input ng-model="title"><br>
>, <Line: +	 <textarea ng-model="text"></textarea> <br/>
>, <Line: +	 <pane title="{{title}}">{{text}}</pane>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should have transcluded', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 *
>, <Line: +	 */
>, <Line: +	var ngTranscludeDirective = ngDirective({
>, <Line: +		restrict: 'EAC',
>, <Line: +		link: function ($scope, $element, $attrs, controller, $transclude) {
>, <Line: +			if (!$transclude) {
>, <Line: +				throw minErr('ngTransclude')('orphan',
>, <Line: +					'Illegal use of ngTransclude directive in the template! ' +
>, <Line: +					'No parent directive that requires a transclusion found. ' +
>, <Line: +					'Element: {0}',
>, <Line: +					startingTag($element));
>, <Line: +			}
>, <Line: +			$transclude(function (clone) {
>, <Line: +				$element.empty();
>, <Line: +				$element.append(clone);
>, <Line: +			});
>, <Line: +		}
>, <Line: +	});
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name script
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * Load the content of a `<script>` element into {@link ng.$templateCache `$templateCache`}, so that the
>, <Line: +	 * template can be used by {@link ng.directive:ngInclude `ngInclude`},
>, <Line: +	 * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive directives}. The type of the
>, <Line: +	 * `<script>` element must be specified as `text/ng-template`, and a cache name for the template must be
>, <Line: +	 * assigned through the element's `id`, which can then be used as a directive's `templateUrl`.
>, <Line: +	 *
>, <Line: +	 * @param {string} type Must be set to `'text/ng-template'`.
>, <Line: +	 * @param {string} id Cache name of the template.
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example>
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script type="text/ng-template" id="/tpl.html">
>, <Line: +	 Content of the template.
>, <Line: +	 </script>
>, <Line: +	 <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
>, <Line: +	 <div id="tpl-content" ng-include src="currentTpl"></div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should load template defined inside script tag', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var scriptDirective = ['$templateCache', function ($templateCache) {
>, <Line: +		return {
>, <Line: +			restrict: 'E',
>, <Line: +			terminal: true,
>, <Line: +			compile: function (element, attr) {
>, <Line: +				if (attr.type == 'text/ng-template') {
>, <Line: +					var templateUrl = attr.id,
>, <Line: +					// IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
>, <Line: +						text = element[0].text;
>, <Line: +					$templateCache.put(templateUrl, text);
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	var ngOptionsMinErr = minErr('ngOptions');
>, <Line: +	/**
>, <Line: +	 * @ngdoc directive
>, <Line: +	 * @name select
>, <Line: +	 * @restrict E
>, <Line: +	 *
>, <Line: +	 * @description
>, <Line: +	 * HTML `SELECT` element with angular data-binding.
>, <Line: +	 *
>, <Line: +	 * # `ngOptions`
>, <Line: +	 *
>, <Line: +	 * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
>, <Line: +	 * elements for the `<select>` element using the array or object obtained by evaluating the
>, <Line: +	 * `ngOptions` comprehension_expression.
>, <Line: +	 *
>, <Line: +	 * In many cases, `ngRepeat` can be used on `<option>` elements instead of `ngOptions` to achieve a
>, <Line: +	 * similar result. However, the `ngOptions` provides some benefits such as reducing memory and
>, <Line: +	 * increasing speed by not creating a new scope for each repeated instance, as well as providing
>, <Line: +	 * more flexibility in how the `select`'s model is assigned via `select as`. `ngOptions` should be
>, <Line: +	 * used when the `select` model needs to be bound to a non-string value. This is because an option
>, <Line: +	 * element can only be bound to string values at present.
>, <Line: +	 *
>, <Line: +	 * When an item in the `<select>` menu is selected, the array element or object property
>, <Line: +	 * represented by the selected option will be bound to the model identified by the `ngModel`
>, <Line: +	 * directive.
>, <Line: +	 *
>, <Line: +	 * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
>, <Line: +	 * be nested into the `<select>` element. This element will then represent the `null` or "not selected"
>, <Line: +	 * option. See example below for demonstration.
>, <Line: +	 *
>, <Line: +	 * <div class="alert alert-warning">
>, <Line: +	 * **Note:** `ngModel` compares by reference, not value. This is important when binding to an
>, <Line: +	 * array of objects. See an example [in this jsfiddle](http://jsfiddle.net/qWzTb/).
>, <Line: +	 * </div>
>, <Line: +	 *
>, <Line: +	 * ## `select as`
>, <Line: +	 *
>, <Line: +	 * Using `select as` will bind the result of the `select as` expression to the model, but
>, <Line: +	 * the value of the `<select>` and `<option>` html elements will be either the index (for array data sources)
>, <Line: +	 * or property name (for object data sources) of the value within the collection. If a `track by` expression
>, <Line: +	 * is used, the result of that expression will be set as the value of the `option` and `select` elements.
>, <Line: +	 *
>, <Line: +	 * ### `select as` with `trackexpr`
>, <Line: +	 *
>, <Line: +	 * Using `select as` together with `trackexpr` is not recommended. Reasoning:
>, <Line: +	 *
>, <Line: +	 * - Example: &lt;select ng-options="item.subItem as item.label for item in values track by item.id" ng-model="selected"&gt;
>, <Line: +	 *   values: [{id: 1, label: 'aLabel', subItem: {name: 'aSubItem'}}, {id: 2, label: 'bLabel', subItem: {name: 'bSubItem'}}],
>, <Line: +	 *   $scope.selected = {name: 'aSubItem'};
>, <Line: +	 * - track by is always applied to `value`, with the purpose of preserving the selection,
>, <Line: +	 *   (to `item` in this case)
>, <Line: +	 * - to calculate whether an item is selected we do the following:
>, <Line: +	 *   1. apply `track by` to the values in the array, e.g.
>, <Line: +	 *      In the example: [1,2]
>, <Line: +	 *   2. apply `track by` to the already selected value in `ngModel`:
>, <Line: +	 *      In the example: this is not possible, as `track by` refers to `item.id`, but the selected
>, <Line: +	 *      value from `ngModel` is `{name: aSubItem}`.
>, <Line: +	 *
>, <Line: +	 * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: +	 * @param {string=} name Property name of the form under which the control is published.
>, <Line: +	 * @param {string=} required The control is considered valid only if value is entered.
>, <Line: +	 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: +	 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: +	 *    `required` when you want to data-bind to the `required` attribute.
>, <Line: +	 * @param {comprehension_expression=} ngOptions in one of the following forms:
>, <Line: +	 *
>, <Line: +	 *   * for array data sources:
>, <Line: +	 *     * `label` **`for`** `value` **`in`** `array`
>, <Line: +	 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
>, <Line: +	 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
>, <Line: +	 *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
>, <Line: +	 *   * for object data sources:
>, <Line: +	 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
>, <Line: +	 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
>, <Line: +	 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
>, <Line: +	 *     * `select` **`as`** `label` **`group by`** `group`
>, <Line: +	 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
>, <Line: +	 *
>, <Line: +	 * Where:
>, <Line: +	 *
>, <Line: +	 *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
>, <Line: +	 *   * `value`: local variable which will refer to each item in the `array` or each property value
>, <Line: +	 *      of `object` during iteration.
>, <Line: +	 *   * `key`: local variable which will refer to a property name in `object` during iteration.
>, <Line: +	 *   * `label`: The result of this expression will be the label for `<option>` element. The
>, <Line: +	 *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
>, <Line: +	 *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
>, <Line: +	 *      element. If not specified, `select` expression will default to `value`.
>, <Line: +	 *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
>, <Line: +	 *      DOM element.
>, <Line: +	 *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
>, <Line: +	 *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
>, <Line: +	 *     `value` variable (e.g. `value.propertyName`). With this the selection is preserved
>, <Line: +	 *      even when the options are recreated (e.g. reloaded from the server).
>, <Line: +	 *
>, <Line: +	 * @example
>, <Line: +	 <example module="selectExample">
>, <Line: +	 <file name="index.html">
>, <Line: +	 <script>
>, <Line: +	 angular.module('selectExample', [])
>, <Line: +	 .controller('ExampleController', ['$scope', function($scope) {
>, <Line: +	 </script>
>, <Line: +	 <div ng-controller="ExampleController">
>, <Line: +	 <ul>
>, <Line: +	 <li ng-repeat="color in colors">
>, <Line: +	 Name: <input ng-model="color.name">
>, <Line: +	 [<a href ng-click="colors.splice($index, 1)">X</a>]
>, <Line: +	 </li>
>, <Line: +	 <li>
>, <Line: +	 [<a href ng-click="colors.push({})">add</a>]
>, <Line: +	 </li>
>, <Line: +	 </ul>
>, <Line: +	 <hr/>
>, <Line: +	 Color (null not allowed):
>, <Line: +	 <select ng-model="myColor" ng-options="color.name for color in colors"></select><br>
>, <Line: +	 Color (null allowed):
>, <Line: +	 <span  class="nullable">
>, <Line: +	 <select ng-model="myColor" ng-options="color.name for color in colors">
>, <Line: +	 <option value="">-- choose color --</option>
>, <Line: +	 </select>
>, <Line: +	 </span><br/>
>, <Line: +	 Color grouped by shade:
>, <Line: +	 <select ng-model="myColor" ng-options="color.name group by color.shade for color in colors">
>, <Line: +	 </select><br/>
>, <Line: +	 Select <a href ng-click="myColor = { name:'not in list', shade: 'other' }">bogus</a>.<br>
>, <Line: +	 <hr/>
>, <Line: +	 Currently selected: {{ {selected_color:myColor} }}
>, <Line: +	 <div style="border:solid 1px black; height:20px"
>, <Line: +	 ng-style="{'background-color':myColor.name}">
>, <Line: +	 </div>
>, <Line: +	 </div>
>, <Line: +	 </file>
>, <Line: +	 <file name="protractor.js" type="protractor">
>, <Line: +	 it('should check ng-options', function() {
>, <Line: +	 </file>
>, <Line: +	 </example>
>, <Line: +	 */
>, <Line: +	var ngOptionsDirective = valueFn({
>, <Line: +		restrict: 'A',
>, <Line: +		terminal: true
>, <Line: +	});
>, <Line: +	var selectDirective = ['$compile', '$parse', function ($compile, $parse) {
>, <Line: +		//000011111111110000000000022222222220000000000000000000003333333333000000000000004444444444444440000000005555555555555550000000666666666666666000000000000000777777777700000000000000000008888888888
>, <Line: +		var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
>, <Line: +			nullModelCtrl = {$setViewValue: noop};
>, <Line: +		return {
>, <Line: +			restrict: 'E',
>, <Line: +			require: ['select', '?ngModel'],
>, <Line: +			controller: ['$element', '$scope', '$attrs', function ($element, $scope, $attrs) {
>, <Line: +				var self = this,
>, <Line: +					optionsMap = {},
>, <Line: +					ngModelCtrl = nullModelCtrl,
>, <Line: +					nullOption,
>, <Line: +					unknownOption;
>, <Line: +				self.databound = $attrs.ngModel;
>, <Line: +				self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
>, <Line: +					ngModelCtrl = ngModelCtrl_;
>, <Line: +					nullOption = nullOption_;
>, <Line: +					unknownOption = unknownOption_;
>, <Line: +				};
>, <Line: +				self.addOption = function (value, element) {
>, <Line: +					assertNotHasOwnProperty(value, '"option value"');
>, <Line: +					optionsMap[value] = true;
>, <Line: +					if (ngModelCtrl.$viewValue == value) {
>, <Line: +						$element.val(value);
>, <Line: +						if (unknownOption.parent()) unknownOption.remove();
>, <Line: +					}
>, <Line: +					// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459
>, <Line: +					// Adding an <option selected="selected"> element to a <select required="required"> should
>, <Line: +					// automatically select the new element
>, <Line: +					if (element && element[0].hasAttribute('selected')) {
>, <Line: +						element[0].selected = true;
>, <Line: +					}
>, <Line: +				};
>, <Line: +				self.removeOption = function (value) {
>, <Line: +					if (this.hasOption(value)) {
>, <Line: +						delete optionsMap[value];
>, <Line: +						if (ngModelCtrl.$viewValue == value) {
>, <Line: +							this.renderUnknownOption(value);
>, <Line: +						}
>, <Line: +					}
>, <Line: +				};
>, <Line: +				self.renderUnknownOption = function (val) {
>, <Line: +					var unknownVal = '? ' + hashKey(val) + ' ?';
>, <Line: +					unknownOption.val(unknownVal);
>, <Line: +					$element.prepend(unknownOption);
>, <Line: +					$element.val(unknownVal);
>, <Line: +					unknownOption.prop('selected', true); // needed for IE
>, <Line: +				};
>, <Line: +				self.hasOption = function (value) {
>, <Line: +					return optionsMap.hasOwnProperty(value);
>, <Line: +				};
>, <Line: +				$scope.$on('$destroy', function () {
>, <Line: +					// disable unknown option so that we don't do work when the whole select is being destroyed
>, <Line: +					self.renderUnknownOption = noop;
>, <Line: +				});
>, <Line: +			}],
>, <Line: +			link: function (scope, element, attr, ctrls) {
>, <Line: +				// if ngModel is not defined, we don't need to do anything
>, <Line: +				if (!ctrls[1]) return;
>, <Line: +				var selectCtrl = ctrls[0],
>, <Line: +					ngModelCtrl = ctrls[1],
>, <Line: +					multiple = attr.multiple,
>, <Line: +					optionsExp = attr.ngOptions,
>, <Line: +					nullOption = false, // if false, user will not be able to select it (used by ngOptions)
>, <Line: +					emptyOption,
>, <Line: +					renderScheduled = false,
>, <Line: +				// we can't just jqLite('<option>') since jqLite is not smart enough
>, <Line: +				// to create it in <select> and IE barfs otherwise.
>, <Line: +					optionTemplate = jqLite(document.createElement('option')),
>, <Line: +					optGroupTemplate = jqLite(document.createElement('optgroup')),
>, <Line: +					unknownOption = optionTemplate.clone();
>, <Line: +				// find "null" option
>, <Line: +				for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
>, <Line: +					if (children[i].value === '') {
>, <Line: +						emptyOption = nullOption = children.eq(i);
>, <Line: +						break;
>, <Line: +					}
>, <Line: +				}
>, <Line: +				selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
>, <Line: +				// required validator
>, <Line: +				if (multiple) {
>, <Line: +					ngModelCtrl.$isEmpty = function (value) {
>, <Line: +						return !value || value.length === 0;
>, <Line: +					};
>, <Line: +				}
>, <Line: +				if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
>, <Line: +				else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);
>, <Line: +				else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
>, <Line: +				////////////////////////////
>, <Line: +				function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
>, <Line: +					ngModelCtrl.$render = function () {
>, <Line: +						var viewValue = ngModelCtrl.$viewValue;
>, <Line: +						if (selectCtrl.hasOption(viewValue)) {
>, <Line: +							if (unknownOption.parent()) unknownOption.remove();
>, <Line: +							selectElement.val(viewValue);
>, <Line: +							if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
>, <Line: +						} else {
>, <Line: +							if (isUndefined(viewValue) && emptyOption) {
>, <Line: +								selectElement.val('');
>, <Line: +							} else {
>, <Line: +								selectCtrl.renderUnknownOption(viewValue);
>, <Line: +							}
>, <Line: +						}
>, <Line: +					};
>, <Line: +					selectElement.on('change', function () {
>, <Line: +						scope.$apply(function () {
>, <Line: +							if (unknownOption.parent()) unknownOption.remove();
>, <Line: +							ngModelCtrl.$setViewValue(selectElement.val());
>, <Line: +						});
>, <Line: +					});
>, <Line: +				}
>, <Line: +				function setupAsMultiple(scope, selectElement, ctrl) {
>, <Line: +					var lastView;
>, <Line: +					ctrl.$render = function () {
>, <Line: +						var items = new HashMap(ctrl.$viewValue);
>, <Line: +						forEach(selectElement.find('option'), function (option) {
>, <Line: +							option.selected = isDefined(items.get(option.value));
>, <Line: +						});
>, <Line: +					};
>, <Line: +					// we have to do it on each watch since ngModel watches reference, but
>, <Line: +					// we need to work of an array, so we need to see if anything was inserted/removed
>, <Line: +					scope.$watch(function selectMultipleWatch() {
>, <Line: +						if (!equals(lastView, ctrl.$viewValue)) {
>, <Line: +							lastView = shallowCopy(ctrl.$viewValue);
>, <Line: +							ctrl.$render();
>, <Line: +						}
>, <Line: +					});
>, <Line: +					selectElement.on('change', function () {
>, <Line: +						scope.$apply(function () {
>, <Line: +							var array = [];
>, <Line: +							forEach(selectElement.find('option'), function (option) {
>, <Line: +								if (option.selected) {
>, <Line: +									array.push(option.value);
>, <Line: +								}
>, <Line: +							});
>, <Line: +							ctrl.$setViewValue(array);
>, <Line: +						});
>, <Line: +					});
>, <Line: +				}
>, <Line: +				function setupAsOptions(scope, selectElement, ctrl) {
>, <Line: +					var match;
>, <Line: +					if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
>, <Line: +						throw ngOptionsMinErr('iexp',
>, <Line: +							"Expected expression in form of " +
>, <Line: +							"'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
>, <Line: +							" but got '{0}'. Element: {1}",
>, <Line: +							optionsExp, startingTag(selectElement));
>, <Line: +					}
>, <Line: +					var displayFn = $parse(match[2] || match[1]),
>, <Line: +						valueName = match[4] || match[6],
>, <Line: +						selectAs = / as /.test(match[0]) && match[1],
>, <Line: +						selectAsFn = selectAs ? $parse(selectAs) : null,
>, <Line: +						keyName = match[5],
>, <Line: +						groupByFn = $parse(match[3] || ''),
>, <Line: +						valueFn = $parse(match[2] ? match[1] : valueName),
>, <Line: +						valuesFn = $parse(match[7]),
>, <Line: +						track = match[8],
>, <Line: +						trackFn = track ? $parse(match[8]) : null,
>, <Line: +						trackKeysCache = {},
>, <Line: +					// This is an array of array of existing option groups in DOM.
>, <Line: +					// We try to reuse these if possible
>, <Line: +					// - optionGroupsCache[0] is the options with no option group
>, <Line: +					// - optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
>, <Line: +						optionGroupsCache = [[{
>, <Line: +							element: selectElement,
>, <Line: +							label: ''
>, <Line: +						}]],
>, <Line: +					//re-usable object to represent option's locals
>, <Line: +						locals = {};
>, <Line: +					if (nullOption) {
>, <Line: +						// compile the element since there might be bindings in it
>, <Line: +						$compile(nullOption)(scope);
>, <Line: +						// remove the class, which is added automatically because we recompile the element and it
>, <Line: +						// becomes the compilation root
>, <Line: +						nullOption.removeClass('ng-scope');
>, <Line: +						// we need to remove it before calling selectElement.empty() because otherwise IE will
>, <Line: +						// remove the label from the element. wtf?
>, <Line: +						nullOption.remove();
>, <Line: +					}
>, <Line: +					// clear contents, we'll add what's needed based on the model
>, <Line: +					selectElement.empty();
>, <Line: +					selectElement.on('change', selectionChanged);
>, <Line: +					ctrl.$render = render;
>, <Line: +					scope.$watchCollection(valuesFn, scheduleRendering);
>, <Line: +					scope.$watchCollection(getLabels, scheduleRendering);
>, <Line: +					if (multiple) {
>, <Line: +						scope.$watchCollection(function () {
>, <Line: +							return ctrl.$modelValue;
>, <Line: +						}, scheduleRendering);
>, <Line: +					}
>, <Line: +					// ------------------------------------------------------------------ //
>, <Line: +					function callExpression(exprFn, key, value) {
>, <Line: +						locals[valueName] = value;
>, <Line: +						if (keyName) locals[keyName] = key;
>, <Line: +						return exprFn(scope, locals);
>, <Line: +					}
>, <Line: +					function selectionChanged() {
>, <Line: +						scope.$apply(function () {
>, <Line: +							var collection = valuesFn(scope) || [];
>, <Line: +							var viewValue;
>, <Line: +							if (multiple) {
>, <Line: +								viewValue = [];
>, <Line: +								forEach(selectElement.val(), function (selectedKey) {
>, <Line: +									selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey;
>, <Line: +									viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
>, <Line: +								});
>, <Line: +							} else {
>, <Line: +								var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
>, <Line: +								viewValue = getViewValue(selectedKey, collection[selectedKey]);
>, <Line: +							}
>, <Line: +							ctrl.$setViewValue(viewValue);
>, <Line: +							render();
>, <Line: +						});
>, <Line: +					}
>, <Line: +					function getViewValue(key, value) {
>, <Line: +						if (key === '?') {
>, <Line: +							return undefined;
>, <Line: +						} else if (key === '') {
>, <Line: +							return null;
>, <Line: +						} else {
>, <Line: +							var viewValueFn = selectAsFn ? selectAsFn : valueFn;
>, <Line: +							return callExpression(viewValueFn, key, value);
>, <Line: +						}
>, <Line: +					}
>, <Line: +					function getLabels() {
>, <Line: +						var values = valuesFn(scope);
>, <Line: +						var toDisplay;
>, <Line: +						if (values && isArray(values)) {
>, <Line: +							toDisplay = new Array(values.length);
>, <Line: +							for (var i = 0, ii = values.length; i < ii; i++) {
>, <Line: +								toDisplay[i] = callExpression(displayFn, i, values[i]);
>, <Line: +							}
>, <Line: +							return toDisplay;
>, <Line: +						} else if (values) {
>, <Line: +							// TODO: Add a test for this case
>, <Line: +							toDisplay = {};
>, <Line: +							for (var prop in values) {
>, <Line: +								if (values.hasOwnProperty(prop)) {
>, <Line: +									toDisplay[prop] = callExpression(displayFn, prop, values[prop]);
>, <Line: +								}
>, <Line: +							}
>, <Line: +						}
>, <Line: +						return toDisplay;
>, <Line: +					}
>, <Line: +					function createIsSelectedFn(viewValue) {
>, <Line: +						var selectedSet;
>, <Line: +						if (multiple) {
>, <Line: +							if (trackFn && isArray(viewValue)) {
>, <Line: +								selectedSet = new HashMap([]);
>, <Line: +								for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) {
>, <Line: +									// tracking by key
>, <Line: +									selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), true);
>, <Line: +								}
>, <Line: +							} else {
>, <Line: +								selectedSet = new HashMap(viewValue);
>, <Line: +							}
>, <Line: +						} else if (trackFn) {
>, <Line: +							viewValue = callExpression(trackFn, null, viewValue);
>, <Line: +						}
>, <Line: +						return function isSelected(key, value) {
>, <Line: +							var compareValueFn;
>, <Line: +							if (trackFn) {
>, <Line: +								compareValueFn = trackFn;
>, <Line: +							} else if (selectAsFn) {
>, <Line: +								compareValueFn = selectAsFn;
>, <Line: +							} else {
>, <Line: +								compareValueFn = valueFn;
>, <Line: +							}
>, <Line: +							if (multiple) {
>, <Line: +								return isDefined(selectedSet.remove(callExpression(compareValueFn, key, value)));
>, <Line: +							} else {
>, <Line: +								return viewValue === callExpression(compareValueFn, key, value);
>, <Line: +							}
>, <Line: +						};
>, <Line: +					}
>, <Line: +					function scheduleRendering() {
>, <Line: +						if (!renderScheduled) {
>, <Line: +							scope.$$postDigest(render);
>, <Line: +							renderScheduled = true;
>, <Line: +						}
>, <Line: +					}
>, <Line: +					/**
>, <Line: +					 * A new labelMap is created with each render.
>, <Line: +					 * This function is called for each existing option with added=false,
>, <Line: +					 * and each new option with added=true.
>, <Line: +					 * - Labels that are passed to this method twice,
>, <Line: +					 * (once with added=true and once with added=false) will end up with a value of 0, and
>, <Line: +					 * will cause no change to happen to the corresponding option.
>, <Line: +					 * - Labels that are passed to this method only once with added=false will end up with a
>, <Line: +					 * value of -1 and will eventually be passed to selectCtrl.removeOption()
>, <Line: +					 * - Labels that are passed to this method only once with added=true will end up with a
>, <Line: +					 * value of 1 and will eventually be passed to selectCtrl.addOption()
>, <Line: +					 */
>, <Line: +					function updateLabelMap(labelMap, label, added) {
>, <Line: +						labelMap[label] = labelMap[label] || 0;
>, <Line: +						labelMap[label] += (added ? 1 : -1);
>, <Line: +					}
>, <Line: +					function render() {
>, <Line: +						renderScheduled = false;
>, <Line: +						// Temporary location for the option groups before we render them
>, <Line: +						var optionGroups = {'': []},
>, <Line: +							optionGroupNames = [''],
>, <Line: +							optionGroupName,
>, <Line: +							optionGroup,
>, <Line: +							option,
>, <Line: +							existingParent, existingOptions, existingOption,
>, <Line: +							viewValue = ctrl.$viewValue,
>, <Line: +							values = valuesFn(scope) || [],
>, <Line: +							keys = keyName ? sortedKeys(values) : values,
>, <Line: +							key,
>, <Line: +							value,
>, <Line: +							groupLength, length,
>, <Line: +							groupIndex, index,
>, <Line: +							labelMap = {},
>, <Line: +							selected,
>, <Line: +							isSelected = createIsSelectedFn(viewValue),
>, <Line: +							anySelected = false,
>, <Line: +							lastElement,
>, <Line: +							element,
>, <Line: +							label,
>, <Line: +							optionId;
>, <Line: +						trackKeysCache = {};
>, <Line: +						// We now build up the list of options we need (we merge later)
>, <Line: +						for (index = 0; length = keys.length, index < length; index++) {
>, <Line: +							key = index;
>, <Line: +							if (keyName) {
>, <Line: +								key = keys[index];
>, <Line: +								if (key.charAt(0) === '$') continue;
>, <Line: +							}
>, <Line: +							value = values[key];
>, <Line: +							optionGroupName = callExpression(groupByFn, key, value) || '';
>, <Line: +							if (!(optionGroup = optionGroups[optionGroupName])) {
>, <Line: +								optionGroup = optionGroups[optionGroupName] = [];
>, <Line: +								optionGroupNames.push(optionGroupName);
>, <Line: +							}
>, <Line: +							selected = isSelected(key, value);
>, <Line: +							anySelected = anySelected || selected;
>, <Line: +							label = callExpression(displayFn, key, value); // what will be seen by the user
>, <Line: +							// doing displayFn(scope, locals) || '' overwrites zero values
>, <Line: +							label = isDefined(label) ? label : '';
>, <Line: +							optionId = trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index);
>, <Line: +							if (trackFn) {
>, <Line: +								trackKeysCache[optionId] = key;
>, <Line: +							}
>, <Line: +							optionGroup.push({
>, <Line: +								// either the index into array or key from object
>, <Line: +								id: optionId,
>, <Line: +								label: label,
>, <Line: +								selected: selected                   // determine if we should be selected
>, <Line: +							});
>, <Line: +						}
>, <Line: +						if (!multiple) {
>, <Line: +							if (nullOption || viewValue === null) {
>, <Line: +								// insert null option if we have a placeholder, or the model is null
>, <Line: +								optionGroups[''].unshift({
>, <Line: +									id: '',
>, <Line: +									label: '',
>, <Line: +									selected: !anySelected
>, <Line: +								});
>, <Line: +							} else if (!anySelected) {
>, <Line: +								// option could not be found, we have to insert the undefined item
>, <Line: +								optionGroups[''].unshift({
>, <Line: +									id: '?',
>, <Line: +									label: '',
>, <Line: +									selected: true
>, <Line: +								});
>, <Line: +							}
>, <Line: +						}
>, <Line: +						// Now we need to update the list of DOM nodes to match the optionGroups we computed above
>, <Line: +						for (groupIndex = 0, groupLength = optionGroupNames.length;
>, <Line: +							 groupIndex < groupLength;
>, <Line: +							 groupIndex++) {
>, <Line: +							// current option group name or '' if no group
>, <Line: +							optionGroupName = optionGroupNames[groupIndex];
>, <Line: +							// list of options for that group. (first item has the parent)
>, <Line: +							optionGroup = optionGroups[optionGroupName];
>, <Line: +							if (optionGroupsCache.length <= groupIndex) {
>, <Line: +								// we need to grow the optionGroups
>, <Line: +								existingParent = {
>, <Line: +									element: optGroupTemplate.clone().attr('label', optionGroupName),
>, <Line: +									label: optionGroup.label
>, <Line: +								};
>, <Line: +								existingOptions = [existingParent];
>, <Line: +								optionGroupsCache.push(existingOptions);
>, <Line: +								selectElement.append(existingParent.element);
>, <Line: +							} else {
>, <Line: +								existingOptions = optionGroupsCache[groupIndex];
>, <Line: +								existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element
>, <Line: +								// update the OPTGROUP label if not the same.
>, <Line: +								if (existingParent.label != optionGroupName) {
>, <Line: +									existingParent.element.attr('label', existingParent.label = optionGroupName);
>, <Line: +								}
>, <Line: +							}
>, <Line: +							lastElement = null;  // start at the beginning
>, <Line: +							for (index = 0, length = optionGroup.length; index < length; index++) {
>, <Line: +								option = optionGroup[index];
>, <Line: +								if ((existingOption = existingOptions[index + 1])) {
>, <Line: +									// reuse elements
>, <Line: +									lastElement = existingOption.element;
>, <Line: +									if (existingOption.label !== option.label) {
>, <Line: +										updateLabelMap(labelMap, existingOption.label, false);
>, <Line: +										updateLabelMap(labelMap, option.label, true);
>, <Line: +										lastElement.text(existingOption.label = option.label);
>, <Line: +										lastElement.prop('label', existingOption.label);
>, <Line: +									}
>, <Line: +									if (existingOption.id !== option.id) {
>, <Line: +										lastElement.val(existingOption.id = option.id);
>, <Line: +									}
>, <Line: +									// lastElement.prop('selected') provided by jQuery has side-effects
>, <Line: +									if (lastElement[0].selected !== option.selected) {
>, <Line: +										lastElement.prop('selected', (existingOption.selected = option.selected));
>, <Line: +										if (msie) {
>, <Line: +											// See #7692
>, <Line: +											// The selected item wouldn't visually update on IE without this.
>, <Line: +											// Tested on Win7: IE9, IE10 and IE11. Future IEs should be tested as well
>, <Line: +											lastElement.prop('selected', existingOption.selected);
>, <Line: +										}
>, <Line: +									}
>, <Line: +								} else {
>, <Line: +									// grow elements
>, <Line: +									// if it's a null option
>, <Line: +									if (option.id === '' && nullOption) {
>, <Line: +										// put back the pre-compiled element
>, <Line: +										element = nullOption;
>, <Line: +									} else {
>, <Line: +										// jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
>, <Line: +										// in this version of jQuery on some browser the .text() returns a string
>, <Line: +										// rather then the element.
>, <Line: +										(element = optionTemplate.clone())
>, <Line: +											.val(option.id)
>, <Line: +											.prop('selected', option.selected)
>, <Line: +											.attr('selected', option.selected)
>, <Line: +											.prop('label', option.label)
>, <Line: +											.text(option.label);
>, <Line: +									}
>, <Line: +									existingOptions.push(existingOption = {
>, <Line: +										element: element,
>, <Line: +										label: option.label,
>, <Line: +										id: option.id,
>, <Line: +										selected: option.selected
>, <Line: +									});
>, <Line: +									updateLabelMap(labelMap, option.label, true);
>, <Line: +									if (lastElement) {
>, <Line: +										lastElement.after(element);
>, <Line: +									} else {
>, <Line: +										existingParent.element.append(element);
>, <Line: +									}
>, <Line: +									lastElement = element;
>, <Line: +								}
>, <Line: +							}
>, <Line: +							// remove any excessive OPTIONs in a group
>, <Line: +							index++; // increment since the existingOptions[0] is parent element not OPTION
>, <Line: +							while (existingOptions.length > index) {
>, <Line: +								option = existingOptions.pop();
>, <Line: +								updateLabelMap(labelMap, option.label, false);
>, <Line: +								option.element.remove();
>, <Line: +							}
>, <Line: +							forEach(labelMap, function (count, label) {
>, <Line: +								if (count > 0) {
>, <Line: +									selectCtrl.addOption(label);
>, <Line: +								} else if (count < 0) {
>, <Line: +									selectCtrl.removeOption(label);
>, <Line: +								}
>, <Line: +							});
>, <Line: +						}
>, <Line: +						// remove any excessive OPTGROUPs from select
>, <Line: +						while (optionGroupsCache.length > groupIndex) {
>, <Line: +							optionGroupsCache.pop()[0].element.remove();
>, <Line: +						}
>, <Line: +					}
>, <Line: +				}
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	var optionDirective = ['$interpolate', function ($interpolate) {
>, <Line: +		var nullSelectCtrl = {
>, <Line: +			addOption: noop,
>, <Line: +			removeOption: noop
>, <Line: +		};
>, <Line: +		return {
>, <Line: +			restrict: 'E',
>, <Line: +			priority: 100,
>, <Line: +			compile: function (element, attr) {
>, <Line: +				if (isUndefined(attr.value)) {
>, <Line: +					var interpolateFn = $interpolate(element.text(), true);
>, <Line: +					if (!interpolateFn) {
>, <Line: +						attr.$set('value', element.text());
>, <Line: +					}
>, <Line: +				}
>, <Line: +				return function (scope, element, attr) {
>, <Line: +					var selectCtrlName = '$selectController',
>, <Line: +						parent = element.parent(),
>, <Line: +						selectCtrl = parent.data(selectCtrlName) ||
>, <Line: +							parent.parent().data(selectCtrlName); // in case we are in optgroup
>, <Line: +					if (!selectCtrl || !selectCtrl.databound) {
>, <Line: +						selectCtrl = nullSelectCtrl;
>, <Line: +					}
>, <Line: +					if (interpolateFn) {
>, <Line: +						scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
>, <Line: +							attr.$set('value', newVal);
>, <Line: +							if (oldVal !== newVal) {
>, <Line: +								selectCtrl.removeOption(oldVal);
>, <Line: +							}
>, <Line: +							selectCtrl.addOption(newVal, element);
>, <Line: +						});
>, <Line: +					} else {
>, <Line: +						selectCtrl.addOption(attr.value, element);
>, <Line: +					}
>, <Line: +					element.on('$destroy', function () {
>, <Line: +						selectCtrl.removeOption(attr.value);
>, <Line: +					});
>, <Line: +				};
>, <Line: +			}
>, <Line: +		};
>, <Line: +	}];
>, <Line: +	var styleDirective = valueFn({
>, <Line: +		restrict: 'E',
>, <Line: +		terminal: false
>, <Line: +	});
>, <Line: +	if (window.angular.bootstrap) {
>, <Line: +		//AngularJS is already loaded, so we can return here...
>, <Line: +		console.log('WARNING: Tried to load angular more than once.');
>, <Line: +		return;
>, <Line: +	}
>, <Line: +	//try to bind to jquery now so that one can write jqLite(document).ready()
>, <Line: +	//but we will rebind on bootstrap again.
>, <Line: +	bindJQuery();
>, <Line: +	publishExternalAPI(angular);
>, <Line: +	jqLite(document).ready(function () {
>, <Line: +		angularInit(document, bootstrap);
>, <Line: +	});
>]
[<Line: -(function(window, document, undefined) {'use strict';
>, <Line: -/**
>, <Line: - * @description
>, <Line: - *
>, <Line: - * This object provides a utility for producing rich Error messages within
>, <Line: - * Angular. It can be called as follows:
>, <Line: - *
>, <Line: - * var exampleMinErr = minErr('example');
>, <Line: - * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
>, <Line: - *
>, <Line: - * The above creates an instance of minErr in the example namespace. The
>, <Line: - * resulting error will have a namespaced error code of example.one.  The
>, <Line: - * resulting error will replace {0} with the value of foo, and {1} with the
>, <Line: - * value of bar. The object is not restricted in the number of arguments it can
>, <Line: - * take.
>, <Line: - *
>, <Line: - * If fewer arguments are specified than necessary for interpolation, the extra
>, <Line: - * interpolation markers will be preserved in the final string.
>, <Line: - *
>, <Line: - * Since data will be parsed statically during a build step, some restrictions
>, <Line: - * are applied with respect to how minErr instances are created and called.
>, <Line: - * Instances should have names of the form namespaceMinErr for a minErr created
>, <Line: - * using minErr('namespace') . Error codes, namespaces and template strings
>, <Line: - * should all be static strings, not variables or general expressions.
>, <Line: - *
>, <Line: - * @param {string} module The namespace to use for the new minErr instance.
>, <Line: - * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning
>, <Line: - *   error from returned function, for cases when a particular type of error is useful.
>, <Line: - * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance
>, <Line: - */
>, <Line: -function minErr(module, ErrorConstructor) {
>, <Line: -  ErrorConstructor = ErrorConstructor || Error;
>, <Line: -  return function() {
>, <Line: -    var code = arguments[0],
>, <Line: -      prefix = '[' + (module ? module + ':' : '') + code + '] ',
>, <Line: -      template = arguments[1],
>, <Line: -      templateArgs = arguments,
>, <Line: -      message, i;
>, <Line: -    message = prefix + template.replace(/\{\d+\}/g, function(match) {
>, <Line: -      var index = +match.slice(1, -1), arg;
>, <Line: -      if (index + 2 < templateArgs.length) {
>, <Line: -        return toDebugString(templateArgs[index + 2]);
>, <Line: -      }
>, <Line: -      return match;
>, <Line: -    });
>, <Line: -    message = message + '\nhttp://errors.angularjs.org/1.3.4/' +
>, <Line: -      (module ? module + '/' : '') + code;
>, <Line: -    for (i = 2; i < arguments.length; i++) {
>, <Line: -      message = message + (i == 2 ? '?' : '&') + 'p' + (i - 2) + '=' +
>, <Line: -        encodeURIComponent(toDebugString(arguments[i]));
>, <Line: -    }
>, <Line: -    return new ErrorConstructor(message);
>, <Line: -  };
>, <Line: -}
>, <Line: -/* We need to tell jshint what variables are being exported */
>, <Line: -/* global angular: true,
>, <Line: -  msie: true,
>, <Line: -  jqLite: true,
>, <Line: -  jQuery: true,
>, <Line: -  slice: true,
>, <Line: -  splice: true,
>, <Line: -  push: true,
>, <Line: -  toString: true,
>, <Line: -  ngMinErr: true,
>, <Line: -  angularModule: true,
>, <Line: -  uid: true,
>, <Line: -  REGEX_STRING_REGEXP: true,
>, <Line: -  VALIDITY_STATE_PROPERTY: true,
>, <Line: -  lowercase: true,
>, <Line: -  uppercase: true,
>, <Line: -  manualLowercase: true,
>, <Line: -  manualUppercase: true,
>, <Line: -  nodeName_: true,
>, <Line: -  isArrayLike: true,
>, <Line: -  forEach: true,
>, <Line: -  sortedKeys: true,
>, <Line: -  forEachSorted: true,
>, <Line: -  reverseParams: true,
>, <Line: -  nextUid: true,
>, <Line: -  setHashKey: true,
>, <Line: -  extend: true,
>, <Line: -  int: true,
>, <Line: -  inherit: true,
>, <Line: -  noop: true,
>, <Line: -  identity: true,
>, <Line: -  valueFn: true,
>, <Line: -  isUndefined: true,
>, <Line: -  isDefined: true,
>, <Line: -  isObject: true,
>, <Line: -  isString: true,
>, <Line: -  isNumber: true,
>, <Line: -  isDate: true,
>, <Line: -  isArray: true,
>, <Line: -  isFunction: true,
>, <Line: -  isRegExp: true,
>, <Line: -  isWindow: true,
>, <Line: -  isScope: true,
>, <Line: -  isFile: true,
>, <Line: -  isBlob: true,
>, <Line: -  isBoolean: true,
>, <Line: -  isPromiseLike: true,
>, <Line: -  trim: true,
>, <Line: -  escapeForRegexp: true,
>, <Line: -  isElement: true,
>, <Line: -  makeMap: true,
>, <Line: -  includes: true,
>, <Line: -  arrayRemove: true,
>, <Line: -  copy: true,
>, <Line: -  shallowCopy: true,
>, <Line: -  equals: true,
>, <Line: -  csp: true,
>, <Line: -  concat: true,
>, <Line: -  sliceArgs: true,
>, <Line: -  bind: true,
>, <Line: -  toJsonReplacer: true,
>, <Line: -  toJson: true,
>, <Line: -  fromJson: true,
>, <Line: -  startingTag: true,
>, <Line: -  tryDecodeURIComponent: true,
>, <Line: -  parseKeyValue: true,
>, <Line: -  toKeyValue: true,
>, <Line: -  encodeUriSegment: true,
>, <Line: -  encodeUriQuery: true,
>, <Line: -  angularInit: true,
>, <Line: -  bootstrap: true,
>, <Line: -  getTestability: true,
>, <Line: -  snake_case: true,
>, <Line: -  bindJQuery: true,
>, <Line: -  assertArg: true,
>, <Line: -  assertArgFn: true,
>, <Line: -  assertNotHasOwnProperty: true,
>, <Line: -  getter: true,
>, <Line: -  getBlockNodes: true,
>, <Line: -  hasOwnProperty: true,
>, <Line: -  createMap: true,
>, <Line: -  NODE_TYPE_ELEMENT: true,
>, <Line: -  NODE_TYPE_TEXT: true,
>, <Line: -  NODE_TYPE_COMMENT: true,
>, <Line: -  NODE_TYPE_DOCUMENT: true,
>, <Line: -  NODE_TYPE_DOCUMENT_FRAGMENT: true,
>, <Line: -*/
>, <Line: -/**
>, <Line: - * @ngdoc module
>, <Line: - * @name ng
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - *
>, <Line: - * # ng (core module)
>, <Line: - * The ng module is loaded by default when an AngularJS application is started. The module itself
>, <Line: - * contains the essential components for an AngularJS application to function. The table below
>, <Line: - * lists a high level breakdown of each of the services/factories, filters, directives and testing
>, <Line: - * components available within this core module.
>, <Line: - *
>, <Line: - * <div doc-module-components="ng"></div>
>, <Line: - */
>, <Line: -var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
>, <Line: -var VALIDITY_STATE_PROPERTY = 'validity';
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.lowercase
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description Converts the specified string to lowercase.
>, <Line: - * @param {string} string String to be converted to lowercase.
>, <Line: - * @returns {string} Lowercased string.
>, <Line: - */
>, <Line: -var lowercase = function(string) {return isString(string) ? string.toLowerCase() : string;};
>, <Line: -var hasOwnProperty = Object.prototype.hasOwnProperty;
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.uppercase
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description Converts the specified string to uppercase.
>, <Line: - * @param {string} string String to be converted to uppercase.
>, <Line: - * @returns {string} Uppercased string.
>, <Line: - */
>, <Line: -var uppercase = function(string) {return isString(string) ? string.toUpperCase() : string;};
>, <Line: -var manualLowercase = function(s) {
>, <Line: -  /* jshint bitwise: false */
>, <Line: -  return isString(s)
>, <Line: -      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
>, <Line: -      : s;
>, <Line: -};
>, <Line: -var manualUppercase = function(s) {
>, <Line: -  /* jshint bitwise: false */
>, <Line: -  return isString(s)
>, <Line: -      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
>, <Line: -      : s;
>, <Line: -};
>, <Line: -if ('i' !== 'I'.toLowerCase()) {
>, <Line: -  lowercase = manualLowercase;
>, <Line: -  uppercase = manualUppercase;
>, <Line: -}
>, <Line: -var /** holds major version number for IE or NaN for real browsers */
>, <Line: -    msie,
>, <Line: -    jqLite,           // delay binding since jQuery could be loaded after us.
>, <Line: -    jQuery,           // delay binding
>, <Line: -    slice             = [].slice,
>, <Line: -    splice            = [].splice,
>, <Line: -    push              = [].push,
>, <Line: -    toString          = Object.prototype.toString,
>, <Line: -    ngMinErr          = minErr('ng'),
>, <Line: -    /** @name angular */
>, <Line: -    angular           = window.angular || (window.angular = {}),
>, <Line: -    angularModule,
>, <Line: -    uid               = 0;
>, <Line: -/**
>, <Line: - * documentMode is an IE-only property
>, <Line: - * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
>, <Line: - */
>, <Line: -msie = document.documentMode;
>, <Line: -/**
>, <Line: - * @private
>, <Line: - * @param {*} obj
>, <Line: - * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
>, <Line: - *                   String ...)
>, <Line: - */
>, <Line: -function isArrayLike(obj) {
>, <Line: -  if (obj == null || isWindow(obj)) {
>, <Line: -    return false;
>, <Line: -  }
>, <Line: -  var length = obj.length;
>, <Line: -  if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
>, <Line: -    return true;
>, <Line: -  }
>, <Line: -  return isString(obj) || isArray(obj) || length === 0 ||
>, <Line: -         typeof length === 'number' && length > 0 && (length - 1) in obj;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.forEach
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
>, <Line: - * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`
>, <Line: - * is the value of an object property or an array element, `key` is the object property key or
>, <Line: - * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.
>, <Line: - *
>, <Line: - * It is worth noting that `.forEach` does not iterate over inherited properties because it filters
>, <Line: - * using the `hasOwnProperty` method.
>, <Line: - *
>, <Line: - * Unlike ES262's
>, <Line: - * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),
>, <Line: - * Providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just
>, <Line: - * return the value provided.
>, <Line: - *
>, <Line: -   ```js
>, <Line: -     var values = {name: 'misko', gender: 'male'};
>, <Line: -     var log = [];
>, <Line: -     angular.forEach(values, function(value, key) {
>, <Line: -     expect(log).toEqual(['name: misko', 'gender: male']);
>, <Line: -   ```
>, <Line: - *
>, <Line: - * @param {Object|Array} obj Object to iterate over.
>, <Line: - * @param {Function} iterator Iterator function.
>, <Line: - * @param {Object=} context Object to become context (`this`) for the iterator function.
>, <Line: - * @returns {Object|Array} Reference to `obj`.
>, <Line: - */
>, <Line: -function forEach(obj, iterator, context) {
>, <Line: -  var key, length;
>, <Line: -  if (obj) {
>, <Line: -    if (isFunction(obj)) {
>, <Line: -      for (key in obj) {
>, <Line: -        // Need to check if hasOwnProperty exists,
>, <Line: -        // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
>, <Line: -        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
>, <Line: -          iterator.call(context, obj[key], key, obj);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    } else if (isArray(obj) || isArrayLike(obj)) {
>, <Line: -      var isPrimitive = typeof obj !== 'object';
>, <Line: -      for (key = 0, length = obj.length; key < length; key++) {
>, <Line: -        if (isPrimitive || key in obj) {
>, <Line: -          iterator.call(context, obj[key], key, obj);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    } else if (obj.forEach && obj.forEach !== forEach) {
>, <Line: -        obj.forEach(iterator, context, obj);
>, <Line: -    } else {
>, <Line: -      for (key in obj) {
>, <Line: -        if (obj.hasOwnProperty(key)) {
>, <Line: -          iterator.call(context, obj[key], key, obj);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -function sortedKeys(obj) {
>, <Line: -  return Object.keys(obj).sort();
>, <Line: -}
>, <Line: -function forEachSorted(obj, iterator, context) {
>, <Line: -  var keys = sortedKeys(obj);
>, <Line: -  for (var i = 0; i < keys.length; i++) {
>, <Line: -    iterator.call(context, obj[keys[i]], keys[i]);
>, <Line: -  }
>, <Line: -  return keys;
>, <Line: -}
>, <Line: -/**
>, <Line: - * when using forEach the params are value, key, but it is often useful to have key, value.
>, <Line: - * @param {function(string, *)} iteratorFn
>, <Line: - * @returns {function(*, string)}
>, <Line: - */
>, <Line: -function reverseParams(iteratorFn) {
>, <Line: -  return function(value, key) { iteratorFn(key, value); };
>, <Line: -}
>, <Line: -/**
>, <Line: - * A consistent way of creating unique IDs in angular.
>, <Line: - *
>, <Line: - * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before
>, <Line: - * we hit number precision issues in JavaScript.
>, <Line: - *
>, <Line: - * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M
>, <Line: - *
>, <Line: - * @returns {number} an unique alpha-numeric string
>, <Line: - */
>, <Line: -function nextUid() {
>, <Line: -  return ++uid;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Set or clear the hashkey for an object.
>, <Line: - * @param obj object
>, <Line: - * @param h the hashkey (!truthy to delete the hashkey)
>, <Line: - */
>, <Line: -function setHashKey(obj, h) {
>, <Line: -  if (h) {
>, <Line: -    obj.$$hashKey = h;
>, <Line: -  }
>, <Line: -  else {
>, <Line: -    delete obj.$$hashKey;
>, <Line: -  }
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.extend
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
>, <Line: - * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
>, <Line: - * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.
>, <Line: - * Note: Keep in mind that `angular.extend` does not support recursive merge (deep copy).
>, <Line: - *
>, <Line: - * @param {Object} dst Destination object.
>, <Line: - * @param {...Object} src Source object(s).
>, <Line: - * @returns {Object} Reference to `dst`.
>, <Line: - */
>, <Line: -function extend(dst) {
>, <Line: -  var h = dst.$$hashKey;
>, <Line: -  for (var i = 1, ii = arguments.length; i < ii; i++) {
>, <Line: -    var obj = arguments[i];
>, <Line: -    if (obj) {
>, <Line: -      var keys = Object.keys(obj);
>, <Line: -      for (var j = 0, jj = keys.length; j < jj; j++) {
>, <Line: -        var key = keys[j];
>, <Line: -        dst[key] = obj[key];
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  setHashKey(dst, h);
>, <Line: -  return dst;
>, <Line: -}
>, <Line: -function int(str) {
>, <Line: -  return parseInt(str, 10);
>, <Line: -}
>, <Line: -function inherit(parent, extra) {
>, <Line: -  return extend(Object.create(parent), extra);
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.noop
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A function that performs no operations. This function can be useful when writing code in the
>, <Line: - * functional style.
>, <Line: -   ```js
>, <Line: -     function foo(callback) {
>, <Line: -   ```
>, <Line: - */
>, <Line: -function noop() {}
>, <Line: -noop.$inject = [];
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.identity
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A function that returns its first argument. This function is useful when writing code in the
>, <Line: - * functional style.
>, <Line: - *
>, <Line: -   ```js
>, <Line: -     function transformer(transformationFn, value) {
>, <Line: -   ```
>, <Line: - */
>, <Line: -function identity($) {return $;}
>, <Line: -identity.$inject = [];
>, <Line: -function valueFn(value) {return function() {return value;};}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isUndefined
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is undefined.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is undefined.
>, <Line: - */
>, <Line: -function isUndefined(value) {return typeof value === 'undefined';}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isDefined
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is defined.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is defined.
>, <Line: - */
>, <Line: -function isDefined(value) {return typeof value !== 'undefined';}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isObject
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
>, <Line: - * considered to be objects. Note that JavaScript arrays are objects.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is an `Object` but not `null`.
>, <Line: - */
>, <Line: -function isObject(value) {
>, <Line: -  // http://jsperf.com/isobject4
>, <Line: -  return value !== null && typeof value === 'object';
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isString
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is a `String`.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a `String`.
>, <Line: - */
>, <Line: -function isString(value) {return typeof value === 'string';}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isNumber
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is a `Number`.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a `Number`.
>, <Line: - */
>, <Line: -function isNumber(value) {return typeof value === 'number';}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isDate
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a value is a date.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a `Date`.
>, <Line: - */
>, <Line: -function isDate(value) {
>, <Line: -  return toString.call(value) === '[object Date]';
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isArray
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is an `Array`.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is an `Array`.
>, <Line: - */
>, <Line: -var isArray = Array.isArray;
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isFunction
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is a `Function`.
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a `Function`.
>, <Line: - */
>, <Line: -function isFunction(value) {return typeof value === 'function';}
>, <Line: -/**
>, <Line: - * Determines if a value is a regular expression object.
>, <Line: - *
>, <Line: - * @private
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a `RegExp`.
>, <Line: - */
>, <Line: -function isRegExp(value) {
>, <Line: -  return toString.call(value) === '[object RegExp]';
>, <Line: -}
>, <Line: -/**
>, <Line: - * Checks if `obj` is a window object.
>, <Line: - *
>, <Line: - * @private
>, <Line: - * @param {*} obj Object to check
>, <Line: - * @returns {boolean} True if `obj` is a window obj.
>, <Line: - */
>, <Line: -function isWindow(obj) {
>, <Line: -  return obj && obj.window === obj;
>, <Line: -}
>, <Line: -function isScope(obj) {
>, <Line: -  return obj && obj.$evalAsync && obj.$watch;
>, <Line: -}
>, <Line: -function isFile(obj) {
>, <Line: -  return toString.call(obj) === '[object File]';
>, <Line: -}
>, <Line: -function isBlob(obj) {
>, <Line: -  return toString.call(obj) === '[object Blob]';
>, <Line: -}
>, <Line: -function isBoolean(value) {
>, <Line: -  return typeof value === 'boolean';
>, <Line: -}
>, <Line: -function isPromiseLike(obj) {
>, <Line: -  return obj && isFunction(obj.then);
>, <Line: -}
>, <Line: -var trim = function(value) {
>, <Line: -  return isString(value) ? value.trim() : value;
>, <Line: -};
>, <Line: -var escapeForRegexp = function(s) {
>, <Line: -  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
>, <Line: -           replace(/\x08/g, '\\x08');
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.isElement
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if a reference is a DOM element (or wrapped jQuery element).
>, <Line: - *
>, <Line: - * @param {*} value Reference to check.
>, <Line: - * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
>, <Line: - */
>, <Line: -function isElement(node) {
>, <Line: -  return !!(node &&
>, <Line: -    (node.nodeName  // we are a direct element
>, <Line: -    || (node.prop && node.attr && node.find)));  // we have an on and find method part of jQuery API
>, <Line: -}
>, <Line: -/**
>, <Line: - * @param str 'key1,key2,...'
>, <Line: - * @returns {object} in the form of {key1:true, key2:true, ...}
>, <Line: - */
>, <Line: -function makeMap(str) {
>, <Line: -  var obj = {}, items = str.split(","), i;
>, <Line: -  for (i = 0; i < items.length; i++)
>, <Line: -    obj[ items[i] ] = true;
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -function nodeName_(element) {
>, <Line: -  return lowercase(element.nodeName || (element[0] && element[0].nodeName));
>, <Line: -}
>, <Line: -function includes(array, obj) {
>, <Line: -  return Array.prototype.indexOf.call(array, obj) != -1;
>, <Line: -}
>, <Line: -function arrayRemove(array, value) {
>, <Line: -  var index = array.indexOf(value);
>, <Line: -  if (index >= 0)
>, <Line: -    array.splice(index, 1);
>, <Line: -  return value;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.copy
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Creates a deep copy of `source`, which should be an object or an array.
>, <Line: - *
>, <Line: - * * If no destination is supplied, a copy of the object or array is created.
>, <Line: - * * If a destination is provided, all of its elements (for array) or properties (for objects)
>, <Line: - *   are deleted and then all elements/properties from the source are copied to it.
>, <Line: - * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
>, <Line: - * * If `source` is identical to 'destination' an exception will be thrown.
>, <Line: - *
>, <Line: - * @param {*} source The source that will be used to make a copy.
>, <Line: - *                   Can be any type, including primitives, `null`, and `undefined`.
>, <Line: - * @param {(Object|Array)=} destination Destination into which the source is copied. If
>, <Line: - *     provided, must be of the same type as `source`.
>, <Line: - * @returns {*} The copy or updated `destination`, if `destination` was specified.
>, <Line: - *
>, <Line: - * @example
>, <Line: - <example module="copyExample">
>, <Line: - <file name="index.html">
>, <Line: - <div ng-controller="ExampleController">
>, <Line: - <form novalidate class="simple-form">
>, <Line: - Name: <input type="text" ng-model="user.name" /><br />
>, <Line: - E-mail: <input type="email" ng-model="user.email" /><br />
>, <Line: - Gender: <input type="radio" ng-model="user.gender" value="male" />male
>, <Line: - <input type="radio" ng-model="user.gender" value="female" />female<br />
>, <Line: - <button ng-click="reset()">RESET</button>
>, <Line: - <button ng-click="update(user)">SAVE</button>
>, <Line: - </form>
>, <Line: - <pre>form = {{user | json}}</pre>
>, <Line: - <pre>master = {{master | json}}</pre>
>, <Line: - </div>
>, <Line: - <script>
>, <Line: -  angular.module('copyExample', [])
>, <Line: -    .controller('ExampleController', ['$scope', function($scope) {
>, <Line: - </script>
>, <Line: - </file>
>, <Line: - </example>
>, <Line: - */
>, <Line: -function copy(source, destination, stackSource, stackDest) {
>, <Line: -  if (isWindow(source) || isScope(source)) {
>, <Line: -    throw ngMinErr('cpws',
>, <Line: -      "Can't copy! Making copies of Window or Scope instances is not supported.");
>, <Line: -  }
>, <Line: -  if (!destination) {
>, <Line: -    destination = source;
>, <Line: -    if (source) {
>, <Line: -      if (isArray(source)) {
>, <Line: -        destination = copy(source, [], stackSource, stackDest);
>, <Line: -      } else if (isDate(source)) {
>, <Line: -        destination = new Date(source.getTime());
>, <Line: -      } else if (isRegExp(source)) {
>, <Line: -        destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
>, <Line: -        destination.lastIndex = source.lastIndex;
>, <Line: -      } else if (isObject(source)) {
>, <Line: -        var emptyObject = Object.create(Object.getPrototypeOf(source));
>, <Line: -        destination = copy(source, emptyObject, stackSource, stackDest);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  } else {
>, <Line: -    if (source === destination) throw ngMinErr('cpi',
>, <Line: -      "Can't copy! Source and destination are identical.");
>, <Line: -    stackSource = stackSource || [];
>, <Line: -    stackDest = stackDest || [];
>, <Line: -    if (isObject(source)) {
>, <Line: -      var index = stackSource.indexOf(source);
>, <Line: -      if (index !== -1) return stackDest[index];
>, <Line: -      stackSource.push(source);
>, <Line: -      stackDest.push(destination);
>, <Line: -    }
>, <Line: -    var result;
>, <Line: -    if (isArray(source)) {
>, <Line: -      destination.length = 0;
>, <Line: -      for (var i = 0; i < source.length; i++) {
>, <Line: -        result = copy(source[i], null, stackSource, stackDest);
>, <Line: -        if (isObject(source[i])) {
>, <Line: -          stackSource.push(source[i]);
>, <Line: -          stackDest.push(result);
>, <Line: -        }
>, <Line: -        destination.push(result);
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      var h = destination.$$hashKey;
>, <Line: -      if (isArray(destination)) {
>, <Line: -        destination.length = 0;
>, <Line: -      } else {
>, <Line: -        forEach(destination, function(value, key) {
>, <Line: -          delete destination[key];
>, <Line: -        });
>, <Line: -      }
>, <Line: -      for (var key in source) {
>, <Line: -        if (source.hasOwnProperty(key)) {
>, <Line: -          result = copy(source[key], null, stackSource, stackDest);
>, <Line: -          if (isObject(source[key])) {
>, <Line: -            stackSource.push(source[key]);
>, <Line: -            stackDest.push(result);
>, <Line: -          }
>, <Line: -          destination[key] = result;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      setHashKey(destination,h);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return destination;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Creates a shallow copy of an object, an array or a primitive.
>, <Line: - *
>, <Line: - * Assumes that there are no proto properties for objects.
>, <Line: - */
>, <Line: -function shallowCopy(src, dst) {
>, <Line: -  if (isArray(src)) {
>, <Line: -    dst = dst || [];
>, <Line: -    for (var i = 0, ii = src.length; i < ii; i++) {
>, <Line: -      dst[i] = src[i];
>, <Line: -    }
>, <Line: -  } else if (isObject(src)) {
>, <Line: -    dst = dst || {};
>, <Line: -    for (var key in src) {
>, <Line: -      if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
>, <Line: -        dst[key] = src[key];
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return dst || src;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.equals
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Determines if two objects or two values are equivalent. Supports value types, regular
>, <Line: - * expressions, arrays and objects.
>, <Line: - *
>, <Line: - * Two objects or values are considered equivalent if at least one of the following is true:
>, <Line: - *
>, <Line: - * * Both objects or values pass `===` comparison.
>, <Line: - * * Both objects or values are of the same type and all of their properties are equal by
>, <Line: - *   comparing them with `angular.equals`.
>, <Line: - * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
>, <Line: - * * Both values represent the same regular expression (In JavaScript,
>, <Line: - *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
>, <Line: - *   representation matches).
>, <Line: - *
>, <Line: - * During a property comparison, properties of `function` type and properties with names
>, <Line: - * that begin with `$` are ignored.
>, <Line: - *
>, <Line: - * Scope and DOMWindow objects are being compared only by identify (`===`).
>, <Line: - *
>, <Line: - * @param {*} o1 Object or value to compare.
>, <Line: - * @param {*} o2 Object or value to compare.
>, <Line: - * @returns {boolean} True if arguments are equal.
>, <Line: - */
>, <Line: -function equals(o1, o2) {
>, <Line: -  if (o1 === o2) return true;
>, <Line: -  if (o1 === null || o2 === null) return false;
>, <Line: -  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
>, <Line: -  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
>, <Line: -  if (t1 == t2) {
>, <Line: -    if (t1 == 'object') {
>, <Line: -      if (isArray(o1)) {
>, <Line: -        if (!isArray(o2)) return false;
>, <Line: -        if ((length = o1.length) == o2.length) {
>, <Line: -          for (key = 0; key < length; key++) {
>, <Line: -            if (!equals(o1[key], o2[key])) return false;
>, <Line: -          }
>, <Line: -          return true;
>, <Line: -        }
>, <Line: -      } else if (isDate(o1)) {
>, <Line: -        if (!isDate(o2)) return false;
>, <Line: -        return equals(o1.getTime(), o2.getTime());
>, <Line: -      } else if (isRegExp(o1) && isRegExp(o2)) {
>, <Line: -        return o1.toString() == o2.toString();
>, <Line: -      } else {
>, <Line: -        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
>, <Line: -        keySet = {};
>, <Line: -        for (key in o1) {
>, <Line: -          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
>, <Line: -          if (!equals(o1[key], o2[key])) return false;
>, <Line: -          keySet[key] = true;
>, <Line: -        }
>, <Line: -        for (key in o2) {
>, <Line: -          if (!keySet.hasOwnProperty(key) &&
>, <Line: -              key.charAt(0) !== '$' &&
>, <Line: -              o2[key] !== undefined &&
>, <Line: -              !isFunction(o2[key])) return false;
>, <Line: -        }
>, <Line: -        return true;
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return false;
>, <Line: -}
>, <Line: -var csp = function() {
>, <Line: -  if (isDefined(csp.isActive_)) return csp.isActive_;
>, <Line: -  var active = !!(document.querySelector('[ng-csp]') ||
>, <Line: -                  document.querySelector('[data-ng-csp]'));
>, <Line: -  if (!active) {
>, <Line: -    try {
>, <Line: -      /* jshint -W031, -W054 */
>, <Line: -      new Function('');
>, <Line: -      /* jshint +W031, +W054 */
>, <Line: -    } catch (e) {
>, <Line: -      active = true;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return (csp.isActive_ = active);
>, <Line: -};
>, <Line: -function concat(array1, array2, index) {
>, <Line: -  return array1.concat(slice.call(array2, index));
>, <Line: -}
>, <Line: -function sliceArgs(args, startIndex) {
>, <Line: -  return slice.call(args, startIndex || 0);
>, <Line: -}
>, <Line: -/* jshint -W101 */
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.bind
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
>, <Line: - * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
>, <Line: - * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
>, <Line: - * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
>, <Line: - *
>, <Line: - * @param {Object} self Context which `fn` should be evaluated in.
>, <Line: - * @param {function()} fn Function to be bound.
>, <Line: - * @param {...*} args Optional arguments to be prebound to the `fn` function call.
>, <Line: - * @returns {function()} Function that wraps the `fn` with all the specified bindings.
>, <Line: - */
>, <Line: -/* jshint +W101 */
>, <Line: -function bind(self, fn) {
>, <Line: -  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
>, <Line: -  if (isFunction(fn) && !(fn instanceof RegExp)) {
>, <Line: -    return curryArgs.length
>, <Line: -      ? function() {
>, <Line: -          return arguments.length
>, <Line: -            ? fn.apply(self, concat(curryArgs, arguments, 0))
>, <Line: -            : fn.apply(self, curryArgs);
>, <Line: -        }
>, <Line: -      : function() {
>, <Line: -          return arguments.length
>, <Line: -            ? fn.apply(self, arguments)
>, <Line: -            : fn.call(self);
>, <Line: -        };
>, <Line: -  } else {
>, <Line: -    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
>, <Line: -    return fn;
>, <Line: -  }
>, <Line: -}
>, <Line: -function toJsonReplacer(key, value) {
>, <Line: -  var val = value;
>, <Line: -  if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
>, <Line: -    val = undefined;
>, <Line: -  } else if (isWindow(value)) {
>, <Line: -    val = '$WINDOW';
>, <Line: -  } else if (value &&  document === value) {
>, <Line: -    val = '$DOCUMENT';
>, <Line: -  } else if (isScope(value)) {
>, <Line: -    val = '$SCOPE';
>, <Line: -  }
>, <Line: -  return val;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.toJson
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
>, <Line: - * stripped since angular uses this notation internally.
>, <Line: - *
>, <Line: - * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
>, <Line: - * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
>, <Line: - * @returns {string|undefined} JSON-ified string representing `obj`.
>, <Line: - */
>, <Line: -function toJson(obj, pretty) {
>, <Line: -  if (typeof obj === 'undefined') return undefined;
>, <Line: -  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.fromJson
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Deserializes a JSON string.
>, <Line: - *
>, <Line: - * @param {string} json JSON string to deserialize.
>, <Line: - * @returns {Object|Array|string|number} Deserialized thingy.
>, <Line: - */
>, <Line: -function fromJson(json) {
>, <Line: -  return isString(json)
>, <Line: -      ? JSON.parse(json)
>, <Line: -      : json;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @returns {string} Returns the string representation of the element.
>, <Line: - */
>, <Line: -function startingTag(element) {
>, <Line: -  element = jqLite(element).clone();
>, <Line: -  try {
>, <Line: -    // turns out IE does not let you set .html() on elements which
>, <Line: -    // are not allowed to have children. So we just ignore it.
>, <Line: -    element.empty();
>, <Line: -  } catch (e) {}
>, <Line: -  var elemHtml = jqLite('<div>').append(element).html();
>, <Line: -  try {
>, <Line: -    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
>, <Line: -        elemHtml.
>, <Line: -          match(/^(<[^>]+>)/)[1].
>, <Line: -          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
>, <Line: -  } catch (e) {
>, <Line: -    return lowercase(elemHtml);
>, <Line: -  }
>, <Line: -}
>, <Line: -/////////////////////////////////////////////////
>, <Line: -/**
>, <Line: - * Tries to decode the URI component without throwing an exception.
>, <Line: - *
>, <Line: - * @private
>, <Line: - * @param str value potential URI component to check.
>, <Line: - * @returns {boolean} True if `value` can be decoded
>, <Line: - * with the decodeURIComponent function.
>, <Line: - */
>, <Line: -function tryDecodeURIComponent(value) {
>, <Line: -  try {
>, <Line: -    return decodeURIComponent(value);
>, <Line: -  } catch (e) {
>, <Line: -    // Ignore any invalid uri component
>, <Line: -  }
>, <Line: -}
>, <Line: -/**
>, <Line: - * Parses an escaped url query string into key-value pairs.
>, <Line: - * @returns {Object.<string,boolean|Array>}
>, <Line: - */
>, <Line: -function parseKeyValue(/**string*/keyValue) {
>, <Line: -  var obj = {}, key_value, key;
>, <Line: -  forEach((keyValue || "").split('&'), function(keyValue) {
>, <Line: -    if (keyValue) {
>, <Line: -      key_value = keyValue.replace(/\+/g,'%20').split('=');
>, <Line: -      key = tryDecodeURIComponent(key_value[0]);
>, <Line: -      if (isDefined(key)) {
>, <Line: -        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
>, <Line: -        if (!hasOwnProperty.call(obj, key)) {
>, <Line: -          obj[key] = val;
>, <Line: -        } else if (isArray(obj[key])) {
>, <Line: -          obj[key].push(val);
>, <Line: -        } else {
>, <Line: -          obj[key] = [obj[key],val];
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  });
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -function toKeyValue(obj) {
>, <Line: -  var parts = [];
>, <Line: -  forEach(obj, function(value, key) {
>, <Line: -    if (isArray(value)) {
>, <Line: -      forEach(value, function(arrayValue) {
>, <Line: -        parts.push(encodeUriQuery(key, true) +
>, <Line: -                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
>, <Line: -      });
>, <Line: -    } else {
>, <Line: -    parts.push(encodeUriQuery(key, true) +
>, <Line: -               (value === true ? '' : '=' + encodeUriQuery(value, true)));
>, <Line: -    }
>, <Line: -  });
>, <Line: -  return parts.length ? parts.join('&') : '';
>, <Line: -}
>, <Line: -/**
>, <Line: - * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
>, <Line: - * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
>, <Line: - * segments:
>, <Line: - *    segment       = *pchar
>, <Line: - *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
>, <Line: - *    pct-encoded   = "%" HEXDIG HEXDIG
>, <Line: - *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
>, <Line: - *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
>, <Line: - *                     / "*" / "+" / "," / ";" / "="
>, <Line: - */
>, <Line: -function encodeUriSegment(val) {
>, <Line: -  return encodeUriQuery(val, true).
>, <Line: -             replace(/%26/gi, '&').
>, <Line: -             replace(/%3D/gi, '=').
>, <Line: -             replace(/%2B/gi, '+');
>, <Line: -}
>, <Line: -/**
>, <Line: - * This method is intended for encoding *key* or *value* parts of query component. We need a custom
>, <Line: - * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
>, <Line: - * encoded per http://tools.ietf.org/html/rfc3986:
>, <Line: - *    query       = *( pchar / "/" / "?" )
>, <Line: - *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
>, <Line: - *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
>, <Line: - *    pct-encoded   = "%" HEXDIG HEXDIG
>, <Line: - *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
>, <Line: - *                     / "*" / "+" / "," / ";" / "="
>, <Line: - */
>, <Line: -function encodeUriQuery(val, pctEncodeSpaces) {
>, <Line: -  return encodeURIComponent(val).
>, <Line: -             replace(/%40/gi, '@').
>, <Line: -             replace(/%3A/gi, ':').
>, <Line: -             replace(/%24/g, '$').
>, <Line: -             replace(/%2C/gi, ',').
>, <Line: -             replace(/%3B/gi, ';').
>, <Line: -             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
>, <Line: -}
>, <Line: -var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
>, <Line: -function getNgAttribute(element, ngAttr) {
>, <Line: -  var attr, i, ii = ngAttrPrefixes.length;
>, <Line: -  element = jqLite(element);
>, <Line: -  for (i = 0; i < ii; ++i) {
>, <Line: -    attr = ngAttrPrefixes[i] + ngAttr;
>, <Line: -    if (isString(attr = element.attr(attr))) {
>, <Line: -      return attr;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return null;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngApp
>, <Line: - * @module ng
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {angular.Module} ngApp an optional application
>, <Line: - *   {@link angular.module module} name to load.
>, <Line: - * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be
>, <Line: - *   created in "strict-di" mode. This means that the application will fail to invoke functions which
>, <Line: - *   do not use explicit function annotation (and are thus unsuitable for minification), as described
>, <Line: - *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in
>, <Line: - *   tracking down the root of these bugs.
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive
>, <Line: - * designates the **root element** of the application and is typically placed near the root element
>, <Line: - * of the page - e.g. on the `<body>` or `<html>` tags.
>, <Line: - *
>, <Line: - * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`
>, <Line: - * found in the document will be used to define the root element to auto-bootstrap as an
>, <Line: - * application. To run multiple applications in an HTML document you must manually bootstrap them using
>, <Line: - * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.
>, <Line: - *
>, <Line: - * You can specify an **AngularJS module** to be used as the root module for the application.  This
>, <Line: - * module will be loaded into the {@link auto.$injector} when the application is bootstrapped and
>, <Line: - * should contain the application code needed or have dependencies on other modules that will
>, <Line: - * contain the code. See {@link angular.module} for more information.
>, <Line: - *
>, <Line: - * In the example below if the `ngApp` directive were not placed on the `html` element then the
>, <Line: - * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`
>, <Line: - * would not be resolved to `3`.
>, <Line: - *
>, <Line: - * `ngApp` is the easiest, and most common, way to bootstrap an application.
>, <Line: - *
>, <Line: - <example module="ngAppDemo">
>, <Line: -   <file name="index.html">
>, <Line: -   <div ng-controller="ngAppDemoController">
>, <Line: -     I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: -   </div>
>, <Line: -   </file>
>, <Line: -   <file name="script.js">
>, <Line: -   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
>, <Line: -     $scope.a = 1;
>, <Line: -     $scope.b = 2;
>, <Line: -   });
>, <Line: -   </file>
>, <Line: - </example>
>, <Line: - *
>, <Line: - * Using `ngStrictDi`, you would see something like this:
>, <Line: - <example ng-app-included="true">
>, <Line: -   <file name="index.html">
>, <Line: -   <div ng-app="ngAppStrictDemo" ng-strict-di>
>, <Line: -       <div ng-controller="GoodController1">
>, <Line: -           I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: -           <p>This renders because the controller does not fail to
>, <Line: -              instantiate, by using explicit annotation style (see
>, <Line: -              script.js for details)
>, <Line: -           </p>
>, <Line: -       </div>
>, <Line: -       <div ng-controller="GoodController2">
>, <Line: -           Name: <input ng-model="name"><br />
>, <Line: -           Hello, {{name}}!
>, <Line: -           <p>This renders because the controller does not fail to
>, <Line: -              instantiate, by using explicit annotation style
>, <Line: -              (see script.js for details)
>, <Line: -           </p>
>, <Line: -       </div>
>, <Line: -       <div ng-controller="BadController">
>, <Line: -           I can add: {{a}} + {{b}} =  {{ a+b }}
>, <Line: -           <p>The controller could not be instantiated, due to relying
>, <Line: -              on automatic function annotations (which are disabled in
>, <Line: -              strict mode). As such, the content of this section is not
>, <Line: -              interpolated, and there should be an error in your web console.
>, <Line: -           </p>
>, <Line: -       </div>
>, <Line: -   </div>
>, <Line: -   </file>
>, <Line: -   <file name="script.js">
>, <Line: -   angular.module('ngAppStrictDemo', [])
>, <Line: -     // BadController will fail to instantiate, due to relying on automatic function annotation,
>, <Line: -     // rather than an explicit annotation
>, <Line: -     .controller('BadController', function($scope) {
>, <Line: -       $scope.a = 1;
>, <Line: -       $scope.b = 2;
>, <Line: -     })
>, <Line: -     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,
>, <Line: -     // due to using explicit annotations using the array style and $inject property, respectively.
>, <Line: -     .controller('GoodController1', ['$scope', function($scope) {
>, <Line: -       $scope.a = 1;
>, <Line: -       $scope.b = 2;
>, <Line: -     }])
>, <Line: -     .controller('GoodController2', GoodController2);
>, <Line: -     function GoodController2($scope) {
>, <Line: -       $scope.name = "World";
>, <Line: -     }
>, <Line: -     GoodController2.$inject = ['$scope'];
>, <Line: -   </file>
>, <Line: -   <file name="style.css">
>, <Line: -   div[ng-controller] {
>, <Line: -       margin-bottom: 1em;
>, <Line: -       -webkit-border-radius: 4px;
>, <Line: -       border-radius: 4px;
>, <Line: -       border: 1px solid;
>, <Line: -       padding: .5em;
>, <Line: -   }
>, <Line: -   div[ng-controller^=Good] {
>, <Line: -       border-color: #d6e9c6;
>, <Line: -       background-color: #dff0d8;
>, <Line: -       color: #3c763d;
>, <Line: -   }
>, <Line: -   div[ng-controller^=Bad] {
>, <Line: -       border-color: #ebccd1;
>, <Line: -       background-color: #f2dede;
>, <Line: -       color: #a94442;
>, <Line: -       margin-bottom: 0;
>, <Line: -   }
>, <Line: -   </file>
>, <Line: - </example>
>, <Line: - */
>, <Line: -function angularInit(element, bootstrap) {
>, <Line: -  var appElement,
>, <Line: -      module,
>, <Line: -      config = {};
>, <Line: -  // The element `element` has priority over any other element
>, <Line: -  forEach(ngAttrPrefixes, function(prefix) {
>, <Line: -    var name = prefix + 'app';
>, <Line: -    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
>, <Line: -      appElement = element;
>, <Line: -      module = element.getAttribute(name);
>, <Line: -    }
>, <Line: -  });
>, <Line: -  forEach(ngAttrPrefixes, function(prefix) {
>, <Line: -    var name = prefix + 'app';
>, <Line: -    var candidate;
>, <Line: -    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
>, <Line: -      appElement = candidate;
>, <Line: -      module = candidate.getAttribute(name);
>, <Line: -    }
>, <Line: -  });
>, <Line: -  if (appElement) {
>, <Line: -    config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
>, <Line: -    bootstrap(appElement, module ? [module] : [], config);
>, <Line: -  }
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.bootstrap
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - * Use this function to manually start up angular application.
>, <Line: - * See: {@link guide/bootstrap Bootstrap}
>, <Line: - * Note that Protractor based end-to-end tests cannot use this function to bootstrap manually.
>, <Line: - * They must use {@link ng.directive:ngApp ngApp}.
>, <Line: - * Angular will detect if it has been loaded into the browser more than once and only allow the
>, <Line: - * first loaded script to be bootstrapped and will report a warning to the browser console for
>, <Line: - * each of the subsequent scripts. This prevents strange results in applications, where otherwise
>, <Line: - * multiple instances of Angular try to work on the DOM.
>, <Line: - * ```html
>, <Line: - * <!doctype html>
>, <Line: - * <html>
>, <Line: - * <body>
>, <Line: - * <div ng-controller="WelcomeController">
>, <Line: - *   {{greeting}}
>, <Line: - * </div>
>, <Line: - * <script src="angular.js"></script>
>, <Line: - * <script>
>, <Line: - *   var app = angular.module('demo', [])
>, <Line: - *   .controller('WelcomeController', function($scope) {
>, <Line: - *       $scope.greeting = 'Welcome!';
>, <Line: - *   angular.bootstrap(document, ['demo']);
>, <Line: - * </script>
>, <Line: - * </body>
>, <Line: - * </html>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @param {DOMElement} element DOM element which is the root of angular application.
>, <Line: - * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
>, <Line: - *     Each item in the array should be the name of a predefined module or a (DI annotated)
>, <Line: - *     function that will be invoked by the injector as a run block.
>, <Line: - *     See: {@link angular.module modules}
>, <Line: - * @param {Object=} config an object for defining configuration options for the application. The
>, <Line: - *     following keys are supported:
>, <Line: - *
>, <Line: - * * `strictDi` - disable automatic function annotation for the application. This is meant to
>, <Line: - *   assist in finding bugs which break minified code. Defaults to `false`.
>, <Line: - *
>, <Line: - * @returns {auto.$injector} Returns the newly created injector for this app.
>, <Line: - */
>, <Line: -function bootstrap(element, modules, config) {
>, <Line: -  if (!isObject(config)) config = {};
>, <Line: -  var defaultConfig = {
>, <Line: -    strictDi: false
>, <Line: -  };
>, <Line: -  config = extend(defaultConfig, config);
>, <Line: -  var doBootstrap = function() {
>, <Line: -    element = jqLite(element);
>, <Line: -    if (element.injector()) {
>, <Line: -      var tag = (element[0] === document) ? 'document' : startingTag(element);
>, <Line: -      //Encode angle brackets to prevent input from being sanitized to empty string #8683
>, <Line: -      throw ngMinErr(
>, <Line: -          'btstrpd',
>, <Line: -          "App Already Bootstrapped with this Element '{0}'",
>, <Line: -          tag.replace(/</,'&lt;').replace(/>/,'&gt;'));
>, <Line: -    }
>, <Line: -    modules = modules || [];
>, <Line: -    modules.unshift(['$provide', function($provide) {
>, <Line: -      $provide.value('$rootElement', element);
>, <Line: -    }]);
>, <Line: -    if (config.debugInfoEnabled) {
>, <Line: -      // Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.
>, <Line: -      modules.push(['$compileProvider', function($compileProvider) {
>, <Line: -        $compileProvider.debugInfoEnabled(true);
>, <Line: -      }]);
>, <Line: -    }
>, <Line: -    modules.unshift('ng');
>, <Line: -    var injector = createInjector(modules, config.strictDi);
>, <Line: -    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
>, <Line: -       function bootstrapApply(scope, element, compile, injector) {
>, <Line: -        scope.$apply(function() {
>, <Line: -          element.data('$injector', injector);
>, <Line: -          compile(element)(scope);
>, <Line: -        });
>, <Line: -      }]
>, <Line: -    );
>, <Line: -    return injector;
>, <Line: -  };
>, <Line: -  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
>, <Line: -  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
>, <Line: -  if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
>, <Line: -    config.debugInfoEnabled = true;
>, <Line: -    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
>, <Line: -  }
>, <Line: -  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
>, <Line: -    return doBootstrap();
>, <Line: -  }
>, <Line: -  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
>, <Line: -  angular.resumeBootstrap = function(extraModules) {
>, <Line: -    forEach(extraModules, function(module) {
>, <Line: -      modules.push(module);
>, <Line: -    });
>, <Line: -    doBootstrap();
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.reloadWithDebugInfo
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - * Use this function to reload the current application with debug information turned on.
>, <Line: - * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.
>, <Line: - *
>, <Line: - * See {@link ng.$compileProvider#debugInfoEnabled} for more.
>, <Line: - */
>, <Line: -function reloadWithDebugInfo() {
>, <Line: -  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
>, <Line: -  window.location.reload();
>, <Line: -}
>, <Line: -/**
>, <Line: - * @name angular.getTestability
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - * Get the testability service for the instance of Angular on the given
>, <Line: - * element.
>, <Line: - * @param {DOMElement} element DOM element which is the root of angular application.
>, <Line: - */
>, <Line: -function getTestability(rootElement) {
>, <Line: -  return angular.element(rootElement).injector().get('$$testability');
>, <Line: -}
>, <Line: -var SNAKE_CASE_REGEXP = /[A-Z]/g;
>, <Line: -function snake_case(name, separator) {
>, <Line: -  separator = separator || '_';
>, <Line: -  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
>, <Line: -    return (pos ? separator : '') + letter.toLowerCase();
>, <Line: -  });
>, <Line: -}
>, <Line: -var bindJQueryFired = false;
>, <Line: -var skipDestroyOnNextJQueryCleanData;
>, <Line: -function bindJQuery() {
>, <Line: -  var originalCleanData;
>, <Line: -  if (bindJQueryFired) {
>, <Line: -    return;
>, <Line: -  }
>, <Line: -  // bind to jQuery if present;
>, <Line: -  jQuery = window.jQuery;
>, <Line: -  // Use jQuery if it exists with proper functionality, otherwise default to us.
>, <Line: -  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.
>, <Line: -  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older
>, <Line: -  // versions. It will not work for sure with jQuery <1.7, though.
>, <Line: -  if (jQuery && jQuery.fn.on) {
>, <Line: -    jqLite = jQuery;
>, <Line: -    extend(jQuery.fn, {
>, <Line: -      scope: JQLitePrototype.scope,
>, <Line: -      isolateScope: JQLitePrototype.isolateScope,
>, <Line: -      controller: JQLitePrototype.controller,
>, <Line: -      injector: JQLitePrototype.injector,
>, <Line: -      inheritedData: JQLitePrototype.inheritedData
>, <Line: -    });
>, <Line: -    // All nodes removed from the DOM via various jQuery APIs like .remove()
>, <Line: -    // are passed through jQuery.cleanData. Monkey-patch this method to fire
>, <Line: -    // the $destroy event on all removed nodes.
>, <Line: -    originalCleanData = jQuery.cleanData;
>, <Line: -    jQuery.cleanData = function(elems) {
>, <Line: -      var events;
>, <Line: -      if (!skipDestroyOnNextJQueryCleanData) {
>, <Line: -        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
>, <Line: -          events = jQuery._data(elem, "events");
>, <Line: -          if (events && events.$destroy) {
>, <Line: -            jQuery(elem).triggerHandler('$destroy');
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        skipDestroyOnNextJQueryCleanData = false;
>, <Line: -      }
>, <Line: -      originalCleanData(elems);
>, <Line: -    };
>, <Line: -  } else {
>, <Line: -    jqLite = JQLite;
>, <Line: -  }
>, <Line: -  angular.element = jqLite;
>, <Line: -  // Prevent double-proxying.
>, <Line: -  bindJQueryFired = true;
>, <Line: -}
>, <Line: -/**
>, <Line: - * throw error if the argument is falsy.
>, <Line: - */
>, <Line: -function assertArg(arg, name, reason) {
>, <Line: -  if (!arg) {
>, <Line: -    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
>, <Line: -  }
>, <Line: -  return arg;
>, <Line: -}
>, <Line: -function assertArgFn(arg, name, acceptArrayAnnotation) {
>, <Line: -  if (acceptArrayAnnotation && isArray(arg)) {
>, <Line: -      arg = arg[arg.length - 1];
>, <Line: -  }
>, <Line: -  assertArg(isFunction(arg), name, 'not a function, got ' +
>, <Line: -      (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
>, <Line: -  return arg;
>, <Line: -}
>, <Line: -/**
>, <Line: - * throw error if the name given is hasOwnProperty
>, <Line: - * @param  {String} name    the name to test
>, <Line: - * @param  {String} context the context in which the name is used, such as module or directive
>, <Line: - */
>, <Line: -function assertNotHasOwnProperty(name, context) {
>, <Line: -  if (name === 'hasOwnProperty') {
>, <Line: -    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
>, <Line: -  }
>, <Line: -}
>, <Line: -/**
>, <Line: - * Return the value accessible from the object by path. Any undefined traversals are ignored
>, <Line: - * @param {Object} obj starting object
>, <Line: - * @param {String} path path to traverse
>, <Line: - * @param {boolean} [bindFnToScope=true]
>, <Line: - * @returns {Object} value as accessible by path
>, <Line: - */
>, <Line: -//TODO(misko): this function needs to be removed
>, <Line: -function getter(obj, path, bindFnToScope) {
>, <Line: -  if (!path) return obj;
>, <Line: -  var keys = path.split('.');
>, <Line: -  var key;
>, <Line: -  var lastInstance = obj;
>, <Line: -  var len = keys.length;
>, <Line: -  for (var i = 0; i < len; i++) {
>, <Line: -    key = keys[i];
>, <Line: -    if (obj) {
>, <Line: -      obj = (lastInstance = obj)[key];
>, <Line: -    }
>, <Line: -  }
>, <Line: -  if (!bindFnToScope && isFunction(obj)) {
>, <Line: -    return bind(lastInstance, obj);
>, <Line: -  }
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Return the DOM siblings between the first and last node in the given array.
>, <Line: - * @param {Array} array like object
>, <Line: - * @returns {jqLite} jqLite collection containing the nodes
>, <Line: - */
>, <Line: -function getBlockNodes(nodes) {
>, <Line: -  // TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
>, <Line: -  //             collection, otherwise update the original collection.
>, <Line: -  var node = nodes[0];
>, <Line: -  var endNode = nodes[nodes.length - 1];
>, <Line: -  var blockNodes = [node];
>, <Line: -  do {
>, <Line: -    node = node.nextSibling;
>, <Line: -    if (!node) break;
>, <Line: -    blockNodes.push(node);
>, <Line: -  } while (node !== endNode);
>, <Line: -  return jqLite(blockNodes);
>, <Line: -}
>, <Line: -/**
>, <Line: - * Creates a new object without a prototype. This object is useful for lookup without having to
>, <Line: - * guard against prototypically inherited properties via hasOwnProperty.
>, <Line: - *
>, <Line: - * Related micro-benchmarks:
>, <Line: - * - http://jsperf.com/object-create2
>, <Line: - * - http://jsperf.com/proto-map-lookup/2
>, <Line: - * - http://jsperf.com/for-in-vs-object-keys2
>, <Line: - * @returns {Object}
>, <Line: - */
>, <Line: -function createMap() {
>, <Line: -  return Object.create(null);
>, <Line: -}
>, <Line: -var NODE_TYPE_ELEMENT = 1;
>, <Line: -var NODE_TYPE_TEXT = 3;
>, <Line: -var NODE_TYPE_COMMENT = 8;
>, <Line: -var NODE_TYPE_DOCUMENT = 9;
>, <Line: -var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name angular.Module
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - * Interface for configuring angular {@link angular.module modules}.
>, <Line: - */
>, <Line: -function setupModuleLoader(window) {
>, <Line: -  var $injectorMinErr = minErr('$injector');
>, <Line: -  var ngMinErr = minErr('ng');
>, <Line: -  function ensure(obj, name, factory) {
>, <Line: -    return obj[name] || (obj[name] = factory());
>, <Line: -  }
>, <Line: -  var angular = ensure(window, 'angular', Object);
>, <Line: -  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
>, <Line: -  angular.$$minErr = angular.$$minErr || minErr;
>, <Line: -  return ensure(angular, 'module', function() {
>, <Line: -    /** @type {Object.<string, angular.Module>} */
>, <Line: -    var modules = {};
>, <Line: -    /**
>, <Line: -     * @ngdoc function
>, <Line: -     * @name angular.module
>, <Line: -     * @module ng
>, <Line: -     * @description
>, <Line: -     * The `angular.module` is a global place for creating, registering and retrieving Angular
>, <Line: -     * modules.
>, <Line: -     * All modules (angular core or 3rd party) that should be available to an application must be
>, <Line: -     * registered using this mechanism.
>, <Line: -     * When passed two or more arguments, a new module is created.  If passed only one argument, an
>, <Line: -     * existing module (the name passed as the first argument to `module`) is retrieved.
>, <Line: -     * # Module
>, <Line: -     * A module is a collection of services, directives, controllers, filters, and configuration information.
>, <Line: -     * `angular.module` is used to configure the {@link auto.$injector $injector}.
>, <Line: -     * ```js
>, <Line: -     * // Create a new module
>, <Line: -     * var myModule = angular.module('myModule', []);
>, <Line: -     * // register a new service
>, <Line: -     * myModule.value('appName', 'MyCoolApp');
>, <Line: -     * // configure existing services inside initialization blocks.
>, <Line: -     * myModule.config(['$locationProvider', function($locationProvider) {
>, <Line: -     *   // Configure existing providers
>, <Line: -     *   $locationProvider.hashPrefix('!');
>, <Line: -     * }]);
>, <Line: -     * ```
>, <Line: -     * Then you can create an injector and load your modules like this:
>, <Line: -     * var injector = angular.injector(['ng', 'myModule'])
>, <Line: -     * However it's more likely that you'll just use
>, <Line: -     * {@link ng.directive:ngApp ngApp} or
>, <Line: -     * {@link angular.bootstrap} to simplify this process for you.
>, <Line: -     * @param {!string} name The name of the module to create or retrieve.
>, <Line: -     * @param {!Array.<string>=} requires If specified then new module is being created. If
>, <Line: -     *        unspecified then the module is being retrieved for further configuration.
>, <Line: -     * @param {Function=} configFn Optional configuration function for the module. Same as
>, <Line: -     *        {@link angular.Module#config Module#config()}.
>, <Line: -     * @returns {module} new module with the {@link angular.Module} api.
>, <Line: -     */
>, <Line: -    return function module(name, requires, configFn) {
>, <Line: -      var assertNotHasOwnProperty = function(name, context) {
>, <Line: -        if (name === 'hasOwnProperty') {
>, <Line: -          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
>, <Line: -        }
>, <Line: -      };
>, <Line: -      assertNotHasOwnProperty(name, 'module');
>, <Line: -      if (requires && modules.hasOwnProperty(name)) {
>, <Line: -        modules[name] = null;
>, <Line: -      }
>, <Line: -      return ensure(modules, name, function() {
>, <Line: -        if (!requires) {
>, <Line: -          throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
>, <Line: -             "the module name or forgot to load it. If registering a module ensure that you " +
>, <Line: -             "specify the dependencies as the second argument.", name);
>, <Line: -        }
>, <Line: -        /** @type {!Array.<Array.<*>>} */
>, <Line: -        var invokeQueue = [];
>, <Line: -        /** @type {!Array.<Function>} */
>, <Line: -        var configBlocks = [];
>, <Line: -        /** @type {!Array.<Function>} */
>, <Line: -        var runBlocks = [];
>, <Line: -        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
>, <Line: -        /** @type {angular.Module} */
>, <Line: -        var moduleInstance = {
>, <Line: -          // Private state
>, <Line: -          _invokeQueue: invokeQueue,
>, <Line: -          _configBlocks: configBlocks,
>, <Line: -          _runBlocks: runBlocks,
>, <Line: -          /**
>, <Line: -           * @ngdoc property
>, <Line: -           * @name angular.Module#requires
>, <Line: -           * @module ng
>, <Line: -           *
>, <Line: -           * @description
>, <Line: -           * Holds the list of modules which the injector will load before the current module is
>, <Line: -           * loaded.
>, <Line: -           */
>, <Line: -          requires: requires,
>, <Line: -          /**
>, <Line: -           * @ngdoc property
>, <Line: -           * @name angular.Module#name
>, <Line: -           * @module ng
>, <Line: -           *
>, <Line: -           * @description
>, <Line: -           * Name of the module.
>, <Line: -           */
>, <Line: -          name: name,
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#provider
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name service name
>, <Line: -           * @param {Function} providerType Construction function for creating new instance of the
>, <Line: -           *                                service.
>, <Line: -           * @description
>, <Line: -           * See {@link auto.$provide#provider $provide.provider()}.
>, <Line: -           */
>, <Line: -          provider: invokeLater('$provide', 'provider'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#factory
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name service name
>, <Line: -           * @param {Function} providerFunction Function for creating new instance of the service.
>, <Line: -           * @description
>, <Line: -           * See {@link auto.$provide#factory $provide.factory()}.
>, <Line: -           */
>, <Line: -          factory: invokeLater('$provide', 'factory'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#service
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name service name
>, <Line: -           * @param {Function} constructor A constructor function that will be instantiated.
>, <Line: -           * @description
>, <Line: -           * See {@link auto.$provide#service $provide.service()}.
>, <Line: -           */
>, <Line: -          service: invokeLater('$provide', 'service'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#value
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name service name
>, <Line: -           * @param {*} object Service instance object.
>, <Line: -           * @description
>, <Line: -           * See {@link auto.$provide#value $provide.value()}.
>, <Line: -           */
>, <Line: -          value: invokeLater('$provide', 'value'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#constant
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name constant name
>, <Line: -           * @param {*} object Constant value.
>, <Line: -           * @description
>, <Line: -           * Because the constant are fixed, they get applied before other provide methods.
>, <Line: -           * See {@link auto.$provide#constant $provide.constant()}.
>, <Line: -           */
>, <Line: -          constant: invokeLater('$provide', 'constant', 'unshift'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#animation
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name animation name
>, <Line: -           * @param {Function} animationFactory Factory function for creating new instance of an
>, <Line: -           *                                    animation.
>, <Line: -           * @description
>, <Line: -           *
>, <Line: -           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.
>, <Line: -           *
>, <Line: -           *
>, <Line: -           * Defines an animation hook that can be later used with
>, <Line: -           * {@link ngAnimate.$animate $animate} service and directives that use this service.
>, <Line: -           *
>, <Line: -           * ```js
>, <Line: -           * module.animation('.animation-name', function($inject1, $inject2) {
>, <Line: -           *   return {
>, <Line: -           *     eventName : function(element, done) {
>, <Line: -           *       //code to run the animation
>, <Line: -           *       //once complete, then run done()
>, <Line: -           *       return function cancellationFunction(element) {
>, <Line: -           *         //code to cancel the animation
>, <Line: -           *       }
>, <Line: -           *     }
>, <Line: -           *   }
>, <Line: -           * })
>, <Line: -           * ```
>, <Line: -           *
>, <Line: -           * See {@link ng.$animateProvider#register $animateProvider.register()} and
>, <Line: -           * {@link ngAnimate ngAnimate module} for more information.
>, <Line: -           */
>, <Line: -          animation: invokeLater('$animateProvider', 'register'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#filter
>, <Line: -           * @module ng
>, <Line: -           * @param {string} name Filter name.
>, <Line: -           * @param {Function} filterFactory Factory function for creating new instance of filter.
>, <Line: -           * @description
>, <Line: -           * See {@link ng.$filterProvider#register $filterProvider.register()}.
>, <Line: -           */
>, <Line: -          filter: invokeLater('$filterProvider', 'register'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#controller
>, <Line: -           * @module ng
>, <Line: -           * @param {string|Object} name Controller name, or an object map of controllers where the
>, <Line: -           *    keys are the names and the values are the constructors.
>, <Line: -           * @param {Function} constructor Controller constructor function.
>, <Line: -           * @description
>, <Line: -           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
>, <Line: -           */
>, <Line: -          controller: invokeLater('$controllerProvider', 'register'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#directive
>, <Line: -           * @module ng
>, <Line: -           * @param {string|Object} name Directive name, or an object map of directives where the
>, <Line: -           *    keys are the names and the values are the factories.
>, <Line: -           * @param {Function} directiveFactory Factory function for creating new instance of
>, <Line: -           * directives.
>, <Line: -           * @description
>, <Line: -           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
>, <Line: -           */
>, <Line: -          directive: invokeLater('$compileProvider', 'directive'),
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#config
>, <Line: -           * @module ng
>, <Line: -           * @param {Function} configFn Execute this function on module load. Useful for service
>, <Line: -           *    configuration.
>, <Line: -           * @description
>, <Line: -           * Use this method to register work which needs to be performed on module loading.
>, <Line: -           * For more about how to configure services, see
>, <Line: -           * {@link providers#provider-recipe Provider Recipe}.
>, <Line: -           */
>, <Line: -          config: config,
>, <Line: -          /**
>, <Line: -           * @ngdoc method
>, <Line: -           * @name angular.Module#run
>, <Line: -           * @module ng
>, <Line: -           * @param {Function} initializationFn Execute this function after injector creation.
>, <Line: -           *    Useful for application initialization.
>, <Line: -           * @description
>, <Line: -           * Use this method to register work which should be performed when the injector is done
>, <Line: -           * loading all modules.
>, <Line: -           */
>, <Line: -          run: function(block) {
>, <Line: -            runBlocks.push(block);
>, <Line: -            return this;
>, <Line: -          }
>, <Line: -        };
>, <Line: -        if (configFn) {
>, <Line: -          config(configFn);
>, <Line: -        }
>, <Line: -        return moduleInstance;
>, <Line: -        /**
>, <Line: -         * @param {string} provider
>, <Line: -         * @param {string} method
>, <Line: -         * @param {String=} insertMethod
>, <Line: -         * @returns {angular.Module}
>, <Line: -         */
>, <Line: -        function invokeLater(provider, method, insertMethod, queue) {
>, <Line: -          if (!queue) queue = invokeQueue;
>, <Line: -          return function() {
>, <Line: -            queue[insertMethod || 'push']([provider, method, arguments]);
>, <Line: -            return moduleInstance;
>, <Line: -          };
>, <Line: -        }
>, <Line: -      });
>, <Line: -    };
>, <Line: -  });
>, <Line: -}
>, <Line: -/* global: toDebugString: true */
>, <Line: -function serializeObject(obj) {
>, <Line: -  var seen = [];
>, <Line: -  return JSON.stringify(obj, function(key, val) {
>, <Line: -    val = toJsonReplacer(key, val);
>, <Line: -    if (isObject(val)) {
>, <Line: -      if (seen.indexOf(val) >= 0) return '<<already seen>>';
>, <Line: -      seen.push(val);
>, <Line: -    }
>, <Line: -    return val;
>, <Line: -}
>, <Line: -function toDebugString(obj) {
>, <Line: -  if (typeof obj === 'function') {
>, <Line: -    return obj.toString().replace(/ \{[\s\S]*$/, '');
>, <Line: -  } else if (typeof obj === 'undefined') {
>, <Line: -    return 'undefined';
>, <Line: -  } else if (typeof obj !== 'string') {
>, <Line: -    return serializeObject(obj);
>, <Line: -  }
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -/* global angularModule: true,
>, <Line: -  version: true,
>, <Line: -  $LocaleProvider,
>, <Line: -  $CompileProvider,
>, <Line: -  htmlAnchorDirective,
>, <Line: -  inputDirective,
>, <Line: -  inputDirective,
>, <Line: -  formDirective,
>, <Line: -  scriptDirective,
>, <Line: -  selectDirective,
>, <Line: -  styleDirective,
>, <Line: -  optionDirective,
>, <Line: -  ngBindDirective,
>, <Line: -  ngBindHtmlDirective,
>, <Line: -  ngBindTemplateDirective,
>, <Line: -  ngClassDirective,
>, <Line: -  ngClassEvenDirective,
>, <Line: -  ngClassOddDirective,
>, <Line: -  ngCspDirective,
>, <Line: -  ngCloakDirective,
>, <Line: -  ngControllerDirective,
>, <Line: -  ngFormDirective,
>, <Line: -  ngHideDirective,
>, <Line: -  ngIfDirective,
>, <Line: -  ngIncludeDirective,
>, <Line: -  ngIncludeFillContentDirective,
>, <Line: -  ngInitDirective,
>, <Line: -  ngNonBindableDirective,
>, <Line: -  ngPluralizeDirective,
>, <Line: -  ngRepeatDirective,
>, <Line: -  ngShowDirective,
>, <Line: -  ngStyleDirective,
>, <Line: -  ngSwitchDirective,
>, <Line: -  ngSwitchWhenDirective,
>, <Line: -  ngSwitchDefaultDirective,
>, <Line: -  ngOptionsDirective,
>, <Line: -  ngTranscludeDirective,
>, <Line: -  ngModelDirective,
>, <Line: -  ngListDirective,
>, <Line: -  ngChangeDirective,
>, <Line: -  patternDirective,
>, <Line: -  patternDirective,
>, <Line: -  requiredDirective,
>, <Line: -  requiredDirective,
>, <Line: -  minlengthDirective,
>, <Line: -  minlengthDirective,
>, <Line: -  maxlengthDirective,
>, <Line: -  maxlengthDirective,
>, <Line: -  ngValueDirective,
>, <Line: -  ngModelOptionsDirective,
>, <Line: -  ngAttributeAliasDirectives,
>, <Line: -  ngEventDirectives,
>, <Line: -  $AnchorScrollProvider,
>, <Line: -  $AnimateProvider,
>, <Line: -  $BrowserProvider,
>, <Line: -  $CacheFactoryProvider,
>, <Line: -  $ControllerProvider,
>, <Line: -  $DocumentProvider,
>, <Line: -  $ExceptionHandlerProvider,
>, <Line: -  $FilterProvider,
>, <Line: -  $InterpolateProvider,
>, <Line: -  $IntervalProvider,
>, <Line: -  $HttpProvider,
>, <Line: -  $HttpBackendProvider,
>, <Line: -  $LocationProvider,
>, <Line: -  $LogProvider,
>, <Line: -  $ParseProvider,
>, <Line: -  $RootScopeProvider,
>, <Line: -  $QProvider,
>, <Line: -  $$QProvider,
>, <Line: -  $$SanitizeUriProvider,
>, <Line: -  $SceProvider,
>, <Line: -  $SceDelegateProvider,
>, <Line: -  $SnifferProvider,
>, <Line: -  $TemplateCacheProvider,
>, <Line: -  $TemplateRequestProvider,
>, <Line: -  $$TestabilityProvider,
>, <Line: -  $TimeoutProvider,
>, <Line: -  $$RAFProvider,
>, <Line: -  $$AsyncCallbackProvider,
>, <Line: -  $WindowProvider
>, <Line: -*/
>, <Line: -/**
>, <Line: - * @ngdoc object
>, <Line: - * @name angular.version
>, <Line: - * @module ng
>, <Line: - * @description
>, <Line: - * An object that contains information about the current AngularJS version. This object has the
>, <Line: - * following properties:
>, <Line: - *
>, <Line: - * - `full`  `{string}`  Full version string, such as "0.9.18".
>, <Line: - * - `major`  `{number}`  Major version number, such as "0".
>, <Line: - * - `minor`  `{number}`  Minor version number, such as "9".
>, <Line: - * - `dot`  `{number}`  Dot version number, such as "18".
>, <Line: - * - `codeName`  `{string}`  Code name of the release, such as "jiggling-armfat".
>, <Line: - */
>, <Line: -var version = {
>, <Line: -  full: '1.3.4',    // all of these placeholder strings will be replaced by grunt's
>, <Line: -  major: 1,    // package task
>, <Line: -  minor: 3,
>, <Line: -  dot: 4,
>, <Line: -  codeName: 'highfalutin-petroglyph'
>, <Line: -};
>, <Line: -function publishExternalAPI(angular) {
>, <Line: -  extend(angular, {
>, <Line: -    'bootstrap': bootstrap,
>, <Line: -    'copy': copy,
>, <Line: -    'extend': extend,
>, <Line: -    'equals': equals,
>, <Line: -    'element': jqLite,
>, <Line: -    'forEach': forEach,
>, <Line: -    'injector': createInjector,
>, <Line: -    'noop': noop,
>, <Line: -    'bind': bind,
>, <Line: -    'toJson': toJson,
>, <Line: -    'fromJson': fromJson,
>, <Line: -    'identity': identity,
>, <Line: -    'isUndefined': isUndefined,
>, <Line: -    'isDefined': isDefined,
>, <Line: -    'isString': isString,
>, <Line: -    'isFunction': isFunction,
>, <Line: -    'isObject': isObject,
>, <Line: -    'isNumber': isNumber,
>, <Line: -    'isElement': isElement,
>, <Line: -    'isArray': isArray,
>, <Line: -    'version': version,
>, <Line: -    'isDate': isDate,
>, <Line: -    'lowercase': lowercase,
>, <Line: -    'uppercase': uppercase,
>, <Line: -    'callbacks': {counter: 0},
>, <Line: -    'getTestability': getTestability,
>, <Line: -    '$$minErr': minErr,
>, <Line: -    '$$csp': csp,
>, <Line: -    'reloadWithDebugInfo': reloadWithDebugInfo
>, <Line: -  angularModule = setupModuleLoader(window);
>, <Line: -  try {
>, <Line: -    angularModule('ngLocale');
>, <Line: -  } catch (e) {
>, <Line: -    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
>, <Line: -  }
>, <Line: -  angularModule('ng', ['ngLocale'], ['$provide',
>, <Line: -    function ngModule($provide) {
>, <Line: -      // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
>, <Line: -      $provide.provider({
>, <Line: -        $$sanitizeUri: $$SanitizeUriProvider
>, <Line: -      });
>, <Line: -      $provide.provider('$compile', $CompileProvider).
>, <Line: -        directive({
>, <Line: -            a: htmlAnchorDirective,
>, <Line: -            input: inputDirective,
>, <Line: -            textarea: inputDirective,
>, <Line: -            form: formDirective,
>, <Line: -            script: scriptDirective,
>, <Line: -            select: selectDirective,
>, <Line: -            style: styleDirective,
>, <Line: -            option: optionDirective,
>, <Line: -            ngBind: ngBindDirective,
>, <Line: -            ngBindHtml: ngBindHtmlDirective,
>, <Line: -            ngBindTemplate: ngBindTemplateDirective,
>, <Line: -            ngClass: ngClassDirective,
>, <Line: -            ngClassEven: ngClassEvenDirective,
>, <Line: -            ngClassOdd: ngClassOddDirective,
>, <Line: -            ngCloak: ngCloakDirective,
>, <Line: -            ngController: ngControllerDirective,
>, <Line: -            ngForm: ngFormDirective,
>, <Line: -            ngHide: ngHideDirective,
>, <Line: -            ngIf: ngIfDirective,
>, <Line: -            ngInclude: ngIncludeDirective,
>, <Line: -            ngInit: ngInitDirective,
>, <Line: -            ngNonBindable: ngNonBindableDirective,
>, <Line: -            ngPluralize: ngPluralizeDirective,
>, <Line: -            ngRepeat: ngRepeatDirective,
>, <Line: -            ngShow: ngShowDirective,
>, <Line: -            ngStyle: ngStyleDirective,
>, <Line: -            ngSwitch: ngSwitchDirective,
>, <Line: -            ngSwitchWhen: ngSwitchWhenDirective,
>, <Line: -            ngSwitchDefault: ngSwitchDefaultDirective,
>, <Line: -            ngOptions: ngOptionsDirective,
>, <Line: -            ngTransclude: ngTranscludeDirective,
>, <Line: -            ngModel: ngModelDirective,
>, <Line: -            ngList: ngListDirective,
>, <Line: -            ngChange: ngChangeDirective,
>, <Line: -            pattern: patternDirective,
>, <Line: -            ngPattern: patternDirective,
>, <Line: -            required: requiredDirective,
>, <Line: -            ngRequired: requiredDirective,
>, <Line: -            minlength: minlengthDirective,
>, <Line: -            ngMinlength: minlengthDirective,
>, <Line: -            maxlength: maxlengthDirective,
>, <Line: -            ngMaxlength: maxlengthDirective,
>, <Line: -            ngValue: ngValueDirective,
>, <Line: -            ngModelOptions: ngModelOptionsDirective
>, <Line: -        }).
>, <Line: -        directive({
>, <Line: -          ngInclude: ngIncludeFillContentDirective
>, <Line: -        }).
>, <Line: -        directive(ngAttributeAliasDirectives).
>, <Line: -        directive(ngEventDirectives);
>, <Line: -      $provide.provider({
>, <Line: -        $anchorScroll: $AnchorScrollProvider,
>, <Line: -        $animate: $AnimateProvider,
>, <Line: -        $browser: $BrowserProvider,
>, <Line: -        $cacheFactory: $CacheFactoryProvider,
>, <Line: -        $controller: $ControllerProvider,
>, <Line: -        $document: $DocumentProvider,
>, <Line: -        $exceptionHandler: $ExceptionHandlerProvider,
>, <Line: -        $filter: $FilterProvider,
>, <Line: -        $interpolate: $InterpolateProvider,
>, <Line: -        $interval: $IntervalProvider,
>, <Line: -        $http: $HttpProvider,
>, <Line: -        $httpBackend: $HttpBackendProvider,
>, <Line: -        $location: $LocationProvider,
>, <Line: -        $log: $LogProvider,
>, <Line: -        $parse: $ParseProvider,
>, <Line: -        $rootScope: $RootScopeProvider,
>, <Line: -        $q: $QProvider,
>, <Line: -        $$q: $$QProvider,
>, <Line: -        $sce: $SceProvider,
>, <Line: -        $sceDelegate: $SceDelegateProvider,
>, <Line: -        $sniffer: $SnifferProvider,
>, <Line: -        $templateCache: $TemplateCacheProvider,
>, <Line: -        $templateRequest: $TemplateRequestProvider,
>, <Line: -        $$testability: $$TestabilityProvider,
>, <Line: -        $timeout: $TimeoutProvider,
>, <Line: -        $window: $WindowProvider,
>, <Line: -        $$rAF: $$RAFProvider,
>, <Line: -        $$asyncCallback: $$AsyncCallbackProvider
>, <Line: -      });
>, <Line: -    }
>, <Line: -  ]);
>, <Line: -}
>, <Line: -/* global JQLitePrototype: true,
>, <Line: -  addEventListenerFn: true,
>, <Line: -  removeEventListenerFn: true,
>, <Line: -  BOOLEAN_ATTR: true,
>, <Line: -  ALIASED_ATTR: true,
>, <Line: -*/
>, <Line: -//////////////////////////////////
>, <Line: -//JQLite
>, <Line: -//////////////////////////////////
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @name angular.element
>, <Line: - * @module ng
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
>, <Line: - *
>, <Line: - * If jQuery is available, `angular.element` is an alias for the
>, <Line: - * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`
>, <Line: - * delegates to Angular's built-in subset of jQuery, called "jQuery lite" or "jqLite."
>, <Line: - *
>, <Line: - * <div class="alert alert-success">jqLite is a tiny, API-compatible subset of jQuery that allows
>, <Line: - * Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most
>, <Line: - * commonly needed functionality with the goal of having a very small footprint.</div>
>, <Line: - *
>, <Line: - * To use jQuery, simply load it before `DOMContentLoaded` event fired.
>, <Line: - *
>, <Line: - * <div class="alert">**Note:** all element references in Angular are always wrapped with jQuery or
>, <Line: - * jqLite; they are never raw DOM references.</div>
>, <Line: - *
>, <Line: - * ## Angular's jqLite
>, <Line: - * jqLite provides only the following jQuery methods:
>, <Line: - *
>, <Line: - * - [`addClass()`](http://api.jquery.com/addClass/)
>, <Line: - * - [`after()`](http://api.jquery.com/after/)
>, <Line: - * - [`append()`](http://api.jquery.com/append/)
>, <Line: - * - [`attr()`](http://api.jquery.com/attr/) - Does not support functions as parameters
>, <Line: - * - [`bind()`](http://api.jquery.com/bind/) - Does not support namespaces, selectors or eventData
>, <Line: - * - [`children()`](http://api.jquery.com/children/) - Does not support selectors
>, <Line: - * - [`clone()`](http://api.jquery.com/clone/)
>, <Line: - * - [`contents()`](http://api.jquery.com/contents/)
>, <Line: - * - [`css()`](http://api.jquery.com/css/) - Only retrieves inline-styles, does not call `getComputedStyle()`
>, <Line: - * - [`data()`](http://api.jquery.com/data/)
>, <Line: - * - [`detach()`](http://api.jquery.com/detach/)
>, <Line: - * - [`empty()`](http://api.jquery.com/empty/)
>, <Line: - * - [`eq()`](http://api.jquery.com/eq/)
>, <Line: - * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
>, <Line: - * - [`hasClass()`](http://api.jquery.com/hasClass/)
>, <Line: - * - [`html()`](http://api.jquery.com/html/)
>, <Line: - * - [`next()`](http://api.jquery.com/next/) - Does not support selectors
>, <Line: - * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
>, <Line: - * - [`off()`](http://api.jquery.com/off/) - Does not support namespaces or selectors
>, <Line: - * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors
>, <Line: - * - [`parent()`](http://api.jquery.com/parent/) - Does not support selectors
>, <Line: - * - [`prepend()`](http://api.jquery.com/prepend/)
>, <Line: - * - [`prop()`](http://api.jquery.com/prop/)
>, <Line: - * - [`ready()`](http://api.jquery.com/ready/)
>, <Line: - * - [`remove()`](http://api.jquery.com/remove/)
>, <Line: - * - [`removeAttr()`](http://api.jquery.com/removeAttr/)
>, <Line: - * - [`removeClass()`](http://api.jquery.com/removeClass/)
>, <Line: - * - [`removeData()`](http://api.jquery.com/removeData/)
>, <Line: - * - [`replaceWith()`](http://api.jquery.com/replaceWith/)
>, <Line: - * - [`text()`](http://api.jquery.com/text/)
>, <Line: - * - [`toggleClass()`](http://api.jquery.com/toggleClass/)
>, <Line: - * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
>, <Line: - * - [`unbind()`](http://api.jquery.com/unbind/) - Does not support namespaces
>, <Line: - * - [`val()`](http://api.jquery.com/val/)
>, <Line: - * - [`wrap()`](http://api.jquery.com/wrap/)
>, <Line: - *
>, <Line: - * ## jQuery/jqLite Extras
>, <Line: - * Angular also provides the following additional methods and events to both jQuery and jqLite:
>, <Line: - *
>, <Line: - * ### Events
>, <Line: - * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
>, <Line: - *    on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM
>, <Line: - *    element before it is removed.
>, <Line: - *
>, <Line: - * ### Methods
>, <Line: - * - `controller(name)` - retrieves the controller of the current element or its parent. By default
>, <Line: - *   retrieves controller associated with the `ngController` directive. If `name` is provided as
>, <Line: - *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
>, <Line: - *   `'ngModel'`).
>, <Line: - * - `injector()` - retrieves the injector of the current element or its parent.
>, <Line: - * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the current
>, <Line: - *   element or its parent. Requires {@link guide/production#disabling-debug-data Debug Data} to
>, <Line: - *   be enabled.
>, <Line: - * - `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope scope} if one is attached directly to the
>, <Line: - *   current element. This getter should be used only on elements that contain a directive which starts a new isolate
>, <Line: - *   scope. Calling `scope()` on this element always returns the original non-isolate scope.
>, <Line: - *   Requires {@link guide/production#disabling-debug-data Debug Data} to be enabled.
>, <Line: - * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
>, <Line: - *   parent element is reached.
>, <Line: - *
>, <Line: - * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
>, <Line: - * @returns {Object} jQuery object.
>, <Line: - */
>, <Line: -JQLite.expando = 'ng339';
>, <Line: -var jqCache = JQLite.cache = {},
>, <Line: -    jqId = 1,
>, <Line: -    addEventListenerFn = function(element, type, fn) {
>, <Line: -      element.addEventListener(type, fn, false);
>, <Line: -    },
>, <Line: -    removeEventListenerFn = function(element, type, fn) {
>, <Line: -      element.removeEventListener(type, fn, false);
>, <Line: -    };
>, <Line: -/*
>, <Line: - * !!! This is an undocumented "private" function !!!
>, <Line: - */
>, <Line: -JQLite._data = function(node) {
>, <Line: -  //jQuery always returns an object on cache miss
>, <Line: -  return this.cache[node[this.expando]] || {};
>, <Line: -};
>, <Line: -function jqNextId() { return ++jqId; }
>, <Line: -var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
>, <Line: -var MOZ_HACK_REGEXP = /^moz([A-Z])/;
>, <Line: -var MOUSE_EVENT_MAP= { mouseleave: "mouseout", mouseenter: "mouseover"};
>, <Line: -var jqLiteMinErr = minErr('jqLite');
>, <Line: -/**
>, <Line: - * Converts snake_case to camelCase.
>, <Line: - * Also there is special case for Moz prefix starting with upper case letter.
>, <Line: - * @param name Name to normalize
>, <Line: - */
>, <Line: -function camelCase(name) {
>, <Line: -  return name.
>, <Line: -    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
>, <Line: -      return offset ? letter.toUpperCase() : letter;
>, <Line: -    }).
>, <Line: -    replace(MOZ_HACK_REGEXP, 'Moz$1');
>, <Line: -}
>, <Line: -var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
>, <Line: -var HTML_REGEXP = /<|&#?\w+;/;
>, <Line: -var TAG_NAME_REGEXP = /<([\w:]+)/;
>, <Line: -var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
>, <Line: -var wrapMap = {
>, <Line: -  'option': [1, '<select multiple="multiple">', '</select>'],
>, <Line: -  'thead': [1, '<table>', '</table>'],
>, <Line: -  'col': [2, '<table><colgroup>', '</colgroup></table>'],
>, <Line: -  'tr': [2, '<table><tbody>', '</tbody></table>'],
>, <Line: -  'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
>, <Line: -  '_default': [0, "", ""]
>, <Line: -};
>, <Line: -wrapMap.optgroup = wrapMap.option;
>, <Line: -wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
>, <Line: -wrapMap.th = wrapMap.td;
>, <Line: -function jqLiteIsTextNode(html) {
>, <Line: -  return !HTML_REGEXP.test(html);
>, <Line: -}
>, <Line: -function jqLiteAcceptsData(node) {
>, <Line: -  // The window object can accept data but has no nodeType
>, <Line: -  // Otherwise we are only interested in elements (1) and documents (9)
>, <Line: -  var nodeType = node.nodeType;
>, <Line: -  return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
>, <Line: -}
>, <Line: -function jqLiteBuildFragment(html, context) {
>, <Line: -  var tmp, tag, wrap,
>, <Line: -      fragment = context.createDocumentFragment(),
>, <Line: -      nodes = [], i;
>, <Line: -  if (jqLiteIsTextNode(html)) {
>, <Line: -    // Convert non-html into a text node
>, <Line: -    nodes.push(context.createTextNode(html));
>, <Line: -  } else {
>, <Line: -    // Convert html into DOM nodes
>, <Line: -    tmp = tmp || fragment.appendChild(context.createElement("div"));
>, <Line: -    tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
>, <Line: -    wrap = wrapMap[tag] || wrapMap._default;
>, <Line: -    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
>, <Line: -    // Descend through wrappers to the right content
>, <Line: -    i = wrap[0];
>, <Line: -    while (i--) {
>, <Line: -      tmp = tmp.lastChild;
>, <Line: -    }
>, <Line: -    nodes = concat(nodes, tmp.childNodes);
>, <Line: -    tmp = fragment.firstChild;
>, <Line: -    tmp.textContent = "";
>, <Line: -  }
>, <Line: -  // Remove wrapper from fragment
>, <Line: -  fragment.textContent = "";
>, <Line: -  fragment.innerHTML = ""; // Clear inner HTML
>, <Line: -  forEach(nodes, function(node) {
>, <Line: -    fragment.appendChild(node);
>, <Line: -  return fragment;
>, <Line: -}
>, <Line: -function jqLiteParseHTML(html, context) {
>, <Line: -  context = context || document;
>, <Line: -  var parsed;
>, <Line: -  if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
>, <Line: -    return [context.createElement(parsed[1])];
>, <Line: -  }
>, <Line: -  if ((parsed = jqLiteBuildFragment(html, context))) {
>, <Line: -    return parsed.childNodes;
>, <Line: -  }
>, <Line: -  return [];
>, <Line: -}
>, <Line: -/////////////////////////////////////////////
>, <Line: -function JQLite(element) {
>, <Line: -  if (element instanceof JQLite) {
>, <Line: -    return element;
>, <Line: -  }
>, <Line: -  var argIsString;
>, <Line: -  if (isString(element)) {
>, <Line: -    element = trim(element);
>, <Line: -    argIsString = true;
>, <Line: -  }
>, <Line: -  if (!(this instanceof JQLite)) {
>, <Line: -    if (argIsString && element.charAt(0) != '<') {
>, <Line: -      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
>, <Line: -    }
>, <Line: -    return new JQLite(element);
>, <Line: -  }
>, <Line: -  if (argIsString) {
>, <Line: -    jqLiteAddNodes(this, jqLiteParseHTML(element));
>, <Line: -  } else {
>, <Line: -    jqLiteAddNodes(this, element);
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteClone(element) {
>, <Line: -  return element.cloneNode(true);
>, <Line: -}
>, <Line: -function jqLiteDealoc(element, onlyDescendants) {
>, <Line: -  if (!onlyDescendants) jqLiteRemoveData(element);
>, <Line: -  if (element.querySelectorAll) {
>, <Line: -    var descendants = element.querySelectorAll('*');
>, <Line: -    for (var i = 0, l = descendants.length; i < l; i++) {
>, <Line: -      jqLiteRemoveData(descendants[i]);
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteOff(element, type, fn, unsupported) {
>, <Line: -  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
>, <Line: -  var expandoStore = jqLiteExpandoStore(element);
>, <Line: -  var events = expandoStore && expandoStore.events;
>, <Line: -  var handle = expandoStore && expandoStore.handle;
>, <Line: -  if (!handle) return; //no listeners registered
>, <Line: -  if (!type) {
>, <Line: -    for (type in events) {
>, <Line: -      if (type !== '$destroy') {
>, <Line: -        removeEventListenerFn(element, type, handle);
>, <Line: -      }
>, <Line: -      delete events[type];
>, <Line: -    }
>, <Line: -  } else {
>, <Line: -    forEach(type.split(' '), function(type) {
>, <Line: -      if (isDefined(fn)) {
>, <Line: -        var listenerFns = events[type];
>, <Line: -        arrayRemove(listenerFns || [], fn);
>, <Line: -        if (listenerFns && listenerFns.length > 0) {
>, <Line: -          return;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      removeEventListenerFn(element, type, handle);
>, <Line: -      delete events[type];
>, <Line: -    });
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteRemoveData(element, name) {
>, <Line: -  var expandoId = element.ng339;
>, <Line: -  var expandoStore = expandoId && jqCache[expandoId];
>, <Line: -  if (expandoStore) {
>, <Line: -    if (name) {
>, <Line: -      delete expandoStore.data[name];
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    if (expandoStore.handle) {
>, <Line: -      if (expandoStore.events.$destroy) {
>, <Line: -        expandoStore.handle({}, '$destroy');
>, <Line: -      }
>, <Line: -      jqLiteOff(element);
>, <Line: -    }
>, <Line: -    delete jqCache[expandoId];
>, <Line: -    element.ng339 = undefined; // don't delete DOM expandos. IE and Chrome don't like it
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteExpandoStore(element, createIfNecessary) {
>, <Line: -  var expandoId = element.ng339,
>, <Line: -      expandoStore = expandoId && jqCache[expandoId];
>, <Line: -  if (createIfNecessary && !expandoStore) {
>, <Line: -    element.ng339 = expandoId = jqNextId();
>, <Line: -    expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined};
>, <Line: -  }
>, <Line: -  return expandoStore;
>, <Line: -}
>, <Line: -function jqLiteData(element, key, value) {
>, <Line: -  if (jqLiteAcceptsData(element)) {
>, <Line: -    var isSimpleSetter = isDefined(value);
>, <Line: -    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
>, <Line: -    var massGetter = !key;
>, <Line: -    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
>, <Line: -    var data = expandoStore && expandoStore.data;
>, <Line: -    if (isSimpleSetter) { // data('key', value)
>, <Line: -      data[key] = value;
>, <Line: -    } else {
>, <Line: -      if (massGetter) {  // data()
>, <Line: -        return data;
>, <Line: -      } else {
>, <Line: -        if (isSimpleGetter) { // data('key')
>, <Line: -          // don't force creation of expandoStore if it doesn't exist yet
>, <Line: -          return data && data[key];
>, <Line: -        } else { // mass-setter: data({key1: val1, key2: val2})
>, <Line: -          extend(data, key);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteHasClass(element, selector) {
>, <Line: -  if (!element.getAttribute) return false;
>, <Line: -  return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").
>, <Line: -      indexOf(" " + selector + " ") > -1);
>, <Line: -}
>, <Line: -function jqLiteRemoveClass(element, cssClasses) {
>, <Line: -  if (cssClasses && element.setAttribute) {
>, <Line: -    forEach(cssClasses.split(' '), function(cssClass) {
>, <Line: -      element.setAttribute('class', trim(
>, <Line: -          (" " + (element.getAttribute('class') || '') + " ")
>, <Line: -          .replace(/[\n\t]/g, " ")
>, <Line: -          .replace(" " + trim(cssClass) + " ", " "))
>, <Line: -      );
>, <Line: -    });
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteAddClass(element, cssClasses) {
>, <Line: -  if (cssClasses && element.setAttribute) {
>, <Line: -    var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
>, <Line: -                            .replace(/[\n\t]/g, " ");
>, <Line: -    forEach(cssClasses.split(' '), function(cssClass) {
>, <Line: -      cssClass = trim(cssClass);
>, <Line: -      if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
>, <Line: -        existingClasses += cssClass + ' ';
>, <Line: -      }
>, <Line: -    });
>, <Line: -    element.setAttribute('class', trim(existingClasses));
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteAddNodes(root, elements) {
>, <Line: -  // THIS CODE IS VERY HOT. Don't make changes without benchmarking.
>, <Line: -  if (elements) {
>, <Line: -    // if a Node (the most common case)
>, <Line: -    if (elements.nodeType) {
>, <Line: -      root[root.length++] = elements;
>, <Line: -    } else {
>, <Line: -      var length = elements.length;
>, <Line: -      // if an Array or NodeList and not a Window
>, <Line: -      if (typeof length === 'number' && elements.window !== elements) {
>, <Line: -        if (length) {
>, <Line: -          for (var i = 0; i < length; i++) {
>, <Line: -            root[root.length++] = elements[i];
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        root[root.length++] = elements;
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteController(element, name) {
>, <Line: -  return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
>, <Line: -}
>, <Line: -function jqLiteInheritedData(element, name, value) {
>, <Line: -  // if element is the document object work with the html element instead
>, <Line: -  // this makes $(document).scope() possible
>, <Line: -  if (element.nodeType == NODE_TYPE_DOCUMENT) {
>, <Line: -    element = element.documentElement;
>, <Line: -  }
>, <Line: -  var names = isArray(name) ? name : [name];
>, <Line: -  while (element) {
>, <Line: -    for (var i = 0, ii = names.length; i < ii; i++) {
>, <Line: -      if ((value = jqLite.data(element, names[i])) !== undefined) return value;
>, <Line: -    }
>, <Line: -    // If dealing with a document fragment node with a host element, and no parent, use the host
>, <Line: -    // element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
>, <Line: -    // to lookup parent controllers.
>, <Line: -    element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteEmpty(element) {
>, <Line: -  jqLiteDealoc(element, true);
>, <Line: -  while (element.firstChild) {
>, <Line: -    element.removeChild(element.firstChild);
>, <Line: -  }
>, <Line: -}
>, <Line: -function jqLiteRemove(element, keepData) {
>, <Line: -  if (!keepData) jqLiteDealoc(element);
>, <Line: -  var parent = element.parentNode;
>, <Line: -  if (parent) parent.removeChild(element);
>, <Line: -}
>, <Line: -function jqLiteDocumentLoaded(action, win) {
>, <Line: -  win = win || window;
>, <Line: -  if (win.document.readyState === 'complete') {
>, <Line: -    // Force the action to be run async for consistent behaviour
>, <Line: -    // from the action's point of view
>, <Line: -    // i.e. it will definitely not be in a $apply
>, <Line: -    win.setTimeout(action);
>, <Line: -  } else {
>, <Line: -    // No need to unbind this handler as load is only ever called once
>, <Line: -    jqLite(win).on('load', action);
>, <Line: -  }
>, <Line: -}
>, <Line: -//////////////////////////////////////////
>, <Line: -// Functions which are declared directly.
>, <Line: -//////////////////////////////////////////
>, <Line: -var JQLitePrototype = JQLite.prototype = {
>, <Line: -  ready: function(fn) {
>, <Line: -    var fired = false;
>, <Line: -    function trigger() {
>, <Line: -      if (fired) return;
>, <Line: -      fired = true;
>, <Line: -      fn();
>, <Line: -    }
>, <Line: -    // check if document is already loaded
>, <Line: -    if (document.readyState === 'complete') {
>, <Line: -      setTimeout(trigger);
>, <Line: -    } else {
>, <Line: -      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
>, <Line: -      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
>, <Line: -      // jshint -W064
>, <Line: -      JQLite(window).on('load', trigger); // fallback to window.onload for others
>, <Line: -      // jshint +W064
>, <Line: -    }
>, <Line: -  },
>, <Line: -  toString: function() {
>, <Line: -    var value = [];
>, <Line: -    forEach(this, function(e) { value.push('' + e);});
>, <Line: -    return '[' + value.join(', ') + ']';
>, <Line: -  },
>, <Line: -  eq: function(index) {
>, <Line: -      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
>, <Line: -  },
>, <Line: -  length: 0,
>, <Line: -  push: push,
>, <Line: -  sort: [].sort,
>, <Line: -  splice: [].splice
>, <Line: -};
>, <Line: -//////////////////////////////////////////
>, <Line: -// Functions iterating getter/setters.
>, <Line: -// these functions return self on setter and
>, <Line: -// value on get.
>, <Line: -//////////////////////////////////////////
>, <Line: -var BOOLEAN_ATTR = {};
>, <Line: -forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
>, <Line: -  BOOLEAN_ATTR[lowercase(value)] = value;
>, <Line: -});
>, <Line: -var BOOLEAN_ELEMENTS = {};
>, <Line: -forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
>, <Line: -  BOOLEAN_ELEMENTS[value] = true;
>, <Line: -});
>, <Line: -var ALIASED_ATTR = {
>, <Line: -  'ngMinlength': 'minlength',
>, <Line: -  'ngMaxlength': 'maxlength',
>, <Line: -  'ngMin': 'min',
>, <Line: -  'ngMax': 'max',
>, <Line: -  'ngPattern': 'pattern'
>, <Line: -};
>, <Line: -function getBooleanAttrName(element, name) {
>, <Line: -  // check dom last since we will most likely fail on name
>, <Line: -  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
>, <Line: -  // booleanAttr is here twice to minimize DOM access
>, <Line: -  return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
>, <Line: -}
>, <Line: -function getAliasedAttrName(element, name) {
>, <Line: -  var nodeName = element.nodeName;
>, <Line: -  return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
>, <Line: -}
>, <Line: -forEach({
>, <Line: -  data: jqLiteData,
>, <Line: -  removeData: jqLiteRemoveData
>, <Line: -}, function(fn, name) {
>, <Line: -  JQLite[name] = fn;
>, <Line: -});
>, <Line: -forEach({
>, <Line: -  data: jqLiteData,
>, <Line: -  inheritedData: jqLiteInheritedData,
>, <Line: -  scope: function(element) {
>, <Line: -    // Can't use jqLiteData here directly so we stay compatible with jQuery!
>, <Line: -    return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
>, <Line: -  },
>, <Line: -  isolateScope: function(element) {
>, <Line: -    // Can't use jqLiteData here directly so we stay compatible with jQuery!
>, <Line: -    return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
>, <Line: -  },
>, <Line: -  controller: jqLiteController,
>, <Line: -  injector: function(element) {
>, <Line: -    return jqLiteInheritedData(element, '$injector');
>, <Line: -  },
>, <Line: -  removeAttr: function(element, name) {
>, <Line: -    element.removeAttribute(name);
>, <Line: -  },
>, <Line: -  hasClass: jqLiteHasClass,
>, <Line: -  css: function(element, name, value) {
>, <Line: -    name = camelCase(name);
>, <Line: -    if (isDefined(value)) {
>, <Line: -      element.style[name] = value;
>, <Line: -    } else {
>, <Line: -      return element.style[name];
>, <Line: -    }
>, <Line: -  },
>, <Line: -  attr: function(element, name, value) {
>, <Line: -    var lowercasedName = lowercase(name);
>, <Line: -    if (BOOLEAN_ATTR[lowercasedName]) {
>, <Line: -      if (isDefined(value)) {
>, <Line: -        if (!!value) {
>, <Line: -          element[name] = true;
>, <Line: -          element.setAttribute(name, lowercasedName);
>, <Line: -        } else {
>, <Line: -          element[name] = false;
>, <Line: -          element.removeAttribute(lowercasedName);
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        return (element[name] ||
>, <Line: -                 (element.attributes.getNamedItem(name) || noop).specified)
>, <Line: -               ? lowercasedName
>, <Line: -               : undefined;
>, <Line: -      }
>, <Line: -    } else if (isDefined(value)) {
>, <Line: -      element.setAttribute(name, value);
>, <Line: -    } else if (element.getAttribute) {
>, <Line: -      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
>, <Line: -      // some elements (e.g. Document) don't have get attribute, so return undefined
>, <Line: -      var ret = element.getAttribute(name, 2);
>, <Line: -      // normalize non-existing attributes to undefined (as jQuery)
>, <Line: -      return ret === null ? undefined : ret;
>, <Line: -    }
>, <Line: -  },
>, <Line: -  prop: function(element, name, value) {
>, <Line: -    if (isDefined(value)) {
>, <Line: -      element[name] = value;
>, <Line: -    } else {
>, <Line: -      return element[name];
>, <Line: -    }
>, <Line: -  },
>, <Line: -  text: (function() {
>, <Line: -    getText.$dv = '';
>, <Line: -    return getText;
>, <Line: -    function getText(element, value) {
>, <Line: -      if (isUndefined(value)) {
>, <Line: -        var nodeType = element.nodeType;
>, <Line: -        return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
>, <Line: -      }
>, <Line: -      element.textContent = value;
>, <Line: -    }
>, <Line: -  })(),
>, <Line: -  val: function(element, value) {
>, <Line: -    if (isUndefined(value)) {
>, <Line: -      if (element.multiple && nodeName_(element) === 'select') {
>, <Line: -        var result = [];
>, <Line: -        forEach(element.options, function(option) {
>, <Line: -          if (option.selected) {
>, <Line: -            result.push(option.value || option.text);
>, <Line: -          }
>, <Line: -        });
>, <Line: -        return result.length === 0 ? null : result;
>, <Line: -      }
>, <Line: -      return element.value;
>, <Line: -    }
>, <Line: -    element.value = value;
>, <Line: -  },
>, <Line: -  html: function(element, value) {
>, <Line: -    if (isUndefined(value)) {
>, <Line: -      return element.innerHTML;
>, <Line: -    }
>, <Line: -    jqLiteDealoc(element, true);
>, <Line: -    element.innerHTML = value;
>, <Line: -  },
>, <Line: -  empty: jqLiteEmpty
>, <Line: -}, function(fn, name) {
>, <Line: -  /**
>, <Line: -   * Properties: writes return selection, reads return first value
>, <Line: -   */
>, <Line: -  JQLite.prototype[name] = function(arg1, arg2) {
>, <Line: -    var i, key;
>, <Line: -    var nodeCount = this.length;
>, <Line: -    // jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
>, <Line: -    // in a way that survives minification.
>, <Line: -    // jqLiteEmpty takes no arguments but is a setter.
>, <Line: -    if (fn !== jqLiteEmpty &&
>, <Line: -        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
>, <Line: -      if (isObject(arg1)) {
>, <Line: -        // we are a write, but the object properties are the key/values
>, <Line: -        for (i = 0; i < nodeCount; i++) {
>, <Line: -          if (fn === jqLiteData) {
>, <Line: -            // data() takes the whole object in jQuery
>, <Line: -            fn(this[i], arg1);
>, <Line: -          } else {
>, <Line: -            for (key in arg1) {
>, <Line: -              fn(this[i], key, arg1[key]);
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        // return self for chaining
>, <Line: -        return this;
>, <Line: -      } else {
>, <Line: -        // we are a read, so read the first child.
>, <Line: -        // TODO: do we still need this?
>, <Line: -        var value = fn.$dv;
>, <Line: -        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
>, <Line: -        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
>, <Line: -        for (var j = 0; j < jj; j++) {
>, <Line: -          var nodeValue = fn(this[j], arg1, arg2);
>, <Line: -          value = value ? value + nodeValue : nodeValue;
>, <Line: -        }
>, <Line: -        return value;
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      // we are a write, so apply to all children
>, <Line: -      for (i = 0; i < nodeCount; i++) {
>, <Line: -        fn(this[i], arg1, arg2);
>, <Line: -      }
>, <Line: -      // return self for chaining
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -  };
>, <Line: -});
>, <Line: -function createEventHandler(element, events) {
>, <Line: -  var eventHandler = function(event, type) {
>, <Line: -    // jQuery specific api
>, <Line: -    event.isDefaultPrevented = function() {
>, <Line: -      return event.defaultPrevented;
>, <Line: -    };
>, <Line: -    var eventFns = events[type || event.type];
>, <Line: -    var eventFnsLength = eventFns ? eventFns.length : 0;
>, <Line: -    if (!eventFnsLength) return;
>, <Line: -    if (isUndefined(event.immediatePropagationStopped)) {
>, <Line: -      var originalStopImmediatePropagation = event.stopImmediatePropagation;
>, <Line: -      event.stopImmediatePropagation = function() {
>, <Line: -        event.immediatePropagationStopped = true;
>, <Line: -        if (event.stopPropagation) {
>, <Line: -          event.stopPropagation();
>, <Line: -        }
>, <Line: -        if (originalStopImmediatePropagation) {
>, <Line: -          originalStopImmediatePropagation.call(event);
>, <Line: -        }
>, <Line: -      };
>, <Line: -    }
>, <Line: -    event.isImmediatePropagationStopped = function() {
>, <Line: -      return event.immediatePropagationStopped === true;
>, <Line: -    };
>, <Line: -    // Copy event handlers in case event handlers array is modified during execution.
>, <Line: -    if ((eventFnsLength > 1)) {
>, <Line: -      eventFns = shallowCopy(eventFns);
>, <Line: -    }
>, <Line: -    for (var i = 0; i < eventFnsLength; i++) {
>, <Line: -      if (!event.isImmediatePropagationStopped()) {
>, <Line: -        eventFns[i].call(element, event);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  // TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all
>, <Line: -  //       events on `element`
>, <Line: -  eventHandler.elem = element;
>, <Line: -  return eventHandler;
>, <Line: -}
>, <Line: -//////////////////////////////////////////
>, <Line: -// Functions iterating traversal.
>, <Line: -// These functions chain results into a single
>, <Line: -// selector.
>, <Line: -//////////////////////////////////////////
>, <Line: -forEach({
>, <Line: -  removeData: jqLiteRemoveData,
>, <Line: -  on: function jqLiteOn(element, type, fn, unsupported) {
>, <Line: -    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
>, <Line: -    // Do not add event handlers to non-elements because they will not be cleaned up.
>, <Line: -    if (!jqLiteAcceptsData(element)) {
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    var expandoStore = jqLiteExpandoStore(element, true);
>, <Line: -    var events = expandoStore.events;
>, <Line: -    var handle = expandoStore.handle;
>, <Line: -    if (!handle) {
>, <Line: -      handle = expandoStore.handle = createEventHandler(element, events);
>, <Line: -    }
>, <Line: -    // http://jsperf.com/string-indexof-vs-split
>, <Line: -    var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
>, <Line: -    var i = types.length;
>, <Line: -    while (i--) {
>, <Line: -      type = types[i];
>, <Line: -      var eventFns = events[type];
>, <Line: -      if (!eventFns) {
>, <Line: -        events[type] = [];
>, <Line: -        if (type === 'mouseenter' || type === 'mouseleave') {
>, <Line: -          // Refer to jQuery's implementation of mouseenter & mouseleave
>, <Line: -          // Read about mouseenter and mouseleave:
>, <Line: -          // http://www.quirksmode.org/js/events_mouse.html#link8
>, <Line: -          jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
>, <Line: -            var target = this, related = event.relatedTarget;
>, <Line: -            // For mousenter/leave call the handler if related is outside the target.
>, <Line: -            // NB: No relatedTarget if the mouse left/entered the browser window
>, <Line: -            if (!related || (related !== target && !target.contains(related))) {
>, <Line: -              handle(event, type);
>, <Line: -            }
>, <Line: -          });
>, <Line: -        } else {
>, <Line: -          if (type !== '$destroy') {
>, <Line: -            addEventListenerFn(element, type, handle);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        eventFns = events[type];
>, <Line: -      }
>, <Line: -      eventFns.push(fn);
>, <Line: -    }
>, <Line: -  },
>, <Line: -  off: jqLiteOff,
>, <Line: -  one: function(element, type, fn) {
>, <Line: -    element = jqLite(element);
>, <Line: -    //add the listener twice so that when it is called
>, <Line: -    //you can remove the original function and still be
>, <Line: -    //able to call element.off(ev, fn) normally
>, <Line: -    element.on(type, function onFn() {
>, <Line: -      element.off(type, fn);
>, <Line: -      element.off(type, onFn);
>, <Line: -    });
>, <Line: -    element.on(type, fn);
>, <Line: -  },
>, <Line: -  replaceWith: function(element, replaceNode) {
>, <Line: -    var index, parent = element.parentNode;
>, <Line: -    jqLiteDealoc(element);
>, <Line: -    forEach(new JQLite(replaceNode), function(node) {
>, <Line: -      if (index) {
>, <Line: -        parent.insertBefore(node, index.nextSibling);
>, <Line: -      } else {
>, <Line: -        parent.replaceChild(node, element);
>, <Line: -      }
>, <Line: -      index = node;
>, <Line: -    });
>, <Line: -  },
>, <Line: -  children: function(element) {
>, <Line: -    var children = [];
>, <Line: -    forEach(element.childNodes, function(element) {
>, <Line: -      if (element.nodeType === NODE_TYPE_ELEMENT)
>, <Line: -        children.push(element);
>, <Line: -    });
>, <Line: -    return children;
>, <Line: -  },
>, <Line: -  contents: function(element) {
>, <Line: -    return element.contentDocument || element.childNodes || [];
>, <Line: -  },
>, <Line: -  append: function(element, node) {
>, <Line: -    var nodeType = element.nodeType;
>, <Line: -    if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
>, <Line: -    node = new JQLite(node);
>, <Line: -    for (var i = 0, ii = node.length; i < ii; i++) {
>, <Line: -      var child = node[i];
>, <Line: -      element.appendChild(child);
>, <Line: -    }
>, <Line: -  },
>, <Line: -  prepend: function(element, node) {
>, <Line: -    if (element.nodeType === NODE_TYPE_ELEMENT) {
>, <Line: -      var index = element.firstChild;
>, <Line: -      forEach(new JQLite(node), function(child) {
>, <Line: -        element.insertBefore(child, index);
>, <Line: -      });
>, <Line: -    }
>, <Line: -  },
>, <Line: -  wrap: function(element, wrapNode) {
>, <Line: -    wrapNode = jqLite(wrapNode).eq(0).clone()[0];
>, <Line: -    var parent = element.parentNode;
>, <Line: -    if (parent) {
>, <Line: -      parent.replaceChild(wrapNode, element);
>, <Line: -    }
>, <Line: -    wrapNode.appendChild(element);
>, <Line: -  },
>, <Line: -  remove: jqLiteRemove,
>, <Line: -  detach: function(element) {
>, <Line: -    jqLiteRemove(element, true);
>, <Line: -  },
>, <Line: -  after: function(element, newElement) {
>, <Line: -    var index = element, parent = element.parentNode;
>, <Line: -    newElement = new JQLite(newElement);
>, <Line: -    for (var i = 0, ii = newElement.length; i < ii; i++) {
>, <Line: -      var node = newElement[i];
>, <Line: -      parent.insertBefore(node, index.nextSibling);
>, <Line: -      index = node;
>, <Line: -    }
>, <Line: -  },
>, <Line: -  addClass: jqLiteAddClass,
>, <Line: -  removeClass: jqLiteRemoveClass,
>, <Line: -  toggleClass: function(element, selector, condition) {
>, <Line: -    if (selector) {
>, <Line: -      forEach(selector.split(' '), function(className) {
>, <Line: -        var classCondition = condition;
>, <Line: -        if (isUndefined(classCondition)) {
>, <Line: -          classCondition = !jqLiteHasClass(element, className);
>, <Line: -        }
>, <Line: -        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
>, <Line: -      });
>, <Line: -    }
>, <Line: -  },
>, <Line: -  parent: function(element) {
>, <Line: -    var parent = element.parentNode;
>, <Line: -    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
>, <Line: -  },
>, <Line: -  next: function(element) {
>, <Line: -    return element.nextElementSibling;
>, <Line: -  },
>, <Line: -  find: function(element, selector) {
>, <Line: -    if (element.getElementsByTagName) {
>, <Line: -      return element.getElementsByTagName(selector);
>, <Line: -    } else {
>, <Line: -      return [];
>, <Line: -    }
>, <Line: -  },
>, <Line: -  clone: jqLiteClone,
>, <Line: -  triggerHandler: function(element, event, extraParameters) {
>, <Line: -    var dummyEvent, eventFnsCopy, handlerArgs;
>, <Line: -    var eventName = event.type || event;
>, <Line: -    var expandoStore = jqLiteExpandoStore(element);
>, <Line: -    var events = expandoStore && expandoStore.events;
>, <Line: -    var eventFns = events && events[eventName];
>, <Line: -    if (eventFns) {
>, <Line: -      // Create a dummy event to pass to the handlers
>, <Line: -      dummyEvent = {
>, <Line: -        preventDefault: function() { this.defaultPrevented = true; },
>, <Line: -        isDefaultPrevented: function() { return this.defaultPrevented === true; },
>, <Line: -        stopImmediatePropagation: function() { this.immediatePropagationStopped = true; },
>, <Line: -        isImmediatePropagationStopped: function() { return this.immediatePropagationStopped === true; },
>, <Line: -        stopPropagation: noop,
>, <Line: -        type: eventName,
>, <Line: -        target: element
>, <Line: -      };
>, <Line: -      // If a custom event was provided then extend our dummy event with it
>, <Line: -      if (event.type) {
>, <Line: -        dummyEvent = extend(dummyEvent, event);
>, <Line: -      }
>, <Line: -      // Copy event handlers in case event handlers array is modified during execution.
>, <Line: -      eventFnsCopy = shallowCopy(eventFns);
>, <Line: -      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
>, <Line: -      forEach(eventFnsCopy, function(fn) {
>, <Line: -        if (!dummyEvent.isImmediatePropagationStopped()) {
>, <Line: -          fn.apply(element, handlerArgs);
>, <Line: -        }
>, <Line: -      });
>, <Line: -    }
>, <Line: -  }
>, <Line: -}, function(fn, name) {
>, <Line: -  /**
>, <Line: -   * chaining functions
>, <Line: -   */
>, <Line: -  JQLite.prototype[name] = function(arg1, arg2, arg3) {
>, <Line: -    var value;
>, <Line: -    for (var i = 0, ii = this.length; i < ii; i++) {
>, <Line: -      if (isUndefined(value)) {
>, <Line: -        value = fn(this[i], arg1, arg2, arg3);
>, <Line: -        if (isDefined(value)) {
>, <Line: -          // any function which returns a value needs to be wrapped
>, <Line: -          value = jqLite(value);
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return isDefined(value) ? value : this;
>, <Line: -  };
>, <Line: -  // bind legacy bind/unbind to on/off
>, <Line: -  JQLite.prototype.bind = JQLite.prototype.on;
>, <Line: -  JQLite.prototype.unbind = JQLite.prototype.off;
>, <Line: -});
>, <Line: -/**
>, <Line: - * Computes a hash of an 'obj'.
>, <Line: - * Hash of a:
>, <Line: - *  string is string
>, <Line: - *  number is number as string
>, <Line: - *  object is either result of calling $$hashKey function on the object or uniquely generated id,
>, <Line: - *         that is also assigned to the $$hashKey property of the object.
>, <Line: - *
>, <Line: - * @param obj
>, <Line: - * @returns {string} hash string such that the same input will have the same hash string.
>, <Line: - *         The resulting string key is in 'type:hashKey' format.
>, <Line: - */
>, <Line: -function hashKey(obj, nextUidFn) {
>, <Line: -  var key = obj && obj.$$hashKey;
>, <Line: -  if (key) {
>, <Line: -    if (typeof key === 'function') {
>, <Line: -      key = obj.$$hashKey();
>, <Line: -    }
>, <Line: -    return key;
>, <Line: -  }
>, <Line: -  var objType = typeof obj;
>, <Line: -  if (objType == 'function' || (objType == 'object' && obj !== null)) {
>, <Line: -    key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
>, <Line: -  } else {
>, <Line: -    key = objType + ':' + obj;
>, <Line: -  }
>, <Line: -  return key;
>, <Line: -}
>, <Line: -/**
>, <Line: - * HashMap which can use objects as keys
>, <Line: - */
>, <Line: -function HashMap(array, isolatedUid) {
>, <Line: -  if (isolatedUid) {
>, <Line: -    var uid = 0;
>, <Line: -    this.nextUid = function() {
>, <Line: -      return ++uid;
>, <Line: -    };
>, <Line: -  }
>, <Line: -  forEach(array, this.put, this);
>, <Line: -}
>, <Line: -HashMap.prototype = {
>, <Line: -  /**
>, <Line: -   * Store key value pair
>, <Line: -   * @param key key to store can be any type
>, <Line: -   * @param value value to store can be any type
>, <Line: -   */
>, <Line: -  put: function(key, value) {
>, <Line: -    this[hashKey(key, this.nextUid)] = value;
>, <Line: -  },
>, <Line: -  /**
>, <Line: -   * @param key
>, <Line: -   * @returns {Object} the value for the key
>, <Line: -   */
>, <Line: -  get: function(key) {
>, <Line: -    return this[hashKey(key, this.nextUid)];
>, <Line: -  },
>, <Line: -  /**
>, <Line: -   * Remove the key/value pair
>, <Line: -   * @param key
>, <Line: -   */
>, <Line: -  remove: function(key) {
>, <Line: -    var value = this[key = hashKey(key, this.nextUid)];
>, <Line: -    delete this[key];
>, <Line: -    return value;
>, <Line: -  }
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc function
>, <Line: - * @module ng
>, <Line: - * @name angular.injector
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Creates an injector object that can be used for retrieving services as well as for
>, <Line: - * dependency injection (see {@link guide/di dependency injection}).
>, <Line: - *
>, <Line: - * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
>, <Line: - *     {@link angular.module}. The `ng` module must be explicitly added.
>, <Line: - * @param {boolean=} [strictDi=false] Whether the injector should be in strict mode, which
>, <Line: - *     disallows argument name annotation inference.
>, <Line: - * @returns {injector} Injector object. See {@link auto.$injector $injector}.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Typical usage
>, <Line: - * ```js
>, <Line: - *   // create an injector
>, <Line: - *   var $injector = angular.injector(['ng']);
>, <Line: - *
>, <Line: - *   // use the injector to kick off your application
>, <Line: - *   // use the type inference to auto inject arguments, or use implicit injection
>, <Line: - *   $injector.invoke(function($rootScope, $compile, $document) {
>, <Line: - *     $compile($document)($rootScope);
>, <Line: - *     $rootScope.$digest();
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Sometimes you want to get access to the injector of a currently running Angular app
>, <Line: - * from outside Angular. Perhaps, you want to inject and compile some markup after the
>, <Line: - * application has been bootstrapped. You can do this using the extra `injector()` added
>, <Line: - * to JQuery/jqLite elements. See {@link angular.element}.
>, <Line: - *
>, <Line: - * *This is fairly rare but could be the case if a third party library is injecting the
>, <Line: - * markup.*
>, <Line: - *
>, <Line: - * In the following example a new block of HTML containing a `ng-controller`
>, <Line: - * directive is added to the end of the document body by JQuery. We then compile and link
>, <Line: - * it into the current AngularJS scope.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
>, <Line: - * $(document.body).append($div);
>, <Line: - *
>, <Line: - * angular.element(document).injector().invoke(function($compile) {
>, <Line: - *   var scope = angular.element($div).scope();
>, <Line: - *   $compile($div)(scope);
>, <Line: - * });
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc module
>, <Line: - * @name auto
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Implicit module which gets automatically added to each {@link auto.$injector $injector}.
>, <Line: - */
>, <Line: -var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
>, <Line: -var FN_ARG_SPLIT = /,/;
>, <Line: -var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
>, <Line: -var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
>, <Line: -var $injectorMinErr = minErr('$injector');
>, <Line: -function anonFn(fn) {
>, <Line: -  // For anonymous functions, showing at the very least the function signature can help in
>, <Line: -  // debugging.
>, <Line: -  var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
>, <Line: -      args = fnText.match(FN_ARGS);
>, <Line: -  if (args) {
>, <Line: -    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
>, <Line: -  }
>, <Line: -  return 'fn';
>, <Line: -}
>, <Line: -function annotate(fn, strictDi, name) {
>, <Line: -  var $inject,
>, <Line: -      fnText,
>, <Line: -      argDecl,
>, <Line: -      last;
>, <Line: -  if (typeof fn === 'function') {
>, <Line: -    if (!($inject = fn.$inject)) {
>, <Line: -      $inject = [];
>, <Line: -      if (fn.length) {
>, <Line: -        if (strictDi) {
>, <Line: -          if (!isString(name) || !name) {
>, <Line: -            name = fn.name || anonFn(fn);
>, <Line: -          }
>, <Line: -          throw $injectorMinErr('strictdi',
>, <Line: -            '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
>, <Line: -        }
>, <Line: -        fnText = fn.toString().replace(STRIP_COMMENTS, '');
>, <Line: -        argDecl = fnText.match(FN_ARGS);
>, <Line: -        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
>, <Line: -          arg.replace(FN_ARG, function(all, underscore, name) {
>, <Line: -            $inject.push(name);
>, <Line: -          });
>, <Line: -        });
>, <Line: -      }
>, <Line: -      fn.$inject = $inject;
>, <Line: -    }
>, <Line: -  } else if (isArray(fn)) {
>, <Line: -    last = fn.length - 1;
>, <Line: -    assertArgFn(fn[last], 'fn');
>, <Line: -    $inject = fn.slice(0, last);
>, <Line: -  } else {
>, <Line: -    assertArgFn(fn, 'fn', true);
>, <Line: -  }
>, <Line: -  return $inject;
>, <Line: -}
>, <Line: -///////////////////////////////////////
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $injector
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * `$injector` is used to retrieve object instances as defined by
>, <Line: - * {@link auto.$provide provider}, instantiate types, invoke methods,
>, <Line: - * and load modules.
>, <Line: - *
>, <Line: - * The following always holds true:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   var $injector = angular.injector();
>, <Line: - *   expect($injector.get('$injector')).toBe($injector);
>, <Line: - *   expect($injector.invoke(function($injector) {
>, <Line: - *     return $injector;
>, <Line: - *   })).toBe($injector);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * # Injection Function Annotation
>, <Line: - *
>, <Line: - * JavaScript does not have annotations, and annotations are needed for dependency injection. The
>, <Line: - * following are all valid ways of annotating function with injection arguments and are equivalent.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   // inferred (only works if code not minified/obfuscated)
>, <Line: - *   $injector.invoke(function(serviceA){});
>, <Line: - *
>, <Line: - *   // annotated
>, <Line: - *   function explicit(serviceA) {};
>, <Line: - *   explicit.$inject = ['serviceA'];
>, <Line: - *   $injector.invoke(explicit);
>, <Line: - *
>, <Line: - *   // inline
>, <Line: - *   $injector.invoke(['serviceA', function(serviceA){}]);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * ## Inference
>, <Line: - *
>, <Line: - * In JavaScript calling `toString()` on a function returns the function definition. The definition
>, <Line: - * can then be parsed and the function arguments can be extracted. This method of discovering
>, <Line: - * annotations is disallowed when the injector is in strict mode.
>, <Line: - * *NOTE:* This does not work with minification, and obfuscation tools since these tools change the
>, <Line: - * argument names.
>, <Line: - *
>, <Line: - * ## `$inject` Annotation
>, <Line: - * By adding an `$inject` property onto a function the injection parameters can be specified.
>, <Line: - *
>, <Line: - * ## Inline
>, <Line: - * As an array of injection names, where the last item in the array is the function to call.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $injector#get
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Return an instance of the service.
>, <Line: - *
>, <Line: - * @param {string} name The name of the instance to retrieve.
>, <Line: - * @return {*} The instance.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $injector#invoke
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Invoke the method and supply the method arguments from the `$injector`.
>, <Line: - *
>, <Line: - * @param {!Function} fn The function to invoke. Function parameters are injected according to the
>, <Line: - *   {@link guide/di $inject Annotation} rules.
>, <Line: - * @param {Object=} self The `this` for the invoked method.
>, <Line: - * @param {Object=} locals Optional object. If preset then any argument names are read from this
>, <Line: - *                         object first, before the `$injector` is consulted.
>, <Line: - * @returns {*} the value returned by the invoked `fn` function.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $injector#has
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Allows the user to query if the particular service exists.
>, <Line: - *
>, <Line: - * @param {string} name Name of the service to query.
>, <Line: - * @returns {boolean} `true` if injector has given service.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $injector#instantiate
>, <Line: - * @description
>, <Line: - * Create a new instance of JS type. The method takes a constructor function, invokes the new
>, <Line: - * operator, and supplies all of the arguments to the constructor function as specified by the
>, <Line: - * constructor annotation.
>, <Line: - *
>, <Line: - * @param {Function} Type Annotated constructor function.
>, <Line: - * @param {Object=} locals Optional object. If preset then any argument names are read from this
>, <Line: - * object first, before the `$injector` is consulted.
>, <Line: - * @returns {Object} new instance of `Type`.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $injector#annotate
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Returns an array of service names which the function is requesting for injection. This API is
>, <Line: - * used by the injector to determine which services need to be injected into the function when the
>, <Line: - * function is invoked. There are three ways in which the function can be annotated with the needed
>, <Line: - * dependencies.
>, <Line: - *
>, <Line: - * # Argument names
>, <Line: - *
>, <Line: - * The simplest form is to extract the dependencies from the arguments of the function. This is done
>, <Line: - * by converting the function into a string using `toString()` method and extracting the argument
>, <Line: - * names.
>, <Line: - * ```js
>, <Line: - *   // Given
>, <Line: - *   function MyController($scope, $route) {
>, <Line: - *     // ...
>, <Line: - *   }
>, <Line: - *
>, <Line: - *   // Then
>, <Line: - *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * You can disallow this method by using strict injection mode.
>, <Line: - *
>, <Line: - * This method does not work with code minification / obfuscation. For this reason the following
>, <Line: - * annotation strategies are supported.
>, <Line: - *
>, <Line: - * # The `$inject` property
>, <Line: - *
>, <Line: - * If a function has an `$inject` property and its value is an array of strings, then the strings
>, <Line: - * represent names of services to be injected into the function.
>, <Line: - * ```js
>, <Line: - *   // Given
>, <Line: - *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
>, <Line: - *     // ...
>, <Line: - *   }
>, <Line: - *   // Define function dependencies
>, <Line: - *   MyController['$inject'] = ['$scope', '$route'];
>, <Line: - *
>, <Line: - *   // Then
>, <Line: - *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * # The array notation
>, <Line: - *
>, <Line: - * It is often desirable to inline Injected functions and that's when setting the `$inject` property
>, <Line: - * is very inconvenient. In these situations using the array notation to specify the dependencies in
>, <Line: - * a way that survives minification is a better choice:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   // We wish to write this (not minification / obfuscation safe)
>, <Line: - *   injector.invoke(function($compile, $rootScope) {
>, <Line: - *     // ...
>, <Line: - *   });
>, <Line: - *
>, <Line: - *   // We are forced to write break inlining
>, <Line: - *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
>, <Line: - *     // ...
>, <Line: - *   };
>, <Line: - *   tmpFn.$inject = ['$compile', '$rootScope'];
>, <Line: - *   injector.invoke(tmpFn);
>, <Line: - *
>, <Line: - *   // To better support inline function the inline annotation is supported
>, <Line: - *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
>, <Line: - *     // ...
>, <Line: - *   }]);
>, <Line: - *
>, <Line: - *   // Therefore
>, <Line: - *   expect(injector.annotate(
>, <Line: - *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
>, <Line: - *    ).toEqual(['$compile', '$rootScope']);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @param {Function|Array.<string|Function>} fn Function for which dependent service names need to
>, <Line: - * be retrieved as described above.
>, <Line: - *
>, <Line: - * @param {boolean=} [strictDi=false] Disallow argument name annotation inference.
>, <Line: - *
>, <Line: - * @returns {Array.<string>} The names of the services which the function requires.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $provide
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * The {@link auto.$provide $provide} service has a number of methods for registering components
>, <Line: - * with the {@link auto.$injector $injector}. Many of these functions are also exposed on
>, <Line: - * {@link angular.Module}.
>, <Line: - *
>, <Line: - * An Angular **service** is a singleton object created by a **service factory**.  These **service
>, <Line: - * factories** are functions which, in turn, are created by a **service provider**.
>, <Line: - * The **service providers** are constructor functions. When instantiated they must contain a
>, <Line: - * property called `$get`, which holds the **service factory** function.
>, <Line: - *
>, <Line: - * When you request a service, the {@link auto.$injector $injector} is responsible for finding the
>, <Line: - * correct **service provider**, instantiating it and then calling its `$get` **service factory**
>, <Line: - * function to get the instance of the **service**.
>, <Line: - *
>, <Line: - * Often services have no configuration options and there is no need to add methods to the service
>, <Line: - * provider.  The provider will be no more than a constructor function with a `$get` property. For
>, <Line: - * these cases the {@link auto.$provide $provide} service has additional helper methods to register
>, <Line: - * services without specifying a provider.
>, <Line: - *
>, <Line: - * * {@link auto.$provide#provider provider(provider)} - registers a **service provider** with the
>, <Line: - *     {@link auto.$injector $injector}
>, <Line: - * * {@link auto.$provide#constant constant(obj)} - registers a value/object that can be accessed by
>, <Line: - *     providers and services.
>, <Line: - * * {@link auto.$provide#value value(obj)} - registers a value/object that can only be accessed by
>, <Line: - *     services, not providers.
>, <Line: - * * {@link auto.$provide#factory factory(fn)} - registers a service **factory function**, `fn`,
>, <Line: - *     that will be wrapped in a **service provider** object, whose `$get` property will contain the
>, <Line: - *     given factory function.
>, <Line: - * * {@link auto.$provide#service service(class)} - registers a **constructor function**, `class`
>, <Line: - *     that will be wrapped in a **service provider** object, whose `$get` property will instantiate
>, <Line: - *      a new object using the given constructor function.
>, <Line: - *
>, <Line: - * See the individual methods for more information and examples.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#provider
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **provider function** with the {@link auto.$injector $injector}. Provider functions
>, <Line: - * are constructor functions, whose instances are responsible for "providing" a factory for a
>, <Line: - * service.
>, <Line: - *
>, <Line: - * Service provider names start with the name of the service they provide followed by `Provider`.
>, <Line: - * For example, the {@link ng.$log $log} service has a provider called
>, <Line: - * {@link ng.$logProvider $logProvider}.
>, <Line: - *
>, <Line: - * Service provider objects can have additional methods which allow configuration of the provider
>, <Line: - * and its service. Importantly, you can configure what kind of service is created by the `$get`
>, <Line: - * method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a
>, <Line: - * method {@link ng.$logProvider#debugEnabled debugEnabled}
>, <Line: - * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the
>, <Line: - * console or not.
>, <Line: - *
>, <Line: - * @param {string} name The name of the instance. NOTE: the provider will be available under `name +
>, <Line: -                        'Provider'` key.
>, <Line: - * @param {(Object|function())} provider If the provider is:
>, <Line: - *
>, <Line: - *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
>, <Line: - *     {@link auto.$injector#invoke $injector.invoke()} when an instance needs to be created.
>, <Line: - *   - `Constructor`: a new instance of the provider will be created using
>, <Line: - *     {@link auto.$injector#instantiate $injector.instantiate()}, then treated as `object`.
>, <Line: - *
>, <Line: - * @returns {Object} registered provider instance
>, <Line: - * @example
>, <Line: - *
>, <Line: - * The following example shows how to create a simple event tracking service and register it using
>, <Line: - * {@link auto.$provide#provider $provide.provider()}.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *  // Define the eventTracker provider
>, <Line: - *  function EventTrackerProvider() {
>, <Line: - *    var trackingUrl = '/track';
>, <Line: - *
>, <Line: - *    // A provider method for configuring where the tracked events should been saved
>, <Line: - *    this.setTrackingUrl = function(url) {
>, <Line: - *      trackingUrl = url;
>, <Line: - *    };
>, <Line: - *
>, <Line: - *    // The service factory function
>, <Line: - *    this.$get = ['$http', function($http) {
>, <Line: - *      var trackedEvents = {};
>, <Line: - *      return {
>, <Line: - *        // Call this to track an event
>, <Line: - *        event: function(event) {
>, <Line: - *          var count = trackedEvents[event] || 0;
>, <Line: - *          count += 1;
>, <Line: - *          trackedEvents[event] = count;
>, <Line: - *          return count;
>, <Line: - *        },
>, <Line: - *        // Call this to save the tracked events to the trackingUrl
>, <Line: - *        save: function() {
>, <Line: - *          $http.post(trackingUrl, trackedEvents);
>, <Line: - *        }
>, <Line: - *      };
>, <Line: - *    }];
>, <Line: - *  }
>, <Line: - *
>, <Line: - *  describe('eventTracker', function() {
>, <Line: - *    var postSpy;
>, <Line: - *
>, <Line: - *    beforeEach(module(function($provide) {
>, <Line: - *      // Register the eventTracker provider
>, <Line: - *      $provide.provider('eventTracker', EventTrackerProvider);
>, <Line: - *    }));
>, <Line: - *
>, <Line: - *    beforeEach(module(function(eventTrackerProvider) {
>, <Line: - *      // Configure eventTracker provider
>, <Line: - *      eventTrackerProvider.setTrackingUrl('/custom-track');
>, <Line: - *    }));
>, <Line: - *
>, <Line: - *    it('tracks events', inject(function(eventTracker) {
>, <Line: - *      expect(eventTracker.event('login')).toEqual(1);
>, <Line: - *      expect(eventTracker.event('login')).toEqual(2);
>, <Line: - *    }));
>, <Line: - *
>, <Line: - *    it('saves to the tracking url', inject(function(eventTracker, $http) {
>, <Line: - *      postSpy = spyOn($http, 'post');
>, <Line: - *      eventTracker.event('login');
>, <Line: - *      eventTracker.save();
>, <Line: - *      expect(postSpy).toHaveBeenCalled();
>, <Line: - *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');
>, <Line: - *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');
>, <Line: - *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });
>, <Line: - *    }));
>, <Line: - *  });
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#factory
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **service factory**, which will be called to return the service instance.
>, <Line: - * This is short for registering a service where its provider consists of only a `$get` property,
>, <Line: - * which is the given service factory function.
>, <Line: - * You should use {@link auto.$provide#factory $provide.factory(getFn)} if you do not need to
>, <Line: - * configure your service in a provider.
>, <Line: - *
>, <Line: - * @param {string} name The name of the instance.
>, <Line: - * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand
>, <Line: - *                            for `$provide.provider(name, {$get: $getFn})`.
>, <Line: - * @returns {Object} registered provider instance
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here is an example of registering a service
>, <Line: - * ```js
>, <Line: - *   $provide.factory('ping', ['$http', function($http) {
>, <Line: - *     return function ping() {
>, <Line: - *       return $http.send('/ping');
>, <Line: - *     };
>, <Line: - *   }]);
>, <Line: - * ```
>, <Line: - * You would then inject and use this service like this:
>, <Line: - * ```js
>, <Line: - *   someModule.controller('Ctrl', ['ping', function(ping) {
>, <Line: - *     ping();
>, <Line: - *   }]);
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#service
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **service constructor**, which will be invoked with `new` to create the service
>, <Line: - * instance.
>, <Line: - * This is short for registering a service where its provider's `$get` property is the service
>, <Line: - * constructor function that will be used to instantiate the service instance.
>, <Line: - *
>, <Line: - * You should use {@link auto.$provide#service $provide.service(class)} if you define your service
>, <Line: - * as a type/class.
>, <Line: - *
>, <Line: - * @param {string} name The name of the instance.
>, <Line: - * @param {Function} constructor A class (constructor function) that will be instantiated.
>, <Line: - * @returns {Object} registered provider instance
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here is an example of registering a service using
>, <Line: - * {@link auto.$provide#service $provide.service(class)}.
>, <Line: - * ```js
>, <Line: - *   var Ping = function($http) {
>, <Line: - *     this.$http = $http;
>, <Line: - *   };
>, <Line: - *
>, <Line: - *   Ping.$inject = ['$http'];
>, <Line: - *
>, <Line: - *   Ping.prototype.send = function() {
>, <Line: - *     return this.$http.get('/ping');
>, <Line: - *   };
>, <Line: - *   $provide.service('ping', Ping);
>, <Line: - * ```
>, <Line: - * You would then inject and use this service like this:
>, <Line: - * ```js
>, <Line: - *   someModule.controller('Ctrl', ['ping', function(ping) {
>, <Line: - *     ping.send();
>, <Line: - *   }]);
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#value
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **value service** with the {@link auto.$injector $injector}, such as a string, a
>, <Line: - * number, an array, an object or a function.  This is short for registering a service where its
>, <Line: - * provider's `$get` property is a factory function that takes no arguments and returns the **value
>, <Line: - * service**.
>, <Line: - *
>, <Line: - * Value services are similar to constant services, except that they cannot be injected into a
>, <Line: - * module configuration function (see {@link angular.Module#config}) but they can be overridden by
>, <Line: - * an Angular
>, <Line: - * {@link auto.$provide#decorator decorator}.
>, <Line: - *
>, <Line: - * @param {string} name The name of the instance.
>, <Line: - * @param {*} value The value.
>, <Line: - * @returns {Object} registered provider instance
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here are some examples of creating value services.
>, <Line: - * ```js
>, <Line: - *   $provide.value('ADMIN_USER', 'admin');
>, <Line: - *
>, <Line: - *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });
>, <Line: - *
>, <Line: - *   $provide.value('halfOf', function(value) {
>, <Line: - *     return value / 2;
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#constant
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **constant service**, such as a string, a number, an array, an object or a function,
>, <Line: - * with the {@link auto.$injector $injector}. Unlike {@link auto.$provide#value value} it can be
>, <Line: - * injected into a module configuration function (see {@link angular.Module#config}) and it cannot
>, <Line: - * be overridden by an Angular {@link auto.$provide#decorator decorator}.
>, <Line: - *
>, <Line: - * @param {string} name The name of the constant.
>, <Line: - * @param {*} value The constant value.
>, <Line: - * @returns {Object} registered instance
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here a some examples of creating constants:
>, <Line: - * ```js
>, <Line: - *   $provide.constant('SHARD_HEIGHT', 306);
>, <Line: - *
>, <Line: - *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);
>, <Line: - *
>, <Line: - *   $provide.constant('double', function(value) {
>, <Line: - *     return value * 2;
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $provide#decorator
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Register a **service decorator** with the {@link auto.$injector $injector}. A service decorator
>, <Line: - * intercepts the creation of a service, allowing it to override or modify the behaviour of the
>, <Line: - * service. The object returned by the decorator may be the original service, or a new service
>, <Line: - * object which replaces or wraps and delegates to the original service.
>, <Line: - *
>, <Line: - * @param {string} name The name of the service to decorate.
>, <Line: - * @param {function()} decorator This function will be invoked when the service needs to be
>, <Line: - *    instantiated and should return the decorated service instance. The function is called using
>, <Line: - *    the {@link auto.$injector#invoke injector.invoke} method and is therefore fully injectable.
>, <Line: - *    Local injection arguments:
>, <Line: - *
>, <Line: - *    * `$delegate` - The original service instance, which can be monkey patched, configured,
>, <Line: - *      decorated or delegated to.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here we decorate the {@link ng.$log $log} service to convert warnings to errors by intercepting
>, <Line: - * calls to {@link ng.$log#error $log.warn()}.
>, <Line: - * ```js
>, <Line: - *   $provide.decorator('$log', ['$delegate', function($delegate) {
>, <Line: - *     $delegate.warn = $delegate.error;
>, <Line: - *     return $delegate;
>, <Line: - *   }]);
>, <Line: - * ```
>, <Line: - */
>, <Line: -function createInjector(modulesToLoad, strictDi) {
>, <Line: -  strictDi = (strictDi === true);
>, <Line: -  var INSTANTIATING = {},
>, <Line: -      providerSuffix = 'Provider',
>, <Line: -      path = [],
>, <Line: -      loadedModules = new HashMap([], true),
>, <Line: -      providerCache = {
>, <Line: -        $provide: {
>, <Line: -            provider: supportObject(provider),
>, <Line: -            factory: supportObject(factory),
>, <Line: -            service: supportObject(service),
>, <Line: -            value: supportObject(value),
>, <Line: -            constant: supportObject(constant),
>, <Line: -            decorator: decorator
>, <Line: -          }
>, <Line: -      },
>, <Line: -      providerInjector = (providerCache.$injector =
>, <Line: -          createInternalInjector(providerCache, function() {
>, <Line: -            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
>, <Line: -          })),
>, <Line: -      instanceCache = {},
>, <Line: -      instanceInjector = (instanceCache.$injector =
>, <Line: -          createInternalInjector(instanceCache, function(servicename) {
>, <Line: -            var provider = providerInjector.get(servicename + providerSuffix);
>, <Line: -            return instanceInjector.invoke(provider.$get, provider, undefined, servicename);
>, <Line: -          }));
>, <Line: -  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });
>, <Line: -  return instanceInjector;
>, <Line: -  ////////////////////////////////////
>, <Line: -  // $provider
>, <Line: -  ////////////////////////////////////
>, <Line: -  function supportObject(delegate) {
>, <Line: -    return function(key, value) {
>, <Line: -      if (isObject(key)) {
>, <Line: -        forEach(key, reverseParams(delegate));
>, <Line: -      } else {
>, <Line: -        return delegate(key, value);
>, <Line: -      }
>, <Line: -    };
>, <Line: -  }
>, <Line: -  function provider(name, provider_) {
>, <Line: -    assertNotHasOwnProperty(name, 'service');
>, <Line: -    if (isFunction(provider_) || isArray(provider_)) {
>, <Line: -      provider_ = providerInjector.instantiate(provider_);
>, <Line: -    }
>, <Line: -    if (!provider_.$get) {
>, <Line: -      throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
>, <Line: -    }
>, <Line: -    return providerCache[name + providerSuffix] = provider_;
>, <Line: -  }
>, <Line: -  function enforceReturnValue(name, factory) {
>, <Line: -    return function enforcedReturnValue() {
>, <Line: -      var result = instanceInjector.invoke(factory, this, undefined, name);
>, <Line: -      if (isUndefined(result)) {
>, <Line: -        throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
>, <Line: -      }
>, <Line: -      return result;
>, <Line: -    };
>, <Line: -  }
>, <Line: -  function factory(name, factoryFn, enforce) {
>, <Line: -    return provider(name, {
>, <Line: -      $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
>, <Line: -    });
>, <Line: -  }
>, <Line: -  function service(name, constructor) {
>, <Line: -    return factory(name, ['$injector', function($injector) {
>, <Line: -      return $injector.instantiate(constructor);
>, <Line: -    }]);
>, <Line: -  }
>, <Line: -  function value(name, val) { return factory(name, valueFn(val), false); }
>, <Line: -  function constant(name, value) {
>, <Line: -    assertNotHasOwnProperty(name, 'constant');
>, <Line: -    providerCache[name] = value;
>, <Line: -    instanceCache[name] = value;
>, <Line: -  }
>, <Line: -  function decorator(serviceName, decorFn) {
>, <Line: -    var origProvider = providerInjector.get(serviceName + providerSuffix),
>, <Line: -        orig$get = origProvider.$get;
>, <Line: -    origProvider.$get = function() {
>, <Line: -      var origInstance = instanceInjector.invoke(orig$get, origProvider);
>, <Line: -      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
>, <Line: -    };
>, <Line: -  }
>, <Line: -  ////////////////////////////////////
>, <Line: -  // Module Loading
>, <Line: -  ////////////////////////////////////
>, <Line: -  function loadModules(modulesToLoad) {
>, <Line: -    var runBlocks = [], moduleFn;
>, <Line: -    forEach(modulesToLoad, function(module) {
>, <Line: -      if (loadedModules.get(module)) return;
>, <Line: -      loadedModules.put(module, true);
>, <Line: -      function runInvokeQueue(queue) {
>, <Line: -        var i, ii;
>, <Line: -        for (i = 0, ii = queue.length; i < ii; i++) {
>, <Line: -          var invokeArgs = queue[i],
>, <Line: -              provider = providerInjector.get(invokeArgs[0]);
>, <Line: -          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      try {
>, <Line: -        if (isString(module)) {
>, <Line: -          moduleFn = angularModule(module);
>, <Line: -          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
>, <Line: -          runInvokeQueue(moduleFn._invokeQueue);
>, <Line: -          runInvokeQueue(moduleFn._configBlocks);
>, <Line: -        } else if (isFunction(module)) {
>, <Line: -            runBlocks.push(providerInjector.invoke(module));
>, <Line: -        } else if (isArray(module)) {
>, <Line: -            runBlocks.push(providerInjector.invoke(module));
>, <Line: -        } else {
>, <Line: -          assertArgFn(module, 'module');
>, <Line: -        }
>, <Line: -      } catch (e) {
>, <Line: -        if (isArray(module)) {
>, <Line: -          module = module[module.length - 1];
>, <Line: -        }
>, <Line: -        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
>, <Line: -          // Safari & FF's stack traces don't contain error.message content
>, <Line: -          // unlike those of Chrome and IE
>, <Line: -          // So if stack doesn't contain message, we create a new string that contains both.
>, <Line: -          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
>, <Line: -          /* jshint -W022 */
>, <Line: -          e = e.message + '\n' + e.stack;
>, <Line: -        }
>, <Line: -        throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
>, <Line: -                  module, e.stack || e.message || e);
>, <Line: -      }
>, <Line: -    });
>, <Line: -    return runBlocks;
>, <Line: -  }
>, <Line: -  ////////////////////////////////////
>, <Line: -  // internal Injector
>, <Line: -  ////////////////////////////////////
>, <Line: -  function createInternalInjector(cache, factory) {
>, <Line: -    function getService(serviceName) {
>, <Line: -      if (cache.hasOwnProperty(serviceName)) {
>, <Line: -        if (cache[serviceName] === INSTANTIATING) {
>, <Line: -          throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
>, <Line: -                    serviceName + ' <- ' + path.join(' <- '));
>, <Line: -        }
>, <Line: -        return cache[serviceName];
>, <Line: -      } else {
>, <Line: -        try {
>, <Line: -          path.unshift(serviceName);
>, <Line: -          cache[serviceName] = INSTANTIATING;
>, <Line: -          return cache[serviceName] = factory(serviceName);
>, <Line: -        } catch (err) {
>, <Line: -          if (cache[serviceName] === INSTANTIATING) {
>, <Line: -            delete cache[serviceName];
>, <Line: -          }
>, <Line: -          throw err;
>, <Line: -        } finally {
>, <Line: -          path.shift();
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function invoke(fn, self, locals, serviceName) {
>, <Line: -      if (typeof locals === 'string') {
>, <Line: -        serviceName = locals;
>, <Line: -        locals = null;
>, <Line: -      }
>, <Line: -      var args = [],
>, <Line: -          $inject = annotate(fn, strictDi, serviceName),
>, <Line: -          length, i,
>, <Line: -          key;
>, <Line: -      for (i = 0, length = $inject.length; i < length; i++) {
>, <Line: -        key = $inject[i];
>, <Line: -        if (typeof key !== 'string') {
>, <Line: -          throw $injectorMinErr('itkn',
>, <Line: -                  'Incorrect injection token! Expected service name as string, got {0}', key);
>, <Line: -        }
>, <Line: -        args.push(
>, <Line: -          locals && locals.hasOwnProperty(key)
>, <Line: -          ? locals[key]
>, <Line: -          : getService(key)
>, <Line: -        );
>, <Line: -      }
>, <Line: -      if (isArray(fn)) {
>, <Line: -        fn = fn[length];
>, <Line: -      }
>, <Line: -      // http://jsperf.com/angularjs-invoke-apply-vs-switch
>, <Line: -      // #5388
>, <Line: -      return fn.apply(self, args);
>, <Line: -    }
>, <Line: -    function instantiate(Type, locals, serviceName) {
>, <Line: -      // Check if Type is annotated and use just the given function at n-1 as parameter
>, <Line: -      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
>, <Line: -      // Object creation: http://jsperf.com/create-constructor/2
>, <Line: -      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype);
>, <Line: -      var returnedValue = invoke(Type, instance, locals, serviceName);
>, <Line: -      return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
>, <Line: -    }
>, <Line: -    return {
>, <Line: -      invoke: invoke,
>, <Line: -      instantiate: instantiate,
>, <Line: -      get: getService,
>, <Line: -      annotate: annotate,
>, <Line: -      has: function(name) {
>, <Line: -        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
>, <Line: -      }
>, <Line: -    };
>, <Line: -  }
>, <Line: -}
>, <Line: -createInjector.$$annotate = annotate;
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $anchorScrollProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Use `$anchorScrollProvider` to disable automatic scrolling whenever
>, <Line: - * {@link ng.$location#hash $location.hash()} changes.
>, <Line: - */
>, <Line: -function $AnchorScrollProvider() {
>, <Line: -  var autoScrollingEnabled = true;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $anchorScrollProvider#disableAutoScrolling
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
>, <Line: -   * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.<br />
>, <Line: -   * Use this method to disable automatic scrolling.
>, <Line: -   *
>, <Line: -   * If automatic scrolling is disabled, one must explicitly call
>, <Line: -   * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the element related to the
>, <Line: -   * current hash.
>, <Line: -   */
>, <Line: -  this.disableAutoScrolling = function() {
>, <Line: -    autoScrollingEnabled = false;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc service
>, <Line: -   * @name $anchorScroll
>, <Line: -   * @kind function
>, <Line: -   * @requires $window
>, <Line: -   * @requires $location
>, <Line: -   * @requires $rootScope
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * When called, it checks the current value of {@link ng.$location#hash $location.hash()} and
>, <Line: -   * scrolls to the related element, according to the rules specified in the
>, <Line: -   * [Html5 spec](http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document).
>, <Line: -   *
>, <Line: -   * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to
>, <Line: -   * match any anchor whenever it changes. This can be disabled by calling
>, <Line: -   * {@link ng.$anchorScrollProvider#disableAutoScrolling $anchorScrollProvider.disableAutoScrolling()}.
>, <Line: -   *
>, <Line: -   * Additionally, you can use its {@link ng.$anchorScroll#yOffset yOffset} property to specify a
>, <Line: -   * vertical scroll-offset (either fixed or dynamic).
>, <Line: -   *
>, <Line: -   * @property {(number|function|jqLite)} yOffset
>, <Line: -   * If set, specifies a vertical scroll-offset. This is often useful when there are fixed
>, <Line: -   * positioned elements at the top of the page, such as navbars, headers etc.
>, <Line: -   *
>, <Line: -   * `yOffset` can be specified in various ways:
>, <Line: -   * - **number**: A fixed number of pixels to be used as offset.<br /><br />
>, <Line: -   * - **function**: A getter function called everytime `$anchorScroll()` is executed. Must return
>, <Line: -   *   a number representing the offset (in pixels).<br /><br />
>, <Line: -   * - **jqLite**: A jqLite/jQuery element to be used for specifying the offset. The distance from
>, <Line: -   *   the top of the page to the element's bottom will be used as offset.<br />
>, <Line: -   *   **Note**: The element will be taken into account only as long as its `position` is set to
>, <Line: -   *   `fixed`. This option is useful, when dealing with responsive navbars/headers that adjust
>, <Line: -   *   their height and/or positioning according to the viewport's size.
>, <Line: -   *
>, <Line: -   * <br />
>, <Line: -   * <div class="alert alert-warning">
>, <Line: -   * In order for `yOffset` to work properly, scrolling should take place on the document's root and
>, <Line: -   * not some child element.
>, <Line: -   * </div>
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -     <example module="anchorScrollExample">
>, <Line: -       <file name="index.html">
>, <Line: -         <div id="scrollArea" ng-controller="ScrollController">
>, <Line: -           <a ng-click="gotoBottom()">Go to bottom</a>
>, <Line: -           <a id="bottom"></a> You're at the bottom!
>, <Line: -         </div>
>, <Line: -       </file>
>, <Line: -       <file name="script.js">
>, <Line: -         angular.module('anchorScrollExample', [])
>, <Line: -           .controller('ScrollController', ['$scope', '$location', '$anchorScroll',
>, <Line: -             function ($scope, $location, $anchorScroll) {
>, <Line: -               $scope.gotoBottom = function() {
>, <Line: -                 // set the location.hash to the id of
>, <Line: -                 // the element you wish to scroll to.
>, <Line: -                 $location.hash('bottom');
>, <Line: -                 // call $anchorScroll()
>, <Line: -                 $anchorScroll();
>, <Line: -               };
>, <Line: -             }]);
>, <Line: -       </file>
>, <Line: -       <file name="style.css">
>, <Line: -         #scrollArea {
>, <Line: -           height: 280px;
>, <Line: -           overflow: auto;
>, <Line: -         }
>, <Line: -         #bottom {
>, <Line: -           display: block;
>, <Line: -           margin-top: 2000px;
>, <Line: -         }
>, <Line: -       </file>
>, <Line: -     </example>
>, <Line: -   *
>, <Line: -   * <hr />
>, <Line: -   * The example below illustrates the use of a vertical scroll-offset (specified as a fixed value).
>, <Line: -   * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more details.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -     <example module="anchorScrollOffsetExample">
>, <Line: -       <file name="index.html">
>, <Line: -         <div class="fixed-header" ng-controller="headerCtrl">
>, <Line: -           <a href="" ng-click="gotoAnchor(x)" ng-repeat="x in [1,2,3,4,5]">
>, <Line: -             Go to anchor {{x}}
>, <Line: -           </a>
>, <Line: -         </div>
>, <Line: -         <div id="anchor{{x}}" class="anchor" ng-repeat="x in [1,2,3,4,5]">
>, <Line: -           Anchor {{x}} of 5
>, <Line: -         </div>
>, <Line: -       </file>
>, <Line: -       <file name="script.js">
>, <Line: -         angular.module('anchorScrollOffsetExample', [])
>, <Line: -           .run(['$anchorScroll', function($anchorScroll) {
>, <Line: -             $anchorScroll.yOffset = 50;   // always scroll by 50 extra pixels
>, <Line: -           }])
>, <Line: -           .controller('headerCtrl', ['$anchorScroll', '$location', '$scope',
>, <Line: -             function ($anchorScroll, $location, $scope) {
>, <Line: -               $scope.gotoAnchor = function(x) {
>, <Line: -                 var newHash = 'anchor' + x;
>, <Line: -                 if ($location.hash() !== newHash) {
>, <Line: -                   // set the $location.hash to `newHash` and
>, <Line: -                   // $anchorScroll will automatically scroll to it
>, <Line: -                   $location.hash('anchor' + x);
>, <Line: -                 } else {
>, <Line: -                   // call $anchorScroll() explicitly,
>, <Line: -                   // since $location.hash hasn't changed
>, <Line: -                   $anchorScroll();
>, <Line: -                 }
>, <Line: -               };
>, <Line: -             }
>, <Line: -           ]);
>, <Line: -       </file>
>, <Line: -       <file name="style.css">
>, <Line: -         body {
>, <Line: -           padding-top: 50px;
>, <Line: -         }
>, <Line: -         .anchor {
>, <Line: -           border: 2px dashed DarkOrchid;
>, <Line: -           padding: 10px 10px 200px 10px;
>, <Line: -         }
>, <Line: -         .fixed-header {
>, <Line: -           background-color: rgba(0, 0, 0, 0.2);
>, <Line: -           height: 50px;
>, <Line: -           position: fixed;
>, <Line: -           top: 0; left: 0; right: 0;
>, <Line: -         }
>, <Line: -         .fixed-header > a {
>, <Line: -           display: inline-block;
>, <Line: -           margin: 5px 15px;
>, <Line: -         }
>, <Line: -       </file>
>, <Line: -     </example>
>, <Line: -   */
>, <Line: -  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
>, <Line: -    var document = $window.document;
>, <Line: -    // Helper function to get first anchor from a NodeList
>, <Line: -    // (using `Array#some()` instead of `angular#forEach()` since it's more performant
>, <Line: -    //  and working in all supported browsers.)
>, <Line: -    function getFirstAnchor(list) {
>, <Line: -      var result = null;
>, <Line: -      Array.prototype.some.call(list, function(element) {
>, <Line: -        if (nodeName_(element) === 'a') {
>, <Line: -          result = element;
>, <Line: -          return true;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return result;
>, <Line: -    }
>, <Line: -    function getYOffset() {
>, <Line: -      var offset = scroll.yOffset;
>, <Line: -      if (isFunction(offset)) {
>, <Line: -        offset = offset();
>, <Line: -      } else if (isElement(offset)) {
>, <Line: -        var elem = offset[0];
>, <Line: -        var style = $window.getComputedStyle(elem);
>, <Line: -        if (style.position !== 'fixed') {
>, <Line: -          offset = 0;
>, <Line: -        } else {
>, <Line: -          offset = elem.getBoundingClientRect().bottom;
>, <Line: -        }
>, <Line: -      } else if (!isNumber(offset)) {
>, <Line: -        offset = 0;
>, <Line: -      }
>, <Line: -      return offset;
>, <Line: -    }
>, <Line: -    function scrollTo(elem) {
>, <Line: -      if (elem) {
>, <Line: -        elem.scrollIntoView();
>, <Line: -        var offset = getYOffset();
>, <Line: -        if (offset) {
>, <Line: -          // `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
>, <Line: -          // This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
>, <Line: -          // top of the viewport.
>, <Line: -          //
>, <Line: -          // IF the number of pixels from the top of `elem` to the end of the page's content is less
>, <Line: -          // than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some
>, <Line: -          // way down the page.
>, <Line: -          //
>, <Line: -          // This is often the case for elements near the bottom of the page.
>, <Line: -          //
>, <Line: -          // In such cases we do not need to scroll the whole `offset` up, just the difference between
>, <Line: -          // the top of the element and the offset, which is enough to align the top of `elem` at the
>, <Line: -          // desired position.
>, <Line: -          var elemTop = elem.getBoundingClientRect().top;
>, <Line: -          $window.scrollBy(0, elemTop - offset);
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        $window.scrollTo(0, 0);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function scroll() {
>, <Line: -      var hash = $location.hash(), elm;
>, <Line: -      // empty hash, scroll to the top of the page
>, <Line: -      if (!hash) scrollTo(null);
>, <Line: -      // element with given id
>, <Line: -      else if ((elm = document.getElementById(hash))) scrollTo(elm);
>, <Line: -      // first anchor with given name :-D
>, <Line: -      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
>, <Line: -      // no element and hash == 'top', scroll to the top of the page
>, <Line: -      else if (hash === 'top') scrollTo(null);
>, <Line: -    }
>, <Line: -    // does not scroll when user clicks on anchor link that is currently on
>, <Line: -    // (no url change, no $location.hash() change), browser native does scroll
>, <Line: -    if (autoScrollingEnabled) {
>, <Line: -      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
>, <Line: -        function autoScrollWatchAction(newVal, oldVal) {
>, <Line: -          // skip the initial scroll if $location.hash is empty
>, <Line: -          if (newVal === oldVal && newVal === '') return;
>, <Line: -          jqLiteDocumentLoaded(function() {
>, <Line: -            $rootScope.$evalAsync(scroll);
>, <Line: -          });
>, <Line: -        });
>, <Line: -    }
>, <Line: -    return scroll;
>, <Line: -  }];
>, <Line: -}
>, <Line: -var $animateMinErr = minErr('$animate');
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $animateProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Default implementation of $animate that doesn't perform any animations, instead just
>, <Line: - * synchronously performs DOM
>, <Line: - * updates and calls done() callbacks.
>, <Line: - *
>, <Line: - * In order to enable animations the ngAnimate module has to be loaded.
>, <Line: - *
>, <Line: - * To see the functional implementation check out src/ngAnimate/animate.js
>, <Line: - */
>, <Line: -var $AnimateProvider = ['$provide', function($provide) {
>, <Line: -  this.$$selectors = {};
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $animateProvider#register
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Registers a new injectable animation factory function. The factory function produces the
>, <Line: -   * animation object which contains callback functions for each event that is expected to be
>, <Line: -   * animated.
>, <Line: -   *
>, <Line: -   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction`
>, <Line: -   *   must be called once the element animation is complete. If a function is returned then the
>, <Line: -   *   animation service will use this function to cancel the animation whenever a cancel event is
>, <Line: -   *   triggered.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   *   return {
>, <Line: -     *     eventFn : function(element, done) {
>, <Line: -     *       //code to run the animation
>, <Line: -     *       //once complete, then run done()
>, <Line: -     *       return function cancellationFunction() {
>, <Line: -     *         //code to cancel the animation
>, <Line: -     *       }
>, <Line: -     *     }
>, <Line: -     *   }
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {string} name The name of the animation.
>, <Line: -   * @param {Function} factory The factory function that will be executed to return the animation
>, <Line: -   *                           object.
>, <Line: -   */
>, <Line: -  this.register = function(name, factory) {
>, <Line: -    var key = name + '-animation';
>, <Line: -    if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',
>, <Line: -        "Expecting class selector starting with '.' got '{0}'.", name);
>, <Line: -    this.$$selectors[name.substr(1)] = key;
>, <Line: -    $provide.factory(key, factory);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $animateProvider#classNameFilter
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets and/or returns the CSS class regular expression that is checked when performing
>, <Line: -   * an animation. Upon bootstrap the classNameFilter value is not set at all and will
>, <Line: -   * therefore enable $animate to attempt to perform an animation on any element.
>, <Line: -   * When setting the classNameFilter value, animations will only be performed on elements
>, <Line: -   * that successfully match the filter expression. This in turn can boost performance
>, <Line: -   * for low-powered devices as well as applications containing a lot of structural operations.
>, <Line: -   * @param {RegExp=} expression The className expression which will be checked against all animations
>, <Line: -   * @return {RegExp} The current CSS className expression value. If null then there is no expression value
>, <Line: -   */
>, <Line: -  this.classNameFilter = function(expression) {
>, <Line: -    if (arguments.length === 1) {
>, <Line: -      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
>, <Line: -    }
>, <Line: -    return this.$$classNameFilter;
>, <Line: -  };
>, <Line: -  this.$get = ['$$q', '$$asyncCallback', '$rootScope', function($$q, $$asyncCallback, $rootScope) {
>, <Line: -    var currentDefer;
>, <Line: -    function runAnimationPostDigest(fn) {
>, <Line: -      var cancelFn, defer = $$q.defer();
>, <Line: -      defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
>, <Line: -        cancelFn && cancelFn();
>, <Line: -      };
>, <Line: -      $rootScope.$$postDigest(function ngAnimatePostDigest() {
>, <Line: -        cancelFn = fn(function ngAnimateNotifyComplete() {
>, <Line: -          defer.resolve();
>, <Line: -        });
>, <Line: -      });
>, <Line: -      return defer.promise;
>, <Line: -    }
>, <Line: -    function resolveElementClasses(element, classes) {
>, <Line: -      var toAdd = [], toRemove = [];
>, <Line: -      var hasClasses = createMap();
>, <Line: -      forEach((element.attr('class') || '').split(/\s+/), function(className) {
>, <Line: -        hasClasses[className] = true;
>, <Line: -      });
>, <Line: -      forEach(classes, function(status, className) {
>, <Line: -        var hasClass = hasClasses[className];
>, <Line: -        // If the most recent class manipulation (via $animate) was to remove the class, and the
>, <Line: -        // element currently has the class, the class is scheduled for removal. Otherwise, if
>, <Line: -        // the most recent class manipulation (via $animate) was to add the class, and the
>, <Line: -        // element does not currently have the class, the class is scheduled to be added.
>, <Line: -        if (status === false && hasClass) {
>, <Line: -          toRemove.push(className);
>, <Line: -        } else if (status === true && !hasClass) {
>, <Line: -          toAdd.push(className);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return (toAdd.length + toRemove.length) > 0 &&
>, <Line: -        [toAdd.length ? toAdd : null, toRemove.length ? toRemove : null];
>, <Line: -    }
>, <Line: -    function cachedClassManipulation(cache, classes, op) {
>, <Line: -      for (var i=0, ii = classes.length; i < ii; ++i) {
>, <Line: -        var className = classes[i];
>, <Line: -        cache[className] = op;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function asyncPromise() {
>, <Line: -      // only serve one instance of a promise in order to save CPU cycles
>, <Line: -      if (!currentDefer) {
>, <Line: -        currentDefer = $$q.defer();
>, <Line: -        $$asyncCallback(function() {
>, <Line: -          currentDefer.resolve();
>, <Line: -          currentDefer = null;
>, <Line: -        });
>, <Line: -      }
>, <Line: -      return currentDefer.promise;
>, <Line: -    }
>, <Line: -    function applyStyles(element, options) {
>, <Line: -      if (angular.isObject(options)) {
>, <Line: -        var styles = extend(options.from || {}, options.to || {});
>, <Line: -        element.css(styles);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     *
>, <Line: -     * @ngdoc service
>, <Line: -     * @name $animate
>, <Line: -     * @description The $animate service provides rudimentary DOM manipulation functions to
>, <Line: -     * insert, remove and move elements within the DOM, as well as adding and removing classes.
>, <Line: -     * This service is the core service used by the ngAnimate $animator service which provides
>, <Line: -     * high-level animation hooks for CSS and JavaScript.
>, <Line: -     *
>, <Line: -     * $animate is available in the AngularJS core, however, the ngAnimate module must be included
>, <Line: -     * to enable full out animation support. Otherwise, $animate will only perform simple DOM
>, <Line: -     * manipulation operations.
>, <Line: -     *
>, <Line: -     * To learn more about enabling animation support, click here to visit the {@link ngAnimate
>, <Line: -     * ngAnimate module page} as well as the {@link ngAnimate.$animate ngAnimate $animate service
>, <Line: -     * page}.
>, <Line: -     */
>, <Line: -    return {
>, <Line: -      animate: function(element, from, to) {
>, <Line: -        applyStyles(element, { from: from, to: to });
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#enter
>, <Line: -       * @kind function
>, <Line: -       * @description Inserts the element into the DOM either after the `after` element or
>, <Line: -       * as the first child within the `parent` element. When the function is called a promise
>, <Line: -       * is returned that will be resolved at a later time.
>, <Line: -       * @param {DOMElement} element the element which will be inserted into the DOM
>, <Line: -       * @param {DOMElement} parent the parent element which will append the element as
>, <Line: -       *   a child (if the after element is not present)
>, <Line: -       * @param {DOMElement} after the sibling element which will append the element
>, <Line: -       *   after itself
>, <Line: -       * @param {object=} options an optional collection of styles that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      enter: function(element, parent, after, options) {
>, <Line: -        applyStyles(element, options);
>, <Line: -        after ? after.after(element)
>, <Line: -              : parent.prepend(element);
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#leave
>, <Line: -       * @kind function
>, <Line: -       * @description Removes the element from the DOM. When the function is called a promise
>, <Line: -       * is returned that will be resolved at a later time.
>, <Line: -       * @param {DOMElement} element the element which will be removed from the DOM
>, <Line: -       * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      leave: function(element, options) {
>, <Line: -        element.remove();
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#move
>, <Line: -       * @kind function
>, <Line: -       * @description Moves the position of the provided element within the DOM to be placed
>, <Line: -       * either after the `after` element or inside of the `parent` element. When the function
>, <Line: -       * is called a promise is returned that will be resolved at a later time.
>, <Line: -       *
>, <Line: -       * @param {DOMElement} element the element which will be moved around within the
>, <Line: -       *   DOM
>, <Line: -       * @param {DOMElement} parent the parent element where the element will be
>, <Line: -       *   inserted into (if the after element is not present)
>, <Line: -       * @param {DOMElement} after the sibling element where the element will be
>, <Line: -       *   positioned next to
>, <Line: -       * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      move: function(element, parent, after, options) {
>, <Line: -        // Do not remove element before insert. Removing will cause data associated with the
>, <Line: -        // element to be dropped. Insert will implicitly do the remove.
>, <Line: -        return this.enter(element, parent, after, options);
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#addClass
>, <Line: -       * @kind function
>, <Line: -       * @description Adds the provided className CSS class value to the provided element.
>, <Line: -       * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: -       * @param {DOMElement} element the element which will have the className value
>, <Line: -       *   added to it
>, <Line: -       * @param {string} className the CSS class which will be added to the element
>, <Line: -       * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      addClass: function(element, className, options) {
>, <Line: -        return this.setClass(element, className, [], options);
>, <Line: -      },
>, <Line: -      $$addClassImmediately: function(element, className, options) {
>, <Line: -        element = jqLite(element);
>, <Line: -        className = !isString(className)
>, <Line: -                        ? (isArray(className) ? className.join(' ') : '')
>, <Line: -                        : className;
>, <Line: -        forEach(element, function(element) {
>, <Line: -          jqLiteAddClass(element, className);
>, <Line: -        });
>, <Line: -        applyStyles(element, options);
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#removeClass
>, <Line: -       * @kind function
>, <Line: -       * @description Removes the provided className CSS class value from the provided element.
>, <Line: -       * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: -       * @param {DOMElement} element the element which will have the className value
>, <Line: -       *   removed from it
>, <Line: -       * @param {string} className the CSS class which will be removed from the element
>, <Line: -       * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      removeClass: function(element, className, options) {
>, <Line: -        return this.setClass(element, [], className, options);
>, <Line: -      },
>, <Line: -      $$removeClassImmediately: function(element, className, options) {
>, <Line: -        element = jqLite(element);
>, <Line: -        className = !isString(className)
>, <Line: -                        ? (isArray(className) ? className.join(' ') : '')
>, <Line: -                        : className;
>, <Line: -        forEach(element, function(element) {
>, <Line: -          jqLiteRemoveClass(element, className);
>, <Line: -        });
>, <Line: -        applyStyles(element, options);
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       *
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $animate#setClass
>, <Line: -       * @kind function
>, <Line: -       * @description Adds and/or removes the given CSS classes to and from the element.
>, <Line: -       * When the function is called a promise is returned that will be resolved at a later time.
>, <Line: -       * @param {DOMElement} element the element which will have its CSS classes changed
>, <Line: -       *   removed from it
>, <Line: -       * @param {string} add the CSS classes which will be added to the element
>, <Line: -       * @param {string} remove the CSS class which will be removed from the element
>, <Line: -       * @param {object=} options an optional collection of options that will be applied to the element.
>, <Line: -       * @return {Promise} the animation callback promise
>, <Line: -       */
>, <Line: -      setClass: function(element, add, remove, options) {
>, <Line: -        var self = this;
>, <Line: -        var STORAGE_KEY = '$$animateClasses';
>, <Line: -        var createdCache = false;
>, <Line: -        element = jqLite(element);
>, <Line: -        var cache = element.data(STORAGE_KEY);
>, <Line: -        if (!cache) {
>, <Line: -          cache = {
>, <Line: -            classes: {},
>, <Line: -            options: options
>, <Line: -          };
>, <Line: -          createdCache = true;
>, <Line: -        } else if (options && cache.options) {
>, <Line: -          cache.options = angular.extend(cache.options || {}, options);
>, <Line: -        }
>, <Line: -        var classes = cache.classes;
>, <Line: -        add = isArray(add) ? add : add.split(' ');
>, <Line: -        remove = isArray(remove) ? remove : remove.split(' ');
>, <Line: -        cachedClassManipulation(classes, add, true);
>, <Line: -        cachedClassManipulation(classes, remove, false);
>, <Line: -        if (createdCache) {
>, <Line: -          cache.promise = runAnimationPostDigest(function(done) {
>, <Line: -            var cache = element.data(STORAGE_KEY);
>, <Line: -            element.removeData(STORAGE_KEY);
>, <Line: -            // in the event that the element is removed before postDigest
>, <Line: -            // is run then the cache will be undefined and there will be
>, <Line: -            // no need anymore to add or remove and of the element classes
>, <Line: -            if (cache) {
>, <Line: -              var classes = resolveElementClasses(element, cache.classes);
>, <Line: -              if (classes) {
>, <Line: -                self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
>, <Line: -              }
>, <Line: -            }
>, <Line: -            done();
>, <Line: -          });
>, <Line: -          element.data(STORAGE_KEY, cache);
>, <Line: -        }
>, <Line: -        return cache.promise;
>, <Line: -      },
>, <Line: -      $$setClassImmediately: function(element, add, remove, options) {
>, <Line: -        add && this.$$addClassImmediately(element, add);
>, <Line: -        remove && this.$$removeClassImmediately(element, remove);
>, <Line: -        applyStyles(element, options);
>, <Line: -        return asyncPromise();
>, <Line: -      },
>, <Line: -      enabled: noop,
>, <Line: -      cancel: noop
>, <Line: -    };
>, <Line: -  }];
>, <Line: -}];
>, <Line: -function $$AsyncCallbackProvider() {
>, <Line: -  this.$get = ['$$rAF', '$timeout', function($$rAF, $timeout) {
>, <Line: -    return $$rAF.supported
>, <Line: -      ? function(fn) { return $$rAF(fn); }
>, <Line: -      : function(fn) {
>, <Line: -        return $timeout(fn, 0, false);
>, <Line: -      };
>, <Line: -  }];
>, <Line: -}
>, <Line: -/* global stripHash: true */
>, <Line: -/**
>, <Line: - * ! This is a private undocumented service !
>, <Line: - *
>, <Line: - * @name $browser
>, <Line: - * @requires $log
>, <Line: - * @description
>, <Line: - * This object has two goals:
>, <Line: - *
>, <Line: - * - hide all the global state in the browser caused by the window object
>, <Line: - * - abstract away all the browser specific features and inconsistencies
>, <Line: - *
>, <Line: - * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
>, <Line: - * service, which can be used for convenient testing of the application without the interaction with
>, <Line: - * the real browser apis.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @param {object} window The global window object.
>, <Line: - * @param {object} document jQuery wrapped document.
>, <Line: - * @param {object} $log window.console or an object with the same interface.
>, <Line: - * @param {object} $sniffer $sniffer service
>, <Line: - */
>, <Line: -function Browser(window, document, $log, $sniffer) {
>, <Line: -  var self = this,
>, <Line: -      rawDocument = document[0],
>, <Line: -      location = window.location,
>, <Line: -      history = window.history,
>, <Line: -      setTimeout = window.setTimeout,
>, <Line: -      clearTimeout = window.clearTimeout,
>, <Line: -      pendingDeferIds = {};
>, <Line: -  self.isMock = false;
>, <Line: -  var outstandingRequestCount = 0;
>, <Line: -  var outstandingRequestCallbacks = [];
>, <Line: -  // TODO(vojta): remove this temporary api
>, <Line: -  self.$$completeOutstandingRequest = completeOutstandingRequest;
>, <Line: -  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };
>, <Line: -  /**
>, <Line: -   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
>, <Line: -   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
>, <Line: -   */
>, <Line: -  function completeOutstandingRequest(fn) {
>, <Line: -    try {
>, <Line: -      fn.apply(null, sliceArgs(arguments, 1));
>, <Line: -    } finally {
>, <Line: -      outstandingRequestCount--;
>, <Line: -      if (outstandingRequestCount === 0) {
>, <Line: -        while (outstandingRequestCallbacks.length) {
>, <Line: -          try {
>, <Line: -            outstandingRequestCallbacks.pop()();
>, <Line: -          } catch (e) {
>, <Line: -            $log.error(e);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @private
>, <Line: -   * Note: this method is used only by scenario runner
>, <Line: -   * TODO(vojta): prefix this method with $$ ?
>, <Line: -   * @param {function()} callback Function that will be called when no outstanding request
>, <Line: -   */
>, <Line: -  self.notifyWhenNoOutstandingRequests = function(callback) {
>, <Line: -    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
>, <Line: -    // at some deterministic time in respect to the test runner's actions. Leaving things up to the
>, <Line: -    // regular poller would result in flaky tests.
>, <Line: -    forEach(pollFns, function(pollFn) { pollFn(); });
>, <Line: -    if (outstandingRequestCount === 0) {
>, <Line: -      callback();
>, <Line: -    } else {
>, <Line: -      outstandingRequestCallbacks.push(callback);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  // Poll Watcher API
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  var pollFns = [],
>, <Line: -      pollTimeout;
>, <Line: -  /**
>, <Line: -   * @name $browser#addPollFn
>, <Line: -   *
>, <Line: -   * @param {function()} fn Poll function to add
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Adds a function to the list of functions that poller periodically executes,
>, <Line: -   * and starts polling if not started yet.
>, <Line: -   *
>, <Line: -   * @returns {function()} the added function
>, <Line: -   */
>, <Line: -  self.addPollFn = function(fn) {
>, <Line: -    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
>, <Line: -    pollFns.push(fn);
>, <Line: -    return fn;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @param {number} interval How often should browser call poll functions (ms)
>, <Line: -   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Configures the poller to run in the specified intervals, using the specified
>, <Line: -   * setTimeout fn and kicks it off.
>, <Line: -   */
>, <Line: -  function startPoller(interval, setTimeout) {
>, <Line: -    (function check() {
>, <Line: -      forEach(pollFns, function(pollFn) { pollFn(); });
>, <Line: -      pollTimeout = setTimeout(check, interval);
>, <Line: -    })();
>, <Line: -  }
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  // URL API
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  var cachedState, lastHistoryState,
>, <Line: -      lastBrowserUrl = location.href,
>, <Line: -      baseElement = document.find('base'),
>, <Line: -      reloadLocation = null;
>, <Line: -  cacheState();
>, <Line: -  lastHistoryState = cachedState;
>, <Line: -  /**
>, <Line: -   * @name $browser#url
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * GETTER:
>, <Line: -   * Without any argument, this method just returns current value of location.href.
>, <Line: -   *
>, <Line: -   * SETTER:
>, <Line: -   * With at least one argument, this method sets url to new value.
>, <Line: -   * If html5 history api supported, pushState/replaceState is used, otherwise
>, <Line: -   * location.href/location.replace is used.
>, <Line: -   * Returns its own instance to allow chaining
>, <Line: -   *
>, <Line: -   * NOTE: this api is intended for use only by the $location service. Please use the
>, <Line: -   * {@link ng.$location $location service} to change url.
>, <Line: -   *
>, <Line: -   * @param {string} url New url (when used as setter)
>, <Line: -   * @param {boolean=} replace Should new url replace current history record?
>, <Line: -   * @param {object=} state object to use with pushState/replaceState
>, <Line: -   */
>, <Line: -  self.url = function(url, replace, state) {
>, <Line: -    // In modern browsers `history.state` is `null` by default; treating it separately
>, <Line: -    // from `undefined` would cause `$browser.url('/foo')` to change `history.state`
>, <Line: -    // to undefined via `pushState`. Instead, let's change `undefined` to `null` here.
>, <Line: -    if (isUndefined(state)) {
>, <Line: -      state = null;
>, <Line: -    }
>, <Line: -    // Android Browser BFCache causes location, history reference to become stale.
>, <Line: -    if (location !== window.location) location = window.location;
>, <Line: -    if (history !== window.history) history = window.history;
>, <Line: -    // setter
>, <Line: -    if (url) {
>, <Line: -      var sameState = lastHistoryState === state;
>, <Line: -      // Don't change anything if previous and current URLs and states match. This also prevents
>, <Line: -      // IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.
>, <Line: -      // See https://github.com/angular/angular.js/commit/ffb2701
>, <Line: -      if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
>, <Line: -        return self;
>, <Line: -      }
>, <Line: -      var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
>, <Line: -      lastBrowserUrl = url;
>, <Line: -      lastHistoryState = state;
>, <Line: -      // Don't use history API if only the hash changed
>, <Line: -      // due to a bug in IE10/IE11 which leads
>, <Line: -      // to not firing a `hashchange` nor `popstate` event
>, <Line: -      // in some cases (see #9143).
>, <Line: -      if ($sniffer.history && (!sameBase || !sameState)) {
>, <Line: -        history[replace ? 'replaceState' : 'pushState'](state, '', url);
>, <Line: -        cacheState();
>, <Line: -        // Do the assignment again so that those two variables are referentially identical.
>, <Line: -        lastHistoryState = cachedState;
>, <Line: -      } else {
>, <Line: -        if (!sameBase) {
>, <Line: -          reloadLocation = url;
>, <Line: -        }
>, <Line: -        if (replace) {
>, <Line: -          location.replace(url);
>, <Line: -        } else {
>, <Line: -          location.href = url;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return self;
>, <Line: -    // getter
>, <Line: -    } else {
>, <Line: -      // - reloadLocation is needed as browsers don't allow to read out
>, <Line: -      //   the new location.href if a reload happened.
>, <Line: -      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
>, <Line: -      return reloadLocation || location.href.replace(/%27/g,"'");
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @name $browser#state
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is a getter.
>, <Line: -   *
>, <Line: -   * Return history.state or null if history.state is undefined.
>, <Line: -   *
>, <Line: -   * @returns {object} state
>, <Line: -   */
>, <Line: -  self.state = function() {
>, <Line: -    return cachedState;
>, <Line: -  };
>, <Line: -  var urlChangeListeners = [],
>, <Line: -      urlChangeInit = false;
>, <Line: -  function cacheStateAndFireUrlChange() {
>, <Line: -    cacheState();
>, <Line: -    fireUrlChange();
>, <Line: -  }
>, <Line: -  // This variable should be used *only* inside the cacheState function.
>, <Line: -  var lastCachedState = null;
>, <Line: -  function cacheState() {
>, <Line: -    // This should be the only place in $browser where `history.state` is read.
>, <Line: -    cachedState = window.history.state;
>, <Line: -    cachedState = isUndefined(cachedState) ? null : cachedState;
>, <Line: -    // Prevent callbacks fo fire twice if both hashchange & popstate were fired.
>, <Line: -    if (equals(cachedState, lastCachedState)) {
>, <Line: -      cachedState = lastCachedState;
>, <Line: -    }
>, <Line: -    lastCachedState = cachedState;
>, <Line: -  }
>, <Line: -  function fireUrlChange() {
>, <Line: -    if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    lastBrowserUrl = self.url();
>, <Line: -    lastHistoryState = cachedState;
>, <Line: -    forEach(urlChangeListeners, function(listener) {
>, <Line: -      listener(self.url(), cachedState);
>, <Line: -    });
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @name $browser#onUrlChange
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Register callback function that will be called, when url changes.
>, <Line: -   *
>, <Line: -   * It's only called when the url is changed from outside of angular:
>, <Line: -   * - user types different url into address bar
>, <Line: -   * - user clicks on history (forward/back) button
>, <Line: -   * - user clicks on a link
>, <Line: -   *
>, <Line: -   * It's not called when url is changed by $browser.url() method
>, <Line: -   *
>, <Line: -   * The listener gets called with new url as parameter.
>, <Line: -   *
>, <Line: -   * NOTE: this api is intended for use only by the $location service. Please use the
>, <Line: -   * {@link ng.$location $location service} to monitor url changes in angular apps.
>, <Line: -   *
>, <Line: -   * @param {function(string)} listener Listener function to be called when url changes.
>, <Line: -   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
>, <Line: -   */
>, <Line: -  self.onUrlChange = function(callback) {
>, <Line: -    // TODO(vojta): refactor to use node's syntax for events
>, <Line: -    if (!urlChangeInit) {
>, <Line: -      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
>, <Line: -      // don't fire popstate when user change the address bar and don't fire hashchange when url
>, <Line: -      // changed by push/replaceState
>, <Line: -      // html5 history api - popstate event
>, <Line: -      if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange);
>, <Line: -      // hashchange event
>, <Line: -      jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
>, <Line: -      urlChangeInit = true;
>, <Line: -    }
>, <Line: -    urlChangeListeners.push(callback);
>, <Line: -    return callback;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * Checks whether the url has changed outside of Angular.
>, <Line: -   * Needs to be exported to be able to check for changes that have been done in sync,
>, <Line: -   * as hashchange/popstate events fire in async.
>, <Line: -   */
>, <Line: -  self.$$checkUrlChange = fireUrlChange;
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  // Misc API
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  /**
>, <Line: -   * @name $browser#baseHref
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Returns current <base href>
>, <Line: -   * (always relative - without domain)
>, <Line: -   *
>, <Line: -   * @returns {string} The current base href
>, <Line: -   */
>, <Line: -  self.baseHref = function() {
>, <Line: -    var href = baseElement.attr('href');
>, <Line: -    return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
>, <Line: -  };
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  // Cookies API
>, <Line: -  //////////////////////////////////////////////////////////////
>, <Line: -  var lastCookies = {};
>, <Line: -  var lastCookieString = '';
>, <Line: -  var cookiePath = self.baseHref();
>, <Line: -  function safeDecodeURIComponent(str) {
>, <Line: -    try {
>, <Line: -      return decodeURIComponent(str);
>, <Line: -    } catch (e) {
>, <Line: -      return str;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @name $browser#cookies
>, <Line: -   *
>, <Line: -   * @param {string=} name Cookie name
>, <Line: -   * @param {string=} value Cookie value
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * The cookies method provides a 'private' low level access to browser cookies.
>, <Line: -   * It is not meant to be used directly, use the $cookie service instead.
>, <Line: -   *
>, <Line: -   * The return values vary depending on the arguments that the method was called with as follows:
>, <Line: -   *
>, <Line: -   * - cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify
>, <Line: -   *   it
>, <Line: -   * - cookies(name, value) -> set name to value, if value is undefined delete the cookie
>, <Line: -   * - cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that
>, <Line: -   *   way)
>, <Line: -   *
>, <Line: -   * @returns {Object} Hash of all cookies (if called without any parameter)
>, <Line: -   */
>, <Line: -  self.cookies = function(name, value) {
>, <Line: -    var cookieLength, cookieArray, cookie, i, index;
>, <Line: -    if (name) {
>, <Line: -      if (value === undefined) {
>, <Line: -        rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath +
>, <Line: -                                ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
>, <Line: -      } else {
>, <Line: -        if (isString(value)) {
>, <Line: -          cookieLength = (rawDocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) +
>, <Line: -                                ';path=' + cookiePath).length + 1;
>, <Line: -          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
>, <Line: -          // - 300 cookies
>, <Line: -          // - 20 cookies per unique domain
>, <Line: -          // - 4096 bytes per cookie
>, <Line: -          if (cookieLength > 4096) {
>, <Line: -            $log.warn("Cookie '" + name +
>, <Line: -              "' possibly not set or overflowed because it was too large (" +
>, <Line: -              cookieLength + " > 4096 bytes)!");
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    } else {
>, <Line: -      if (rawDocument.cookie !== lastCookieString) {
>, <Line: -        lastCookieString = rawDocument.cookie;
>, <Line: -        cookieArray = lastCookieString.split("; ");
>, <Line: -        lastCookies = {};
>, <Line: -        for (i = 0; i < cookieArray.length; i++) {
>, <Line: -          cookie = cookieArray[i];
>, <Line: -          index = cookie.indexOf('=');
>, <Line: -          if (index > 0) { //ignore nameless cookies
>, <Line: -            name = safeDecodeURIComponent(cookie.substring(0, index));
>, <Line: -            // the first value that is seen for a cookie is the most
>, <Line: -            // specific one.  values for the same cookie name that
>, <Line: -            // follow are for less specific paths.
>, <Line: -            if (lastCookies[name] === undefined) {
>, <Line: -              lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return lastCookies;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @name $browser#defer
>, <Line: -   * @param {function()} fn A function, who's execution should be deferred.
>, <Line: -   * @param {number=} [delay=0] of milliseconds to defer the function execution.
>, <Line: -   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Executes a fn asynchronously via `setTimeout(fn, delay)`.
>, <Line: -   *
>, <Line: -   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
>, <Line: -   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
>, <Line: -   * via `$browser.defer.flush()`.
>, <Line: -   *
>, <Line: -   */
>, <Line: -  self.defer = function(fn, delay) {
>, <Line: -    var timeoutId;
>, <Line: -    outstandingRequestCount++;
>, <Line: -    timeoutId = setTimeout(function() {
>, <Line: -      delete pendingDeferIds[timeoutId];
>, <Line: -      completeOutstandingRequest(fn);
>, <Line: -    }, delay || 0);
>, <Line: -    pendingDeferIds[timeoutId] = true;
>, <Line: -    return timeoutId;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @name $browser#defer.cancel
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Cancels a deferred task identified with `deferId`.
>, <Line: -   *
>, <Line: -   * @param {*} deferId Token returned by the `$browser.defer` function.
>, <Line: -   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
>, <Line: -   *                    canceled.
>, <Line: -   */
>, <Line: -  self.defer.cancel = function(deferId) {
>, <Line: -    if (pendingDeferIds[deferId]) {
>, <Line: -      delete pendingDeferIds[deferId];
>, <Line: -      clearTimeout(deferId);
>, <Line: -      completeOutstandingRequest(noop);
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    return false;
>, <Line: -  };
>, <Line: -}
>, <Line: -function $BrowserProvider() {
>, <Line: -  this.$get = ['$window', '$log', '$sniffer', '$document',
>, <Line: -      function($window, $log, $sniffer, $document) {
>, <Line: -        return new Browser($window, $document, $log, $sniffer);
>, <Line: -      }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $cacheFactory
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to
>, <Line: - * them.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *
>, <Line: - *  var cache = $cacheFactory('cacheId');
>, <Line: - *  expect($cacheFactory.get('cacheId')).toBe(cache);
>, <Line: - *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
>, <Line: - *
>, <Line: - *  cache.put("key", "value");
>, <Line: - *  cache.put("another key", "another value");
>, <Line: - *
>, <Line: - *  // We've specified no options on creation
>, <Line: - *  expect(cache.info()).toEqual({id: 'cacheId', size: 2});
>, <Line: - *
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - * @param {string} cacheId Name or id of the newly created cache.
>, <Line: - * @param {object=} options Options object that specifies the cache behavior. Properties:
>, <Line: - *
>, <Line: - *   - `{number=}` `capacity`  turns the cache into LRU cache.
>, <Line: - *
>, <Line: - * @returns {object} Newly created cache object with the following set of methods:
>, <Line: - *
>, <Line: - * - `{object}` `info()`  Returns id, size, and options of cache.
>, <Line: - * - `{{*}}` `put({string} key, {*} value)`  Puts a new key-value pair into the cache and returns
>, <Line: - *   it.
>, <Line: - * - `{{*}}` `get({string} key)`  Returns cached value for `key` or undefined for cache miss.
>, <Line: - * - `{void}` `remove({string} key)`  Removes a key-value pair from the cache.
>, <Line: - * - `{void}` `removeAll()`  Removes all cached values.
>, <Line: - * - `{void}` `destroy()`  Removes references to this cache from $cacheFactory.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="cacheExampleApp">
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="CacheController">
>, <Line: -         <input ng-model="newCacheKey" placeholder="Key">
>, <Line: -         <input ng-model="newCacheValue" placeholder="Value">
>, <Line: -         <button ng-click="put(newCacheKey, newCacheValue)">Cache</button>
>, <Line: -         <p ng-if="keys.length">Cached Values</p>
>, <Line: -         <div ng-repeat="key in keys">
>, <Line: -           <span ng-bind="key"></span>
>, <Line: -           <span>: </span>
>, <Line: -           <b ng-bind="cache.get(key)"></b>
>, <Line: -         </div>
>, <Line: -         <p>Cache Info</p>
>, <Line: -         <div ng-repeat="(key, value) in cache.info()">
>, <Line: -           <span ng-bind="key"></span>
>, <Line: -           <span>: </span>
>, <Line: -           <b ng-bind="value"></b>
>, <Line: -         </div>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="script.js">
>, <Line: -       angular.module('cacheExampleApp', []).
>, <Line: -         controller('CacheController', ['$scope', '$cacheFactory', function($scope, $cacheFactory) {
>, <Line: -           $scope.keys = [];
>, <Line: -           $scope.cache = $cacheFactory('cacheId');
>, <Line: -           $scope.put = function(key, value) {
>, <Line: -             if ($scope.cache.get(key) === undefined) {
>, <Line: -               $scope.keys.push(key);
>, <Line: -             }
>, <Line: -             $scope.cache.put(key, value === undefined ? null : value);
>, <Line: -           };
>, <Line: -         }]);
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       p {
>, <Line: -         margin: 10px 0 3px;
>, <Line: -       }
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -function $CacheFactoryProvider() {
>, <Line: -  this.$get = function() {
>, <Line: -    var caches = {};
>, <Line: -    function cacheFactory(cacheId, options) {
>, <Line: -      if (cacheId in caches) {
>, <Line: -        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
>, <Line: -      }
>, <Line: -      var size = 0,
>, <Line: -          stats = extend({}, options, {id: cacheId}),
>, <Line: -          data = {},
>, <Line: -          capacity = (options && options.capacity) || Number.MAX_VALUE,
>, <Line: -          lruHash = {},
>, <Line: -          freshEnd = null,
>, <Line: -          staleEnd = null;
>, <Line: -      /**
>, <Line: -       * @ngdoc type
>, <Line: -       * @name $cacheFactory.Cache
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * A cache object used to store and retrieve data, primarily used by
>, <Line: -       * {@link $http $http} and the {@link ng.directive:script script} directive to cache
>, <Line: -       * templates and other data.
>, <Line: -       *
>, <Line: -       * ```js
>, <Line: -       *  angular.module('superCache')
>, <Line: -       *    .factory('superCache', ['$cacheFactory', function($cacheFactory) {
>, <Line: -       *      return $cacheFactory('super-cache');
>, <Line: -       *    }]);
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       * Example test:
>, <Line: -       *
>, <Line: -       * ```js
>, <Line: -       *  it('should behave like a cache', inject(function(superCache) {
>, <Line: -       *    superCache.put('key', 'value');
>, <Line: -       *    superCache.put('another key', 'another value');
>, <Line: -       *
>, <Line: -       *    expect(superCache.info()).toEqual({
>, <Line: -       *      id: 'super-cache',
>, <Line: -       *      size: 2
>, <Line: -       *    });
>, <Line: -       *
>, <Line: -       *    superCache.remove('another key');
>, <Line: -       *    expect(superCache.get('another key')).toBeUndefined();
>, <Line: -       *
>, <Line: -       *    superCache.removeAll();
>, <Line: -       *    expect(superCache.info()).toEqual({
>, <Line: -       *      id: 'super-cache',
>, <Line: -       *      size: 0
>, <Line: -       *    });
>, <Line: -       *  }));
>, <Line: -       * ```
>, <Line: -       */
>, <Line: -      return caches[cacheId] = {
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#put
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Inserts a named entry into the {@link $cacheFactory.Cache Cache} object to be
>, <Line: -         * retrieved later, and incrementing the size of the cache if the key was not already
>, <Line: -         * present in the cache. If behaving like an LRU cache, it will also remove stale
>, <Line: -         * entries from the set.
>, <Line: -         *
>, <Line: -         * It will not insert undefined values into the cache.
>, <Line: -         *
>, <Line: -         * @param {string} key the key under which the cached data is stored.
>, <Line: -         * @param {*} value the value to store alongside the key. If it is undefined, the key
>, <Line: -         *    will not be stored.
>, <Line: -         * @returns {*} the value stored.
>, <Line: -         */
>, <Line: -        put: function(key, value) {
>, <Line: -          if (capacity < Number.MAX_VALUE) {
>, <Line: -            var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
>, <Line: -            refresh(lruEntry);
>, <Line: -          }
>, <Line: -          if (isUndefined(value)) return;
>, <Line: -          if (!(key in data)) size++;
>, <Line: -          data[key] = value;
>, <Line: -          if (size > capacity) {
>, <Line: -            this.remove(staleEnd.key);
>, <Line: -          }
>, <Line: -          return value;
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#get
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object.
>, <Line: -         *
>, <Line: -         * @param {string} key the key of the data to be retrieved
>, <Line: -         * @returns {*} the value stored.
>, <Line: -         */
>, <Line: -        get: function(key) {
>, <Line: -          if (capacity < Number.MAX_VALUE) {
>, <Line: -            var lruEntry = lruHash[key];
>, <Line: -            if (!lruEntry) return;
>, <Line: -            refresh(lruEntry);
>, <Line: -          }
>, <Line: -          return data[key];
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#remove
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Removes an entry from the {@link $cacheFactory.Cache Cache} object.
>, <Line: -         *
>, <Line: -         * @param {string} key the key of the entry to be removed
>, <Line: -         */
>, <Line: -        remove: function(key) {
>, <Line: -          if (capacity < Number.MAX_VALUE) {
>, <Line: -            var lruEntry = lruHash[key];
>, <Line: -            if (!lruEntry) return;
>, <Line: -            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
>, <Line: -            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
>, <Line: -            link(lruEntry.n,lruEntry.p);
>, <Line: -            delete lruHash[key];
>, <Line: -          }
>, <Line: -          delete data[key];
>, <Line: -          size--;
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#removeAll
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Clears the cache object of any entries.
>, <Line: -         */
>, <Line: -        removeAll: function() {
>, <Line: -          data = {};
>, <Line: -          size = 0;
>, <Line: -          lruHash = {};
>, <Line: -          freshEnd = staleEnd = null;
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#destroy
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Destroys the {@link $cacheFactory.Cache Cache} object entirely,
>, <Line: -         * removing it from the {@link $cacheFactory $cacheFactory} set.
>, <Line: -         */
>, <Line: -        destroy: function() {
>, <Line: -          data = null;
>, <Line: -          stats = null;
>, <Line: -          lruHash = null;
>, <Line: -          delete caches[cacheId];
>, <Line: -        },
>, <Line: -        /**
>, <Line: -         * @ngdoc method
>, <Line: -         * @name $cacheFactory.Cache#info
>, <Line: -         * @kind function
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Retrieve information regarding a particular {@link $cacheFactory.Cache Cache}.
>, <Line: -         *
>, <Line: -         * @returns {object} an object with the following properties:
>, <Line: -         *   <ul>
>, <Line: -         *     <li>**id**: the id of the cache instance</li>
>, <Line: -         *     <li>**size**: the number of entries kept in the cache instance</li>
>, <Line: -         *     <li>**...**: any additional properties from the options object when creating the
>, <Line: -         *       cache.</li>
>, <Line: -         *   </ul>
>, <Line: -         */
>, <Line: -        info: function() {
>, <Line: -          return extend({}, stats, {size: size});
>, <Line: -        }
>, <Line: -      };
>, <Line: -      /**
>, <Line: -       * makes the `entry` the freshEnd of the LRU linked list
>, <Line: -       */
>, <Line: -      function refresh(entry) {
>, <Line: -        if (entry != freshEnd) {
>, <Line: -          if (!staleEnd) {
>, <Line: -            staleEnd = entry;
>, <Line: -          } else if (staleEnd == entry) {
>, <Line: -            staleEnd = entry.n;
>, <Line: -          }
>, <Line: -          link(entry.n, entry.p);
>, <Line: -          link(entry, freshEnd);
>, <Line: -          freshEnd = entry;
>, <Line: -          freshEnd.n = null;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      /**
>, <Line: -       * bidirectionally links two entries of the LRU linked list
>, <Line: -       */
>, <Line: -      function link(nextEntry, prevEntry) {
>, <Line: -        if (nextEntry != prevEntry) {
>, <Line: -          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
>, <Line: -          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $cacheFactory#info
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Get information about all the caches that have been created
>, <Line: -   *
>, <Line: -   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
>, <Line: -   */
>, <Line: -    cacheFactory.info = function() {
>, <Line: -      var info = {};
>, <Line: -      forEach(caches, function(cache, cacheId) {
>, <Line: -        info[cacheId] = cache.info();
>, <Line: -      });
>, <Line: -      return info;
>, <Line: -    };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $cacheFactory#get
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Get access to a cache object by the `cacheId` used when it was created.
>, <Line: -   *
>, <Line: -   * @param {string} cacheId Name or id of a cache to access.
>, <Line: -   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
>, <Line: -   */
>, <Line: -    cacheFactory.get = function(cacheId) {
>, <Line: -      return caches[cacheId];
>, <Line: -    };
>, <Line: -    return cacheFactory;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $templateCache
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The first time a template is used, it is loaded in the template cache for quick retrieval. You
>, <Line: - * can load templates directly into the cache in a `script` tag, or by consuming the
>, <Line: - * `$templateCache` service directly.
>, <Line: - *
>, <Line: - * Adding via the `script` tag:
>, <Line: - *
>, <Line: - * ```html
>, <Line: - *   <script type="text/ng-template" id="templateId.html">
>, <Line: - *     <p>This is the content of the template</p>
>, <Line: - *   </script>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * **Note:** the `script` tag containing the template does not need to be included in the `head` of
>, <Line: - * the document, but it must be a descendent of the {@link ng.$rootElement $rootElement} (IE,
>, <Line: - * element with ng-app attribute), otherwise the template will be ignored.
>, <Line: - *
>, <Line: - * Adding via the $templateCache service:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * var myApp = angular.module('myApp', []);
>, <Line: - * myApp.run(function($templateCache) {
>, <Line: - *   $templateCache.put('templateId.html', 'This is the content of the template');
>, <Line: - * });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * To retrieve the template later, simply use it in your HTML:
>, <Line: - * ```html
>, <Line: - * <div ng-include=" 'templateId.html' "></div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * or get it via Javascript:
>, <Line: - * ```js
>, <Line: - * $templateCache.get('templateId.html')
>, <Line: - * ```
>, <Line: - *
>, <Line: - * See {@link ng.$cacheFactory $cacheFactory}.
>, <Line: - *
>, <Line: - */
>, <Line: -function $TemplateCacheProvider() {
>, <Line: -  this.$get = ['$cacheFactory', function($cacheFactory) {
>, <Line: -    return $cacheFactory('templates');
>, <Line: -  }];
>, <Line: -}
>, <Line: -/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
>, <Line: - *
>, <Line: - * DOM-related variables:
>, <Line: - *
>, <Line: - * - "node" - DOM Node
>, <Line: - * - "element" - DOM Element or Node
>, <Line: - * - "$node" or "$element" - jqLite-wrapped node or element
>, <Line: - *
>, <Line: - *
>, <Line: - * Compiler related stuff:
>, <Line: - *
>, <Line: - * - "linkFn" - linking fn of a single directive
>, <Line: - * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
>, <Line: - * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
>, <Line: - * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $compile
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Compiles an HTML string or DOM into a template and produces a template function, which
>, <Line: - * can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.
>, <Line: - *
>, <Line: - * The compilation is a process of walking the DOM tree and matching DOM elements to
>, <Line: - * {@link ng.$compileProvider#directive directives}.
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** This document is an in-depth reference of all directive options.
>, <Line: - * For a gentle introduction to directives with examples of common use cases,
>, <Line: - * see the {@link guide/directive directive guide}.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * ## Comprehensive Directive API
>, <Line: - *
>, <Line: - * There are many different options for a directive.
>, <Line: - *
>, <Line: - * The difference resides in the return value of the factory function.
>, <Line: - * You can either return a "Directive Definition Object" (see below) that defines the directive properties,
>, <Line: - * or just the `postLink` function (all other properties will have the default values).
>, <Line: - *
>, <Line: - * <div class="alert alert-success">
>, <Line: - * **Best Practice:** It's recommended to use the "directive definition object" form.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * Here's an example directive declared with a Directive Definition Object:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   var myModule = angular.module(...);
>, <Line: - *
>, <Line: - *   myModule.directive('directiveName', function factory(injectables) {
>, <Line: - *     var directiveDefinitionObject = {
>, <Line: - *       priority: 0,
>, <Line: - *       template: '<div></div>', // or // function(tElement, tAttrs) { ... },
>, <Line: - *       // or
>, <Line: - *       // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
>, <Line: - *       transclude: false,
>, <Line: - *       restrict: 'A',
>, <Line: - *       templateNamespace: 'html',
>, <Line: - *       scope: false,
>, <Line: - *       controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
>, <Line: - *       controllerAs: 'stringAlias',
>, <Line: - *       require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
>, <Line: - *       compile: function compile(tElement, tAttrs, transclude) {
>, <Line: - *         return {
>, <Line: - *           pre: function preLink(scope, iElement, iAttrs, controller) { ... },
>, <Line: - *           post: function postLink(scope, iElement, iAttrs, controller) { ... }
>, <Line: - *         }
>, <Line: - *         // or
>, <Line: - *         // return function postLink( ... ) { ... }
>, <Line: - *       },
>, <Line: - *       // or
>, <Line: - *       // link: {
>, <Line: - *       //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
>, <Line: - *       //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
>, <Line: - *       // }
>, <Line: - *       // or
>, <Line: - *       // link: function postLink( ... ) { ... }
>, <Line: - *     };
>, <Line: - *     return directiveDefinitionObject;
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** Any unspecified options will use the default value. You can see the default values below.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * Therefore the above can be simplified as:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   var myModule = angular.module(...);
>, <Line: - *
>, <Line: - *   myModule.directive('directiveName', function factory(injectables) {
>, <Line: - *     var directiveDefinitionObject = {
>, <Line: - *       link: function postLink(scope, iElement, iAttrs) { ... }
>, <Line: - *     };
>, <Line: - *     return directiveDefinitionObject;
>, <Line: - *     // or
>, <Line: - *     // return function postLink(scope, iElement, iAttrs) { ... }
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - *
>, <Line: - * ### Directive Definition Object
>, <Line: - *
>, <Line: - * The directive definition object provides instructions to the {@link ng.$compile
>, <Line: - * compiler}. The attributes are:
>, <Line: - *
>, <Line: - * #### `multiElement`
>, <Line: - * When this property is set to true, the HTML compiler will collect DOM nodes between
>, <Line: - * nodes with the attributes `directive-name-start` and `directive-name-end`, and group them
>, <Line: - * together as the directive elements. It is recomended that this feature be used on directives
>, <Line: - * which are not strictly behavioural (such as {@link ngClick}), and which
>, <Line: - * do not manipulate or replace child nodes (such as {@link ngInclude}).
>, <Line: - *
>, <Line: - * #### `priority`
>, <Line: - * When there are multiple directives defined on a single DOM element, sometimes it
>, <Line: - * is necessary to specify the order in which the directives are applied. The `priority` is used
>, <Line: - * to sort the directives before their `compile` functions get called. Priority is defined as a
>, <Line: - * number. Directives with greater numerical `priority` are compiled first. Pre-link functions
>, <Line: - * are also run in priority order, but post-link functions are run in reverse order. The order
>, <Line: - * of directives with the same priority is undefined. The default priority is `0`.
>, <Line: - *
>, <Line: - * #### `terminal`
>, <Line: - * If set to true then the current `priority` will be the last set of directives
>, <Line: - * which will execute (any directives at the current priority will still execute
>, <Line: - * as the order of execution on same `priority` is undefined). Note that expressions
>, <Line: - * and other directives used in the directive's template will also be excluded from execution.
>, <Line: - *
>, <Line: - * #### `scope`
>, <Line: - * **If set to `true`,** then a new scope will be created for this directive. If multiple directives on the
>, <Line: - * same element request a new scope, only one new scope is created. The new scope rule does not
>, <Line: - * apply for the root of the template since the root of the template always gets a new scope.
>, <Line: - *
>, <Line: - * **If set to `{}` (object hash),** then a new "isolate" scope is created. The 'isolate' scope differs from
>, <Line: - * normal scope in that it does not prototypically inherit from the parent scope. This is useful
>, <Line: - * when creating reusable components, which should not accidentally read or modify data in the
>, <Line: - * parent scope.
>, <Line: - *
>, <Line: - * The 'isolate' scope takes an object hash which defines a set of local scope properties
>, <Line: - * derived from the parent scope. These local properties are useful for aliasing values for
>, <Line: - * templates. Locals definition is a hash of local scope property to its source:
>, <Line: - *
>, <Line: - * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
>, <Line: - *   always a string since DOM attributes are strings. If no `attr` name is specified  then the
>, <Line: - *   attribute name is assumed to be the same as the local name.
>, <Line: - *   Given `<widget my-attr="hello {{name}}">` and widget definition
>, <Line: - *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
>, <Line: - *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
>, <Line: - *   `localName` property on the widget scope. The `name` is read from the parent scope (not
>, <Line: - *   component scope).
>, <Line: - *
>, <Line: - * * `=` or `=attr` - set up bi-directional binding between a local scope property and the
>, <Line: - *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`
>, <Line: - *   name is specified then the attribute name is assumed to be the same as the local name.
>, <Line: - *   Given `<widget my-attr="parentModel">` and widget definition of
>, <Line: - *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
>, <Line: - *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
>, <Line: - *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
>, <Line: - *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
>, <Line: - *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional. If
>, <Line: - *   you want to shallow watch for changes (i.e. $watchCollection instead of $watch) you can use
>, <Line: - *   `=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).
>, <Line: - *
>, <Line: - * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
>, <Line: - *   If no `attr` name is specified then the attribute name is assumed to be the same as the
>, <Line: - *   local name. Given `<widget my-attr="count = count + value">` and widget definition of
>, <Line: - *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
>, <Line: - *   a function wrapper for the `count = count + value` expression. Often it's desirable to
>, <Line: - *   pass data from the isolated scope via an expression to the parent scope, this can be
>, <Line: - *   done by passing a map of local variable names and values into the expression wrapper fn.
>, <Line: - *   For example, if the expression is `increment(amount)` then we can specify the amount value
>, <Line: - *   by calling the `localFn` as `localFn({amount: 22})`.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `bindToController`
>, <Line: - * When an isolate scope is used for a component (see above), and `controllerAs` is used, `bindToController: true` will
>, <Line: - * allow a component to have its properties bound to the controller, rather than to scope. When the controller
>, <Line: - * is instantiated, the initial values of the isolate scope bindings are already available.
>, <Line: - *
>, <Line: - * #### `controller`
>, <Line: - * Controller constructor function. The controller is instantiated before the
>, <Line: - * pre-linking phase and it is shared with other directives (see
>, <Line: - * `require` attribute). This allows the directives to communicate with each other and augment
>, <Line: - * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:
>, <Line: - *
>, <Line: - * * `$scope` - Current scope associated with the element
>, <Line: - * * `$element` - Current element
>, <Line: - * * `$attrs` - Current attributes object for the element
>, <Line: - * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:
>, <Line: - *   `function([scope], cloneLinkingFn, futureParentElement)`.
>, <Line: - *    * `scope`: optional argument to override the scope.
>, <Line: - *    * `cloneLinkingFn`: optional argument to create clones of the original transcluded content.
>, <Line: - *    * `futureParentElement`:
>, <Line: - *        * defines the parent to which the `cloneLinkingFn` will add the cloned elements.
>, <Line: - *        * default: `$element.parent()` resp. `$element` for `transclude:'element'` resp. `transclude:true`.
>, <Line: - *        * only needed for transcludes that are allowed to contain non html elements (e.g. SVG elements)
>, <Line: - *          and when the `cloneLinkinFn` is passed,
>, <Line: - *          as those elements need to created and cloned in a special way when they are defined outside their
>, <Line: - *          usual containers (e.g. like `<svg>`).
>, <Line: - *        * See also the `directive.templateNamespace` property.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `require`
>, <Line: - * Require another directive and inject its controller as the fourth argument to the linking function. The
>, <Line: - * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
>, <Line: - * injected argument will be an array in corresponding order. If no such directive can be
>, <Line: - * found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:
>, <Line: - *
>, <Line: - * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
>, <Line: - * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
>, <Line: - * * `^` - Locate the required controller by searching the element and its parents. Throw an error if not found.
>, <Line: - * * `^^` - Locate the required controller by searching the element's parents. Throw an error if not found.
>, <Line: - * * `?^` - Attempt to locate the required controller by searching the element and its parents or pass
>, <Line: - *   `null` to the `link` fn if not found.
>, <Line: - * * `?^^` - Attempt to locate the required controller by searching the element's parents, or pass
>, <Line: - *   `null` to the `link` fn if not found.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `controllerAs`
>, <Line: - * Controller alias at the directive scope. An alias for the controller so it
>, <Line: - * can be referenced at the directive template. The directive needs to define a scope for this
>, <Line: - * configuration to be used. Useful in the case when directive is used as component.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `restrict`
>, <Line: - * String of subset of `EACM` which restricts the directive to a specific directive
>, <Line: - * declaration style. If omitted, the defaults (elements and attributes) are used.
>, <Line: - *
>, <Line: - * * `E` - Element name (default): `<my-directive></my-directive>`
>, <Line: - * * `A` - Attribute (default): `<div my-directive="exp"></div>`
>, <Line: - * * `C` - Class: `<div class="my-directive: exp;"></div>`
>, <Line: - * * `M` - Comment: `<!-- directive: my-directive exp -->`
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `templateNamespace`
>, <Line: - * String representing the document type used by the markup in the template.
>, <Line: - * AngularJS needs this information as those elements need to be created and cloned
>, <Line: - * in a special way when they are defined outside their usual containers like `<svg>` and `<math>`.
>, <Line: - *
>, <Line: - * * `html` - All root nodes in the template are HTML. Root nodes may also be
>, <Line: - *   top-level elements such as `<svg>` or `<math>`.
>, <Line: - * * `svg` - The root nodes in the template are SVG elements (excluding `<math>`).
>, <Line: - * * `math` - The root nodes in the template are MathML elements (excluding `<svg>`).
>, <Line: - *
>, <Line: - * If no `templateNamespace` is specified, then the namespace is considered to be `html`.
>, <Line: - *
>, <Line: - * #### `template`
>, <Line: - * HTML markup that may:
>, <Line: - * * Replace the contents of the directive's element (default).
>, <Line: - * * Replace the directive's element itself (if `replace` is true - DEPRECATED).
>, <Line: - * * Wrap the contents of the directive's element (if `transclude` is true).
>, <Line: - *
>, <Line: - * Value may be:
>, <Line: - *
>, <Line: - * * A string. For example `<div red-on-hover>{{delete_str}}</div>`.
>, <Line: - * * A function which takes two arguments `tElement` and `tAttrs` (described in the `compile`
>, <Line: - *   function api below) and returns a string value.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `templateUrl`
>, <Line: - * This is similar to `template` but the template is loaded from the specified URL, asynchronously.
>, <Line: - *
>, <Line: - * Because template loading is asynchronous the compiler will suspend compilation of directives on that element
>, <Line: - * for later when the template has been resolved.  In the meantime it will continue to compile and link
>, <Line: - * sibling and parent elements as though this element had not contained any directives.
>, <Line: - *
>, <Line: - * The compiler does not suspend the entire compilation to wait for templates to be loaded because this
>, <Line: - * would result in the whole app "stalling" until all templates are loaded asynchronously - even in the
>, <Line: - * case when only one deeply nested directive has `templateUrl`.
>, <Line: - *
>, <Line: - * Template loading is asynchronous even if the template has been preloaded into the {@link $templateCache}
>, <Line: - *
>, <Line: - * You can specify `templateUrl` as a string representing the URL or as a function which takes two
>, <Line: - * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
>, <Line: - * a string value representing the url.  In either case, the template URL is passed through {@link
>, <Line: - * $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `replace` ([*DEPRECATED*!], will be removed in next major release - i.e. v2.0)
>, <Line: - * specify what the template should replace. Defaults to `false`.
>, <Line: - *
>, <Line: - * * `true` - the template will replace the directive's element.
>, <Line: - * * `false` - the template will replace the contents of the directive's element.
>, <Line: - *
>, <Line: - * The replacement process migrates all of the attributes / classes from the old element to the new
>, <Line: - * one. See the {@link guide/directive#template-expanding-directive
>, <Line: - * Directives Guide} for an example.
>, <Line: - *
>, <Line: - * There are very few scenarios where element replacement is required for the application function,
>, <Line: - * the main one being reusable custom components that are used within SVG contexts
>, <Line: - * (because SVG doesn't work with custom elements in the DOM tree).
>, <Line: - *
>, <Line: - * #### `transclude`
>, <Line: - * Extract the contents of the element where the directive appears and make it available to the directive.
>, <Line: - * The contents are compiled and provided to the directive as a **transclusion function**. See the
>, <Line: - * {@link $compile#transclusion Transclusion} section below.
>, <Line: - *
>, <Line: - * There are two kinds of transclusion depending upon whether you want to transclude just the contents of the
>, <Line: - * directive's element or the entire element:
>, <Line: - *
>, <Line: - * * `true` - transclude the content (i.e. the child nodes) of the directive's element.
>, <Line: - * * `'element'` - transclude the whole of the directive's element including any directives on this
>, <Line: - *   element that defined at a lower priority than this directive. When used, the `template`
>, <Line: - *   property is ignored.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `compile`
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   function compile(tElement, tAttrs, transclude) { ... }
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The compile function deals with transforming the template DOM. Since most directives do not do
>, <Line: - * template transformation, it is not used often. The compile function takes the following arguments:
>, <Line: - *
>, <Line: - *   * `tElement` - template element - The element where the directive has been declared. It is
>, <Line: - *     safe to do template transformation on the element and child elements only.
>, <Line: - *
>, <Line: - *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
>, <Line: - *     between all directive compile functions.
>, <Line: - *
>, <Line: - *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** The template instance and the link instance may be different objects if the template has
>, <Line: - * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
>, <Line: - * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
>, <Line: - * should be done in a linking function rather than in a compile function.
>, <Line: - * </div>
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** The compile function cannot handle directives that recursively use themselves in their
>, <Line: - * own templates or compile functions. Compiling these directives results in an infinite loop and a
>, <Line: - * stack overflow errors.
>, <Line: - *
>, <Line: - * This can be avoided by manually using $compile in the postLink function to imperatively compile
>, <Line: - * a directive's template instead of relying on automatic template compilation via `template` or
>, <Line: - * `templateUrl` declaration or manual compilation inside the compile function.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * <div class="alert alert-error">
>, <Line: - * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
>, <Line: - *   e.g. does not know about the right outer scope. Please use the transclude function that is passed
>, <Line: - *   to the link function instead.
>, <Line: - * </div>
>, <Line: - * A compile function can have a return value which can be either a function or an object.
>, <Line: - *
>, <Line: - * * returning a (post-link) function - is equivalent to registering the linking function via the
>, <Line: - *   `link` property of the config object when the compile function is empty.
>, <Line: - *
>, <Line: - * * returning an object with function(s) registered via `pre` and `post` properties - allows you to
>, <Line: - *   control when a linking function should be called during the linking phase. See info about
>, <Line: - *   pre-linking and post-linking functions below.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### `link`
>, <Line: - * This property is used only if the `compile` property is not defined.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The link function is responsible for registering DOM listeners as well as updating the DOM. It is
>, <Line: - * executed after the template has been cloned. This is where most of the directive logic will be
>, <Line: - * put.
>, <Line: - *
>, <Line: - *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be used by the
>, <Line: - *     directive for registering {@link ng.$rootScope.Scope#$watch watches}.
>, <Line: - *
>, <Line: - *   * `iElement` - instance element - The element where the directive is to be used. It is safe to
>, <Line: - *     manipulate the children of the element only in `postLink` function since the children have
>, <Line: - *     already been linked.
>, <Line: - *
>, <Line: - *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
>, <Line: - *     between all directive linking functions.
>, <Line: - *
>, <Line: - *   * `controller` - a controller instance - A controller instance if at least one directive on the
>, <Line: - *     element defines a controller. The controller is shared among all the directives, which allows
>, <Line: - *     the directives to use the controllers as a communication channel.
>, <Line: - *
>, <Line: - *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
>, <Line: - *     This is the same as the `$transclude`
>, <Line: - *     parameter of directive controllers, see there for details.
>, <Line: - *     `function([scope], cloneLinkingFn, futureParentElement)`.
>, <Line: - *
>, <Line: - * #### Pre-linking function
>, <Line: - *
>, <Line: - * Executed before the child elements are linked. Not safe to do DOM transformation since the
>, <Line: - * compiler linking function will fail to locate the correct elements for linking.
>, <Line: - *
>, <Line: - * #### Post-linking function
>, <Line: - *
>, <Line: - * Executed after the child elements are linked.
>, <Line: - *
>, <Line: - * Note that child elements that contain `templateUrl` directives will not have been compiled
>, <Line: - * and linked since they are waiting for their template to load asynchronously and their own
>, <Line: - * compilation and linking has been suspended until that occurs.
>, <Line: - *
>, <Line: - * It is safe to do DOM transformation in the post-linking function on elements that are not waiting
>, <Line: - * for their async templates to be resolved.
>, <Line: - *
>, <Line: - *
>, <Line: - * ### Transclusion
>, <Line: - *
>, <Line: - * Transclusion is the process of extracting a collection of DOM element from one part of the DOM and
>, <Line: - * copying them to another part of the DOM, while maintaining their connection to the original AngularJS
>, <Line: - * scope from where they were taken.
>, <Line: - *
>, <Line: - * Transclusion is used (often with {@link ngTransclude}) to insert the
>, <Line: - * original contents of a directive's element into a specified place in the template of the directive.
>, <Line: - * The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded
>, <Line: - * content has access to the properties on the scope from which it was taken, even if the directive
>, <Line: - * has isolated scope.
>, <Line: - * See the {@link guide/directive#creating-a-directive-that-wraps-other-elements Directives Guide}.
>, <Line: - *
>, <Line: - * This makes it possible for the widget to have private state for its template, while the transcluded
>, <Line: - * content has access to its originating scope.
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** When testing an element transclude directive you must not place the directive at the root of the
>, <Line: - * DOM fragment that is being compiled. See {@link guide/unit-testing#testing-transclusion-directives
>, <Line: - * Testing Transclusion Directives}.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * #### Transclusion Functions
>, <Line: - *
>, <Line: - * When a directive requests transclusion, the compiler extracts its contents and provides a **transclusion
>, <Line: - * function** to the directive's `link` function and `controller`. This transclusion function is a special
>, <Line: - * **linking function** that will return the compiled contents linked to a new transclusion scope.
>, <Line: - *
>, <Line: - * <div class="alert alert-info">
>, <Line: - * If you are just using {@link ngTransclude} then you don't need to worry about this function, since
>, <Line: - * ngTransclude will deal with it for us.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * If you want to manually control the insertion and removal of the transcluded content in your directive
>, <Line: - * then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery
>, <Line: - * object that contains the compiled DOM, which is linked to the correct transclusion scope.
>, <Line: - *
>, <Line: - * When you call a transclusion function you can pass in a **clone attach function**. This function accepts
>, <Line: - * two parameters, `function(clone, scope) { ... }`, where the `clone` is a fresh compiled copy of your transcluded
>, <Line: - * content and the `scope` is the newly created transclusion scope, to which the clone is bound.
>, <Line: - *
>, <Line: - * <div class="alert alert-info">
>, <Line: - * **Best Practice**: Always provide a `cloneFn` (clone attach function) when you call a translude function
>, <Line: - * since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * It is normal practice to attach your transcluded content (`clone`) to the DOM inside your **clone
>, <Line: - * attach function**:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * var transcludedContent, transclusionScope;
>, <Line: - *
>, <Line: - * $transclude(function(clone, scope) {
>, <Line: - *   element.append(clone);
>, <Line: - *   transcludedContent = clone;
>, <Line: - *   transclusionScope = scope;
>, <Line: - * });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Later, if you want to remove the transcluded content from your DOM then you should also destroy the
>, <Line: - * associated transclusion scope:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * transcludedContent.remove();
>, <Line: - * transclusionScope.$destroy();
>, <Line: - * ```
>, <Line: - *
>, <Line: - * <div class="alert alert-info">
>, <Line: - * **Best Practice**: if you intend to add and remove transcluded content manually in your directive
>, <Line: - * (by calling the transclude function to get the DOM and and calling `element.remove()` to remove it),
>, <Line: - * then you are also responsible for calling `$destroy` on the transclusion scope.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * The built-in DOM manipulation directives, such as {@link ngIf}, {@link ngSwitch} and {@link ngRepeat}
>, <Line: - * automatically destroy their transluded clones as necessary so you do not need to worry about this if
>, <Line: - * you are simply using {@link ngTransclude} to inject the transclusion into your directive.
>, <Line: - *
>, <Line: - *
>, <Line: - * #### Transclusion Scopes
>, <Line: - *
>, <Line: - * When you call a transclude function it returns a DOM fragment that is pre-bound to a **transclusion
>, <Line: - * scope**. This scope is special, in that it is a child of the directive's scope (and so gets destroyed
>, <Line: - * when the directive's scope gets destroyed) but it inherits the properties of the scope from which it
>, <Line: - * was taken.
>, <Line: - *
>, <Line: - * For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look
>, <Line: - * like this:
>, <Line: - *
>, <Line: - * ```html
>, <Line: - * <div ng-app>
>, <Line: - *   <div isolate>
>, <Line: - *     <div transclusion>
>, <Line: - *     </div>
>, <Line: - *   </div>
>, <Line: - * </div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The `$parent` scope hierarchy will look like this:
>, <Line: - *
>, <Line: - * ```
>, <Line: - * - $rootScope
>, <Line: - *   - isolate
>, <Line: - *     - transclusion
>, <Line: - * ```
>, <Line: - *
>, <Line: - * but the scopes will inherit prototypically from different scopes to their `$parent`.
>, <Line: - *
>, <Line: - * ```
>, <Line: - * - $rootScope
>, <Line: - *   - transclusion
>, <Line: - * - isolate
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - * ### Attributes
>, <Line: - *
>, <Line: - * The {@link ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the
>, <Line: - * `link()` or `compile()` functions. It has a variety of uses.
>, <Line: - *
>, <Line: - * accessing *Normalized attribute names:*
>, <Line: - * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
>, <Line: - * the attributes object allows for normalized access to
>, <Line: - *   the attributes.
>, <Line: - *
>, <Line: - * * *Directive inter-communication:* All directives share the same instance of the attributes
>, <Line: - *   object which allows the directives to use the attributes object as inter directive
>, <Line: - *   communication.
>, <Line: - *
>, <Line: - * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object
>, <Line: - *   allowing other directives to read the interpolated value.
>, <Line: - *
>, <Line: - * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
>, <Line: - *   that contain interpolation (e.g. `src="{{bar}}"`). Not only is this very efficient but it's also
>, <Line: - *   the only way to easily get the actual value because during the linking phase the interpolation
>, <Line: - *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * function linkingFn(scope, elm, attrs, ctrl) {
>, <Line: - *   // get the attribute value
>, <Line: - *   console.log(attrs.ngModel);
>, <Line: - *
>, <Line: - *   // change the attribute
>, <Line: - *   attrs.$set('ngModel', 'new value');
>, <Line: - *
>, <Line: - *   // observe changes to interpolated attribute
>, <Line: - *   attrs.$observe('ngModel', function(value) {
>, <Line: - *     console.log('ngModel has changed value to ' + value);
>, <Line: - *   });
>, <Line: - * }
>, <Line: - * ```
>, <Line: - *
>, <Line: - * ## Example
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note**: Typically directives are registered with `module.directive`. The example below is
>, <Line: - * to illustrate how `$compile` works.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - <example module="compileExample">
>, <Line: -   <file name="index.html">
>, <Line: -    <script>
>, <Line: -      angular.module('compileExample', [], function($compileProvider) {
>, <Line: -        // configure new 'compile' directive by passing a directive
>, <Line: -        // factory function. The factory function injects the '$compile'
>, <Line: -        $compileProvider.directive('compile', function($compile) {
>, <Line: -          // directive factory creates a link function
>, <Line: -          return function(scope, element, attrs) {
>, <Line: -            scope.$watch(
>, <Line: -              function(scope) {
>, <Line: -                 // watch the 'compile' expression for changes
>, <Line: -                return scope.$eval(attrs.compile);
>, <Line: -              },
>, <Line: -              function(value) {
>, <Line: -                // when the 'compile' expression changes
>, <Line: -                // assign it into the current DOM
>, <Line: -                element.html(value);
>, <Line: -                // compile the new DOM and link it to the current
>, <Line: -                // scope.
>, <Line: -                // NOTE: we only compile .childNodes so that
>, <Line: -                // we don't get into infinite loop compiling ourselves
>, <Line: -                $compile(element.contents())(scope);
>, <Line: -              }
>, <Line: -            );
>, <Line: -          };
>, <Line: -        });
>, <Line: -      })
>, <Line: -      .controller('GreeterController', ['$scope', function($scope) {
>, <Line: -        $scope.name = 'Angular';
>, <Line: -        $scope.html = 'Hello {{name}}';
>, <Line: -      }]);
>, <Line: -    </script>
>, <Line: -    <div ng-controller="GreeterController">
>, <Line: -      <input ng-model="name"> <br>
>, <Line: -      <textarea ng-model="html"></textarea> <br>
>, <Line: -      <div compile="html"></div>
>, <Line: -    </div>
>, <Line: -   </file>
>, <Line: -   <file name="protractor.js" type="protractor">
>, <Line: -     it('should auto compile', function() {
>, <Line: -       var textarea = $('textarea');
>, <Line: -       var output = $('div[compile]');
>, <Line: -       // The initial state reads 'Hello Angular'.
>, <Line: -       expect(output.getText()).toBe('Hello Angular');
>, <Line: -       textarea.clear();
>, <Line: -       textarea.sendKeys('{{name}}!');
>, <Line: -       expect(output.getText()).toBe('Angular!');
>, <Line: -     });
>, <Line: -   </file>
>, <Line: - </example>
>, <Line: - *
>, <Line: - *
>, <Line: - * @param {string|DOMElement} element Element or HTML string to compile into a template function.
>, <Line: - * @param {function(angular.Scope, cloneAttachFn=)} transclude function available to directives - DEPRECATED.
>, <Line: - *
>, <Line: - * <div class="alert alert-error">
>, <Line: - * **Note:** Passing a `transclude` function to the $compile function is deprecated, as it
>, <Line: - *   e.g. will not use the right outer scope. Please pass the transclude function as a
>, <Line: - *   `parentBoundTranscludeFn` to the link function instead.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * @param {number} maxPriority only apply directives lower than given priority (Only effects the
>, <Line: - *                 root element(s), not their children)
>, <Line: - * @returns {function(scope, cloneAttachFn=, options=)} a link function which is used to bind template
>, <Line: - * (a DOM element/tree) to a scope. Where:
>, <Line: - *
>, <Line: - *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
>, <Line: - *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
>, <Line: - *  `template` and call the `cloneAttachFn` function allowing the caller to attach the
>, <Line: - *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
>, <Line: - *  called as: <br> `cloneAttachFn(clonedElement, scope)` where:
>, <Line: - *
>, <Line: - *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
>, <Line: - *      * `scope` - is the current scope with which the linking function is working with.
>, <Line: - *
>, <Line: - *  * `options` - An optional object hash with linking options. If `options` is provided, then the following
>, <Line: - *  keys may be used to control linking behavior:
>, <Line: - *
>, <Line: - *      * `parentBoundTranscludeFn` - the transclude function made available to
>, <Line: - *        directives; if given, it will be passed through to the link functions of
>, <Line: - *        directives found in `element` during compilation.
>, <Line: - *      * `transcludeControllers` - an object hash with keys that map controller names
>, <Line: - *        to controller instances; if given, it will make the controllers
>, <Line: - *        available to directives.
>, <Line: - *      * `futureParentElement` - defines the parent to which the `cloneAttachFn` will add
>, <Line: - *        the cloned elements; only needed for transcludes that are allowed to contain non html
>, <Line: - *        elements (e.g. SVG elements). See also the directive.controller property.
>, <Line: - *
>, <Line: - * Calling the linking function returns the element of the template. It is either the original
>, <Line: - * element passed in, or the clone of the element if the `cloneAttachFn` is provided.
>, <Line: - *
>, <Line: - * After linking the view is not updated until after a call to $digest which typically is done by
>, <Line: - * Angular automatically.
>, <Line: - *
>, <Line: - * If you need access to the bound view, there are two ways to do it:
>, <Line: - *
>, <Line: - * - If you are not asking the linking function to clone the template, create the DOM element(s)
>, <Line: - *   before you send them to the compiler and keep this reference around.
>, <Line: - *   ```js
>, <Line: - *     var element = $compile('<p>{{total}}</p>')(scope);
>, <Line: - *   ```
>, <Line: - *
>, <Line: - * - if on the other hand, you need the element to be cloned, the view reference from the original
>, <Line: - *   example would not point to the clone, but rather to the original template that was cloned. In
>, <Line: - *   this case, you can access the clone via the cloneAttachFn:
>, <Line: - *   ```js
>, <Line: - *     var templateElement = angular.element('<p>{{total}}</p>'),
>, <Line: - *         scope = ....;
>, <Line: - *
>, <Line: - *     var clonedElement = $compile(templateElement)(scope, function(clonedElement, scope) {
>, <Line: - *       //attach the clone to DOM document at the right place
>, <Line: - *     });
>, <Line: - *
>, <Line: - *     //now we have reference to the cloned DOM via `clonedElement`
>, <Line: - *   ```
>, <Line: - *
>, <Line: - *
>, <Line: - * For information on how the compiler works, see the
>, <Line: - * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
>, <Line: - */
>, <Line: -var $compileMinErr = minErr('$compile');
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $compileProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - */
>, <Line: -$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
>, <Line: -function $CompileProvider($provide, $$sanitizeUriProvider) {
>, <Line: -  var hasDirectives = {},
>, <Line: -      Suffix = 'Directive',
>, <Line: -      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
>, <Line: -      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
>, <Line: -      ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
>, <Line: -      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
>, <Line: -  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
>, <Line: -  // The assumption is that future DOM event attribute names will begin with
>, <Line: -  // 'on' and be composed of only English letters.
>, <Line: -  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
>, <Line: -  function parseIsolateBindings(scope, directiveName) {
>, <Line: -    var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
>, <Line: -    var bindings = {};
>, <Line: -    forEach(scope, function(definition, scopeName) {
>, <Line: -      var match = definition.match(LOCAL_REGEXP);
>, <Line: -      if (!match) {
>, <Line: -        throw $compileMinErr('iscp',
>, <Line: -            "Invalid isolate scope definition for directive '{0}'." +
>, <Line: -            " Definition: {... {1}: '{2}' ...}",
>, <Line: -            directiveName, scopeName, definition);
>, <Line: -      }
>, <Line: -      bindings[scopeName] = {
>, <Line: -        mode: match[1][0],
>, <Line: -        collection: match[2] === '*',
>, <Line: -        optional: match[3] === '?',
>, <Line: -        attrName: match[4] || scopeName
>, <Line: -      };
>, <Line: -    });
>, <Line: -    return bindings;
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $compileProvider#directive
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Register a new directive with the compiler.
>, <Line: -   *
>, <Line: -   * @param {string|Object} name Name of the directive in camel-case (i.e. <code>ngBind</code> which
>, <Line: -   *    will match as <code>ng-bind</code>), or an object map of directives where the keys are the
>, <Line: -   *    names and the values are the factories.
>, <Line: -   * @param {Function|Array} directiveFactory An injectable directive factory function. See
>, <Line: -   *    {@link guide/directive} for more info.
>, <Line: -   * @returns {ng.$compileProvider} Self for chaining.
>, <Line: -   */
>, <Line: -   this.directive = function registerDirective(name, directiveFactory) {
>, <Line: -    assertNotHasOwnProperty(name, 'directive');
>, <Line: -    if (isString(name)) {
>, <Line: -      assertArg(directiveFactory, 'directiveFactory');
>, <Line: -      if (!hasDirectives.hasOwnProperty(name)) {
>, <Line: -        hasDirectives[name] = [];
>, <Line: -        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
>, <Line: -          function($injector, $exceptionHandler) {
>, <Line: -            var directives = [];
>, <Line: -            forEach(hasDirectives[name], function(directiveFactory, index) {
>, <Line: -              try {
>, <Line: -                var directive = $injector.invoke(directiveFactory);
>, <Line: -                if (isFunction(directive)) {
>, <Line: -                  directive = { compile: valueFn(directive) };
>, <Line: -                } else if (!directive.compile && directive.link) {
>, <Line: -                  directive.compile = valueFn(directive.link);
>, <Line: -                }
>, <Line: -                directive.priority = directive.priority || 0;
>, <Line: -                directive.index = index;
>, <Line: -                directive.name = directive.name || name;
>, <Line: -                directive.require = directive.require || (directive.controller && directive.name);
>, <Line: -                directive.restrict = directive.restrict || 'EA';
>, <Line: -                if (isObject(directive.scope)) {
>, <Line: -                  directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name);
>, <Line: -                }
>, <Line: -                directives.push(directive);
>, <Line: -              } catch (e) {
>, <Line: -                $exceptionHandler(e);
>, <Line: -              }
>, <Line: -            });
>, <Line: -            return directives;
>, <Line: -          }]);
>, <Line: -      }
>, <Line: -      hasDirectives[name].push(directiveFactory);
>, <Line: -    } else {
>, <Line: -      forEach(name, reverseParams(registerDirective));
>, <Line: -    }
>, <Line: -    return this;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $compileProvider#aHrefSanitizationWhitelist
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: -   * urls during a[href] sanitization.
>, <Line: -   *
>, <Line: -   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: -   *
>, <Line: -   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
>, <Line: -   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
>, <Line: -   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: -   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: -   *
>, <Line: -   * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: -   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: -   *    chaining otherwise.
>, <Line: -   */
>, <Line: -  this.aHrefSanitizationWhitelist = function(regexp) {
>, <Line: -    if (isDefined(regexp)) {
>, <Line: -      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $compileProvider#imgSrcSanitizationWhitelist
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: -   * urls during img[src] sanitization.
>, <Line: -   *
>, <Line: -   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: -   *
>, <Line: -   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
>, <Line: -   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
>, <Line: -   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: -   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: -   *
>, <Line: -   * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: -   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: -   *    chaining otherwise.
>, <Line: -   */
>, <Line: -  this.imgSrcSanitizationWhitelist = function(regexp) {
>, <Line: -    if (isDefined(regexp)) {
>, <Line: -      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name  $compileProvider#debugInfoEnabled
>, <Line: -   *
>, <Line: -   * @param {boolean=} enabled update the debugInfoEnabled state if provided, otherwise just return the
>, <Line: -   * current debugInfoEnabled state
>, <Line: -   * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: -   *
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Call this method to enable/disable various debug runtime information in the compiler such as adding
>, <Line: -   * binding information and a reference to the current scope on to DOM elements.
>, <Line: -   * If enabled, the compiler will add the following to DOM elements that have been bound to the scope
>, <Line: -   * * `ng-binding` CSS class
>, <Line: -   * * `$binding` data property containing an array of the binding expressions
>, <Line: -   *
>, <Line: -   * You may want to use this in production for a significant performance boost. See
>, <Line: -   * {@link guide/production#disabling-debug-data Disabling Debug Data} for more.
>, <Line: -   *
>, <Line: -   * The default value is true.
>, <Line: -   */
>, <Line: -  var debugInfoEnabled = true;
>, <Line: -  this.debugInfoEnabled = function(enabled) {
>, <Line: -    if (isDefined(enabled)) {
>, <Line: -      debugInfoEnabled = enabled;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    return debugInfoEnabled;
>, <Line: -  };
>, <Line: -  this.$get = [
>, <Line: -            '$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse',
>, <Line: -            '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri',
>, <Line: -    function($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,
>, <Line: -             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {
>, <Line: -    var Attributes = function(element, attributesToCopy) {
>, <Line: -      if (attributesToCopy) {
>, <Line: -        var keys = Object.keys(attributesToCopy);
>, <Line: -        var i, l, key;
>, <Line: -        for (i = 0, l = keys.length; i < l; i++) {
>, <Line: -          key = keys[i];
>, <Line: -          this[key] = attributesToCopy[key];
>, <Line: -        }
>, <Line: -      } else {
>, <Line: -        this.$attr = {};
>, <Line: -      }
>, <Line: -      this.$$element = element;
>, <Line: -    };
>, <Line: -    Attributes.prototype = {
>, <Line: -      $normalize: directiveNormalize,
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $compile.directive.Attributes#$addClass
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Adds the CSS class value specified by the classVal parameter to the element. If animations
>, <Line: -       * are enabled then an animation will be triggered for the class addition.
>, <Line: -       *
>, <Line: -       * @param {string} classVal The className value that will be added to the element
>, <Line: -       */
>, <Line: -      $addClass: function(classVal) {
>, <Line: -        if (classVal && classVal.length > 0) {
>, <Line: -          $animate.addClass(this.$$element, classVal);
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $compile.directive.Attributes#$removeClass
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Removes the CSS class value specified by the classVal parameter from the element. If
>, <Line: -       * animations are enabled then an animation will be triggered for the class removal.
>, <Line: -       *
>, <Line: -       * @param {string} classVal The className value that will be removed from the element
>, <Line: -       */
>, <Line: -      $removeClass: function(classVal) {
>, <Line: -        if (classVal && classVal.length > 0) {
>, <Line: -          $animate.removeClass(this.$$element, classVal);
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $compile.directive.Attributes#$updateClass
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Adds and removes the appropriate CSS class values to the element based on the difference
>, <Line: -       * between the new and old CSS class values (specified as newClasses and oldClasses).
>, <Line: -       *
>, <Line: -       * @param {string} newClasses The current CSS className value
>, <Line: -       * @param {string} oldClasses The former CSS className value
>, <Line: -       */
>, <Line: -      $updateClass: function(newClasses, oldClasses) {
>, <Line: -        var toAdd = tokenDifference(newClasses, oldClasses);
>, <Line: -        if (toAdd && toAdd.length) {
>, <Line: -          $animate.addClass(this.$$element, toAdd);
>, <Line: -        }
>, <Line: -        var toRemove = tokenDifference(oldClasses, newClasses);
>, <Line: -        if (toRemove && toRemove.length) {
>, <Line: -          $animate.removeClass(this.$$element, toRemove);
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * Set a normalized attribute on the element in a way such that all directives
>, <Line: -       * can share the attribute. This function properly handles boolean attributes.
>, <Line: -       * @param {string} key Normalized key. (ie ngAttribute)
>, <Line: -       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
>, <Line: -       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
>, <Line: -       *     Defaults to true.
>, <Line: -       * @param {string=} attrName Optional none normalized name. Defaults to key.
>, <Line: -       */
>, <Line: -      $set: function(key, value, writeAttr, attrName) {
>, <Line: -        // TODO: decide whether or not to throw an error if "class"
>, <Line: -        //is set through this function since it may cause $updateClass to
>, <Line: -        //become unstable.
>, <Line: -        var node = this.$$element[0],
>, <Line: -            booleanKey = getBooleanAttrName(node, key),
>, <Line: -            aliasedKey = getAliasedAttrName(node, key),
>, <Line: -            observer = key,
>, <Line: -            nodeName;
>, <Line: -        if (booleanKey) {
>, <Line: -          this.$$element.prop(key, value);
>, <Line: -          attrName = booleanKey;
>, <Line: -        } else if (aliasedKey) {
>, <Line: -          this[aliasedKey] = value;
>, <Line: -          observer = aliasedKey;
>, <Line: -        }
>, <Line: -        this[key] = value;
>, <Line: -        // translate normalized key to actual key
>, <Line: -        if (attrName) {
>, <Line: -          this.$attr[key] = attrName;
>, <Line: -        } else {
>, <Line: -          attrName = this.$attr[key];
>, <Line: -          if (!attrName) {
>, <Line: -            this.$attr[key] = attrName = snake_case(key, '-');
>, <Line: -          }
>, <Line: -        }
>, <Line: -        nodeName = nodeName_(this.$$element);
>, <Line: -        if ((nodeName === 'a' && key === 'href') ||
>, <Line: -            (nodeName === 'img' && key === 'src')) {
>, <Line: -          // sanitize a[href] and img[src] values
>, <Line: -          this[key] = value = $$sanitizeUri(value, key === 'src');
>, <Line: -        } else if (nodeName === 'img' && key === 'srcset') {
>, <Line: -          // sanitize img[srcset] values
>, <Line: -          var result = "";
>, <Line: -          // first check if there are spaces because it's not the same pattern
>, <Line: -          var trimmedSrcset = trim(value);
>, <Line: -          //                (   999x   ,|   999w   ,|   ,|,   )
>, <Line: -          var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
>, <Line: -          var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
>, <Line: -          // split srcset into tuple of uri and descriptor except for the last item
>, <Line: -          var rawUris = trimmedSrcset.split(pattern);
>, <Line: -          // for each tuples
>, <Line: -          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
>, <Line: -          for (var i = 0; i < nbrUrisWith2parts; i++) {
>, <Line: -            var innerIdx = i * 2;
>, <Line: -            // sanitize the uri
>, <Line: -            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
>, <Line: -            // add the descriptor
>, <Line: -            result += (" " + trim(rawUris[innerIdx + 1]));
>, <Line: -          }
>, <Line: -          // split the last item into uri and descriptor
>, <Line: -          var lastTuple = trim(rawUris[i * 2]).split(/\s/);
>, <Line: -          // sanitize the last uri
>, <Line: -          result += $$sanitizeUri(trim(lastTuple[0]), true);
>, <Line: -          // and add the last descriptor if any
>, <Line: -          if (lastTuple.length === 2) {
>, <Line: -            result += (" " + trim(lastTuple[1]));
>, <Line: -          }
>, <Line: -          this[key] = value = result;
>, <Line: -        }
>, <Line: -        if (writeAttr !== false) {
>, <Line: -          if (value === null || value === undefined) {
>, <Line: -            this.$$element.removeAttr(attrName);
>, <Line: -          } else {
>, <Line: -            this.$$element.attr(attrName, value);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        // fire observers
>, <Line: -        var $$observers = this.$$observers;
>, <Line: -        $$observers && forEach($$observers[observer], function(fn) {
>, <Line: -          try {
>, <Line: -            fn(value);
>, <Line: -          } catch (e) {
>, <Line: -            $exceptionHandler(e);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $compile.directive.Attributes#$observe
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Observes an interpolated attribute.
>, <Line: -       *
>, <Line: -       * The observer function will be invoked once during the next `$digest` following
>, <Line: -       * compilation. The observer is then invoked whenever the interpolated value
>, <Line: -       * changes.
>, <Line: -       *
>, <Line: -       * @param {string} key Normalized key. (ie ngAttribute) .
>, <Line: -       * @param {function(interpolatedValue)} fn Function that will be called whenever
>, <Line: -                the interpolated value of the attribute changes.
>, <Line: -       *        See the {@link guide/directive#text-and-attribute-bindings Directives} guide for more info.
>, <Line: -       * @returns {function()} Returns a deregistration function for this observer.
>, <Line: -       */
>, <Line: -      $observe: function(key, fn) {
>, <Line: -        var attrs = this,
>, <Line: -            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
>, <Line: -            listeners = ($$observers[key] || ($$observers[key] = []));
>, <Line: -        listeners.push(fn);
>, <Line: -        $rootScope.$evalAsync(function() {
>, <Line: -          if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
>, <Line: -            // no one registered attribute interpolation function, so lets call it manually
>, <Line: -            fn(attrs[key]);
>, <Line: -          }
>, <Line: -        });
>, <Line: -        return function() {
>, <Line: -          arrayRemove(listeners, fn);
>, <Line: -        };
>, <Line: -      }
>, <Line: -    };
>, <Line: -    function safeAddClass($element, className) {
>, <Line: -      try {
>, <Line: -        $element.addClass(className);
>, <Line: -      } catch (e) {
>, <Line: -        // ignore, since it means that we are trying to set class on
>, <Line: -        // SVG element, where class name is read-only.
>, <Line: -      }
>, <Line: -    }
>, <Line: -    var startSymbol = $interpolate.startSymbol(),
>, <Line: -        endSymbol = $interpolate.endSymbol(),
>, <Line: -        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
>, <Line: -            ? identity
>, <Line: -            : function denormalizeTemplate(template) {
>, <Line: -              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
>, <Line: -        },
>, <Line: -        NG_ATTR_BINDING = /^ngAttr[A-Z]/;
>, <Line: -    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
>, <Line: -      var bindings = $element.data('$binding') || [];
>, <Line: -      if (isArray(binding)) {
>, <Line: -        bindings = bindings.concat(binding);
>, <Line: -      } else {
>, <Line: -        bindings.push(binding);
>, <Line: -      }
>, <Line: -      $element.data('$binding', bindings);
>, <Line: -    } : noop;
>, <Line: -    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
>, <Line: -      safeAddClass($element, 'ng-binding');
>, <Line: -    } : noop;
>, <Line: -    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
>, <Line: -      var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
>, <Line: -      $element.data(dataName, scope);
>, <Line: -    } : noop;
>, <Line: -    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
>, <Line: -      safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
>, <Line: -    } : noop;
>, <Line: -    return compile;
>, <Line: -    //================================
>, <Line: -    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
>, <Line: -                        previousCompileContext) {
>, <Line: -      if (!($compileNodes instanceof jqLite)) {
>, <Line: -        // jquery always rewraps, whereas we need to preserve the original selector so that we can
>, <Line: -        // modify it.
>, <Line: -        $compileNodes = jqLite($compileNodes);
>, <Line: -      }
>, <Line: -      // We can not compile top level text elements since text nodes can be merged and we will
>, <Line: -      // not be able to attach scope data to them, so we will wrap them in <span>
>, <Line: -      forEach($compileNodes, function(node, index) {
>, <Line: -        if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) /* non-empty */ ) {
>, <Line: -          $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
>, <Line: -        }
>, <Line: -      });
>, <Line: -      var compositeLinkFn =
>, <Line: -              compileNodes($compileNodes, transcludeFn, $compileNodes,
>, <Line: -                           maxPriority, ignoreDirective, previousCompileContext);
>, <Line: -      compile.$$addScopeClass($compileNodes);
>, <Line: -      var namespace = null;
>, <Line: -      return function publicLinkFn(scope, cloneConnectFn, options) {
>, <Line: -        assertArg(scope, 'scope');
>, <Line: -        options = options || {};
>, <Line: -        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
>, <Line: -          transcludeControllers = options.transcludeControllers,
>, <Line: -          futureParentElement = options.futureParentElement;
>, <Line: -        // When `parentBoundTranscludeFn` is passed, it is a
>, <Line: -        // `controllersBoundTransclude` function (it was previously passed
>, <Line: -        // as `transclude` to directive.link) so we must unwrap it to get
>, <Line: -        // its `boundTranscludeFn`
>, <Line: -        if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
>, <Line: -          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
>, <Line: -        }
>, <Line: -        if (!namespace) {
>, <Line: -          namespace = detectNamespaceForChildElements(futureParentElement);
>, <Line: -        }
>, <Line: -        var $linkNode;
>, <Line: -        if (namespace !== 'html') {
>, <Line: -          // When using a directive with replace:true and templateUrl the $compileNodes
>, <Line: -          // (or a child element inside of them)
>, <Line: -          // might change, so we need to recreate the namespace adapted compileNodes
>, <Line: -          // for call to the link function.
>, <Line: -          // Note: This will already clone the nodes...
>, <Line: -          $linkNode = jqLite(
>, <Line: -            wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html())
>, <Line: -          );
>, <Line: -        } else if (cloneConnectFn) {
>, <Line: -          // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
>, <Line: -          // and sometimes changes the structure of the DOM.
>, <Line: -          $linkNode = JQLitePrototype.clone.call($compileNodes);
>, <Line: -        } else {
>, <Line: -          $linkNode = $compileNodes;
>, <Line: -        }
>, <Line: -        if (transcludeControllers) {
>, <Line: -          for (var controllerName in transcludeControllers) {
>, <Line: -            $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        compile.$$addScopeInfo($linkNode, scope);
>, <Line: -        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
>, <Line: -        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
>, <Line: -        return $linkNode;
>, <Line: -      };
>, <Line: -    }
>, <Line: -    function detectNamespaceForChildElements(parentElement) {
>, <Line: -      // TODO: Make this detect MathML as well...
>, <Line: -      var node = parentElement && parentElement[0];
>, <Line: -      if (!node) {
>, <Line: -        return 'html';
>, <Line: -      } else {
>, <Line: -        return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Compile function matches each node in nodeList against the directives. Once all directives
>, <Line: -     * for a particular node are collected their compile functions are executed. The compile
>, <Line: -     * functions return values - the linking functions - are combined into a composite linking
>, <Line: -     * function, which is the a linking function for the node.
>, <Line: -     *
>, <Line: -     * @param {NodeList} nodeList an array of nodes or NodeList to compile
>, <Line: -     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
>, <Line: -     *        scope argument is auto-generated to the new child of the transcluded parent scope.
>, <Line: -     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then
>, <Line: -     *        the rootElement must be set the jqLite collection of the compile root. This is
>, <Line: -     *        needed so that the jqLite collection items can be replaced with widgets.
>, <Line: -     * @param {number=} maxPriority Max directive priority.
>, <Line: -     * @returns {Function} A composite linking function of all of the matched directives or null.
>, <Line: -     */
>, <Line: -    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
>, <Line: -                            previousCompileContext) {
>, <Line: -      var linkFns = [],
>, <Line: -          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
>, <Line: -      for (var i = 0; i < nodeList.length; i++) {
>, <Line: -        attrs = new Attributes();
>, <Line: -        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
>, <Line: -        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
>, <Line: -                                        ignoreDirective);
>, <Line: -        nodeLinkFn = (directives.length)
>, <Line: -            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
>, <Line: -                                      null, [], [], previousCompileContext)
>, <Line: -            : null;
>, <Line: -        if (nodeLinkFn && nodeLinkFn.scope) {
>, <Line: -          compile.$$addScopeClass(attrs.$$element);
>, <Line: -        }
>, <Line: -        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
>, <Line: -                      !(childNodes = nodeList[i].childNodes) ||
>, <Line: -                      !childNodes.length)
>, <Line: -            ? null
>, <Line: -            : compileNodes(childNodes,
>, <Line: -                 nodeLinkFn ? (
>, <Line: -                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
>, <Line: -                     && nodeLinkFn.transclude) : transcludeFn);
>, <Line: -        if (nodeLinkFn || childLinkFn) {
>, <Line: -          linkFns.push(i, nodeLinkFn, childLinkFn);
>, <Line: -          linkFnFound = true;
>, <Line: -          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
>, <Line: -        }
>, <Line: -        //use the previous context only for the first element in the virtual group
>, <Line: -        previousCompileContext = null;
>, <Line: -      }
>, <Line: -      // return a linking function if we have found anything, null otherwise
>, <Line: -      return linkFnFound ? compositeLinkFn : null;
>, <Line: -      function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
>, <Line: -        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
>, <Line: -        var stableNodeList;
>, <Line: -        if (nodeLinkFnFound) {
>, <Line: -          // copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our
>, <Line: -          // offsets don't get screwed up
>, <Line: -          var nodeListLength = nodeList.length;
>, <Line: -          stableNodeList = new Array(nodeListLength);
>, <Line: -          // create a sparse array by only copying the elements which have a linkFn
>, <Line: -          for (i = 0; i < linkFns.length; i+=3) {
>, <Line: -            idx = linkFns[i];
>, <Line: -            stableNodeList[idx] = nodeList[idx];
>, <Line: -          }
>, <Line: -        } else {
>, <Line: -          stableNodeList = nodeList;
>, <Line: -        }
>, <Line: -        for (i = 0, ii = linkFns.length; i < ii;) {
>, <Line: -          node = stableNodeList[linkFns[i++]];
>, <Line: -          nodeLinkFn = linkFns[i++];
>, <Line: -          childLinkFn = linkFns[i++];
>, <Line: -          if (nodeLinkFn) {
>, <Line: -            if (nodeLinkFn.scope) {
>, <Line: -              childScope = scope.$new();
>, <Line: -              compile.$$addScopeInfo(jqLite(node), childScope);
>, <Line: -            } else {
>, <Line: -              childScope = scope;
>, <Line: -            }
>, <Line: -            if (nodeLinkFn.transcludeOnThisElement) {
>, <Line: -              childBoundTranscludeFn = createBoundTranscludeFn(
>, <Line: -                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn,
>, <Line: -                  nodeLinkFn.elementTranscludeOnThisElement);
>, <Line: -            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
>, <Line: -              childBoundTranscludeFn = parentBoundTranscludeFn;
>, <Line: -            } else if (!parentBoundTranscludeFn && transcludeFn) {
>, <Line: -              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
>, <Line: -            } else {
>, <Line: -              childBoundTranscludeFn = null;
>, <Line: -            }
>, <Line: -            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
>, <Line: -          } else if (childLinkFn) {
>, <Line: -            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
>, <Line: -      var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
>, <Line: -        if (!transcludedScope) {
>, <Line: -          transcludedScope = scope.$new(false, containingScope);
>, <Line: -          transcludedScope.$$transcluded = true;
>, <Line: -        }
>, <Line: -        return transcludeFn(transcludedScope, cloneFn, {
>, <Line: -          parentBoundTranscludeFn: previousBoundTranscludeFn,
>, <Line: -          transcludeControllers: controllers,
>, <Line: -          futureParentElement: futureParentElement
>, <Line: -        });
>, <Line: -      };
>, <Line: -      return boundTranscludeFn;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Looks for directives on the given node and adds them to the directive collection which is
>, <Line: -     * sorted.
>, <Line: -     *
>, <Line: -     * @param node Node to search.
>, <Line: -     * @param directives An array to which the directives are added to. This array is sorted before
>, <Line: -     *        the function returns.
>, <Line: -     * @param attrs The shared attrs object which is used to populate the normalized attributes.
>, <Line: -     * @param {number=} maxPriority Max directive priority.
>, <Line: -     */
>, <Line: -    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
>, <Line: -      var nodeType = node.nodeType,
>, <Line: -          attrsMap = attrs.$attr,
>, <Line: -          match,
>, <Line: -          className;
>, <Line: -      switch (nodeType) {
>, <Line: -        case NODE_TYPE_ELEMENT: /* Element */
>, <Line: -          // use the node name: <directive>
>, <Line: -          addDirective(directives,
>, <Line: -              directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
>, <Line: -          // iterate over the attributes
>, <Line: -          for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
>, <Line: -                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
>, <Line: -            var attrStartName = false;
>, <Line: -            var attrEndName = false;
>, <Line: -            attr = nAttrs[j];
>, <Line: -            name = attr.name;
>, <Line: -            value = trim(attr.value);
>, <Line: -            // support ngAttr attribute binding
>, <Line: -            ngAttrName = directiveNormalize(name);
>, <Line: -            if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
>, <Line: -              name = snake_case(ngAttrName.substr(6), '-');
>, <Line: -            }
>, <Line: -            var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
>, <Line: -            if (directiveIsMultiElement(directiveNName)) {
>, <Line: -              if (ngAttrName === directiveNName + 'Start') {
>, <Line: -                attrStartName = name;
>, <Line: -                attrEndName = name.substr(0, name.length - 5) + 'end';
>, <Line: -                name = name.substr(0, name.length - 6);
>, <Line: -              }
>, <Line: -            }
>, <Line: -            nName = directiveNormalize(name.toLowerCase());
>, <Line: -            attrsMap[nName] = name;
>, <Line: -            if (isNgAttr || !attrs.hasOwnProperty(nName)) {
>, <Line: -                attrs[nName] = value;
>, <Line: -                if (getBooleanAttrName(node, nName)) {
>, <Line: -                  attrs[nName] = true; // presence means true
>, <Line: -                }
>, <Line: -            }
>, <Line: -            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
>, <Line: -            addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
>, <Line: -                          attrEndName);
>, <Line: -          }
>, <Line: -          // use class as directive
>, <Line: -          className = node.className;
>, <Line: -          if (isString(className) && className !== '') {
>, <Line: -            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
>, <Line: -              nName = directiveNormalize(match[2]);
>, <Line: -              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
>, <Line: -                attrs[nName] = trim(match[3]);
>, <Line: -              }
>, <Line: -              className = className.substr(match.index + match[0].length);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          break;
>, <Line: -        case NODE_TYPE_TEXT: /* Text Node */
>, <Line: -          addTextInterpolateDirective(directives, node.nodeValue);
>, <Line: -          break;
>, <Line: -        case NODE_TYPE_COMMENT: /* Comment */
>, <Line: -          try {
>, <Line: -            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
>, <Line: -            if (match) {
>, <Line: -              nName = directiveNormalize(match[1]);
>, <Line: -              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
>, <Line: -                attrs[nName] = trim(match[2]);
>, <Line: -              }
>, <Line: -            }
>, <Line: -          } catch (e) {
>, <Line: -            // turns out that under some circumstances IE9 throws errors when one attempts to read
>, <Line: -            // comment's node value.
>, <Line: -            // Just ignore it and continue. (Can't seem to reproduce in test case.)
>, <Line: -          }
>, <Line: -          break;
>, <Line: -      }
>, <Line: -      directives.sort(byPriority);
>, <Line: -      return directives;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Given a node with an directive-start it collects all of the siblings until it finds
>, <Line: -     * directive-end.
>, <Line: -     * @param node
>, <Line: -     * @param attrStart
>, <Line: -     * @param attrEnd
>, <Line: -     * @returns {*}
>, <Line: -     */
>, <Line: -    function groupScan(node, attrStart, attrEnd) {
>, <Line: -      var nodes = [];
>, <Line: -      var depth = 0;
>, <Line: -      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
>, <Line: -        do {
>, <Line: -          if (!node) {
>, <Line: -            throw $compileMinErr('uterdir',
>, <Line: -                      "Unterminated attribute, found '{0}' but no matching '{1}' found.",
>, <Line: -                      attrStart, attrEnd);
>, <Line: -          }
>, <Line: -          if (node.nodeType == NODE_TYPE_ELEMENT) {
>, <Line: -            if (node.hasAttribute(attrStart)) depth++;
>, <Line: -            if (node.hasAttribute(attrEnd)) depth--;
>, <Line: -          }
>, <Line: -          nodes.push(node);
>, <Line: -          node = node.nextSibling;
>, <Line: -        } while (depth > 0);
>, <Line: -      } else {
>, <Line: -        nodes.push(node);
>, <Line: -      }
>, <Line: -      return jqLite(nodes);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Wrapper for linking function which converts normal linking function into a grouped
>, <Line: -     * linking function.
>, <Line: -     * @param linkFn
>, <Line: -     * @param attrStart
>, <Line: -     * @param attrEnd
>, <Line: -     * @returns {Function}
>, <Line: -     */
>, <Line: -    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
>, <Line: -      return function(scope, element, attrs, controllers, transcludeFn) {
>, <Line: -        element = groupScan(element[0], attrStart, attrEnd);
>, <Line: -        return linkFn(scope, element, attrs, controllers, transcludeFn);
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Once the directives have been collected, their compile functions are executed. This method
>, <Line: -     * is responsible for inlining directive templates as well as terminating the application
>, <Line: -     * of the directives if the terminal directive has been reached.
>, <Line: -     *
>, <Line: -     * @param {Array} directives Array of collected directives to execute their compile function.
>, <Line: -     *        this needs to be pre-sorted by priority order.
>, <Line: -     * @param {Node} compileNode The raw DOM node to apply the compile functions to
>, <Line: -     * @param {Object} templateAttrs The shared attribute function
>, <Line: -     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
>, <Line: -     *                                                  scope argument is auto-generated to the new
>, <Line: -     *                                                  child of the transcluded parent scope.
>, <Line: -     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
>, <Line: -     *                              argument has the root jqLite array so that we can replace nodes
>, <Line: -     *                              on it.
>, <Line: -     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
>, <Line: -     *                                           compiling the transclusion.
>, <Line: -     * @param {Array.<Function>} preLinkFns
>, <Line: -     * @param {Array.<Function>} postLinkFns
>, <Line: -     * @param {Object} previousCompileContext Context used for previous compilation of the current
>, <Line: -     *                                        node
>, <Line: -     * @returns {Function} linkFn
>, <Line: -     */
>, <Line: -    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
>, <Line: -                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
>, <Line: -                                   previousCompileContext) {
>, <Line: -      previousCompileContext = previousCompileContext || {};
>, <Line: -      var terminalPriority = -Number.MAX_VALUE,
>, <Line: -          newScopeDirective,
>, <Line: -          controllerDirectives = previousCompileContext.controllerDirectives,
>, <Line: -          controllers,
>, <Line: -          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
>, <Line: -          templateDirective = previousCompileContext.templateDirective,
>, <Line: -          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
>, <Line: -          hasTranscludeDirective = false,
>, <Line: -          hasTemplate = false,
>, <Line: -          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
>, <Line: -          $compileNode = templateAttrs.$$element = jqLite(compileNode),
>, <Line: -          directive,
>, <Line: -          directiveName,
>, <Line: -          $template,
>, <Line: -          replaceDirective = originalReplaceDirective,
>, <Line: -          childTranscludeFn = transcludeFn,
>, <Line: -          linkFn,
>, <Line: -          directiveValue;
>, <Line: -      // executes all directives on the current element
>, <Line: -      for (var i = 0, ii = directives.length; i < ii; i++) {
>, <Line: -        directive = directives[i];
>, <Line: -        var attrStart = directive.$$start;
>, <Line: -        var attrEnd = directive.$$end;
>, <Line: -        // collect multiblock sections
>, <Line: -        if (attrStart) {
>, <Line: -          $compileNode = groupScan(compileNode, attrStart, attrEnd);
>, <Line: -        }
>, <Line: -        $template = undefined;
>, <Line: -        if (terminalPriority > directive.priority) {
>, <Line: -          break; // prevent further processing of directives
>, <Line: -        }
>, <Line: -        if (directiveValue = directive.scope) {
>, <Line: -          // skip the check for directives with async templates, we'll check the derived sync
>, <Line: -          // directive when the template arrives
>, <Line: -          if (!directive.templateUrl) {
>, <Line: -            if (isObject(directiveValue)) {
>, <Line: -              // This directive is trying to add an isolated scope.
>, <Line: -              // Check that there is no scope of any kind already
>, <Line: -              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
>, <Line: -                                directive, $compileNode);
>, <Line: -              newIsolateScopeDirective = directive;
>, <Line: -            } else {
>, <Line: -              // This directive is trying to add a child scope.
>, <Line: -              // Check that there is no isolated scope already
>, <Line: -              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
>, <Line: -                                $compileNode);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          newScopeDirective = newScopeDirective || directive;
>, <Line: -        }
>, <Line: -        directiveName = directive.name;
>, <Line: -        if (!directive.templateUrl && directive.controller) {
>, <Line: -          directiveValue = directive.controller;
>, <Line: -          controllerDirectives = controllerDirectives || {};
>, <Line: -          assertNoDuplicate("'" + directiveName + "' controller",
>, <Line: -              controllerDirectives[directiveName], directive, $compileNode);
>, <Line: -          controllerDirectives[directiveName] = directive;
>, <Line: -        }
>, <Line: -        if (directiveValue = directive.transclude) {
>, <Line: -          hasTranscludeDirective = true;
>, <Line: -          // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
>, <Line: -          // This option should only be used by directives that know how to safely handle element transclusion,
>, <Line: -          // where the transcluded nodes are added or replaced after linking.
>, <Line: -          if (!directive.$$tlb) {
>, <Line: -            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
>, <Line: -            nonTlbTranscludeDirective = directive;
>, <Line: -          }
>, <Line: -          if (directiveValue == 'element') {
>, <Line: -            hasElementTranscludeDirective = true;
>, <Line: -            terminalPriority = directive.priority;
>, <Line: -            $template = $compileNode;
>, <Line: -            $compileNode = templateAttrs.$$element =
>, <Line: -                jqLite(document.createComment(' ' + directiveName + ': ' +
>, <Line: -                                              templateAttrs[directiveName] + ' '));
>, <Line: -            compileNode = $compileNode[0];
>, <Line: -            replaceWith(jqCollection, sliceArgs($template), compileNode);
>, <Line: -            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
>, <Line: -                                        replaceDirective && replaceDirective.name, {
>, <Line: -                                          // Don't pass in:
>, <Line: -                                          // - controllerDirectives - otherwise we'll create duplicates controllers
>, <Line: -                                          // - newIsolateScopeDirective or templateDirective - combining templates with
>, <Line: -                                          //   element transclusion doesn't make sense.
>, <Line: -                                          //
>, <Line: -                                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
>, <Line: -                                          // on the same element more than once.
>, <Line: -                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
>, <Line: -                                        });
>, <Line: -          } else {
>, <Line: -            $template = jqLite(jqLiteClone(compileNode)).contents();
>, <Line: -            $compileNode.empty(); // clear contents
>, <Line: -            childTranscludeFn = compile($template, transcludeFn);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (directive.template) {
>, <Line: -          hasTemplate = true;
>, <Line: -          assertNoDuplicate('template', templateDirective, directive, $compileNode);
>, <Line: -          templateDirective = directive;
>, <Line: -          directiveValue = (isFunction(directive.template))
>, <Line: -              ? directive.template($compileNode, templateAttrs)
>, <Line: -              : directive.template;
>, <Line: -          directiveValue = denormalizeTemplate(directiveValue);
>, <Line: -          if (directive.replace) {
>, <Line: -            replaceDirective = directive;
>, <Line: -            if (jqLiteIsTextNode(directiveValue)) {
>, <Line: -              $template = [];
>, <Line: -            } else {
>, <Line: -              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
>, <Line: -            }
>, <Line: -            compileNode = $template[0];
>, <Line: -            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
>, <Line: -              throw $compileMinErr('tplrt',
>, <Line: -                  "Template for directive '{0}' must have exactly one root element. {1}",
>, <Line: -                  directiveName, '');
>, <Line: -            }
>, <Line: -            replaceWith(jqCollection, $compileNode, compileNode);
>, <Line: -            var newTemplateAttrs = {$attr: {}};
>, <Line: -            // combine directives from the original node and from the template:
>, <Line: -            // - take the array of directives for this element
>, <Line: -            // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
>, <Line: -            // - collect directives from the template and sort them by priority
>, <Line: -            // - combine directives as: processed + template + unprocessed
>, <Line: -            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
>, <Line: -            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
>, <Line: -            if (newIsolateScopeDirective) {
>, <Line: -              markDirectivesAsIsolate(templateDirectives);
>, <Line: -            }
>, <Line: -            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
>, <Line: -            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
>, <Line: -            ii = directives.length;
>, <Line: -          } else {
>, <Line: -            $compileNode.html(directiveValue);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (directive.templateUrl) {
>, <Line: -          hasTemplate = true;
>, <Line: -          assertNoDuplicate('template', templateDirective, directive, $compileNode);
>, <Line: -          templateDirective = directive;
>, <Line: -          if (directive.replace) {
>, <Line: -            replaceDirective = directive;
>, <Line: -          }
>, <Line: -          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
>, <Line: -              templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
>, <Line: -                controllerDirectives: controllerDirectives,
>, <Line: -                newIsolateScopeDirective: newIsolateScopeDirective,
>, <Line: -                templateDirective: templateDirective,
>, <Line: -                nonTlbTranscludeDirective: nonTlbTranscludeDirective
>, <Line: -              });
>, <Line: -          ii = directives.length;
>, <Line: -        } else if (directive.compile) {
>, <Line: -          try {
>, <Line: -            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
>, <Line: -            if (isFunction(linkFn)) {
>, <Line: -              addLinkFns(null, linkFn, attrStart, attrEnd);
>, <Line: -            } else if (linkFn) {
>, <Line: -              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
>, <Line: -            }
>, <Line: -          } catch (e) {
>, <Line: -            $exceptionHandler(e, startingTag($compileNode));
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (directive.terminal) {
>, <Line: -          nodeLinkFn.terminal = true;
>, <Line: -          terminalPriority = Math.max(terminalPriority, directive.priority);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
>, <Line: -      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
>, <Line: -      nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
>, <Line: -      nodeLinkFn.templateOnThisElement = hasTemplate;
>, <Line: -      nodeLinkFn.transclude = childTranscludeFn;
>, <Line: -      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
>, <Line: -      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
>, <Line: -      return nodeLinkFn;
>, <Line: -      ////////////////////
>, <Line: -      function addLinkFns(pre, post, attrStart, attrEnd) {
>, <Line: -        if (pre) {
>, <Line: -          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
>, <Line: -          pre.require = directive.require;
>, <Line: -          pre.directiveName = directiveName;
>, <Line: -          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
>, <Line: -            pre = cloneAndAnnotateFn(pre, {isolateScope: true});
>, <Line: -          }
>, <Line: -          preLinkFns.push(pre);
>, <Line: -        }
>, <Line: -        if (post) {
>, <Line: -          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
>, <Line: -          post.require = directive.require;
>, <Line: -          post.directiveName = directiveName;
>, <Line: -          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
>, <Line: -            post = cloneAndAnnotateFn(post, {isolateScope: true});
>, <Line: -          }
>, <Line: -          postLinkFns.push(post);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      function getControllers(directiveName, require, $element, elementControllers) {
>, <Line: -        var value, retrievalMethod = 'data', optional = false;
>, <Line: -        var $searchElement = $element;
>, <Line: -        var match;
>, <Line: -        if (isString(require)) {
>, <Line: -          match = require.match(REQUIRE_PREFIX_REGEXP);
>, <Line: -          require = require.substring(match[0].length);
>, <Line: -          if (match[3]) {
>, <Line: -            if (match[1]) match[3] = null;
>, <Line: -            else match[1] = match[3];
>, <Line: -          }
>, <Line: -          if (match[1] === '^') {
>, <Line: -            retrievalMethod = 'inheritedData';
>, <Line: -          } else if (match[1] === '^^') {
>, <Line: -            retrievalMethod = 'inheritedData';
>, <Line: -            $searchElement = $element.parent();
>, <Line: -          }
>, <Line: -          if (match[2] === '?') {
>, <Line: -            optional = true;
>, <Line: -          }
>, <Line: -          value = null;
>, <Line: -          if (elementControllers && retrievalMethod === 'data') {
>, <Line: -            if (value = elementControllers[require]) {
>, <Line: -              value = value.instance;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          value = value || $searchElement[retrievalMethod]('$' + require + 'Controller');
>, <Line: -          if (!value && !optional) {
>, <Line: -            throw $compileMinErr('ctreq',
>, <Line: -                "Controller '{0}', required by directive '{1}', can't be found!",
>, <Line: -                require, directiveName);
>, <Line: -          }
>, <Line: -          return value || null;
>, <Line: -        } else if (isArray(require)) {
>, <Line: -          value = [];
>, <Line: -          forEach(require, function(require) {
>, <Line: -            value.push(getControllers(directiveName, require, $element, elementControllers));
>, <Line: -          });
>, <Line: -        }
>, <Line: -        return value;
>, <Line: -      }
>, <Line: -      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
>, <Line: -        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,
>, <Line: -            attrs;
>, <Line: -        if (compileNode === linkNode) {
>, <Line: -          attrs = templateAttrs;
>, <Line: -          $element = templateAttrs.$$element;
>, <Line: -        } else {
>, <Line: -          $element = jqLite(linkNode);
>, <Line: -          attrs = new Attributes($element, templateAttrs);
>, <Line: -        }
>, <Line: -        if (newIsolateScopeDirective) {
>, <Line: -          isolateScope = scope.$new(true);
>, <Line: -        }
>, <Line: -        if (boundTranscludeFn) {
>, <Line: -          // track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`
>, <Line: -          // is later passed as `parentBoundTranscludeFn` to `publicLinkFn`
>, <Line: -          transcludeFn = controllersBoundTransclude;
>, <Line: -          transcludeFn.$$boundTransclude = boundTranscludeFn;
>, <Line: -        }
>, <Line: -        if (controllerDirectives) {
>, <Line: -          // TODO: merge `controllers` and `elementControllers` into single object.
>, <Line: -          controllers = {};
>, <Line: -          elementControllers = {};
>, <Line: -          forEach(controllerDirectives, function(directive) {
>, <Line: -            var locals = {
>, <Line: -              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
>, <Line: -              $element: $element,
>, <Line: -              $attrs: attrs,
>, <Line: -              $transclude: transcludeFn
>, <Line: -            }, controllerInstance;
>, <Line: -            controller = directive.controller;
>, <Line: -            if (controller == '@') {
>, <Line: -              controller = attrs[directive.name];
>, <Line: -            }
>, <Line: -            controllerInstance = $controller(controller, locals, true, directive.controllerAs);
>, <Line: -            // For directives with element transclusion the element is a comment,
>, <Line: -            // but jQuery .data doesn't support attaching data to comment nodes as it's hard to
>, <Line: -            // clean up (http://bugs.jquery.com/ticket/8335).
>, <Line: -            // Instead, we save the controllers for the element in a local hash and attach to .data
>, <Line: -            // later, once we have the actual element.
>, <Line: -            elementControllers[directive.name] = controllerInstance;
>, <Line: -            if (!hasElementTranscludeDirective) {
>, <Line: -              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
>, <Line: -            }
>, <Line: -            controllers[directive.name] = controllerInstance;
>, <Line: -          });
>, <Line: -        }
>, <Line: -        if (newIsolateScopeDirective) {
>, <Line: -          compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective ||
>, <Line: -              templateDirective === newIsolateScopeDirective.$$originalDirective)));
>, <Line: -          compile.$$addScopeClass($element, true);
>, <Line: -          var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name];
>, <Line: -          var isolateBindingContext = isolateScope;
>, <Line: -          if (isolateScopeController && isolateScopeController.identifier &&
>, <Line: -              newIsolateScopeDirective.bindToController === true) {
>, <Line: -            isolateBindingContext = isolateScopeController.instance;
>, <Line: -          }
>, <Line: -          forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
>, <Line: -            var attrName = definition.attrName,
>, <Line: -                optional = definition.optional,
>, <Line: -                mode = definition.mode, // @, =, or &
>, <Line: -                lastValue,
>, <Line: -                parentGet, parentSet, compare;
>, <Line: -            switch (mode) {
>, <Line: -              case '@':
>, <Line: -                attrs.$observe(attrName, function(value) {
>, <Line: -                  isolateBindingContext[scopeName] = value;
>, <Line: -                });
>, <Line: -                attrs.$$observers[attrName].$$scope = scope;
>, <Line: -                if (attrs[attrName]) {
>, <Line: -                  // If the attribute has been provided then we trigger an interpolation to ensure
>, <Line: -                  // the value is there for use in the link fn
>, <Line: -                  isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope);
>, <Line: -                }
>, <Line: -                break;
>, <Line: -              case '=':
>, <Line: -                if (optional && !attrs[attrName]) {
>, <Line: -                  return;
>, <Line: -                }
>, <Line: -                parentGet = $parse(attrs[attrName]);
>, <Line: -                if (parentGet.literal) {
>, <Line: -                  compare = equals;
>, <Line: -                } else {
>, <Line: -                  compare = function(a, b) { return a === b || (a !== a && b !== b); };
>, <Line: -                }
>, <Line: -                parentSet = parentGet.assign || function() {
>, <Line: -                  // reset the change, or we will throw this exception on every $digest
>, <Line: -                  lastValue = isolateBindingContext[scopeName] = parentGet(scope);
>, <Line: -                  throw $compileMinErr('nonassign',
>, <Line: -                      "Expression '{0}' used with directive '{1}' is non-assignable!",
>, <Line: -                      attrs[attrName], newIsolateScopeDirective.name);
>, <Line: -                };
>, <Line: -                lastValue = isolateBindingContext[scopeName] = parentGet(scope);
>, <Line: -                var parentValueWatch = function parentValueWatch(parentValue) {
>, <Line: -                  if (!compare(parentValue, isolateBindingContext[scopeName])) {
>, <Line: -                    // we are out of sync and need to copy
>, <Line: -                    if (!compare(parentValue, lastValue)) {
>, <Line: -                      // parent changed and it has precedence
>, <Line: -                      isolateBindingContext[scopeName] = parentValue;
>, <Line: -                    } else {
>, <Line: -                      // if the parent can be assigned then do so
>, <Line: -                      parentSet(scope, parentValue = isolateBindingContext[scopeName]);
>, <Line: -                    }
>, <Line: -                  }
>, <Line: -                  return lastValue = parentValue;
>, <Line: -                };
>, <Line: -                parentValueWatch.$stateful = true;
>, <Line: -                var unwatch;
>, <Line: -                if (definition.collection) {
>, <Line: -                  unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
>, <Line: -                } else {
>, <Line: -                  unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
>, <Line: -                }
>, <Line: -                isolateScope.$on('$destroy', unwatch);
>, <Line: -                break;
>, <Line: -              case '&':
>, <Line: -                parentGet = $parse(attrs[attrName]);
>, <Line: -                isolateBindingContext[scopeName] = function(locals) {
>, <Line: -                  return parentGet(scope, locals);
>, <Line: -                };
>, <Line: -                break;
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -        if (controllers) {
>, <Line: -          forEach(controllers, function(controller) {
>, <Line: -            controller();
>, <Line: -          });
>, <Line: -          controllers = null;
>, <Line: -        }
>, <Line: -        // PRELINKING
>, <Line: -        for (i = 0, ii = preLinkFns.length; i < ii; i++) {
>, <Line: -          linkFn = preLinkFns[i];
>, <Line: -          invokeLinkFn(linkFn,
>, <Line: -              linkFn.isolateScope ? isolateScope : scope,
>, <Line: -              $element,
>, <Line: -              attrs,
>, <Line: -              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
>, <Line: -              transcludeFn
>, <Line: -          );
>, <Line: -        }
>, <Line: -        // RECURSION
>, <Line: -        // We only pass the isolate scope, if the isolate directive has a template,
>, <Line: -        // otherwise the child elements do not belong to the isolate directive.
>, <Line: -        var scopeToChild = scope;
>, <Line: -        if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
>, <Line: -          scopeToChild = isolateScope;
>, <Line: -        }
>, <Line: -        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
>, <Line: -        // POSTLINKING
>, <Line: -        for (i = postLinkFns.length - 1; i >= 0; i--) {
>, <Line: -          linkFn = postLinkFns[i];
>, <Line: -          invokeLinkFn(linkFn,
>, <Line: -              linkFn.isolateScope ? isolateScope : scope,
>, <Line: -              $element,
>, <Line: -              attrs,
>, <Line: -              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
>, <Line: -              transcludeFn
>, <Line: -          );
>, <Line: -        }
>, <Line: -        // This is the function that is injected as `$transclude`.
>, <Line: -        // Note: all arguments are optional!
>, <Line: -        function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
>, <Line: -          var transcludeControllers;
>, <Line: -          // No scope passed in:
>, <Line: -          if (!isScope(scope)) {
>, <Line: -            futureParentElement = cloneAttachFn;
>, <Line: -            cloneAttachFn = scope;
>, <Line: -            scope = undefined;
>, <Line: -          }
>, <Line: -          if (hasElementTranscludeDirective) {
>, <Line: -            transcludeControllers = elementControllers;
>, <Line: -          }
>, <Line: -          if (!futureParentElement) {
>, <Line: -            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
>, <Line: -          }
>, <Line: -          return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function markDirectivesAsIsolate(directives) {
>, <Line: -      // mark all directives as needing isolate scope.
>, <Line: -      for (var j = 0, jj = directives.length; j < jj; j++) {
>, <Line: -        directives[j] = inherit(directives[j], {$$isolateScope: true});
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * looks up the directive and decorates it with exception handling and proper parameters. We
>, <Line: -     * call this the boundDirective.
>, <Line: -     *
>, <Line: -     * @param {string} name name of the directive to look up.
>, <Line: -     * @param {string} location The directive must be found in specific format.
>, <Line: -     *   String containing any of theses characters:
>, <Line: -     *
>, <Line: -     *   * `E`: element name
>, <Line: -     *   * `A': attribute
>, <Line: -     *   * `C`: class
>, <Line: -     *   * `M`: comment
>, <Line: -     * @returns {boolean} true if directive was added.
>, <Line: -     */
>, <Line: -    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
>, <Line: -                          endAttrName) {
>, <Line: -      if (name === ignoreDirective) return null;
>, <Line: -      var match = null;
>, <Line: -      if (hasDirectives.hasOwnProperty(name)) {
>, <Line: -        for (var directive, directives = $injector.get(name + Suffix),
>, <Line: -            i = 0, ii = directives.length; i < ii; i++) {
>, <Line: -          try {
>, <Line: -            directive = directives[i];
>, <Line: -            if ((maxPriority === undefined || maxPriority > directive.priority) &&
>, <Line: -                 directive.restrict.indexOf(location) != -1) {
>, <Line: -              if (startAttrName) {
>, <Line: -                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
>, <Line: -              }
>, <Line: -              tDirectives.push(directive);
>, <Line: -              match = directive;
>, <Line: -            }
>, <Line: -          } catch (e) { $exceptionHandler(e); }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return match;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * looks up the directive and returns true if it is a multi-element directive,
>, <Line: -     * and therefore requires DOM nodes between -start and -end markers to be grouped
>, <Line: -     * together.
>, <Line: -     *
>, <Line: -     * @param {string} name name of the directive to look up.
>, <Line: -     * @returns true if directive was registered as multi-element.
>, <Line: -     */
>, <Line: -    function directiveIsMultiElement(name) {
>, <Line: -      if (hasDirectives.hasOwnProperty(name)) {
>, <Line: -        for (var directive, directives = $injector.get(name + Suffix),
>, <Line: -            i = 0, ii = directives.length; i < ii; i++) {
>, <Line: -          directive = directives[i];
>, <Line: -          if (directive.multiElement) {
>, <Line: -            return true;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return false;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * When the element is replaced with HTML template then the new attributes
>, <Line: -     * on the template need to be merged with the existing attributes in the DOM.
>, <Line: -     * The desired effect is to have both of the attributes present.
>, <Line: -     *
>, <Line: -     * @param {object} dst destination attributes (original DOM)
>, <Line: -     * @param {object} src source attributes (from the directive template)
>, <Line: -     */
>, <Line: -    function mergeTemplateAttributes(dst, src) {
>, <Line: -      var srcAttr = src.$attr,
>, <Line: -          dstAttr = dst.$attr,
>, <Line: -          $element = dst.$$element;
>, <Line: -      // reapply the old attributes to the new element
>, <Line: -      forEach(dst, function(value, key) {
>, <Line: -        if (key.charAt(0) != '$') {
>, <Line: -          if (src[key] && src[key] !== value) {
>, <Line: -            value += (key === 'style' ? ';' : ' ') + src[key];
>, <Line: -          }
>, <Line: -          dst.$set(key, value, true, srcAttr[key]);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      // copy the new attributes on the old attrs object
>, <Line: -      forEach(src, function(value, key) {
>, <Line: -        if (key == 'class') {
>, <Line: -          safeAddClass($element, value);
>, <Line: -          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
>, <Line: -        } else if (key == 'style') {
>, <Line: -          $element.attr('style', $element.attr('style') + ';' + value);
>, <Line: -          dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
>, <Line: -          // `dst` will never contain hasOwnProperty as DOM parser won't let it.
>, <Line: -          // You will get an "InvalidCharacterError: DOM Exception 5" error if you
>, <Line: -          // have an attribute like "has-own-property" or "data-has-own-property", etc.
>, <Line: -        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
>, <Line: -          dst[key] = value;
>, <Line: -          dstAttr[key] = srcAttr[key];
>, <Line: -        }
>, <Line: -      });
>, <Line: -    }
>, <Line: -    function compileTemplateUrl(directives, $compileNode, tAttrs,
>, <Line: -        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
>, <Line: -      var linkQueue = [],
>, <Line: -          afterTemplateNodeLinkFn,
>, <Line: -          afterTemplateChildLinkFn,
>, <Line: -          beforeTemplateCompileNode = $compileNode[0],
>, <Line: -          origAsyncDirective = directives.shift(),
>, <Line: -          // The fact that we have to copy and patch the directive seems wrong!
>, <Line: -          derivedSyncDirective = extend({}, origAsyncDirective, {
>, <Line: -            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
>, <Line: -          }),
>, <Line: -          templateUrl = (isFunction(origAsyncDirective.templateUrl))
>, <Line: -              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
>, <Line: -              : origAsyncDirective.templateUrl,
>, <Line: -          templateNamespace = origAsyncDirective.templateNamespace;
>, <Line: -      $compileNode.empty();
>, <Line: -      $templateRequest($sce.getTrustedResourceUrl(templateUrl))
>, <Line: -        .then(function(content) {
>, <Line: -          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
>, <Line: -          content = denormalizeTemplate(content);
>, <Line: -          if (origAsyncDirective.replace) {
>, <Line: -            if (jqLiteIsTextNode(content)) {
>, <Line: -              $template = [];
>, <Line: -            } else {
>, <Line: -              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
>, <Line: -            }
>, <Line: -            compileNode = $template[0];
>, <Line: -            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
>, <Line: -              throw $compileMinErr('tplrt',
>, <Line: -                  "Template for directive '{0}' must have exactly one root element. {1}",
>, <Line: -                  origAsyncDirective.name, templateUrl);
>, <Line: -            }
>, <Line: -            tempTemplateAttrs = {$attr: {}};
>, <Line: -            replaceWith($rootElement, $compileNode, compileNode);
>, <Line: -            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
>, <Line: -            if (isObject(origAsyncDirective.scope)) {
>, <Line: -              markDirectivesAsIsolate(templateDirectives);
>, <Line: -            }
>, <Line: -            directives = templateDirectives.concat(directives);
>, <Line: -            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
>, <Line: -          } else {
>, <Line: -            compileNode = beforeTemplateCompileNode;
>, <Line: -            $compileNode.html(content);
>, <Line: -          }
>, <Line: -          directives.unshift(derivedSyncDirective);
>, <Line: -          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
>, <Line: -              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
>, <Line: -              previousCompileContext);
>, <Line: -          forEach($rootElement, function(node, i) {
>, <Line: -            if (node == compileNode) {
>, <Line: -              $rootElement[i] = $compileNode[0];
>, <Line: -            }
>, <Line: -          });
>, <Line: -          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
>, <Line: -          while (linkQueue.length) {
>, <Line: -            var scope = linkQueue.shift(),
>, <Line: -                beforeTemplateLinkNode = linkQueue.shift(),
>, <Line: -                linkRootElement = linkQueue.shift(),
>, <Line: -                boundTranscludeFn = linkQueue.shift(),
>, <Line: -                linkNode = $compileNode[0];
>, <Line: -            if (scope.$$destroyed) continue;
>, <Line: -            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
>, <Line: -              var oldClasses = beforeTemplateLinkNode.className;
>, <Line: -              if (!(previousCompileContext.hasElementTranscludeDirective &&
>, <Line: -                  origAsyncDirective.replace)) {
>, <Line: -                // it was cloned therefore we have to clone as well.
>, <Line: -                linkNode = jqLiteClone(compileNode);
>, <Line: -              }
>, <Line: -              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
>, <Line: -              // Copy in CSS classes from original node
>, <Line: -              safeAddClass(jqLite(linkNode), oldClasses);
>, <Line: -            }
>, <Line: -            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
>, <Line: -              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
>, <Line: -            } else {
>, <Line: -              childBoundTranscludeFn = boundTranscludeFn;
>, <Line: -            }
>, <Line: -            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
>, <Line: -              childBoundTranscludeFn);
>, <Line: -          }
>, <Line: -          linkQueue = null;
>, <Line: -        });
>, <Line: -      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
>, <Line: -        var childBoundTranscludeFn = boundTranscludeFn;
>, <Line: -        if (scope.$$destroyed) return;
>, <Line: -        if (linkQueue) {
>, <Line: -          linkQueue.push(scope,
>, <Line: -                         node,
>, <Line: -                         rootElement,
>, <Line: -                         childBoundTranscludeFn);
>, <Line: -        } else {
>, <Line: -          if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
>, <Line: -            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
>, <Line: -          }
>, <Line: -          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
>, <Line: -        }
>, <Line: -      };
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Sorting function for bound directives.
>, <Line: -     */
>, <Line: -    function byPriority(a, b) {
>, <Line: -      var diff = b.priority - a.priority;
>, <Line: -      if (diff !== 0) return diff;
>, <Line: -      if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
>, <Line: -      return a.index - b.index;
>, <Line: -    }
>, <Line: -    function assertNoDuplicate(what, previousDirective, directive, element) {
>, <Line: -      if (previousDirective) {
>, <Line: -        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',
>, <Line: -            previousDirective.name, directive.name, what, startingTag(element));
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function addTextInterpolateDirective(directives, text) {
>, <Line: -      var interpolateFn = $interpolate(text, true);
>, <Line: -      if (interpolateFn) {
>, <Line: -        directives.push({
>, <Line: -          priority: 0,
>, <Line: -          compile: function textInterpolateCompileFn(templateNode) {
>, <Line: -            var templateNodeParent = templateNode.parent(),
>, <Line: -                hasCompileParent = !!templateNodeParent.length;
>, <Line: -            // When transcluding a template that has bindings in the root
>, <Line: -            // we don't have a parent and thus need to add the class during linking fn.
>, <Line: -            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
>, <Line: -            return function textInterpolateLinkFn(scope, node) {
>, <Line: -              var parent = node.parent();
>, <Line: -              if (!hasCompileParent) compile.$$addBindingClass(parent);
>, <Line: -              compile.$$addBindingInfo(parent, interpolateFn.expressions);
>, <Line: -              scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
>, <Line: -                node[0].nodeValue = value;
>, <Line: -              });
>, <Line: -            };
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function wrapTemplate(type, template) {
>, <Line: -      type = lowercase(type || 'html');
>, <Line: -      switch (type) {
>, <Line: -      case 'svg':
>, <Line: -      case 'math':
>, <Line: -        var wrapper = document.createElement('div');
>, <Line: -        wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
>, <Line: -        return wrapper.childNodes[0].childNodes;
>, <Line: -      default:
>, <Line: -        return template;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function getTrustedContext(node, attrNormalizedName) {
>, <Line: -      if (attrNormalizedName == "srcdoc") {
>, <Line: -        return $sce.HTML;
>, <Line: -      }
>, <Line: -      var tag = nodeName_(node);
>, <Line: -      // maction[xlink:href] can source SVG.  It's not limited to <maction>.
>, <Line: -      if (attrNormalizedName == "xlinkHref" ||
>, <Line: -          (tag == "form" && attrNormalizedName == "action") ||
>, <Line: -          (tag != "img" && (attrNormalizedName == "src" ||
>, <Line: -                            attrNormalizedName == "ngSrc"))) {
>, <Line: -        return $sce.RESOURCE_URL;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
>, <Line: -      var interpolateFn = $interpolate(value, true);
>, <Line: -      // no interpolation found -> ignore
>, <Line: -      if (!interpolateFn) return;
>, <Line: -      if (name === "multiple" && nodeName_(node) === "select") {
>, <Line: -        throw $compileMinErr("selmulti",
>, <Line: -            "Binding to the 'multiple' attribute is not supported. Element: {0}",
>, <Line: -            startingTag(node));
>, <Line: -      }
>, <Line: -      directives.push({
>, <Line: -        priority: 100,
>, <Line: -        compile: function() {
>, <Line: -            return {
>, <Line: -              pre: function attrInterpolatePreLinkFn(scope, element, attr) {
>, <Line: -                var $$observers = (attr.$$observers || (attr.$$observers = {}));
>, <Line: -                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
>, <Line: -                  throw $compileMinErr('nodomevents',
>, <Line: -                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
>, <Line: -                          "ng- versions (such as ng-click instead of onclick) instead.");
>, <Line: -                }
>, <Line: -                // If the attribute was removed, then we are done
>, <Line: -                if (!attr[name]) {
>, <Line: -                  return;
>, <Line: -                }
>, <Line: -                // we need to interpolate again, in case the attribute value has been updated
>, <Line: -                // (e.g. by another directive's compile function)
>, <Line: -                interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name),
>, <Line: -                    ALL_OR_NOTHING_ATTRS[name] || allOrNothing);
>, <Line: -                // if attribute was updated so that there is no interpolation going on we don't want to
>, <Line: -                // register any observers
>, <Line: -                if (!interpolateFn) return;
>, <Line: -                // initialize attr object so that it's ready in case we need the value for isolate
>, <Line: -                // scope initialization, otherwise the value would not be available from isolate
>, <Line: -                // directive's linking fn during linking phase
>, <Line: -                attr[name] = interpolateFn(scope);
>, <Line: -                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
>, <Line: -                (attr.$$observers && attr.$$observers[name].$$scope || scope).
>, <Line: -                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
>, <Line: -                    //special case for class attribute addition + removal
>, <Line: -                    //so that class changes can tap into the animation
>, <Line: -                    //hooks provided by the $animate service. Be sure to
>, <Line: -                    //skip animations when the first digest occurs (when
>, <Line: -                    //both the new and the old values are the same) since
>, <Line: -                    //the CSS classes are the non-interpolated values
>, <Line: -                    if (name === 'class' && newValue != oldValue) {
>, <Line: -                      attr.$updateClass(newValue, oldValue);
>, <Line: -                    } else {
>, <Line: -                      attr.$set(name, newValue);
>, <Line: -                    }
>, <Line: -                  });
>, <Line: -              }
>, <Line: -            };
>, <Line: -          }
>, <Line: -      });
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * This is a special jqLite.replaceWith, which can replace items which
>, <Line: -     * have no parents, provided that the containing jqLite collection is provided.
>, <Line: -     *
>, <Line: -     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
>, <Line: -     *                               in the root of the tree.
>, <Line: -     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep
>, <Line: -     *                                  the shell, but replace its DOM node reference.
>, <Line: -     * @param {Node} newNode The new DOM node.
>, <Line: -     */
>, <Line: -    function replaceWith($rootElement, elementsToRemove, newNode) {
>, <Line: -      var firstElementToRemove = elementsToRemove[0],
>, <Line: -          removeCount = elementsToRemove.length,
>, <Line: -          parent = firstElementToRemove.parentNode,
>, <Line: -          i, ii;
>, <Line: -      if ($rootElement) {
>, <Line: -        for (i = 0, ii = $rootElement.length; i < ii; i++) {
>, <Line: -          if ($rootElement[i] == firstElementToRemove) {
>, <Line: -            $rootElement[i++] = newNode;
>, <Line: -            for (var j = i, j2 = j + removeCount - 1,
>, <Line: -                     jj = $rootElement.length;
>, <Line: -                 j < jj; j++, j2++) {
>, <Line: -              if (j2 < jj) {
>, <Line: -                $rootElement[j] = $rootElement[j2];
>, <Line: -              } else {
>, <Line: -                delete $rootElement[j];
>, <Line: -              }
>, <Line: -            }
>, <Line: -            $rootElement.length -= removeCount - 1;
>, <Line: -            // If the replaced element is also the jQuery .context then replace it
>, <Line: -            // .context is a deprecated jQuery api, so we should set it only when jQuery set it
>, <Line: -            // http://api.jquery.com/context/
>, <Line: -            if ($rootElement.context === firstElementToRemove) {
>, <Line: -              $rootElement.context = newNode;
>, <Line: -            }
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (parent) {
>, <Line: -        parent.replaceChild(newNode, firstElementToRemove);
>, <Line: -      }
>, <Line: -      // TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?
>, <Line: -      var fragment = document.createDocumentFragment();
>, <Line: -      fragment.appendChild(firstElementToRemove);
>, <Line: -      // Copy over user data (that includes Angular's $scope etc.). Don't copy private
>, <Line: -      // data here because there's no public interface in jQuery to do that and copying over
>, <Line: -      // event listeners (which is the main use of private data) wouldn't work anyway.
>, <Line: -      jqLite(newNode).data(jqLite(firstElementToRemove).data());
>, <Line: -      // Remove data of the replaced element. We cannot just call .remove()
>, <Line: -      // on the element it since that would deallocate scope that is needed
>, <Line: -      // for the new node. Instead, remove the data "manually".
>, <Line: -      if (!jQuery) {
>, <Line: -        delete jqLite.cache[firstElementToRemove[jqLite.expando]];
>, <Line: -      } else {
>, <Line: -        // jQuery 2.x doesn't expose the data storage. Use jQuery.cleanData to clean up after
>, <Line: -        // the replaced element. The cleanData version monkey-patched by Angular would cause
>, <Line: -        // the scope to be trashed and we do need the very same scope to work with the new
>, <Line: -        // element. However, we cannot just cache the non-patched version and use it here as
>, <Line: -        // that would break if another library patches the method after Angular does (one
>, <Line: -        // example is jQuery UI). Instead, set a flag indicating scope destroying should be
>, <Line: -        // skipped this one time.
>, <Line: -        skipDestroyOnNextJQueryCleanData = true;
>, <Line: -        jQuery.cleanData([firstElementToRemove]);
>, <Line: -      }
>, <Line: -      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
>, <Line: -        var element = elementsToRemove[k];
>, <Line: -        jqLite(element).remove(); // must do this way to clean up expando
>, <Line: -        fragment.appendChild(element);
>, <Line: -        delete elementsToRemove[k];
>, <Line: -      }
>, <Line: -      elementsToRemove[0] = newNode;
>, <Line: -      elementsToRemove.length = 1;
>, <Line: -    }
>, <Line: -    function cloneAndAnnotateFn(fn, annotation) {
>, <Line: -      return extend(function() { return fn.apply(null, arguments); }, fn, annotation);
>, <Line: -    }
>, <Line: -    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
>, <Line: -      try {
>, <Line: -        linkFn(scope, $element, attrs, controllers, transcludeFn);
>, <Line: -      } catch (e) {
>, <Line: -        $exceptionHandler(e, startingTag($element));
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
>, <Line: -/**
>, <Line: - * Converts all accepted directives format into proper directive name.
>, <Line: - * All of these will become 'myDirective':
>, <Line: - *   my:Directive
>, <Line: - *   my-directive
>, <Line: - *   x-my-directive
>, <Line: - *   data-my:directive
>, <Line: - *
>, <Line: - * Also there is special case for Moz prefix starting with upper case letter.
>, <Line: - * @param name Name to normalize
>, <Line: - */
>, <Line: -function directiveNormalize(name) {
>, <Line: -  return camelCase(name.replace(PREFIX_REGEXP, ''));
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name $compile.directive.Attributes
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A shared object between directive compile / linking functions which contains normalized DOM
>, <Line: - * element attributes. The values reflect current binding state `{{ }}`. The normalization is
>, <Line: - * needed since all of these are treated as equivalent in Angular:
>, <Line: - *
>, <Line: - * ```
>, <Line: - *    <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
>, <Line: - * ```
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc property
>, <Line: - * @name $compile.directive.Attributes#$attr
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A map of DOM element attribute names to the normalized name. This is
>, <Line: - * needed to do reverse lookup from normalized name back to actual name.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $compile.directive.Attributes#$set
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Set DOM element attribute value.
>, <Line: - *
>, <Line: - *
>, <Line: - * @param {string} name Normalized element attribute name of the property to modify. The name is
>, <Line: - *          reverse-translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
>, <Line: - *          property to the original name.
>, <Line: - * @param {string} value Value to set the attribute to. The value can be an interpolated string.
>, <Line: - */
>, <Line: -/**
>, <Line: - * Closure compiler type information
>, <Line: - */
>, <Line: -function nodesetLinkingFn(
>, <Line: -  /* angular.Scope */ scope,
>, <Line: -  /* NodeList */ nodeList,
>, <Line: -  /* Element */ rootElement,
>, <Line: -  /* function(Function) */ boundTranscludeFn
>, <Line: -) {}
>, <Line: -function directiveLinkingFn(
>, <Line: -  /* nodesetLinkingFn */ nodesetLinkingFn,
>, <Line: -  /* angular.Scope */ scope,
>, <Line: -  /* Node */ node,
>, <Line: -  /* Element */ rootElement,
>, <Line: -  /* function(Function) */ boundTranscludeFn
>, <Line: -) {}
>, <Line: -function tokenDifference(str1, str2) {
>, <Line: -  var values = '',
>, <Line: -      tokens1 = str1.split(/\s+/),
>, <Line: -      tokens2 = str2.split(/\s+/);
>, <Line: -  outer:
>, <Line: -  for (var i = 0; i < tokens1.length; i++) {
>, <Line: -    var token = tokens1[i];
>, <Line: -    for (var j = 0; j < tokens2.length; j++) {
>, <Line: -      if (token == tokens2[j]) continue outer;
>, <Line: -    }
>, <Line: -    values += (values.length > 0 ? ' ' : '') + token;
>, <Line: -  }
>, <Line: -  return values;
>, <Line: -}
>, <Line: -function removeComments(jqNodes) {
>, <Line: -  jqNodes = jqLite(jqNodes);
>, <Line: -  var i = jqNodes.length;
>, <Line: -  if (i <= 1) {
>, <Line: -    return jqNodes;
>, <Line: -  }
>, <Line: -  while (i--) {
>, <Line: -    var node = jqNodes[i];
>, <Line: -    if (node.nodeType === NODE_TYPE_COMMENT) {
>, <Line: -      splice.call(jqNodes, i, 1);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return jqNodes;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $controllerProvider
>, <Line: - * @description
>, <Line: - * The {@link ng.$controller $controller service} is used by Angular to create new
>, <Line: - * controllers.
>, <Line: - *
>, <Line: - * This provider allows controller registration via the
>, <Line: - * {@link ng.$controllerProvider#register register} method.
>, <Line: - */
>, <Line: -function $ControllerProvider() {
>, <Line: -  var controllers = {},
>, <Line: -      globals = false,
>, <Line: -      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $controllerProvider#register
>, <Line: -   * @param {string|Object} name Controller name, or an object map of controllers where the keys are
>, <Line: -   *    the names and the values are the constructors.
>, <Line: -   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
>, <Line: -   *    annotations in the array notation).
>, <Line: -   */
>, <Line: -  this.register = function(name, constructor) {
>, <Line: -    assertNotHasOwnProperty(name, 'controller');
>, <Line: -    if (isObject(name)) {
>, <Line: -      extend(controllers, name);
>, <Line: -    } else {
>, <Line: -      controllers[name] = constructor;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $controllerProvider#allowGlobals
>, <Line: -   * @description If called, allows `$controller` to find controller constructors on `window`
>, <Line: -   */
>, <Line: -  this.allowGlobals = function() {
>, <Line: -    globals = true;
>, <Line: -  };
>, <Line: -  this.$get = ['$injector', '$window', function($injector, $window) {
>, <Line: -    /**
>, <Line: -     * @ngdoc service
>, <Line: -     * @name $controller
>, <Line: -     * @requires $injector
>, <Line: -     *
>, <Line: -     * @param {Function|string} constructor If called with a function then it's considered to be the
>, <Line: -     *    controller constructor function. Otherwise it's considered to be a string which is used
>, <Line: -     *    to retrieve the controller constructor using the following steps:
>, <Line: -     *
>, <Line: -     *    * check if a controller with given name is registered via `$controllerProvider`
>, <Line: -     *    * check if evaluating the string on the current scope returns a constructor
>, <Line: -     *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global
>, <Line: -     *      `window` object (not recommended)
>, <Line: -     *
>, <Line: -     *    The string can use the `controller as property` syntax, where the controller instance is published
>, <Line: -     *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this
>, <Line: -     *    to work correctly.
>, <Line: -     *
>, <Line: -     * @param {Object} locals Injection locals for Controller.
>, <Line: -     * @return {Object} Instance of given controller.
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * `$controller` service is responsible for instantiating controllers.
>, <Line: -     *
>, <Line: -     * It's just a simple call to {@link auto.$injector $injector}, but extracted into
>, <Line: -     * a service, so that one can override this service with [BC version](https://gist.github.com/1649788).
>, <Line: -     */
>, <Line: -    return function(expression, locals, later, ident) {
>, <Line: -      // PRIVATE API:
>, <Line: -      //   param `later` --- indicates that the controller's constructor is invoked at a later time.
>, <Line: -      //                     If true, $controller will allocate the object with the correct
>, <Line: -      //                     prototype chain, but will not invoke the controller until a returned
>, <Line: -      //                     callback is invoked.
>, <Line: -      //   param `ident` --- An optional label which overrides the label parsed from the controller
>, <Line: -      //                     expression, if any.
>, <Line: -      var instance, match, constructor, identifier;
>, <Line: -      later = later === true;
>, <Line: -      if (ident && isString(ident)) {
>, <Line: -        identifier = ident;
>, <Line: -      }
>, <Line: -      if (isString(expression)) {
>, <Line: -        match = expression.match(CNTRL_REG),
>, <Line: -        constructor = match[1],
>, <Line: -        identifier = identifier || match[3];
>, <Line: -        expression = controllers.hasOwnProperty(constructor)
>, <Line: -            ? controllers[constructor]
>, <Line: -            : getter(locals.$scope, constructor, true) ||
>, <Line: -                (globals ? getter($window, constructor, true) : undefined);
>, <Line: -        assertArgFn(expression, constructor, true);
>, <Line: -      }
>, <Line: -      if (later) {
>, <Line: -        // Instantiate controller later:
>, <Line: -        // This machinery is used to create an instance of the object before calling the
>, <Line: -        // controller's constructor itself.
>, <Line: -        //
>, <Line: -        // This allows properties to be added to the controller before the constructor is
>, <Line: -        // invoked. Primarily, this is used for isolate scope bindings in $compile.
>, <Line: -        //
>, <Line: -        // This feature is not intended for use by applications, and is thus not documented
>, <Line: -        // publicly.
>, <Line: -        // Object creation: http://jsperf.com/create-constructor/2
>, <Line: -        var controllerPrototype = (isArray(expression) ?
>, <Line: -          expression[expression.length - 1] : expression).prototype;
>, <Line: -        instance = Object.create(controllerPrototype);
>, <Line: -        if (identifier) {
>, <Line: -          addIdentifier(locals, identifier, instance, constructor || expression.name);
>, <Line: -        }
>, <Line: -        return extend(function() {
>, <Line: -          $injector.invoke(expression, instance, locals, constructor);
>, <Line: -          return instance;
>, <Line: -        }, {
>, <Line: -          instance: instance,
>, <Line: -          identifier: identifier
>, <Line: -        });
>, <Line: -      }
>, <Line: -      instance = $injector.instantiate(expression, locals, constructor);
>, <Line: -      if (identifier) {
>, <Line: -        addIdentifier(locals, identifier, instance, constructor || expression.name);
>, <Line: -      }
>, <Line: -      return instance;
>, <Line: -    };
>, <Line: -    function addIdentifier(locals, identifier, instance, name) {
>, <Line: -      if (!(locals && isObject(locals.$scope))) {
>, <Line: -        throw minErr('$controller')('noscp',
>, <Line: -          "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
>, <Line: -          name, identifier);
>, <Line: -      }
>, <Line: -      locals.$scope[identifier] = instance;
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $document
>, <Line: - * @requires $window
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A {@link angular.element jQuery or jqLite} wrapper for the browser's `window.document` object.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="documentExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <p>$document title: <b ng-bind="title"></b></p>
>, <Line: -         <p>window.document title: <b ng-bind="windowTitle"></b></p>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="script.js">
>, <Line: -       angular.module('documentExample', [])
>, <Line: -         .controller('ExampleController', ['$scope', '$document', function($scope, $document) {
>, <Line: -           $scope.title = $document[0].title;
>, <Line: -           $scope.windowTitle = angular.element(window.document)[0].title;
>, <Line: -         }]);
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -function $DocumentProvider() {
>, <Line: -  this.$get = ['$window', function(window) {
>, <Line: -    return jqLite(window.document);
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $exceptionHandler
>, <Line: - * @requires ng.$log
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Any uncaught exception in angular expressions is delegated to this service.
>, <Line: - * The default implementation simply delegates to `$log.error` which logs it into
>, <Line: - * the browser console.
>, <Line: - *
>, <Line: - * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
>, <Line: - * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
>, <Line: - *
>, <Line: - * ## Example:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   angular.module('exceptionOverride', []).factory('$exceptionHandler', function() {
>, <Line: - *     return function(exception, cause) {
>, <Line: - *       exception.message += ' (caused by "' + cause + '")';
>, <Line: - *       throw exception;
>, <Line: - *     };
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * This example will override the normal action of `$exceptionHandler`, to make angular
>, <Line: - * exceptions fail hard when they happen, instead of just logging to the console.
>, <Line: - *
>, <Line: - * <hr />
>, <Line: - * Note, that code executed in event-listeners (even those registered using jqLite's `on`/`bind`
>, <Line: - * methods) does not delegate exceptions to the {@link ng.$exceptionHandler $exceptionHandler}
>, <Line: - * (unless executed during a digest).
>, <Line: - *
>, <Line: - * If you wish, you can manually delegate exceptions, e.g.
>, <Line: - * `try { ... } catch(e) { $exceptionHandler(e); }`
>, <Line: - *
>, <Line: - * @param {Error} exception Exception associated with the error.
>, <Line: - * @param {string=} cause optional information about the context in which
>, <Line: - *       the error was thrown.
>, <Line: - *
>, <Line: - */
>, <Line: -function $ExceptionHandlerProvider() {
>, <Line: -  this.$get = ['$log', function($log) {
>, <Line: -    return function(exception, cause) {
>, <Line: -      $log.error.apply($log, arguments);
>, <Line: -    };
>, <Line: -  }];
>, <Line: -}
>, <Line: -var APPLICATION_JSON = 'application/json';
>, <Line: -var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
>, <Line: -var JSON_START = /^\s*(\[|\{[^\{])/;
>, <Line: -var JSON_END = /[\}\]]\s*$/;
>, <Line: -var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
>, <Line: -function defaultHttpResponseTransform(data, headers) {
>, <Line: -  if (isString(data)) {
>, <Line: -    // strip json vulnerability protection prefix
>, <Line: -    data = data.replace(JSON_PROTECTION_PREFIX, '');
>, <Line: -    var contentType = headers('Content-Type');
>, <Line: -    if ((contentType && contentType.indexOf(APPLICATION_JSON) === 0 && data.trim()) ||
>, <Line: -        (JSON_START.test(data) && JSON_END.test(data))) {
>, <Line: -      data = fromJson(data);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return data;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Parse headers into key value object
>, <Line: - *
>, <Line: - * @param {string} headers Raw headers as a string
>, <Line: - * @returns {Object} Parsed headers as key value object
>, <Line: - */
>, <Line: -function parseHeaders(headers) {
>, <Line: -  var parsed = createMap(), key, val, i;
>, <Line: -  if (!headers) return parsed;
>, <Line: -  forEach(headers.split('\n'), function(line) {
>, <Line: -    i = line.indexOf(':');
>, <Line: -    key = lowercase(trim(line.substr(0, i)));
>, <Line: -    val = trim(line.substr(i + 1));
>, <Line: -    if (key) {
>, <Line: -      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
>, <Line: -    }
>, <Line: -  });
>, <Line: -  return parsed;
>, <Line: -}
>, <Line: -/**
>, <Line: - * Returns a function that provides access to parsed headers.
>, <Line: - *
>, <Line: - * Headers are lazy parsed when first requested.
>, <Line: - * @see parseHeaders
>, <Line: - *
>, <Line: - * @param {(string|Object)} headers Headers to provide access to.
>, <Line: - * @returns {function(string=)} Returns a getter function which if called with:
>, <Line: - *
>, <Line: - *   - if called with single an argument returns a single header value or null
>, <Line: - *   - if called with no arguments returns an object containing all headers.
>, <Line: - */
>, <Line: -function headersGetter(headers) {
>, <Line: -  var headersObj = isObject(headers) ? headers : undefined;
>, <Line: -  return function(name) {
>, <Line: -    if (!headersObj) headersObj =  parseHeaders(headers);
>, <Line: -    if (name) {
>, <Line: -      var value = headersObj[lowercase(name)];
>, <Line: -      if (value === void 0) {
>, <Line: -        value = null;
>, <Line: -      }
>, <Line: -      return value;
>, <Line: -    }
>, <Line: -    return headersObj;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * Chain all given functions
>, <Line: - *
>, <Line: - * This function is used for both request and response transforming
>, <Line: - *
>, <Line: - * @param {*} data Data to transform.
>, <Line: - * @param {function(string=)} headers Http headers getter fn.
>, <Line: - * @param {(Function|Array.<Function>)} fns Function or an array of functions.
>, <Line: - * @returns {*} Transformed data.
>, <Line: - */
>, <Line: -function transformData(data, headers, fns) {
>, <Line: -  if (isFunction(fns))
>, <Line: -    return fns(data, headers);
>, <Line: -  forEach(fns, function(fn) {
>, <Line: -    data = fn(data, headers);
>, <Line: -  });
>, <Line: -  return data;
>, <Line: -}
>, <Line: -function isSuccess(status) {
>, <Line: -  return 200 <= status && status < 300;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $httpProvider
>, <Line: - * @description
>, <Line: - * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
>, <Line: - * */
>, <Line: -function $HttpProvider() {
>, <Line: -  /**
>, <Line: -   * @ngdoc property
>, <Line: -   * @name $httpProvider#defaults
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * Object containing default values for all {@link ng.$http $http} requests.
>, <Line: -   *
>, <Line: -   * - **`defaults.cache`** - {Object} - an object built with {@link ng.$cacheFactory `$cacheFactory`}
>, <Line: -   * that will provide the cache for all requests who set their `cache` property to `true`.
>, <Line: -   * If you set the `default.cache = false` then only requests that specify their own custom
>, <Line: -   * cache object will be cached. See {@link $http#caching $http Caching} for more information.
>, <Line: -   *
>, <Line: -   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
>, <Line: -   * Defaults value is `'XSRF-TOKEN'`.
>, <Line: -   *
>, <Line: -   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
>, <Line: -   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
>, <Line: -   *
>, <Line: -   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
>, <Line: -   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
>, <Line: -   * setting default headers.
>, <Line: -   *     - **`defaults.headers.common`**
>, <Line: -   *     - **`defaults.headers.post`**
>, <Line: -   *     - **`defaults.headers.put`**
>, <Line: -   *     - **`defaults.headers.patch`**
>, <Line: -   *
>, <Line: -   **/
>, <Line: -  var defaults = this.defaults = {
>, <Line: -    // transform incoming response data
>, <Line: -    transformResponse: [defaultHttpResponseTransform],
>, <Line: -    // transform outgoing request data
>, <Line: -    transformRequest: [function(d) {
>, <Line: -      return isObject(d) && !isFile(d) && !isBlob(d) ? toJson(d) : d;
>, <Line: -    }],
>, <Line: -    // default headers
>, <Line: -    headers: {
>, <Line: -      common: {
>, <Line: -        'Accept': 'application/json, text/plain, */*'
>, <Line: -      },
>, <Line: -      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
>, <Line: -      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
>, <Line: -      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
>, <Line: -    },
>, <Line: -    xsrfCookieName: 'XSRF-TOKEN',
>, <Line: -    xsrfHeaderName: 'X-XSRF-TOKEN'
>, <Line: -  };
>, <Line: -  var useApplyAsync = false;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $httpProvider#useApplyAsync
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * Configure $http service to combine processing of multiple http responses received at around
>, <Line: -   * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in
>, <Line: -   * significant performance improvement for bigger applications that make many HTTP requests
>, <Line: -   * concurrently (common during application bootstrap).
>, <Line: -   *
>, <Line: -   * Defaults to false. If no value is specifed, returns the current configured value.
>, <Line: -   *
>, <Line: -   * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred
>, <Line: -   *    "apply" on the next tick, giving time for subsequent requests in a roughly ~10ms window
>, <Line: -   *    to load and share the same digest cycle.
>, <Line: -   *
>, <Line: -   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
>, <Line: -   *    otherwise, returns the current configured value.
>, <Line: -   **/
>, <Line: -  this.useApplyAsync = function(value) {
>, <Line: -    if (isDefined(value)) {
>, <Line: -      useApplyAsync = !!value;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    return useApplyAsync;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc property
>, <Line: -   * @name $httpProvider#interceptors
>, <Line: -   * @description
>, <Line: -   *
>, <Line: -   * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
>, <Line: -   * pre-processing of request or postprocessing of responses.
>, <Line: -   *
>, <Line: -   * These service factories are ordered by request, i.e. they are applied in the same order as the
>, <Line: -   * array, on request, but reverse order, on response.
>, <Line: -   *
>, <Line: -   * {@link ng.$http#interceptors Interceptors detailed info}
>, <Line: -   **/
>, <Line: -  var interceptorFactories = this.interceptors = [];
>, <Line: -  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
>, <Line: -      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
>, <Line: -    var defaultCache = $cacheFactory('$http');
>, <Line: -    /**
>, <Line: -     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
>, <Line: -     * The reversal is needed so that we can build up the interception chain around the
>, <Line: -     * server request.
>, <Line: -     */
>, <Line: -    var reversedInterceptors = [];
>, <Line: -    forEach(interceptorFactories, function(interceptorFactory) {
>, <Line: -      reversedInterceptors.unshift(isString(interceptorFactory)
>, <Line: -          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
>, <Line: -    });
>, <Line: -    /**
>, <Line: -     * @ngdoc service
>, <Line: -     * @kind function
>, <Line: -     * @name $http
>, <Line: -     * @requires ng.$httpBackend
>, <Line: -     * @requires $cacheFactory
>, <Line: -     * @requires $rootScope
>, <Line: -     * @requires $q
>, <Line: -     * @requires $injector
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * The `$http` service is a core Angular service that facilitates communication with the remote
>, <Line: -     * HTTP servers via the browser's [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)
>, <Line: -     * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).
>, <Line: -     *
>, <Line: -     * For unit testing applications that use `$http` service, see
>, <Line: -     * {@link ngMock.$httpBackend $httpBackend mock}.
>, <Line: -     *
>, <Line: -     * For a higher level of abstraction, please check out the {@link ngResource.$resource
>, <Line: -     * $resource} service.
>, <Line: -     *
>, <Line: -     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
>, <Line: -     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
>, <Line: -     * it is important to familiarize yourself with these APIs and the guarantees they provide.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ## General usage
>, <Line: -     * The `$http` service is a function which takes a single argument  a configuration object 
>, <Line: -     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
>, <Line: -     * with two $http specific methods: `success` and `error`.
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   // Simple GET request example :
>, <Line: -     *   $http.get('/someUrl').
>, <Line: -     *     success(function(data, status, headers, config) {
>, <Line: -     *       // this callback will be called asynchronously
>, <Line: -     *       // when the response is available
>, <Line: -     *     }).
>, <Line: -     *     error(function(data, status, headers, config) {
>, <Line: -     *       // called asynchronously if an error occurs
>, <Line: -     *       // or server returns response with an error status.
>, <Line: -     *     });
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   // Simple POST request example (passing data) :
>, <Line: -     *   $http.post('/someUrl', {msg:'hello word!'}).
>, <Line: -     *     success(function(data, status, headers, config) {
>, <Line: -     *       // this callback will be called asynchronously
>, <Line: -     *       // when the response is available
>, <Line: -     *     }).
>, <Line: -     *     error(function(data, status, headers, config) {
>, <Line: -     *       // called asynchronously if an error occurs
>, <Line: -     *       // or server returns response with an error status.
>, <Line: -     *     });
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * Since the returned value of calling the $http function is a `promise`, you can also use
>, <Line: -     * the `then` method to register callbacks, and these callbacks will receive a single argument 
>, <Line: -     * an object representing the response. See the API signature and type info below for more
>, <Line: -     * details.
>, <Line: -     *
>, <Line: -     * A response status code between 200 and 299 is considered a success status and
>, <Line: -     * will result in the success callback being called. Note that if the response is a redirect,
>, <Line: -     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
>, <Line: -     * called for such responses.
>, <Line: -     *
>, <Line: -     * ## Writing Unit Tests that use $http
>, <Line: -     * When unit testing (using {@link ngMock ngMock}), it is necessary to call
>, <Line: -     * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush each pending
>, <Line: -     * request using trained responses.
>, <Line: -     *
>, <Line: -     * ```
>, <Line: -     * $httpBackend.expectGET(...);
>, <Line: -     * $http.get(...);
>, <Line: -     * $httpBackend.flush();
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * ## Shortcut methods
>, <Line: -     *
>, <Line: -     * Shortcut methods are also available. All shortcut methods require passing in the URL, and
>, <Line: -     * request data must be passed in for POST/PUT requests.
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   $http.get('/someUrl').success(successCallback);
>, <Line: -     *   $http.post('/someUrl', data).success(successCallback);
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * Complete list of shortcut methods:
>, <Line: -     *
>, <Line: -     * - {@link ng.$http#get $http.get}
>, <Line: -     * - {@link ng.$http#head $http.head}
>, <Line: -     * - {@link ng.$http#post $http.post}
>, <Line: -     * - {@link ng.$http#put $http.put}
>, <Line: -     * - {@link ng.$http#delete $http.delete}
>, <Line: -     * - {@link ng.$http#jsonp $http.jsonp}
>, <Line: -     * - {@link ng.$http#patch $http.patch}
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ## Setting HTTP Headers
>, <Line: -     *
>, <Line: -     * The $http service will automatically add certain HTTP headers to all requests. These defaults
>, <Line: -     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
>, <Line: -     * object, which currently contains this default configuration:
>, <Line: -     *
>, <Line: -     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
>, <Line: -     *   - `Accept: application/json, text/plain, * / *`
>, <Line: -     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
>, <Line: -     *   - `Content-Type: application/json`
>, <Line: -     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
>, <Line: -     *   - `Content-Type: application/json`
>, <Line: -     *
>, <Line: -     * To add or overwrite these defaults, simply add or remove a property from these configuration
>, <Line: -     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
>, <Line: -     * with the lowercased HTTP method name as the key, e.g.
>, <Line: -     * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }.
>, <Line: -     *
>, <Line: -     * The defaults can also be set at runtime via the `$http.defaults` object in the same
>, <Line: -     * fashion. For example:
>, <Line: -     *
>, <Line: -     * ```
>, <Line: -     * module.run(function($http) {
>, <Line: -     *   $http.defaults.headers.common.Authorization = 'Basic YmVlcDpib29w'
>, <Line: -     * });
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * In addition, you can supply a `headers` property in the config object passed when
>, <Line: -     * calling `$http(config)`, which overrides the defaults without changing them globally.
>, <Line: -     *
>, <Line: -     * To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis,
>, <Line: -     * Use the `headers` property, setting the desired header to `undefined`. For example:
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     * var req = {
>, <Line: -     *  method: 'POST',
>, <Line: -     *  url: 'http://example.com',
>, <Line: -     *  headers: {
>, <Line: -     *    'Content-Type': undefined
>, <Line: -     *  },
>, <Line: -     *  data: { test: 'test' },
>, <Line: -     * }
>, <Line: -     *
>, <Line: -     * $http(req).success(function(){...}).error(function(){...});
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * ## Transforming Requests and Responses
>, <Line: -     *
>, <Line: -     * Both requests and responses can be transformed using transformation functions: `transformRequest`
>, <Line: -     * and `transformResponse`. These properties can be a single function that returns
>, <Line: -     * the transformed value (`{function(data, headersGetter)`) or an array of such transformation functions,
>, <Line: -     * which allows you to `push` or `unshift` a new transformation function into the transformation chain.
>, <Line: -     *
>, <Line: -     * ### Default Transformations
>, <Line: -     *
>, <Line: -     * The `$httpProvider` provider and `$http` service expose `defaults.transformRequest` and
>, <Line: -     * `defaults.transformResponse` properties. If a request does not provide its own transformations
>, <Line: -     * then these will be applied.
>, <Line: -     *
>, <Line: -     * You can augment or replace the default transformations by modifying these properties by adding to or
>, <Line: -     * replacing the array.
>, <Line: -     *
>, <Line: -     * Angular provides the following default transformations:
>, <Line: -     *
>, <Line: -     * Request transformations (`$httpProvider.defaults.transformRequest` and `$http.defaults.transformRequest`):
>, <Line: -     *
>, <Line: -     * - If the `data` property of the request configuration object contains an object, serialize it
>, <Line: -     *   into JSON format.
>, <Line: -     *
>, <Line: -     * Response transformations (`$httpProvider.defaults.transformResponse` and `$http.defaults.transformResponse`):
>, <Line: -     *
>, <Line: -     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
>, <Line: -     *  - If JSON response is detected, deserialize it using a JSON parser.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ### Overriding the Default Transformations Per Request
>, <Line: -     *
>, <Line: -     * If you wish override the request/response transformations only for a single request then provide
>, <Line: -     * `transformRequest` and/or `transformResponse` properties on the configuration object passed
>, <Line: -     * into `$http`.
>, <Line: -     *
>, <Line: -     * Note that if you provide these properties on the config object the default transformations will be
>, <Line: -     * overwritten. If you wish to augment the default transformations then you must include them in your
>, <Line: -     * local transformation array.
>, <Line: -     *
>, <Line: -     * The following code demonstrates adding a new response transformation to be run after the default response
>, <Line: -     * transformations have been run.
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     * function appendTransform(defaults, transform) {
>, <Line: -     *
>, <Line: -     *   // We can't guarantee that the default transformation is an array
>, <Line: -     *   defaults = angular.isArray(defaults) ? defaults : [defaults];
>, <Line: -     *
>, <Line: -     *   // Append the new transformation to the defaults
>, <Line: -     *   return defaults.concat(transform);
>, <Line: -     * }
>, <Line: -     *
>, <Line: -     * $http({
>, <Line: -     *   url: '...',
>, <Line: -     *   method: 'GET',
>, <Line: -     *   transformResponse: appendTransform($http.defaults.transformResponse, function(value) {
>, <Line: -     *     return doTransform(value);
>, <Line: -     *   })
>, <Line: -     * });
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ## Caching
>, <Line: -     *
>, <Line: -     * To enable caching, set the request configuration `cache` property to `true` (to use default
>, <Line: -     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).
>, <Line: -     * When the cache is enabled, `$http` stores the response from the server in the specified
>, <Line: -     * cache. The next time the same request is made, the response is served from the cache without
>, <Line: -     * sending a request to the server.
>, <Line: -     *
>, <Line: -     * Note that even if the response is served from cache, delivery of the data is asynchronous in
>, <Line: -     * the same way that real requests are.
>, <Line: -     *
>, <Line: -     * If there are multiple GET requests for the same URL that should be cached using the same
>, <Line: -     * cache, but the cache is not populated yet, only one request to the server will be made and
>, <Line: -     * the remaining requests will be fulfilled using the response from the first request.
>, <Line: -     *
>, <Line: -     * You can change the default cache to a new object (built with
>, <Line: -     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the
>, <Line: -     * {@link ng.$http#defaults `$http.defaults.cache`} property. All requests who set
>, <Line: -     * their `cache` property to `true` will now use this cache object.
>, <Line: -     *
>, <Line: -     * If you set the default cache to `false` then only requests that specify their own custom
>, <Line: -     * cache object will be cached.
>, <Line: -     *
>, <Line: -     * ## Interceptors
>, <Line: -     *
>, <Line: -     * Before you start creating interceptors, be sure to understand the
>, <Line: -     * {@link ng.$q $q and deferred/promise APIs}.
>, <Line: -     *
>, <Line: -     * For purposes of global error handling, authentication, or any kind of synchronous or
>, <Line: -     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
>, <Line: -     * able to intercept requests before they are handed to the server and
>, <Line: -     * responses before they are handed over to the application code that
>, <Line: -     * initiated these requests. The interceptors leverage the {@link ng.$q
>, <Line: -     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
>, <Line: -     *
>, <Line: -     * The interceptors are service factories that are registered with the `$httpProvider` by
>, <Line: -     * adding them to the `$httpProvider.interceptors` array. The factory is called and
>, <Line: -     * injected with dependencies (if specified) and returns the interceptor.
>, <Line: -     *
>, <Line: -     * There are two kinds of interceptors (and two kinds of rejection interceptors):
>, <Line: -     *
>, <Line: -     *   * `request`: interceptors get called with a http `config` object. The function is free to
>, <Line: -     *     modify the `config` object or create a new one. The function needs to return the `config`
>, <Line: -     *     object directly, or a promise containing the `config` or a new `config` object.
>, <Line: -     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or
>, <Line: -     *     resolved with a rejection.
>, <Line: -     *   * `response`: interceptors get called with http `response` object. The function is free to
>, <Line: -     *     modify the `response` object or create a new one. The function needs to return the `response`
>, <Line: -     *     object directly, or as a promise containing the `response` or a new `response` object.
>, <Line: -     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or
>, <Line: -     *     resolved with a rejection.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   // register the interceptor as a service
>, <Line: -     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
>, <Line: -     *     return {
>, <Line: -     *       // optional method
>, <Line: -     *       'request': function(config) {
>, <Line: -     *         // do something on success
>, <Line: -     *         return config;
>, <Line: -     *       },
>, <Line: -     *
>, <Line: -     *       // optional method
>, <Line: -     *      'requestError': function(rejection) {
>, <Line: -     *         // do something on error
>, <Line: -     *         if (canRecover(rejection)) {
>, <Line: -     *           return responseOrNewPromise
>, <Line: -     *         }
>, <Line: -     *         return $q.reject(rejection);
>, <Line: -     *       },
>, <Line: -     *
>, <Line: -     *
>, <Line: -     *
>, <Line: -     *       // optional method
>, <Line: -     *       'response': function(response) {
>, <Line: -     *         // do something on success
>, <Line: -     *         return response;
>, <Line: -     *       },
>, <Line: -     *
>, <Line: -     *       // optional method
>, <Line: -     *      'responseError': function(rejection) {
>, <Line: -     *         // do something on error
>, <Line: -     *         if (canRecover(rejection)) {
>, <Line: -     *           return responseOrNewPromise
>, <Line: -     *         }
>, <Line: -     *         return $q.reject(rejection);
>, <Line: -     *       }
>, <Line: -     *     };
>, <Line: -     *   });
>, <Line: -     *
>, <Line: -     *   $httpProvider.interceptors.push('myHttpInterceptor');
>, <Line: -     *
>, <Line: -     *
>, <Line: -     *   // alternatively, register the interceptor via an anonymous factory
>, <Line: -     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
>, <Line: -     *     return {
>, <Line: -     *      'request': function(config) {
>, <Line: -     *          // same as above
>, <Line: -     *       },
>, <Line: -     *
>, <Line: -     *       'response': function(response) {
>, <Line: -     *          // same as above
>, <Line: -     *       }
>, <Line: -     *     };
>, <Line: -     *   });
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * ## Security Considerations
>, <Line: -     *
>, <Line: -     * When designing web applications, consider security threats from:
>, <Line: -     *
>, <Line: -     * - [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
>, <Line: -     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)
>, <Line: -     *
>, <Line: -     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
>, <Line: -     * pre-configured with strategies that address these issues, but for this to work backend server
>, <Line: -     * cooperation is required.
>, <Line: -     *
>, <Line: -     * ### JSON Vulnerability Protection
>, <Line: -     *
>, <Line: -     * A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
>, <Line: -     * allows third party website to turn your JSON resource URL into
>, <Line: -     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To
>, <Line: -     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
>, <Line: -     * Angular will automatically strip the prefix before processing it as JSON.
>, <Line: -     *
>, <Line: -     * For example if your server needs to return:
>, <Line: -     * ```js
>, <Line: -     * ['one','two']
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * which is vulnerable to attack, your server can return:
>, <Line: -     * ```js
>, <Line: -     * )]}',
>, <Line: -     * ['one','two']
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * Angular will strip the prefix, before processing the JSON.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ### Cross Site Request Forgery (XSRF) Protection
>, <Line: -     *
>, <Line: -     * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which
>, <Line: -     * an unauthorized site can gain your user's private data. Angular provides a mechanism
>, <Line: -     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
>, <Line: -     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
>, <Line: -     * JavaScript that runs on your domain could read the cookie, your server can be assured that
>, <Line: -     * the XHR came from JavaScript running on your domain. The header will not be set for
>, <Line: -     * cross-domain requests.
>, <Line: -     *
>, <Line: -     * To take advantage of this, your server needs to set a token in a JavaScript readable session
>, <Line: -     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
>, <Line: -     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
>, <Line: -     * that only JavaScript running on your domain could have sent the request. The token must be
>, <Line: -     * unique for each user and must be verifiable by the server (to prevent the JavaScript from
>, <Line: -     * making up its own tokens). We recommend that the token is a digest of your site's
>, <Line: -     * authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&#41;)
>, <Line: -     * for added security.
>, <Line: -     *
>, <Line: -     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
>, <Line: -     * properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,
>, <Line: -     * or the per-request config object.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * @param {object} config Object describing the request to be made and how it should be
>, <Line: -     *    processed. The object has following properties:
>, <Line: -     *
>, <Line: -     *    - **method**  `{string}`  HTTP method (e.g. 'GET', 'POST', etc)
>, <Line: -     *    - **url**  `{string}`  Absolute or relative URL of the resource that is being requested.
>, <Line: -     *    - **params**  `{Object.<string|Object>}`  Map of strings or objects which will be turned
>, <Line: -     *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be
>, <Line: -     *      JSONified.
>, <Line: -     *    - **data**  `{string|Object}`  Data to be sent as the request message data.
>, <Line: -     *    - **headers**  `{Object}`  Map of strings or functions which return strings representing
>, <Line: -     *      HTTP headers to send to the server. If the return value of a function is null, the
>, <Line: -     *      header will not be sent.
>, <Line: -     *    - **xsrfHeaderName**  `{string}`  Name of HTTP header to populate with the XSRF token.
>, <Line: -     *    - **xsrfCookieName**  `{string}`  Name of cookie containing the XSRF token.
>, <Line: -     *    - **transformRequest** 
>, <Line: -     *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
>, <Line: -     *      transform function or an array of such functions. The transform function takes the http
>, <Line: -     *      request body and headers and returns its transformed (typically serialized) version.
>, <Line: -     *      See {@link #overriding-the-default-transformations-per-request Overriding the Default Transformations}
>, <Line: -     *    - **transformResponse** 
>, <Line: -     *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
>, <Line: -     *      transform function or an array of such functions. The transform function takes the http
>, <Line: -     *      response body and headers and returns its transformed (typically deserialized) version.
>, <Line: -     *      See {@link #overriding-the-default-transformations-per-request Overriding the Default Transformations}
>, <Line: -     *    - **cache**  `{boolean|Cache}`  If true, a default $http cache will be used to cache the
>, <Line: -     *      GET request, otherwise if a cache instance built with
>, <Line: -     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
>, <Line: -     *      caching.
>, <Line: -     *    - **timeout**  `{number|Promise}`  timeout in milliseconds, or {@link ng.$q promise}
>, <Line: -     *      that should abort the request when resolved.
>, <Line: -     *    - **withCredentials** - `{boolean}` - whether to set the `withCredentials` flag on the
>, <Line: -     *      XHR object. See [requests with credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials)
>, <Line: -     *      for more information.
>, <Line: -     *    - **responseType** - `{string}` - see
>, <Line: -     *      [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).
>, <Line: -     *
>, <Line: -     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
>, <Line: -     *   standard `then` method and two http specific methods: `success` and `error`. The `then`
>, <Line: -     *   method takes two arguments a success and an error callback which will be called with a
>, <Line: -     *   response object. The `success` and `error` methods take a single argument - a function that
>, <Line: -     *   will be called when the request succeeds or fails respectively. The arguments passed into
>, <Line: -     *   these functions are destructured representation of the response object passed into the
>, <Line: -     *   `then` method. The response object has these properties:
>, <Line: -     *
>, <Line: -     *   - **data**  `{string|Object}`  The response body transformed with the transform
>, <Line: -     *     functions.
>, <Line: -     *   - **status**  `{number}`  HTTP status code of the response.
>, <Line: -     *   - **headers**  `{function([headerName])}`  Header getter function.
>, <Line: -     *   - **config**  `{Object}`  The configuration object that was used to generate the request.
>, <Line: -     *   - **statusText**  `{string}`  HTTP status text of the response.
>, <Line: -     *
>, <Line: -     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
>, <Line: -     *   requests. This is primarily meant to be used for debugging purposes.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * @example
>, <Line: -<example module="httpExample">
>, <Line: -<file name="index.html">
>, <Line: -  <div ng-controller="FetchController">
>, <Line: -    <select ng-model="method">
>, <Line: -      <option>GET</option>
>, <Line: -      <option>JSONP</option>
>, <Line: -    </select>
>, <Line: -    <input type="text" ng-model="url" size="80"/>
>, <Line: -    <button id="fetchbtn" ng-click="fetch()">fetch</button><br>
>, <Line: -    <button id="samplegetbtn" ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
>, <Line: -    <button id="samplejsonpbtn"
>, <Line: -      ng-click="updateModel('JSONP',
>, <Line: -                    'https://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">
>, <Line: -      Sample JSONP
>, <Line: -    </button>
>, <Line: -    <button id="invalidjsonpbtn"
>, <Line: -      ng-click="updateModel('JSONP', 'https://angularjs.org/doesntexist&callback=JSON_CALLBACK')">
>, <Line: -        Invalid JSONP
>, <Line: -      </button>
>, <Line: -    <pre>http status code: {{status}}</pre>
>, <Line: -    <pre>http response data: {{data}}</pre>
>, <Line: -  </div>
>, <Line: -</file>
>, <Line: -<file name="script.js">
>, <Line: -  angular.module('httpExample', [])
>, <Line: -    .controller('FetchController', ['$scope', '$http', '$templateCache',
>, <Line: -      function($scope, $http, $templateCache) {
>, <Line: -        $scope.method = 'GET';
>, <Line: -        $scope.url = 'http-hello.html';
>, <Line: -        $scope.fetch = function() {
>, <Line: -          $scope.code = null;
>, <Line: -          $scope.response = null;
>, <Line: -          $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
>, <Line: -            success(function(data, status) {
>, <Line: -              $scope.status = status;
>, <Line: -              $scope.data = data;
>, <Line: -            }).
>, <Line: -            error(function(data, status) {
>, <Line: -              $scope.data = data || "Request failed";
>, <Line: -              $scope.status = status;
>, <Line: -          });
>, <Line: -        };
>, <Line: -        $scope.updateModel = function(method, url) {
>, <Line: -          $scope.method = method;
>, <Line: -          $scope.url = url;
>, <Line: -        };
>, <Line: -      }]);
>, <Line: -</file>
>, <Line: -<file name="http-hello.html">
>, <Line: -  Hello, $http!
>, <Line: -</file>
>, <Line: -<file name="protractor.js" type="protractor">
>, <Line: -  var status = element(by.binding('status'));
>, <Line: -  var data = element(by.binding('data'));
>, <Line: -  var fetchBtn = element(by.id('fetchbtn'));
>, <Line: -  var sampleGetBtn = element(by.id('samplegetbtn'));
>, <Line: -  var sampleJsonpBtn = element(by.id('samplejsonpbtn'));
>, <Line: -  var invalidJsonpBtn = element(by.id('invalidjsonpbtn'));
>, <Line: -  it('should make an xhr GET request', function() {
>, <Line: -    sampleGetBtn.click();
>, <Line: -    fetchBtn.click();
>, <Line: -    expect(status.getText()).toMatch('200');
>, <Line: -    expect(data.getText()).toMatch(/Hello, \$http!/);
>, <Line: -  });
>, <Line: -// Commented out due to flakes. See https://github.com/angular/angular.js/issues/9185
>, <Line: -// it('should make a JSONP request to angularjs.org', function() {
>, <Line: -//   sampleJsonpBtn.click();
>, <Line: -//   fetchBtn.click();
>, <Line: -//   expect(status.getText()).toMatch('200');
>, <Line: -//   expect(data.getText()).toMatch(/Super Hero!/);
>, <Line: -// });
>, <Line: -  it('should make JSONP request to invalid URL and invoke the error handler',
>, <Line: -      function() {
>, <Line: -    invalidJsonpBtn.click();
>, <Line: -    fetchBtn.click();
>, <Line: -    expect(status.getText()).toMatch('0');
>, <Line: -    expect(data.getText()).toMatch('Request failed');
>, <Line: -  });
>, <Line: -</file>
>, <Line: -</example>
>, <Line: -     */
>, <Line: -    function $http(requestConfig) {
>, <Line: -      var config = {
>, <Line: -        method: 'get',
>, <Line: -        transformRequest: defaults.transformRequest,
>, <Line: -        transformResponse: defaults.transformResponse
>, <Line: -      };
>, <Line: -      var headers = mergeHeaders(requestConfig);
>, <Line: -      if (!angular.isObject(requestConfig)) {
>, <Line: -        throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
>, <Line: -      }
>, <Line: -      extend(config, requestConfig);
>, <Line: -      config.headers = headers;
>, <Line: -      config.method = uppercase(config.method);
>, <Line: -      var serverRequest = function(config) {
>, <Line: -        headers = config.headers;
>, <Line: -        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
>, <Line: -        // strip content-type if data is undefined
>, <Line: -        if (isUndefined(reqData)) {
>, <Line: -          forEach(headers, function(value, header) {
>, <Line: -            if (lowercase(header) === 'content-type') {
>, <Line: -                delete headers[header];
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
>, <Line: -          config.withCredentials = defaults.withCredentials;
>, <Line: -        }
>, <Line: -        // send request
>, <Line: -        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
>, <Line: -      };
>, <Line: -      var chain = [serverRequest, undefined];
>, <Line: -      var promise = $q.when(config);
>, <Line: -      // apply interceptors
>, <Line: -      forEach(reversedInterceptors, function(interceptor) {
>, <Line: -        if (interceptor.request || interceptor.requestError) {
>, <Line: -          chain.unshift(interceptor.request, interceptor.requestError);
>, <Line: -        }
>, <Line: -        if (interceptor.response || interceptor.responseError) {
>, <Line: -          chain.push(interceptor.response, interceptor.responseError);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      while (chain.length) {
>, <Line: -        var thenFn = chain.shift();
>, <Line: -        var rejectFn = chain.shift();
>, <Line: -        promise = promise.then(thenFn, rejectFn);
>, <Line: -      }
>, <Line: -      promise.success = function(fn) {
>, <Line: -        promise.then(function(response) {
>, <Line: -          fn(response.data, response.status, response.headers, config);
>, <Line: -        });
>, <Line: -        return promise;
>, <Line: -      };
>, <Line: -      promise.error = function(fn) {
>, <Line: -        promise.then(null, function(response) {
>, <Line: -          fn(response.data, response.status, response.headers, config);
>, <Line: -        });
>, <Line: -        return promise;
>, <Line: -      };
>, <Line: -      return promise;
>, <Line: -      function transformResponse(response) {
>, <Line: -        // make a copy since the response must be cacheable
>, <Line: -        var resp = extend({}, response);
>, <Line: -        if (!response.data) {
>, <Line: -          resp.data = response.data;
>, <Line: -        } else {
>, <Line: -          resp.data = transformData(response.data, response.headers, config.transformResponse);
>, <Line: -        }
>, <Line: -        return (isSuccess(response.status))
>, <Line: -          ? resp
>, <Line: -          : $q.reject(resp);
>, <Line: -      }
>, <Line: -      function mergeHeaders(config) {
>, <Line: -        var defHeaders = defaults.headers,
>, <Line: -            reqHeaders = extend({}, config.headers),
>, <Line: -            defHeaderName, lowercaseDefHeaderName, reqHeaderName;
>, <Line: -        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
>, <Line: -        // using for-in instead of forEach to avoid unecessary iteration after header has been found
>, <Line: -        defaultHeadersIteration:
>, <Line: -        for (defHeaderName in defHeaders) {
>, <Line: -          lowercaseDefHeaderName = lowercase(defHeaderName);
>, <Line: -          for (reqHeaderName in reqHeaders) {
>, <Line: -            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
>, <Line: -              continue defaultHeadersIteration;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
>, <Line: -        }
>, <Line: -        // execute if header value is a function for merged headers
>, <Line: -        execHeaders(reqHeaders);
>, <Line: -        return reqHeaders;
>, <Line: -        function execHeaders(headers) {
>, <Line: -          var headerContent;
>, <Line: -          forEach(headers, function(headerFn, header) {
>, <Line: -            if (isFunction(headerFn)) {
>, <Line: -              headerContent = headerFn();
>, <Line: -              if (headerContent != null) {
>, <Line: -                headers[header] = headerContent;
>, <Line: -              } else {
>, <Line: -                delete headers[header];
>, <Line: -              }
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    $http.pendingRequests = [];
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#get
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `GET` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#delete
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `DELETE` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#head
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `HEAD` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#jsonp
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `JSONP` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request.
>, <Line: -     *                     The name of the callback should be the string `JSON_CALLBACK`.
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -    createShortMethods('get', 'delete', 'head', 'jsonp');
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#post
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `POST` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -     * @param {*} data Request content
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $http#put
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut method to perform `PUT` request.
>, <Line: -     *
>, <Line: -     * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -     * @param {*} data Request content
>, <Line: -     * @param {Object=} config Optional configuration object
>, <Line: -     * @returns {HttpPromise} Future object
>, <Line: -     */
>, <Line: -     /**
>, <Line: -      * @ngdoc method
>, <Line: -      * @name $http#patch
>, <Line: -      *
>, <Line: -      * @description
>, <Line: -      * Shortcut method to perform `PATCH` request.
>, <Line: -      *
>, <Line: -      * @param {string} url Relative or absolute URL specifying the destination of the request
>, <Line: -      * @param {*} data Request content
>, <Line: -      * @param {Object=} config Optional configuration object
>, <Line: -      * @returns {HttpPromise} Future object
>, <Line: -      */
>, <Line: -    createShortMethodsWithData('post', 'put', 'patch');
>, <Line: -        /**
>, <Line: -         * @ngdoc property
>, <Line: -         * @name $http#defaults
>, <Line: -         *
>, <Line: -         * @description
>, <Line: -         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
>, <Line: -         * default headers, withCredentials as well as request and response transformations.
>, <Line: -         *
>, <Line: -         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
>, <Line: -         */
>, <Line: -    $http.defaults = defaults;
>, <Line: -    return $http;
>, <Line: -    function createShortMethods(names) {
>, <Line: -      forEach(arguments, function(name) {
>, <Line: -        $http[name] = function(url, config) {
>, <Line: -          return $http(extend(config || {}, {
>, <Line: -            method: name,
>, <Line: -            url: url
>, <Line: -          }));
>, <Line: -        };
>, <Line: -      });
>, <Line: -    }
>, <Line: -    function createShortMethodsWithData(name) {
>, <Line: -      forEach(arguments, function(name) {
>, <Line: -        $http[name] = function(url, data, config) {
>, <Line: -          return $http(extend(config || {}, {
>, <Line: -            method: name,
>, <Line: -            url: url,
>, <Line: -            data: data
>, <Line: -          }));
>, <Line: -        };
>, <Line: -      });
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * Makes the request.
>, <Line: -     *
>, <Line: -     * !!! ACCESSES CLOSURE VARS:
>, <Line: -     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
>, <Line: -     */
>, <Line: -    function sendReq(config, reqData, reqHeaders) {
>, <Line: -      var deferred = $q.defer(),
>, <Line: -          promise = deferred.promise,
>, <Line: -          cache,
>, <Line: -          cachedResp,
>, <Line: -          url = buildUrl(config.url, config.params);
>, <Line: -      $http.pendingRequests.push(config);
>, <Line: -      promise.then(removePendingReq, removePendingReq);
>, <Line: -      if ((config.cache || defaults.cache) && config.cache !== false &&
>, <Line: -          (config.method === 'GET' || config.method === 'JSONP')) {
>, <Line: -        cache = isObject(config.cache) ? config.cache
>, <Line: -              : isObject(defaults.cache) ? defaults.cache
>, <Line: -              : defaultCache;
>, <Line: -      }
>, <Line: -      if (cache) {
>, <Line: -        cachedResp = cache.get(url);
>, <Line: -        if (isDefined(cachedResp)) {
>, <Line: -          if (isPromiseLike(cachedResp)) {
>, <Line: -            // cached request has already been sent, but there is no response yet
>, <Line: -            cachedResp.then(removePendingReq, removePendingReq);
>, <Line: -            return cachedResp;
>, <Line: -          } else {
>, <Line: -            // serving from cache
>, <Line: -            if (isArray(cachedResp)) {
>, <Line: -              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
>, <Line: -            } else {
>, <Line: -              resolvePromise(cachedResp, 200, {}, 'OK');
>, <Line: -            }
>, <Line: -          }
>, <Line: -        } else {
>, <Line: -          // put the promise for the non-transformed response into cache as a placeholder
>, <Line: -          cache.put(url, promise);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // if we won't have the response in cache, set the xsrf headers and
>, <Line: -      // send the request to the backend
>, <Line: -      if (isUndefined(cachedResp)) {
>, <Line: -        var xsrfValue = urlIsSameOrigin(config.url)
>, <Line: -            ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
>, <Line: -            : undefined;
>, <Line: -        if (xsrfValue) {
>, <Line: -          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
>, <Line: -        }
>, <Line: -        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
>, <Line: -            config.withCredentials, config.responseType);
>, <Line: -      }
>, <Line: -      return promise;
>, <Line: -      /**
>, <Line: -       * Callback registered to $httpBackend():
>, <Line: -       *  - caches the response if desired
>, <Line: -       *  - resolves the raw $http promise
>, <Line: -       *  - calls $apply
>, <Line: -       */
>, <Line: -      function done(status, response, headersString, statusText) {
>, <Line: -        if (cache) {
>, <Line: -          if (isSuccess(status)) {
>, <Line: -            cache.put(url, [status, response, parseHeaders(headersString), statusText]);
>, <Line: -          } else {
>, <Line: -            // remove promise from the cache
>, <Line: -            cache.remove(url);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function resolveHttpPromise() {
>, <Line: -          resolvePromise(response, status, headersString, statusText);
>, <Line: -        }
>, <Line: -        if (useApplyAsync) {
>, <Line: -          $rootScope.$applyAsync(resolveHttpPromise);
>, <Line: -        } else {
>, <Line: -          resolveHttpPromise();
>, <Line: -          if (!$rootScope.$$phase) $rootScope.$apply();
>, <Line: -        }
>, <Line: -      }
>, <Line: -      /**
>, <Line: -       * Resolves the raw $http promise.
>, <Line: -       */
>, <Line: -      function resolvePromise(response, status, headers, statusText) {
>, <Line: -        // normalize internal statuses to 0
>, <Line: -        status = Math.max(status, 0);
>, <Line: -        (isSuccess(status) ? deferred.resolve : deferred.reject)({
>, <Line: -          data: response,
>, <Line: -          status: status,
>, <Line: -          headers: headersGetter(headers),
>, <Line: -          config: config,
>, <Line: -          statusText: statusText
>, <Line: -        });
>, <Line: -      }
>, <Line: -      function removePendingReq() {
>, <Line: -        var idx = $http.pendingRequests.indexOf(config);
>, <Line: -        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function buildUrl(url, params) {
>, <Line: -      if (!params) return url;
>, <Line: -      var parts = [];
>, <Line: -      forEachSorted(params, function(value, key) {
>, <Line: -        if (value === null || isUndefined(value)) return;
>, <Line: -        if (!isArray(value)) value = [value];
>, <Line: -        forEach(value, function(v) {
>, <Line: -          if (isObject(v)) {
>, <Line: -            if (isDate(v)) {
>, <Line: -              v = v.toISOString();
>, <Line: -            } else {
>, <Line: -              v = toJson(v);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          parts.push(encodeUriQuery(key) + '=' +
>, <Line: -                     encodeUriQuery(v));
>, <Line: -        });
>, <Line: -      });
>, <Line: -      if (parts.length > 0) {
>, <Line: -        url += ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
>, <Line: -      }
>, <Line: -      return url;
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -function createXhr() {
>, <Line: -    return new window.XMLHttpRequest();
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $httpBackend
>, <Line: - * @requires $window
>, <Line: - * @requires $document
>, <Line: - *
>, <Line: - * @description
>, <Line: - * HTTP backend used by the {@link ng.$http service} that delegates to
>, <Line: - * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
>, <Line: - *
>, <Line: - * You should never need to use this service directly, instead use the higher-level abstractions:
>, <Line: - * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
>, <Line: - *
>, <Line: - * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
>, <Line: - * $httpBackend} which can be trained with responses.
>, <Line: - */
>, <Line: -function $HttpBackendProvider() {
>, <Line: -  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
>, <Line: -    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
>, <Line: -  }];
>, <Line: -}
>, <Line: -function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
>, <Line: -  // TODO(vojta): fix the signature
>, <Line: -  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
>, <Line: -    $browser.$$incOutstandingRequestCount();
>, <Line: -    url = url || $browser.url();
>, <Line: -    if (lowercase(method) == 'jsonp') {
>, <Line: -      var callbackId = '_' + (callbacks.counter++).toString(36);
>, <Line: -      callbacks[callbackId] = function(data) {
>, <Line: -        callbacks[callbackId].data = data;
>, <Line: -        callbacks[callbackId].called = true;
>, <Line: -      };
>, <Line: -      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
>, <Line: -          callbackId, function(status, text) {
>, <Line: -        completeRequest(callback, status, callbacks[callbackId].data, "", text);
>, <Line: -        callbacks[callbackId] = noop;
>, <Line: -      });
>, <Line: -    } else {
>, <Line: -      var xhr = createXhr();
>, <Line: -      xhr.open(method, url, true);
>, <Line: -      forEach(headers, function(value, key) {
>, <Line: -        if (isDefined(value)) {
>, <Line: -            xhr.setRequestHeader(key, value);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      xhr.onload = function requestLoaded() {
>, <Line: -        var statusText = xhr.statusText || '';
>, <Line: -        // responseText is the old-school way of retrieving response (supported by IE8 & 9)
>, <Line: -        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
>, <Line: -        var response = ('response' in xhr) ? xhr.response : xhr.responseText;
>, <Line: -        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
>, <Line: -        var status = xhr.status === 1223 ? 204 : xhr.status;
>, <Line: -        // fix status code when it is 0 (0 status is undocumented).
>, <Line: -        // Occurs when accessing file resources or on Android 4.1 stock browser
>, <Line: -        // while retrieving files from application cache.
>, <Line: -        if (status === 0) {
>, <Line: -          status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
>, <Line: -        }
>, <Line: -        completeRequest(callback,
>, <Line: -            status,
>, <Line: -            response,
>, <Line: -            xhr.getAllResponseHeaders(),
>, <Line: -            statusText);
>, <Line: -      };
>, <Line: -      var requestError = function() {
>, <Line: -        // The response is always empty
>, <Line: -        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
>, <Line: -        completeRequest(callback, -1, null, null, '');
>, <Line: -      };
>, <Line: -      xhr.onerror = requestError;
>, <Line: -      xhr.onabort = requestError;
>, <Line: -      if (withCredentials) {
>, <Line: -        xhr.withCredentials = true;
>, <Line: -      }
>, <Line: -      if (responseType) {
>, <Line: -        try {
>, <Line: -          xhr.responseType = responseType;
>, <Line: -        } catch (e) {
>, <Line: -          // WebKit added support for the json responseType value on 09/03/2013
>, <Line: -          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
>, <Line: -          // known to throw when setting the value "json" as the response type. Other older
>, <Line: -          // browsers implementing the responseType
>, <Line: -          //
>, <Line: -          // The json response type can be ignored if not supported, because JSON payloads are
>, <Line: -          // parsed on the client-side regardless.
>, <Line: -          if (responseType !== 'json') {
>, <Line: -            throw e;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      xhr.send(post || null);
>, <Line: -    }
>, <Line: -    if (timeout > 0) {
>, <Line: -      var timeoutId = $browserDefer(timeoutRequest, timeout);
>, <Line: -    } else if (isPromiseLike(timeout)) {
>, <Line: -      timeout.then(timeoutRequest);
>, <Line: -    }
>, <Line: -    function timeoutRequest() {
>, <Line: -      jsonpDone && jsonpDone();
>, <Line: -      xhr && xhr.abort();
>, <Line: -    }
>, <Line: -    function completeRequest(callback, status, response, headersString, statusText) {
>, <Line: -      // cancel timeout and subsequent timeout promise resolution
>, <Line: -      timeoutId && $browserDefer.cancel(timeoutId);
>, <Line: -      jsonpDone = xhr = null;
>, <Line: -      callback(status, response, headersString, statusText);
>, <Line: -      $browser.$$completeOutstandingRequest(noop);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  function jsonpReq(url, callbackId, done) {
>, <Line: -    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
>, <Line: -    // - fetches local scripts via XHR and evals them
>, <Line: -    // - adds and immediately removes script elements from the document
>, <Line: -    var script = rawDocument.createElement('script'), callback = null;
>, <Line: -    script.type = "text/javascript";
>, <Line: -    script.src = url;
>, <Line: -    script.async = true;
>, <Line: -    callback = function(event) {
>, <Line: -      removeEventListenerFn(script, "load", callback);
>, <Line: -      removeEventListenerFn(script, "error", callback);
>, <Line: -      rawDocument.body.removeChild(script);
>, <Line: -      script = null;
>, <Line: -      var status = -1;
>, <Line: -      var text = "unknown";
>, <Line: -      if (event) {
>, <Line: -        if (event.type === "load" && !callbacks[callbackId].called) {
>, <Line: -          event = { type: "error" };
>, <Line: -        }
>, <Line: -        text = event.type;
>, <Line: -        status = event.type === "error" ? 404 : 200;
>, <Line: -      }
>, <Line: -      if (done) {
>, <Line: -        done(status, text);
>, <Line: -      }
>, <Line: -    };
>, <Line: -    addEventListenerFn(script, "load", callback);
>, <Line: -    addEventListenerFn(script, "error", callback);
>, <Line: -    rawDocument.body.appendChild(script);
>, <Line: -    return callback;
>, <Line: -  }
>, <Line: -}
>, <Line: -var $interpolateMinErr = minErr('$interpolate');
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $interpolateProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
>, <Line: - *
>, <Line: - * @example
>, <Line: -<example module="customInterpolationApp">
>, <Line: -<file name="index.html">
>, <Line: -<script>
>, <Line: -  var customInterpolationApp = angular.module('customInterpolationApp', []);
>, <Line: -  customInterpolationApp.config(function($interpolateProvider) {
>, <Line: -    $interpolateProvider.startSymbol('//');
>, <Line: -    $interpolateProvider.endSymbol('//');
>, <Line: -  });
>, <Line: -  customInterpolationApp.controller('DemoController', function() {
>, <Line: -      this.label = "This binding is brought you by // interpolation symbols.";
>, <Line: -  });
>, <Line: -</script>
>, <Line: -<div ng-app="App" ng-controller="DemoController as demo">
>, <Line: -    //demo.label//
>, <Line: -</div>
>, <Line: -</file>
>, <Line: -<file name="protractor.js" type="protractor">
>, <Line: -  it('should interpolate binding with custom symbols', function() {
>, <Line: -    expect(element(by.binding('demo.label')).getText()).toBe('This binding is brought you by // interpolation symbols.');
>, <Line: -  });
>, <Line: -</file>
>, <Line: -</example>
>, <Line: - */
>, <Line: -function $InterpolateProvider() {
>, <Line: -  var startSymbol = '{{';
>, <Line: -  var endSymbol = '}}';
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $interpolateProvider#startSymbol
>, <Line: -   * @description
>, <Line: -   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
>, <Line: -   *
>, <Line: -   * @param {string=} value new value to set the starting symbol to.
>, <Line: -   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
>, <Line: -   */
>, <Line: -  this.startSymbol = function(value) {
>, <Line: -    if (value) {
>, <Line: -      startSymbol = value;
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return startSymbol;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $interpolateProvider#endSymbol
>, <Line: -   * @description
>, <Line: -   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
>, <Line: -   *
>, <Line: -   * @param {string=} value new value to set the ending symbol to.
>, <Line: -   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
>, <Line: -   */
>, <Line: -  this.endSymbol = function(value) {
>, <Line: -    if (value) {
>, <Line: -      endSymbol = value;
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return endSymbol;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
>, <Line: -    var startSymbolLength = startSymbol.length,
>, <Line: -        endSymbolLength = endSymbol.length,
>, <Line: -        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
>, <Line: -        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
>, <Line: -    function escape(ch) {
>, <Line: -      return '\\\\\\' + ch;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc service
>, <Line: -     * @name $interpolate
>, <Line: -     * @kind function
>, <Line: -     *
>, <Line: -     * @requires $parse
>, <Line: -     * @requires $sce
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     *
>, <Line: -     * Compiles a string with markup into an interpolation function. This service is used by the
>, <Line: -     * HTML {@link ng.$compile $compile} service for data binding. See
>, <Line: -     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
>, <Line: -     * interpolation markup.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   var $interpolate = ...; // injected
>, <Line: -     *   var exp = $interpolate('Hello {{name | uppercase}}!');
>, <Line: -     *   expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
>, <Line: -     * `true`, the interpolation function will return `undefined` unless all embedded expressions
>, <Line: -     * evaluate to a value other than `undefined`.
>, <Line: -     *
>, <Line: -     * ```js
>, <Line: -     *   var $interpolate = ...; // injected
>, <Line: -     *   var context = {greeting: 'Hello', name: undefined };
>, <Line: -     *
>, <Line: -     *   // default "forgiving" mode
>, <Line: -     *   var exp = $interpolate('{{greeting}} {{name}}!');
>, <Line: -     *   expect(exp(context)).toEqual('Hello !');
>, <Line: -     *
>, <Line: -     *   // "allOrNothing" mode
>, <Line: -     *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
>, <Line: -     *   expect(exp(context)).toBeUndefined();
>, <Line: -     *   context.name = 'Angular';
>, <Line: -     *   expect(exp(context)).toEqual('Hello Angular!');
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.
>, <Line: -     *
>, <Line: -     * ####Escaped Interpolation
>, <Line: -     * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers
>, <Line: -     * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).
>, <Line: -     * It will be rendered as a regular start/end marker, and will not be interpreted as an expression
>, <Line: -     * or binding.
>, <Line: -     *
>, <Line: -     * This enables web-servers to prevent script injection attacks and defacing attacks, to some
>, <Line: -     * degree, while also enabling code examples to work without relying on the
>, <Line: -     * {@link ng.directive:ngNonBindable ngNonBindable} directive.
>, <Line: -     *
>, <Line: -     * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,
>, <Line: -     * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all
>, <Line: -     * interpolation start/end markers with their escaped counterparts.**
>, <Line: -     *
>, <Line: -     * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered
>, <Line: -     * output when the $interpolate service processes the text. So, for HTML elements interpolated
>, <Line: -     * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter
>, <Line: -     * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,
>, <Line: -     * this is typically useful only when user-data is used in rendering a template from the server, or
>, <Line: -     * when otherwise untrusted data is used by a directive.
>, <Line: -     *
>, <Line: -     * <example>
>, <Line: -     *  <file name="index.html">
>, <Line: -     *    <div ng-init="username='A user'">
>, <Line: -     *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
>, <Line: -     *        </p>
>, <Line: -     *      <p><strong>{{username}}</strong> attempts to inject code which will deface the
>, <Line: -     *        application, but fails to accomplish their task, because the server has correctly
>, <Line: -     *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)
>, <Line: -     *        characters.</p>
>, <Line: -     *      <p>Instead, the result of the attempted script injection is visible, and can be removed
>, <Line: -     *        from the database by an administrator.</p>
>, <Line: -     *    </div>
>, <Line: -     *  </file>
>, <Line: -     * </example>
>, <Line: -     *
>, <Line: -     * @param {string} text The text with markup to interpolate.
>, <Line: -     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
>, <Line: -     *    embedded expression in order to return an interpolation function. Strings with no
>, <Line: -     *    embedded expression will return null for the interpolation function.
>, <Line: -     * @param {string=} trustedContext when provided, the returned function passes the interpolated
>, <Line: -     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
>, <Line: -     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
>, <Line: -     *    provides Strict Contextual Escaping for details.
>, <Line: -     * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
>, <Line: -     *    unless all embedded expressions evaluate to a value other than `undefined`.
>, <Line: -     * @returns {function(context)} an interpolation function which is used to compute the
>, <Line: -     *    interpolated string. The function has these parameters:
>, <Line: -     *
>, <Line: -     * - `context`: evaluation context for all expressions embedded in the interpolated text
>, <Line: -     */
>, <Line: -    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
>, <Line: -      allOrNothing = !!allOrNothing;
>, <Line: -      var startIndex,
>, <Line: -          endIndex,
>, <Line: -          index = 0,
>, <Line: -          expressions = [],
>, <Line: -          parseFns = [],
>, <Line: -          textLength = text.length,
>, <Line: -          exp,
>, <Line: -          concat = [],
>, <Line: -          expressionPositions = [];
>, <Line: -      while (index < textLength) {
>, <Line: -        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&
>, <Line: -             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
>, <Line: -          if (index !== startIndex) {
>, <Line: -            concat.push(unescapeText(text.substring(index, startIndex)));
>, <Line: -          }
>, <Line: -          exp = text.substring(startIndex + startSymbolLength, endIndex);
>, <Line: -          expressions.push(exp);
>, <Line: -          parseFns.push($parse(exp, parseStringifyInterceptor));
>, <Line: -          index = endIndex + endSymbolLength;
>, <Line: -          expressionPositions.push(concat.length);
>, <Line: -          concat.push('');
>, <Line: -        } else {
>, <Line: -          // we did not find an interpolation, so we have to add the remainder to the separators array
>, <Line: -          if (index !== textLength) {
>, <Line: -            concat.push(unescapeText(text.substring(index)));
>, <Line: -          }
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      // Concatenating expressions makes it hard to reason about whether some combination of
>, <Line: -      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
>, <Line: -      // single expression be used for iframe[src], object[src], etc., we ensure that the value
>, <Line: -      // that's used is assigned or constructed by some JS code somewhere that is more testable or
>, <Line: -      // make it obvious that you bound the value to some user controlled value.  This helps reduce
>, <Line: -      // the load when auditing for XSS issues.
>, <Line: -      if (trustedContext && concat.length > 1) {
>, <Line: -          throw $interpolateMinErr('noconcat',
>, <Line: -              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
>, <Line: -              "interpolations that concatenate multiple expressions when a trusted value is " +
>, <Line: -              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
>, <Line: -      }
>, <Line: -      if (!mustHaveExpression || expressions.length) {
>, <Line: -        var compute = function(values) {
>, <Line: -          for (var i = 0, ii = expressions.length; i < ii; i++) {
>, <Line: -            if (allOrNothing && isUndefined(values[i])) return;
>, <Line: -            concat[expressionPositions[i]] = values[i];
>, <Line: -          }
>, <Line: -          return concat.join('');
>, <Line: -        };
>, <Line: -        var getValue = function(value) {
>, <Line: -          return trustedContext ?
>, <Line: -            $sce.getTrusted(trustedContext, value) :
>, <Line: -            $sce.valueOf(value);
>, <Line: -        };
>, <Line: -        var stringify = function(value) {
>, <Line: -          if (value == null) { // null || undefined
>, <Line: -            return '';
>, <Line: -          }
>, <Line: -          switch (typeof value) {
>, <Line: -            case 'string':
>, <Line: -              break;
>, <Line: -            case 'number':
>, <Line: -              value = '' + value;
>, <Line: -              break;
>, <Line: -            default:
>, <Line: -              value = toJson(value);
>, <Line: -          }
>, <Line: -          return value;
>, <Line: -        };
>, <Line: -        return extend(function interpolationFn(context) {
>, <Line: -            var i = 0;
>, <Line: -            var ii = expressions.length;
>, <Line: -            var values = new Array(ii);
>, <Line: -            try {
>, <Line: -              for (; i < ii; i++) {
>, <Line: -                values[i] = parseFns[i](context);
>, <Line: -              }
>, <Line: -              return compute(values);
>, <Line: -            } catch (err) {
>, <Line: -              var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text,
>, <Line: -                  err.toString());
>, <Line: -              $exceptionHandler(newErr);
>, <Line: -            }
>, <Line: -          }, {
>, <Line: -          // all of these properties are undocumented for now
>, <Line: -          exp: text, //just for compatibility with regular watchers created via $watch
>, <Line: -          expressions: expressions,
>, <Line: -          $$watchDelegate: function(scope, listener, objectEquality) {
>, <Line: -            var lastValue;
>, <Line: -            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
>, <Line: -              var currValue = compute(values);
>, <Line: -              if (isFunction(listener)) {
>, <Line: -                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
>, <Line: -              }
>, <Line: -              lastValue = currValue;
>, <Line: -            }, objectEquality);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      function unescapeText(text) {
>, <Line: -        return text.replace(escapedStartRegexp, startSymbol).
>, <Line: -          replace(escapedEndRegexp, endSymbol);
>, <Line: -      }
>, <Line: -      function parseStringifyInterceptor(value) {
>, <Line: -        try {
>, <Line: -          value = getValue(value);
>, <Line: -          return allOrNothing && !isDefined(value) ? value : stringify(value);
>, <Line: -        } catch (err) {
>, <Line: -          var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text,
>, <Line: -            err.toString());
>, <Line: -          $exceptionHandler(newErr);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $interpolate#startSymbol
>, <Line: -     * @description
>, <Line: -     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
>, <Line: -     *
>, <Line: -     * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
>, <Line: -     * the symbol.
>, <Line: -     *
>, <Line: -     * @returns {string} start symbol.
>, <Line: -     */
>, <Line: -    $interpolate.startSymbol = function() {
>, <Line: -      return startSymbol;
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $interpolate#endSymbol
>, <Line: -     * @description
>, <Line: -     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
>, <Line: -     *
>, <Line: -     * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
>, <Line: -     * the symbol.
>, <Line: -     *
>, <Line: -     * @returns {string} end symbol.
>, <Line: -     */
>, <Line: -    $interpolate.endSymbol = function() {
>, <Line: -      return endSymbol;
>, <Line: -    };
>, <Line: -    return $interpolate;
>, <Line: -  }];
>, <Line: -}
>, <Line: -function $IntervalProvider() {
>, <Line: -  this.$get = ['$rootScope', '$window', '$q', '$$q',
>, <Line: -       function($rootScope,   $window,   $q,   $$q) {
>, <Line: -    var intervals = {};
>, <Line: -     /**
>, <Line: -      * @ngdoc service
>, <Line: -      * @name $interval
>, <Line: -      *
>, <Line: -      * @description
>, <Line: -      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
>, <Line: -      * milliseconds.
>, <Line: -      *
>, <Line: -      * The return value of registering an interval function is a promise. This promise will be
>, <Line: -      * notified upon each tick of the interval, and will be resolved after `count` iterations, or
>, <Line: -      * run indefinitely if `count` is not defined. The value of the notification will be the
>, <Line: -      * number of iterations that have run.
>, <Line: -      * To cancel an interval, call `$interval.cancel(promise)`.
>, <Line: -      *
>, <Line: -      * In tests you can use {@link ngMock.$interval#flush `$interval.flush(millis)`} to
>, <Line: -      * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
>, <Line: -      * time.
>, <Line: -      *
>, <Line: -      * <div class="alert alert-warning">
>, <Line: -      * **Note**: Intervals created by this service must be explicitly destroyed when you are finished
>, <Line: -      * with them.  In particular they are not automatically destroyed when a controller's scope or a
>, <Line: -      * directive's element are destroyed.
>, <Line: -      * You should take this into consideration and make sure to always cancel the interval at the
>, <Line: -      * appropriate moment.  See the example below for more details on how and when to do this.
>, <Line: -      * </div>
>, <Line: -      *
>, <Line: -      * @param {function()} fn A function that should be called repeatedly.
>, <Line: -      * @param {number} delay Number of milliseconds between each function call.
>, <Line: -      * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
>, <Line: -      *   indefinitely.
>, <Line: -      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: -      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: -      * @returns {promise} A promise which will be notified on each iteration.
>, <Line: -      *
>, <Line: -      * @example
>, <Line: -      * <example module="intervalExample">
>, <Line: -      * <file name="index.html">
>, <Line: -      *   <script>
>, <Line: -      *     angular.module('intervalExample', [])
>, <Line: -      *       .controller('ExampleController', ['$scope', '$interval',
>, <Line: -      *         function($scope, $interval) {
>, <Line: -      *           $scope.format = 'M/d/yy h:mm:ss a';
>, <Line: -      *           $scope.blood_1 = 100;
>, <Line: -      *           $scope.blood_2 = 120;
>, <Line: -      *
>, <Line: -      *           var stop;
>, <Line: -      *           $scope.fight = function() {
>, <Line: -      *             // Don't start a new fight if we are already fighting
>, <Line: -      *             if ( angular.isDefined(stop) ) return;
>, <Line: -      *
>, <Line: -      *           stop = $interval(function() {
>, <Line: -      *             if ($scope.blood_1 > 0 && $scope.blood_2 > 0) {
>, <Line: -      *               $scope.blood_1 = $scope.blood_1 - 3;
>, <Line: -      *               $scope.blood_2 = $scope.blood_2 - 4;
>, <Line: -      *             } else {
>, <Line: -      *               $scope.stopFight();
>, <Line: -      *             }
>, <Line: -      *           }, 100);
>, <Line: -      *         };
>, <Line: -      *
>, <Line: -      *         $scope.stopFight = function() {
>, <Line: -      *           if (angular.isDefined(stop)) {
>, <Line: -      *             $interval.cancel(stop);
>, <Line: -      *             stop = undefined;
>, <Line: -      *           }
>, <Line: -      *         };
>, <Line: -      *
>, <Line: -      *         $scope.resetFight = function() {
>, <Line: -      *           $scope.blood_1 = 100;
>, <Line: -      *           $scope.blood_2 = 120;
>, <Line: -      *         };
>, <Line: -      *
>, <Line: -      *         $scope.$on('$destroy', function() {
>, <Line: -      *           // Make sure that the interval is destroyed too
>, <Line: -      *           $scope.stopFight();
>, <Line: -      *         });
>, <Line: -      *       }])
>, <Line: -      *       // Register the 'myCurrentTime' directive factory method.
>, <Line: -      *       // We inject $interval and dateFilter service since the factory method is DI.
>, <Line: -      *       .directive('myCurrentTime', ['$interval', 'dateFilter',
>, <Line: -      *         function($interval, dateFilter) {
>, <Line: -      *           // return the directive link function. (compile function not needed)
>, <Line: -      *           return function(scope, element, attrs) {
>, <Line: -      *             var format,  // date format
>, <Line: -      *                 stopTime; // so that we can cancel the time updates
>, <Line: -      *
>, <Line: -      *             // used to update the UI
>, <Line: -      *             function updateTime() {
>, <Line: -      *               element.text(dateFilter(new Date(), format));
>, <Line: -      *             }
>, <Line: -      *
>, <Line: -      *             // watch the expression, and update the UI on change.
>, <Line: -      *             scope.$watch(attrs.myCurrentTime, function(value) {
>, <Line: -      *               format = value;
>, <Line: -      *               updateTime();
>, <Line: -      *             });
>, <Line: -      *
>, <Line: -      *             stopTime = $interval(updateTime, 1000);
>, <Line: -      *
>, <Line: -      *             // listen on DOM destroy (removal) event, and cancel the next UI update
>, <Line: -      *             // to prevent updating time after the DOM element was removed.
>, <Line: -      *             element.on('$destroy', function() {
>, <Line: -      *               $interval.cancel(stopTime);
>, <Line: -      *             });
>, <Line: -      *           }
>, <Line: -      *         }]);
>, <Line: -      *   </script>
>, <Line: -      *
>, <Line: -      *   <div>
>, <Line: -      *     <div ng-controller="ExampleController">
>, <Line: -      *       Date format: <input ng-model="format"> <hr/>
>, <Line: -      *       Current time is: <span my-current-time="format"></span>
>, <Line: -      *       <hr/>
>, <Line: -      *       Blood 1 : <font color='red'>{{blood_1}}</font>
>, <Line: -      *       Blood 2 : <font color='red'>{{blood_2}}</font>
>, <Line: -      *       <button type="button" data-ng-click="fight()">Fight</button>
>, <Line: -      *       <button type="button" data-ng-click="stopFight()">StopFight</button>
>, <Line: -      *       <button type="button" data-ng-click="resetFight()">resetFight</button>
>, <Line: -      *     </div>
>, <Line: -      *   </div>
>, <Line: -      *
>, <Line: -      * </file>
>, <Line: -      * </example>
>, <Line: -      */
>, <Line: -    function interval(fn, delay, count, invokeApply) {
>, <Line: -      var setInterval = $window.setInterval,
>, <Line: -          clearInterval = $window.clearInterval,
>, <Line: -          iteration = 0,
>, <Line: -          skipApply = (isDefined(invokeApply) && !invokeApply),
>, <Line: -          deferred = (skipApply ? $$q : $q).defer(),
>, <Line: -          promise = deferred.promise;
>, <Line: -      count = isDefined(count) ? count : 0;
>, <Line: -      promise.then(null, null, fn);
>, <Line: -      promise.$$intervalId = setInterval(function tick() {
>, <Line: -        deferred.notify(iteration++);
>, <Line: -        if (count > 0 && iteration >= count) {
>, <Line: -          deferred.resolve(iteration);
>, <Line: -          clearInterval(promise.$$intervalId);
>, <Line: -          delete intervals[promise.$$intervalId];
>, <Line: -        }
>, <Line: -        if (!skipApply) $rootScope.$apply();
>, <Line: -      }, delay);
>, <Line: -      intervals[promise.$$intervalId] = deferred;
>, <Line: -      return promise;
>, <Line: -    }
>, <Line: -     /**
>, <Line: -      * @ngdoc method
>, <Line: -      * @name $interval#cancel
>, <Line: -      *
>, <Line: -      * @description
>, <Line: -      * Cancels a task associated with the `promise`.
>, <Line: -      *
>, <Line: -      * @param {promise} promise returned by the `$interval` function.
>, <Line: -      * @returns {boolean} Returns `true` if the task was successfully canceled.
>, <Line: -      */
>, <Line: -    interval.cancel = function(promise) {
>, <Line: -      if (promise && promise.$$intervalId in intervals) {
>, <Line: -        intervals[promise.$$intervalId].reject('canceled');
>, <Line: -        $window.clearInterval(promise.$$intervalId);
>, <Line: -        delete intervals[promise.$$intervalId];
>, <Line: -        return true;
>, <Line: -      }
>, <Line: -      return false;
>, <Line: -    };
>, <Line: -    return interval;
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $locale
>, <Line: - *
>, <Line: - * @description
>, <Line: - * $locale service provides localization rules for various Angular components. As of right now the
>, <Line: - * only public api is:
>, <Line: - *
>, <Line: - * * `id`  `{string}`  locale id formatted as `languageId-countryId` (e.g. `en-us`)
>, <Line: - */
>, <Line: -function $LocaleProvider() {
>, <Line: -  this.$get = function() {
>, <Line: -    return {
>, <Line: -      id: 'en-us',
>, <Line: -      NUMBER_FORMATS: {
>, <Line: -        DECIMAL_SEP: '.',
>, <Line: -        GROUP_SEP: ',',
>, <Line: -        PATTERNS: [
>, <Line: -          { // Decimal Pattern
>, <Line: -            minInt: 1,
>, <Line: -            minFrac: 0,
>, <Line: -            maxFrac: 3,
>, <Line: -            posPre: '',
>, <Line: -            posSuf: '',
>, <Line: -            negPre: '-',
>, <Line: -            negSuf: '',
>, <Line: -            gSize: 3,
>, <Line: -            lgSize: 3
>, <Line: -          },{ //Currency Pattern
>, <Line: -            minInt: 1,
>, <Line: -            minFrac: 2,
>, <Line: -            maxFrac: 2,
>, <Line: -            posPre: '\u00A4',
>, <Line: -            posSuf: '',
>, <Line: -            negPre: '(\u00A4',
>, <Line: -            negSuf: ')',
>, <Line: -            gSize: 3,
>, <Line: -            lgSize: 3
>, <Line: -          }
>, <Line: -        ],
>, <Line: -        CURRENCY_SYM: '$'
>, <Line: -      },
>, <Line: -      DATETIME_FORMATS: {
>, <Line: -        MONTH:
>, <Line: -            'January,February,March,April,May,June,July,August,September,October,November,December'
>, <Line: -            .split(','),
>, <Line: -        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
>, <Line: -        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
>, <Line: -        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
>, <Line: -        AMPMS: ['AM','PM'],
>, <Line: -        medium: 'MMM d, y h:mm:ss a',
>, <Line: -        'short': 'M/d/yy h:mm a',
>, <Line: -        fullDate: 'EEEE, MMMM d, y',
>, <Line: -        longDate: 'MMMM d, y',
>, <Line: -        mediumDate: 'MMM d, y',
>, <Line: -        shortDate: 'M/d/yy',
>, <Line: -        mediumTime: 'h:mm:ss a',
>, <Line: -        shortTime: 'h:mm a'
>, <Line: -      },
>, <Line: -      pluralCat: function(num) {
>, <Line: -        if (num === 1) {
>, <Line: -          return 'one';
>, <Line: -        }
>, <Line: -        return 'other';
>, <Line: -      }
>, <Line: -    };
>, <Line: -  };
>, <Line: -}
>, <Line: -var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
>, <Line: -    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
>, <Line: -var $locationMinErr = minErr('$location');
>, <Line: -/**
>, <Line: - * Encode path using encodeUriSegment, ignoring forward slashes
>, <Line: - *
>, <Line: - * @param {string} path Path to encode
>, <Line: - * @returns {string}
>, <Line: - */
>, <Line: -function encodePath(path) {
>, <Line: -  var segments = path.split('/'),
>, <Line: -      i = segments.length;
>, <Line: -  while (i--) {
>, <Line: -    segments[i] = encodeUriSegment(segments[i]);
>, <Line: -  }
>, <Line: -  return segments.join('/');
>, <Line: -}
>, <Line: -function parseAbsoluteUrl(absoluteUrl, locationObj) {
>, <Line: -  var parsedUrl = urlResolve(absoluteUrl);
>, <Line: -  locationObj.$$protocol = parsedUrl.protocol;
>, <Line: -  locationObj.$$host = parsedUrl.hostname;
>, <Line: -  locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
>, <Line: -}
>, <Line: -function parseAppUrl(relativeUrl, locationObj) {
>, <Line: -  var prefixed = (relativeUrl.charAt(0) !== '/');
>, <Line: -  if (prefixed) {
>, <Line: -    relativeUrl = '/' + relativeUrl;
>, <Line: -  }
>, <Line: -  var match = urlResolve(relativeUrl);
>, <Line: -  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
>, <Line: -      match.pathname.substring(1) : match.pathname);
>, <Line: -  locationObj.$$search = parseKeyValue(match.search);
>, <Line: -  locationObj.$$hash = decodeURIComponent(match.hash);
>, <Line: -  // make sure path starts with '/';
>, <Line: -  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
>, <Line: -    locationObj.$$path = '/' + locationObj.$$path;
>, <Line: -  }
>, <Line: -}
>, <Line: -/**
>, <Line: - *
>, <Line: - * @param {string} begin
>, <Line: - * @param {string} whole
>, <Line: - * @returns {string} returns text from whole after begin or undefined if it does not begin with
>, <Line: - *                   expected string.
>, <Line: - */
>, <Line: -function beginsWith(begin, whole) {
>, <Line: -  if (whole.indexOf(begin) === 0) {
>, <Line: -    return whole.substr(begin.length);
>, <Line: -  }
>, <Line: -}
>, <Line: -function stripHash(url) {
>, <Line: -  var index = url.indexOf('#');
>, <Line: -  return index == -1 ? url : url.substr(0, index);
>, <Line: -}
>, <Line: -function stripFile(url) {
>, <Line: -  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
>, <Line: -}
>, <Line: -/* return the server only (scheme://host:port) */
>, <Line: -function serverBase(url) {
>, <Line: -  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
>, <Line: -}
>, <Line: -/**
>, <Line: - * LocationHtml5Url represents an url
>, <Line: - * This object is exposed as $location service when HTML5 mode is enabled and supported
>, <Line: - *
>, <Line: - * @constructor
>, <Line: - * @param {string} appBase application base URL
>, <Line: - * @param {string} basePrefix url path prefix
>, <Line: - */
>, <Line: -function LocationHtml5Url(appBase, basePrefix) {
>, <Line: -  this.$$html5 = true;
>, <Line: -  basePrefix = basePrefix || '';
>, <Line: -  var appBaseNoFile = stripFile(appBase);
>, <Line: -  parseAbsoluteUrl(appBase, this);
>, <Line: -  /**
>, <Line: -   * Parse given html5 (regular) url string into properties
>, <Line: -   * @param {string} url HTML5 url
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  this.$$parse = function(url) {
>, <Line: -    var pathUrl = beginsWith(appBaseNoFile, url);
>, <Line: -    if (!isString(pathUrl)) {
>, <Line: -      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
>, <Line: -          appBaseNoFile);
>, <Line: -    }
>, <Line: -    parseAppUrl(pathUrl, this);
>, <Line: -    if (!this.$$path) {
>, <Line: -      this.$$path = '/';
>, <Line: -    }
>, <Line: -    this.$$compose();
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * Compose url and update `absUrl` property
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  this.$$compose = function() {
>, <Line: -    var search = toKeyValue(this.$$search),
>, <Line: -        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: -    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: -    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
>, <Line: -  };
>, <Line: -  this.$$parseLinkUrl = function(url, relHref) {
>, <Line: -    if (relHref && relHref[0] === '#') {
>, <Line: -      // special case for links to hash fragments:
>, <Line: -      // keep the old url and only replace the hash fragment
>, <Line: -      this.hash(relHref.slice(1));
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    var appUrl, prevAppUrl;
>, <Line: -    var rewrittenUrl;
>, <Line: -    if ((appUrl = beginsWith(appBase, url)) !== undefined) {
>, <Line: -      prevAppUrl = appUrl;
>, <Line: -      if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
>, <Line: -        rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
>, <Line: -      } else {
>, <Line: -        rewrittenUrl = appBase + prevAppUrl;
>, <Line: -      }
>, <Line: -    } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
>, <Line: -      rewrittenUrl = appBaseNoFile + appUrl;
>, <Line: -    } else if (appBaseNoFile == url + '/') {
>, <Line: -      rewrittenUrl = appBaseNoFile;
>, <Line: -    }
>, <Line: -    if (rewrittenUrl) {
>, <Line: -      this.$$parse(rewrittenUrl);
>, <Line: -    }
>, <Line: -    return !!rewrittenUrl;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * LocationHashbangUrl represents url
>, <Line: - * This object is exposed as $location service when developer doesn't opt into html5 mode.
>, <Line: - * It also serves as the base class for html5 mode fallback on legacy browsers.
>, <Line: - *
>, <Line: - * @constructor
>, <Line: - * @param {string} appBase application base URL
>, <Line: - * @param {string} hashPrefix hashbang prefix
>, <Line: - */
>, <Line: -function LocationHashbangUrl(appBase, hashPrefix) {
>, <Line: -  var appBaseNoFile = stripFile(appBase);
>, <Line: -  parseAbsoluteUrl(appBase, this);
>, <Line: -  /**
>, <Line: -   * Parse given hashbang url into properties
>, <Line: -   * @param {string} url Hashbang url
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  this.$$parse = function(url) {
>, <Line: -    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
>, <Line: -    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
>, <Line: -        ? beginsWith(hashPrefix, withoutBaseUrl)
>, <Line: -        : (this.$$html5)
>, <Line: -          ? withoutBaseUrl
>, <Line: -          : '';
>, <Line: -    if (!isString(withoutHashUrl)) {
>, <Line: -      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url,
>, <Line: -          hashPrefix);
>, <Line: -    }
>, <Line: -    parseAppUrl(withoutHashUrl, this);
>, <Line: -    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
>, <Line: -    this.$$compose();
>, <Line: -    /*
>, <Line: -     * In Windows, on an anchor node on documents loaded from
>, <Line: -     * the filesystem, the browser will return a pathname
>, <Line: -     * prefixed with the drive name ('/C:/path') when a
>, <Line: -     * pathname without a drive is set:
>, <Line: -     *  * a.setAttribute('href', '/foo')
>, <Line: -     *   * a.pathname === '/C:/foo' //true
>, <Line: -     *
>, <Line: -     * Inside of Angular, we're always using pathnames that
>, <Line: -     * do not include drive names for routing.
>, <Line: -     */
>, <Line: -    function removeWindowsDriveName(path, url, base) {
>, <Line: -      /*
>, <Line: -      Matches paths for file protocol on windows,
>, <Line: -      such as /C:/foo/bar, and captures only /foo/bar.
>, <Line: -      */
>, <Line: -      var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
>, <Line: -      var firstPathSegmentMatch;
>, <Line: -      //Get the relative path from the input URL.
>, <Line: -      if (url.indexOf(base) === 0) {
>, <Line: -        url = url.replace(base, '');
>, <Line: -      }
>, <Line: -      // The input URL intentionally contains a first path segment that ends with a colon.
>, <Line: -      if (windowsFilePathExp.exec(url)) {
>, <Line: -        return path;
>, <Line: -      }
>, <Line: -      firstPathSegmentMatch = windowsFilePathExp.exec(path);
>, <Line: -      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * Compose hashbang url and update `absUrl` property
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  this.$$compose = function() {
>, <Line: -    var search = toKeyValue(this.$$search),
>, <Line: -        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: -    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: -    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
>, <Line: -  };
>, <Line: -  this.$$parseLinkUrl = function(url, relHref) {
>, <Line: -    if (stripHash(appBase) == stripHash(url)) {
>, <Line: -      this.$$parse(url);
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    return false;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * LocationHashbangUrl represents url
>, <Line: - * This object is exposed as $location service when html5 history api is enabled but the browser
>, <Line: - * does not support it.
>, <Line: - *
>, <Line: - * @constructor
>, <Line: - * @param {string} appBase application base URL
>, <Line: - * @param {string} hashPrefix hashbang prefix
>, <Line: - */
>, <Line: -function LocationHashbangInHtml5Url(appBase, hashPrefix) {
>, <Line: -  this.$$html5 = true;
>, <Line: -  LocationHashbangUrl.apply(this, arguments);
>, <Line: -  var appBaseNoFile = stripFile(appBase);
>, <Line: -  this.$$parseLinkUrl = function(url, relHref) {
>, <Line: -    if (relHref && relHref[0] === '#') {
>, <Line: -      // special case for links to hash fragments:
>, <Line: -      // keep the old url and only replace the hash fragment
>, <Line: -      this.hash(relHref.slice(1));
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    var rewrittenUrl;
>, <Line: -    var appUrl;
>, <Line: -    if (appBase == stripHash(url)) {
>, <Line: -      rewrittenUrl = url;
>, <Line: -    } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
>, <Line: -      rewrittenUrl = appBase + hashPrefix + appUrl;
>, <Line: -    } else if (appBaseNoFile === url + '/') {
>, <Line: -      rewrittenUrl = appBaseNoFile;
>, <Line: -    }
>, <Line: -    if (rewrittenUrl) {
>, <Line: -      this.$$parse(rewrittenUrl);
>, <Line: -    }
>, <Line: -    return !!rewrittenUrl;
>, <Line: -  };
>, <Line: -  this.$$compose = function() {
>, <Line: -    var search = toKeyValue(this.$$search),
>, <Line: -        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
>, <Line: -    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
>, <Line: -    // include hashPrefix in $$absUrl when $$url is empty so IE8 & 9 do not reload page because of removal of '#'
>, <Line: -    this.$$absUrl = appBase + hashPrefix + this.$$url;
>, <Line: -  };
>, <Line: -}
>, <Line: -var locationPrototype = {
>, <Line: -  /**
>, <Line: -   * Are we in html5 mode?
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  $$html5: false,
>, <Line: -  /**
>, <Line: -   * Has any change been replacing?
>, <Line: -   * @private
>, <Line: -   */
>, <Line: -  $$replace: false,
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#absUrl
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter only.
>, <Line: -   *
>, <Line: -   * Return full url representation with all segments encoded according to rules specified in
>, <Line: -   * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var absUrl = $location.absUrl();
>, <Line: -   * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @return {string} full url
>, <Line: -   */
>, <Line: -  absUrl: locationGetter('$$absUrl'),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#url
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter / setter.
>, <Line: -   *
>, <Line: -   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
>, <Line: -   *
>, <Line: -   * Change path, search and hash, when called with parameter and return `$location`.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var url = $location.url();
>, <Line: -   * // => "/some/path?foo=bar&baz=xoxo"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
>, <Line: -   * @return {string} url
>, <Line: -   */
>, <Line: -  url: function(url) {
>, <Line: -    if (isUndefined(url))
>, <Line: -      return this.$$url;
>, <Line: -    var match = PATH_MATCH.exec(url);
>, <Line: -    if (match[1] || url === '') this.path(decodeURIComponent(match[1]));
>, <Line: -    if (match[2] || match[1] || url === '') this.search(match[3] || '');
>, <Line: -    this.hash(match[5] || '');
>, <Line: -    return this;
>, <Line: -  },
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#protocol
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter only.
>, <Line: -   *
>, <Line: -   * Return protocol of current url.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var protocol = $location.protocol();
>, <Line: -   * // => "http"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @return {string} protocol of current url
>, <Line: -   */
>, <Line: -  protocol: locationGetter('$$protocol'),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#host
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter only.
>, <Line: -   *
>, <Line: -   * Return host of current url.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var host = $location.host();
>, <Line: -   * // => "example.com"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @return {string} host of current url.
>, <Line: -   */
>, <Line: -  host: locationGetter('$$host'),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#port
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter only.
>, <Line: -   *
>, <Line: -   * Return port of current url.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var port = $location.port();
>, <Line: -   * // => 80
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @return {Number} port
>, <Line: -   */
>, <Line: -  port: locationGetter('$$port'),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#path
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter / setter.
>, <Line: -   *
>, <Line: -   * Return path of current url when called without any parameter.
>, <Line: -   *
>, <Line: -   * Change path when called with parameter and return `$location`.
>, <Line: -   *
>, <Line: -   * Note: Path should always begin with forward slash (/), this method will add the forward slash
>, <Line: -   * if it is missing.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var path = $location.path();
>, <Line: -   * // => "/some/path"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {(string|number)=} path New path
>, <Line: -   * @return {string} path
>, <Line: -   */
>, <Line: -  path: locationGetterSetter('$$path', function(path) {
>, <Line: -    path = path !== null ? path.toString() : '';
>, <Line: -    return path.charAt(0) == '/' ? path : '/' + path;
>, <Line: -  }),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#search
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter / setter.
>, <Line: -   *
>, <Line: -   * Return search part (as object) of current url when called without any parameter.
>, <Line: -   *
>, <Line: -   * Change search part when called with parameter and return `$location`.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
>, <Line: -   * var searchObject = $location.search();
>, <Line: -   * // => {foo: 'bar', baz: 'xoxo'}
>, <Line: -   *
>, <Line: -   * // set foo to 'yipee'
>, <Line: -   * $location.search('foo', 'yipee');
>, <Line: -   * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
>, <Line: -   * hash object.
>, <Line: -   *
>, <Line: -   * When called with a single argument the method acts as a setter, setting the `search` component
>, <Line: -   * of `$location` to the specified value.
>, <Line: -   *
>, <Line: -   * If the argument is a hash object containing an array of values, these values will be encoded
>, <Line: -   * as duplicate search parameters in the url.
>, <Line: -   *
>, <Line: -   * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number, then `paramValue`
>, <Line: -   * will override only a single search property.
>, <Line: -   *
>, <Line: -   * If `paramValue` is an array, it will override the property of the `search` component of
>, <Line: -   * `$location` specified via the first argument.
>, <Line: -   *
>, <Line: -   * If `paramValue` is `null`, the property specified via the first argument will be deleted.
>, <Line: -   *
>, <Line: -   * If `paramValue` is `true`, the property specified via the first argument will be added with no
>, <Line: -   * value nor trailing equal sign.
>, <Line: -   *
>, <Line: -   * @return {Object} If called with no arguments returns the parsed `search` object. If called with
>, <Line: -   * one or more arguments returns `$location` object itself.
>, <Line: -   */
>, <Line: -  search: function(search, paramValue) {
>, <Line: -    switch (arguments.length) {
>, <Line: -      case 0:
>, <Line: -        return this.$$search;
>, <Line: -      case 1:
>, <Line: -        if (isString(search) || isNumber(search)) {
>, <Line: -          search = search.toString();
>, <Line: -          this.$$search = parseKeyValue(search);
>, <Line: -        } else if (isObject(search)) {
>, <Line: -          search = copy(search, {});
>, <Line: -          // remove object undefined or null properties
>, <Line: -          forEach(search, function(value, key) {
>, <Line: -            if (value == null) delete search[key];
>, <Line: -          });
>, <Line: -          this.$$search = search;
>, <Line: -        } else {
>, <Line: -          throw $locationMinErr('isrcharg',
>, <Line: -              'The first argument of the `$location#search()` call must be a string or an object.');
>, <Line: -        }
>, <Line: -        break;
>, <Line: -      default:
>, <Line: -        if (isUndefined(paramValue) || paramValue === null) {
>, <Line: -          delete this.$$search[search];
>, <Line: -        } else {
>, <Line: -          this.$$search[search] = paramValue;
>, <Line: -        }
>, <Line: -    }
>, <Line: -    this.$$compose();
>, <Line: -    return this;
>, <Line: -  },
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#hash
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter / setter.
>, <Line: -   *
>, <Line: -   * Return hash fragment when called without any parameter.
>, <Line: -   *
>, <Line: -   * Change hash fragment when called with parameter and return `$location`.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   * // given url http://example.com/some/path?foo=bar&baz=xoxo#hashValue
>, <Line: -   * var hash = $location.hash();
>, <Line: -   * // => "hashValue"
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {(string|number)=} hash New hash fragment
>, <Line: -   * @return {string} hash
>, <Line: -   */
>, <Line: -  hash: locationGetterSetter('$$hash', function(hash) {
>, <Line: -    return hash !== null ? hash.toString() : '';
>, <Line: -  }),
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#replace
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * If called, all changes to $location during current `$digest` will be replacing current history
>, <Line: -   * record, instead of adding new one.
>, <Line: -   */
>, <Line: -  replace: function() {
>, <Line: -    this.$$replace = true;
>, <Line: -    return this;
>, <Line: -  }
>, <Line: -};
>, <Line: -forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
>, <Line: -  Location.prototype = Object.create(locationPrototype);
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $location#state
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This method is getter / setter.
>, <Line: -   *
>, <Line: -   * Return the history state object when called without any parameter.
>, <Line: -   *
>, <Line: -   * Change the history state object when called with one parameter and return `$location`.
>, <Line: -   * The state object is later passed to `pushState` or `replaceState`.
>, <Line: -   *
>, <Line: -   * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
>, <Line: -   * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
>, <Line: -   * older browsers (like IE9 or Android < 4.0), don't use this method.
>, <Line: -   *
>, <Line: -   * @param {object=} state State object for pushState or replaceState
>, <Line: -   * @return {object} state
>, <Line: -   */
>, <Line: -  Location.prototype.state = function(state) {
>, <Line: -    if (!arguments.length)
>, <Line: -      return this.$$state;
>, <Line: -    if (Location !== LocationHtml5Url || !this.$$html5) {
>, <Line: -      throw $locationMinErr('nostate', 'History API state support is available only ' +
>, <Line: -        'in HTML5 mode and only in browsers supporting HTML5 History API');
>, <Line: -    }
>, <Line: -    // The user might modify `stateObject` after invoking `$location.state(stateObject)`
>, <Line: -    // but we're changing the $$state reference to $browser.state() during the $digest
>, <Line: -    // so the modification window is narrow.
>, <Line: -    this.$$state = isUndefined(state) ? null : state;
>, <Line: -    return this;
>, <Line: -  };
>, <Line: -});
>, <Line: -function locationGetter(property) {
>, <Line: -  return function() {
>, <Line: -    return this[property];
>, <Line: -  };
>, <Line: -}
>, <Line: -function locationGetterSetter(property, preprocess) {
>, <Line: -  return function(value) {
>, <Line: -    if (isUndefined(value))
>, <Line: -      return this[property];
>, <Line: -    this[property] = preprocess(value);
>, <Line: -    this.$$compose();
>, <Line: -    return this;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $location
>, <Line: - *
>, <Line: - * @requires $rootElement
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The $location service parses the URL in the browser address bar (based on the
>, <Line: - * [window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
>, <Line: - * available to your application. Changes to the URL in the address bar are reflected into
>, <Line: - * $location service and changes to $location are reflected into the browser address bar.
>, <Line: - *
>, <Line: - * **The $location service:**
>, <Line: - *
>, <Line: - * - Exposes the current URL in the browser address bar, so you can
>, <Line: - *   - Watch and observe the URL.
>, <Line: - *   - Change the URL.
>, <Line: - * - Synchronizes the URL with the browser when the user
>, <Line: - *   - Changes the address bar.
>, <Line: - *   - Clicks the back or forward button (or clicks a History link).
>, <Line: - *   - Clicks on a link.
>, <Line: - * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
>, <Line: - *
>, <Line: - * For more information see {@link guide/$location Developer Guide: Using $location}
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $locationProvider
>, <Line: - * @description
>, <Line: - * Use the `$locationProvider` to configure how the application deep linking paths are stored.
>, <Line: - */
>, <Line: -function $LocationProvider() {
>, <Line: -  var hashPrefix = '',
>, <Line: -      html5Mode = {
>, <Line: -        enabled: false,
>, <Line: -        requireBase: true,
>, <Line: -        rewriteLinks: true
>, <Line: -      };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $locationProvider#hashPrefix
>, <Line: -   * @description
>, <Line: -   * @param {string=} prefix Prefix for hash part (containing path and search)
>, <Line: -   * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: -   */
>, <Line: -  this.hashPrefix = function(prefix) {
>, <Line: -    if (isDefined(prefix)) {
>, <Line: -      hashPrefix = prefix;
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return hashPrefix;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $locationProvider#html5Mode
>, <Line: -   * @description
>, <Line: -   * @param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.
>, <Line: -   *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported
>, <Line: -   *   properties:
>, <Line: -   *   - **enabled**  `{boolean}`  (default: false) If true, will rely on `history.pushState` to
>, <Line: -   *     change urls where supported. Will fall back to hash-prefixed paths in browsers that do not
>, <Line: -   *     support `pushState`.
>, <Line: -   *   - **requireBase** - `{boolean}` - (default: `true`) When html5Mode is enabled, specifies
>, <Line: -   *     whether or not a <base> tag is required to be present. If `enabled` and `requireBase` are
>, <Line: -   *     true, and a base tag is not present, an error will be thrown when `$location` is injected.
>, <Line: -   *     See the {@link guide/$location $location guide for more information}
>, <Line: -   *   - **rewriteLinks** - `{boolean}` - (default: `true`) When html5Mode is enabled,
>, <Line: -   *     enables/disables url rewriting for relative links.
>, <Line: -   *
>, <Line: -   * @returns {Object} html5Mode object if used as getter or itself (chaining) if used as setter
>, <Line: -   */
>, <Line: -  this.html5Mode = function(mode) {
>, <Line: -    if (isBoolean(mode)) {
>, <Line: -      html5Mode.enabled = mode;
>, <Line: -      return this;
>, <Line: -    } else if (isObject(mode)) {
>, <Line: -      if (isBoolean(mode.enabled)) {
>, <Line: -        html5Mode.enabled = mode.enabled;
>, <Line: -      }
>, <Line: -      if (isBoolean(mode.requireBase)) {
>, <Line: -        html5Mode.requireBase = mode.requireBase;
>, <Line: -      }
>, <Line: -      if (isBoolean(mode.rewriteLinks)) {
>, <Line: -        html5Mode.rewriteLinks = mode.rewriteLinks;
>, <Line: -      }
>, <Line: -      return this;
>, <Line: -    } else {
>, <Line: -      return html5Mode;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc event
>, <Line: -   * @name $location#$locationChangeStart
>, <Line: -   * @eventType broadcast on root scope
>, <Line: -   * @description
>, <Line: -   * Broadcasted before a URL will change.
>, <Line: -   *
>, <Line: -   * This change can be prevented by calling
>, <Line: -   * `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on} for more
>, <Line: -   * details about event object. Upon successful change
>, <Line: -   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} is fired.
>, <Line: -   *
>, <Line: -   * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
>, <Line: -   * the browser supports the HTML5 History API.
>, <Line: -   *
>, <Line: -   * @param {Object} angularEvent Synthetic event object.
>, <Line: -   * @param {string} newUrl New URL
>, <Line: -   * @param {string=} oldUrl URL that was before it was changed.
>, <Line: -   * @param {string=} newState New history state object
>, <Line: -   * @param {string=} oldState History state object that was before it was changed.
>, <Line: -   */
>, <Line: -  /**
>, <Line: -   * @ngdoc event
>, <Line: -   * @name $location#$locationChangeSuccess
>, <Line: -   * @eventType broadcast on root scope
>, <Line: -   * @description
>, <Line: -   * Broadcasted after a URL was changed.
>, <Line: -   *
>, <Line: -   * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
>, <Line: -   * the browser supports the HTML5 History API.
>, <Line: -   *
>, <Line: -   * @param {Object} angularEvent Synthetic event object.
>, <Line: -   * @param {string} newUrl New URL
>, <Line: -   * @param {string=} oldUrl URL that was before it was changed.
>, <Line: -   * @param {string=} newState New history state object
>, <Line: -   * @param {string=} oldState History state object that was before it was changed.
>, <Line: -   */
>, <Line: -  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
>, <Line: -      function($rootScope, $browser, $sniffer, $rootElement) {
>, <Line: -    var $location,
>, <Line: -        LocationMode,
>, <Line: -        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
>, <Line: -        initialUrl = $browser.url(),
>, <Line: -        appBase;
>, <Line: -    if (html5Mode.enabled) {
>, <Line: -      if (!baseHref && html5Mode.requireBase) {
>, <Line: -        throw $locationMinErr('nobase',
>, <Line: -          "$location in HTML5 mode requires a <base> tag to be present!");
>, <Line: -      }
>, <Line: -      appBase = serverBase(initialUrl) + (baseHref || '/');
>, <Line: -      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
>, <Line: -    } else {
>, <Line: -      appBase = stripHash(initialUrl);
>, <Line: -      LocationMode = LocationHashbangUrl;
>, <Line: -    }
>, <Line: -    $location = new LocationMode(appBase, '#' + hashPrefix);
>, <Line: -    $location.$$parseLinkUrl(initialUrl, initialUrl);
>, <Line: -    $location.$$state = $browser.state();
>, <Line: -    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
>, <Line: -    function setBrowserUrlWithFallback(url, replace, state) {
>, <Line: -      var oldUrl = $location.url();
>, <Line: -      var oldState = $location.$$state;
>, <Line: -      try {
>, <Line: -        $browser.url(url, replace, state);
>, <Line: -        // Make sure $location.state() returns referentially identical (not just deeply equal)
>, <Line: -        // state object; this makes possible quick checking if the state changed in the digest
>, <Line: -        // loop. Checking deep equality would be too expensive.
>, <Line: -        $location.$$state = $browser.state();
>, <Line: -      } catch (e) {
>, <Line: -        // Restore old values if pushState fails
>, <Line: -        $location.url(oldUrl);
>, <Line: -        $location.$$state = oldState;
>, <Line: -        throw e;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    $rootElement.on('click', function(event) {
>, <Line: -      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
>, <Line: -      // currently we open nice url link and redirect then
>, <Line: -      if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.which == 2) return;
>, <Line: -      var elm = jqLite(event.target);
>, <Line: -      // traverse the DOM up to find first A tag
>, <Line: -      while (nodeName_(elm[0]) !== 'a') {
>, <Line: -        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
>, <Line: -        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
>, <Line: -      }
>, <Line: -      var absHref = elm.prop('href');
>, <Line: -      // get the actual href attribute - see
>, <Line: -      // http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx
>, <Line: -      var relHref = elm.attr('href') || elm.attr('xlink:href');
>, <Line: -      if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
>, <Line: -        // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
>, <Line: -        // an animation.
>, <Line: -        absHref = urlResolve(absHref.animVal).href;
>, <Line: -      }
>, <Line: -      // Ignore when url is started with javascript: or mailto:
>, <Line: -      if (IGNORE_URI_REGEXP.test(absHref)) return;
>, <Line: -      if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
>, <Line: -        if ($location.$$parseLinkUrl(absHref, relHref)) {
>, <Line: -          // We do a preventDefault for all urls that are part of the angular application,
>, <Line: -          // in html5mode and also without, so that we are able to abort navigation without
>, <Line: -          // getting double entries in the location history.
>, <Line: -          event.preventDefault();
>, <Line: -          // update location manually
>, <Line: -          if ($location.absUrl() != $browser.url()) {
>, <Line: -            $rootScope.$apply();
>, <Line: -            // hack to work around FF6 bug 684208 when scenario runner clicks on links
>, <Line: -            window.angular['ff-684208-preventDefault'] = true;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    });
>, <Line: -    // rewrite hashbang url <> html5 url
>, <Line: -    if ($location.absUrl() != initialUrl) {
>, <Line: -      $browser.url($location.absUrl(), true);
>, <Line: -    }
>, <Line: -    var initializing = true;
>, <Line: -    // update $location when $browser url changes
>, <Line: -    $browser.onUrlChange(function(newUrl, newState) {
>, <Line: -      $rootScope.$evalAsync(function() {
>, <Line: -        var oldUrl = $location.absUrl();
>, <Line: -        var oldState = $location.$$state;
>, <Line: -        var defaultPrevented;
>, <Line: -        $location.$$parse(newUrl);
>, <Line: -        $location.$$state = newState;
>, <Line: -        defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
>, <Line: -            newState, oldState).defaultPrevented;
>, <Line: -        // if the location was changed by a `$locationChangeStart` handler then stop
>, <Line: -        // processing this location change
>, <Line: -        if ($location.absUrl() !== newUrl) return;
>, <Line: -        if (defaultPrevented) {
>, <Line: -          $location.$$parse(oldUrl);
>, <Line: -          $location.$$state = oldState;
>, <Line: -          setBrowserUrlWithFallback(oldUrl, false, oldState);
>, <Line: -        } else {
>, <Line: -          initializing = false;
>, <Line: -          afterLocationChange(oldUrl, oldState);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      if (!$rootScope.$$phase) $rootScope.$digest();
>, <Line: -    });
>, <Line: -    // update browser
>, <Line: -    $rootScope.$watch(function $locationWatch() {
>, <Line: -      var oldUrl = $browser.url();
>, <Line: -      var oldState = $browser.state();
>, <Line: -      var currentReplace = $location.$$replace;
>, <Line: -      var urlOrStateChanged = oldUrl !== $location.absUrl() ||
>, <Line: -        ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
>, <Line: -      if (initializing || urlOrStateChanged) {
>, <Line: -        initializing = false;
>, <Line: -        $rootScope.$evalAsync(function() {
>, <Line: -          var newUrl = $location.absUrl();
>, <Line: -          var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
>, <Line: -              $location.$$state, oldState).defaultPrevented;
>, <Line: -          // if the location was changed by a `$locationChangeStart` handler then stop
>, <Line: -          // processing this location change
>, <Line: -          if ($location.absUrl() !== newUrl) return;
>, <Line: -          if (defaultPrevented) {
>, <Line: -            $location.$$parse(oldUrl);
>, <Line: -            $location.$$state = oldState;
>, <Line: -          } else {
>, <Line: -            if (urlOrStateChanged) {
>, <Line: -              setBrowserUrlWithFallback(newUrl, currentReplace,
>, <Line: -                                        oldState === $location.$$state ? null : $location.$$state);
>, <Line: -            }
>, <Line: -            afterLocationChange(oldUrl, oldState);
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -      $location.$$replace = false;
>, <Line: -      // we don't need to return anything because $evalAsync will make the digest loop dirty when
>, <Line: -      // there is a change
>, <Line: -    });
>, <Line: -    return $location;
>, <Line: -    function afterLocationChange(oldUrl, oldState) {
>, <Line: -      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl,
>, <Line: -        $location.$$state, oldState);
>, <Line: -    }
>, <Line: -}];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $log
>, <Line: - * @requires $window
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Simple service for logging. Default implementation safely writes the message
>, <Line: - * into the browser's console (if present).
>, <Line: - *
>, <Line: - * The main purpose of this service is to simplify debugging and troubleshooting.
>, <Line: - *
>, <Line: - * The default is to log `debug` messages. You can use
>, <Line: - * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="logExample">
>, <Line: -     <file name="script.js">
>, <Line: -       angular.module('logExample', [])
>, <Line: -         .controller('LogController', ['$scope', '$log', function($scope, $log) {
>, <Line: -           $scope.$log = $log;
>, <Line: -           $scope.message = 'Hello World!';
>, <Line: -         }]);
>, <Line: -     </file>
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="LogController">
>, <Line: -         <p>Reload this page with open console, enter text and hit the log button...</p>
>, <Line: -         Message:
>, <Line: -         <input type="text" ng-model="message"/>
>, <Line: -         <button ng-click="$log.log(message)">log</button>
>, <Line: -         <button ng-click="$log.warn(message)">warn</button>
>, <Line: -         <button ng-click="$log.info(message)">info</button>
>, <Line: -         <button ng-click="$log.error(message)">error</button>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $logProvider
>, <Line: - * @description
>, <Line: - * Use the `$logProvider` to configure how the application logs messages
>, <Line: - */
>, <Line: -function $LogProvider() {
>, <Line: -  var debug = true,
>, <Line: -      self = this;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $logProvider#debugEnabled
>, <Line: -   * @description
>, <Line: -   * @param {boolean=} flag enable or disable debug level messages
>, <Line: -   * @returns {*} current value if used as getter or itself (chaining) if used as setter
>, <Line: -   */
>, <Line: -  this.debugEnabled = function(flag) {
>, <Line: -    if (isDefined(flag)) {
>, <Line: -      debug = flag;
>, <Line: -    return this;
>, <Line: -    } else {
>, <Line: -      return debug;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$get = ['$window', function($window) {
>, <Line: -    return {
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $log#log
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Write a log message
>, <Line: -       */
>, <Line: -      log: consoleLog('log'),
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $log#info
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Write an information message
>, <Line: -       */
>, <Line: -      info: consoleLog('info'),
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $log#warn
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Write a warning message
>, <Line: -       */
>, <Line: -      warn: consoleLog('warn'),
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $log#error
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Write an error message
>, <Line: -       */
>, <Line: -      error: consoleLog('error'),
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $log#debug
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Write a debug message
>, <Line: -       */
>, <Line: -      debug: (function() {
>, <Line: -        var fn = consoleLog('debug');
>, <Line: -        return function() {
>, <Line: -          if (debug) {
>, <Line: -            fn.apply(self, arguments);
>, <Line: -          }
>, <Line: -        };
>, <Line: -      }())
>, <Line: -    };
>, <Line: -    function formatError(arg) {
>, <Line: -      if (arg instanceof Error) {
>, <Line: -        if (arg.stack) {
>, <Line: -          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
>, <Line: -              ? 'Error: ' + arg.message + '\n' + arg.stack
>, <Line: -              : arg.stack;
>, <Line: -        } else if (arg.sourceURL) {
>, <Line: -          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return arg;
>, <Line: -    }
>, <Line: -    function consoleLog(type) {
>, <Line: -      var console = $window.console || {},
>, <Line: -          logFn = console[type] || console.log || noop,
>, <Line: -          hasApply = false;
>, <Line: -      // Note: reading logFn.apply throws an error in IE11 in IE8 document mode.
>, <Line: -      // The reason behind this is that console.log has type "object" in IE8...
>, <Line: -      try {
>, <Line: -        hasApply = !!logFn.apply;
>, <Line: -      } catch (e) {}
>, <Line: -      if (hasApply) {
>, <Line: -        return function() {
>, <Line: -          var args = [];
>, <Line: -          forEach(arguments, function(arg) {
>, <Line: -            args.push(formatError(arg));
>, <Line: -          });
>, <Line: -          return logFn.apply(console, args);
>, <Line: -        };
>, <Line: -      }
>, <Line: -      // we are IE which either doesn't have window.console => this is noop and we do nothing,
>, <Line: -      // or we are IE where console.log doesn't have apply so we log at least first 2 args
>, <Line: -      return function(arg1, arg2) {
>, <Line: -        logFn(arg1, arg2 == null ? '' : arg2);
>, <Line: -      };
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -var $parseMinErr = minErr('$parse');
>, <Line: -// Sandboxing Angular Expressions
>, <Line: -// ------------------------------
>, <Line: -// Angular expressions are generally considered safe because these expressions only have direct
>, <Line: -// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by
>, <Line: -// obtaining a reference to native JS functions such as the Function constructor.
>, <Line: -//
>, <Line: -// As an example, consider the following Angular expression:
>, <Line: -//
>, <Line: -//   {}.toString.constructor('alert("evil JS code")')
>, <Line: -//
>, <Line: -// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
>, <Line: -// against the expression language, but not to prevent exploits that were enabled by exposing
>, <Line: -// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good
>, <Line: -// practice and therefore we are not even trying to protect against interaction with an object
>, <Line: -// explicitly exposed in this way.
>, <Line: -//
>, <Line: -// In general, it is not possible to access a Window object from an angular expression unless a
>, <Line: -// window or some DOM object that has a reference to window is published onto a Scope.
>, <Line: -// Similarly we prevent invocations of function known to be dangerous, as well as assignments to
>, <Line: -// native objects.
>, <Line: -//
>, <Line: -// See https://docs.angularjs.org/guide/security
>, <Line: -function ensureSafeMemberName(name, fullExpression) {
>, <Line: -  if (name === "__defineGetter__" || name === "__defineSetter__"
>, <Line: -      || name === "__lookupGetter__" || name === "__lookupSetter__"
>, <Line: -      || name === "__proto__") {
>, <Line: -    throw $parseMinErr('isecfld',
>, <Line: -        'Attempting to access a disallowed field in Angular expressions! '
>, <Line: -        + 'Expression: {0}', fullExpression);
>, <Line: -  }
>, <Line: -  return name;
>, <Line: -}
>, <Line: -function ensureSafeObject(obj, fullExpression) {
>, <Line: -  // nifty check if obj is Function that is fast and works across iframes and other contexts
>, <Line: -  if (obj) {
>, <Line: -    if (obj.constructor === obj) {
>, <Line: -      throw $parseMinErr('isecfn',
>, <Line: -          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
>, <Line: -          fullExpression);
>, <Line: -    } else if (// isWindow(obj)
>, <Line: -        obj.window === obj) {
>, <Line: -      throw $parseMinErr('isecwindow',
>, <Line: -          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
>, <Line: -          fullExpression);
>, <Line: -    } else if (// isElement(obj)
>, <Line: -        obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
>, <Line: -      throw $parseMinErr('isecdom',
>, <Line: -          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
>, <Line: -          fullExpression);
>, <Line: -    } else if (// block Object so that we can't get hold of dangerous Object.* methods
>, <Line: -        obj === Object) {
>, <Line: -      throw $parseMinErr('isecobj',
>, <Line: -          'Referencing Object in Angular expressions is disallowed! Expression: {0}',
>, <Line: -          fullExpression);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return obj;
>, <Line: -}
>, <Line: -var CALL = Function.prototype.call;
>, <Line: -var APPLY = Function.prototype.apply;
>, <Line: -var BIND = Function.prototype.bind;
>, <Line: -function ensureSafeFunction(obj, fullExpression) {
>, <Line: -  if (obj) {
>, <Line: -    if (obj.constructor === obj) {
>, <Line: -      throw $parseMinErr('isecfn',
>, <Line: -        'Referencing Function in Angular expressions is disallowed! Expression: {0}',
>, <Line: -        fullExpression);
>, <Line: -    } else if (obj === CALL || obj === APPLY || obj === BIND) {
>, <Line: -      throw $parseMinErr('isecff',
>, <Line: -        'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',
>, <Line: -        fullExpression);
>, <Line: -    }
>, <Line: -  }
>, <Line: -}
>, <Line: -//Keyword constants
>, <Line: -var CONSTANTS = createMap();
>, <Line: -forEach({
>, <Line: -  'null': function() { return null; },
>, <Line: -  'true': function() { return true; },
>, <Line: -  'false': function() { return false; },
>, <Line: -  'undefined': function() {}
>, <Line: -}, function(constantGetter, name) {
>, <Line: -  constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = true;
>, <Line: -  CONSTANTS[name] = constantGetter;
>, <Line: -});
>, <Line: -//Not quite a constant, but can be lex/parsed the same
>, <Line: -CONSTANTS['this'] = function(self) { return self; };
>, <Line: -CONSTANTS['this'].sharedGetter = true;
>, <Line: -//Operators - will be wrapped by binaryFn/unaryFn/assignment/filter
>, <Line: -var OPERATORS = extend(createMap(), {
>, <Line: -    '+':function(self, locals, a, b) {
>, <Line: -      a=a(self, locals); b=b(self, locals);
>, <Line: -      if (isDefined(a)) {
>, <Line: -        if (isDefined(b)) {
>, <Line: -          return a + b;
>, <Line: -        }
>, <Line: -        return a;
>, <Line: -      }
>, <Line: -      return isDefined(b) ? b : undefined;},
>, <Line: -    '-':function(self, locals, a, b) {
>, <Line: -          a=a(self, locals); b=b(self, locals);
>, <Line: -          return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
>, <Line: -        },
>, <Line: -    '*':function(self, locals, a, b) {return a(self, locals) * b(self, locals);},
>, <Line: -    '/':function(self, locals, a, b) {return a(self, locals) / b(self, locals);},
>, <Line: -    '%':function(self, locals, a, b) {return a(self, locals) % b(self, locals);},
>, <Line: -    '===':function(self, locals, a, b) {return a(self, locals) === b(self, locals);},
>, <Line: -    '!==':function(self, locals, a, b) {return a(self, locals) !== b(self, locals);},
>, <Line: -    '==':function(self, locals, a, b) {return a(self, locals) == b(self, locals);},
>, <Line: -    '!=':function(self, locals, a, b) {return a(self, locals) != b(self, locals);},
>, <Line: -    '<':function(self, locals, a, b) {return a(self, locals) < b(self, locals);},
>, <Line: -    '>':function(self, locals, a, b) {return a(self, locals) > b(self, locals);},
>, <Line: -    '<=':function(self, locals, a, b) {return a(self, locals) <= b(self, locals);},
>, <Line: -    '>=':function(self, locals, a, b) {return a(self, locals) >= b(self, locals);},
>, <Line: -    '&&':function(self, locals, a, b) {return a(self, locals) && b(self, locals);},
>, <Line: -    '||':function(self, locals, a, b) {return a(self, locals) || b(self, locals);},
>, <Line: -    '!':function(self, locals, a) {return !a(self, locals);},
>, <Line: -    //Tokenized as operators but parsed as assignment/filters
>, <Line: -    '=':true,
>, <Line: -    '|':true
>, <Line: -});
>, <Line: -var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};
>, <Line: -/////////////////////////////////////////
>, <Line: -/**
>, <Line: - * @constructor
>, <Line: - */
>, <Line: -var Lexer = function(options) {
>, <Line: -  this.options = options;
>, <Line: -};
>, <Line: -Lexer.prototype = {
>, <Line: -  constructor: Lexer,
>, <Line: -  lex: function(text) {
>, <Line: -    this.text = text;
>, <Line: -    this.index = 0;
>, <Line: -    this.tokens = [];
>, <Line: -    while (this.index < this.text.length) {
>, <Line: -      var ch = this.text.charAt(this.index);
>, <Line: -      if (ch === '"' || ch === "'") {
>, <Line: -        this.readString(ch);
>, <Line: -      } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
>, <Line: -        this.readNumber();
>, <Line: -      } else if (this.isIdent(ch)) {
>, <Line: -        this.readIdent();
>, <Line: -      } else if (this.is(ch, '(){}[].,;:?')) {
>, <Line: -        this.tokens.push({index: this.index, text: ch});
>, <Line: -        this.index++;
>, <Line: -      } else if (this.isWhitespace(ch)) {
>, <Line: -        this.index++;
>, <Line: -      } else {
>, <Line: -        var ch2 = ch + this.peek();
>, <Line: -        var ch3 = ch2 + this.peek(2);
>, <Line: -        var op1 = OPERATORS[ch];
>, <Line: -        var op2 = OPERATORS[ch2];
>, <Line: -        var op3 = OPERATORS[ch3];
>, <Line: -        if (op1 || op2 || op3) {
>, <Line: -          var token = op3 ? ch3 : (op2 ? ch2 : ch);
>, <Line: -          this.tokens.push({index: this.index, text: token, operator: true});
>, <Line: -          this.index += token.length;
>, <Line: -        } else {
>, <Line: -          this.throwError('Unexpected next character ', this.index, this.index + 1);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return this.tokens;
>, <Line: -  },
>, <Line: -  is: function(ch, chars) {
>, <Line: -    return chars.indexOf(ch) !== -1;
>, <Line: -  },
>, <Line: -  peek: function(i) {
>, <Line: -    var num = i || 1;
>, <Line: -    return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
>, <Line: -  },
>, <Line: -  isNumber: function(ch) {
>, <Line: -    return ('0' <= ch && ch <= '9') && typeof ch === "string";
>, <Line: -  },
>, <Line: -  isWhitespace: function(ch) {
>, <Line: -    // IE treats non-breaking space as \u00A0
>, <Line: -    return (ch === ' ' || ch === '\r' || ch === '\t' ||
>, <Line: -            ch === '\n' || ch === '\v' || ch === '\u00A0');
>, <Line: -  },
>, <Line: -  isIdent: function(ch) {
>, <Line: -    return ('a' <= ch && ch <= 'z' ||
>, <Line: -            'A' <= ch && ch <= 'Z' ||
>, <Line: -            '_' === ch || ch === '$');
>, <Line: -  },
>, <Line: -  isExpOperator: function(ch) {
>, <Line: -    return (ch === '-' || ch === '+' || this.isNumber(ch));
>, <Line: -  },
>, <Line: -  throwError: function(error, start, end) {
>, <Line: -    end = end || this.index;
>, <Line: -    var colStr = (isDefined(start)
>, <Line: -            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring(start, end) + ']'
>, <Line: -            : ' ' + end);
>, <Line: -    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
>, <Line: -        error, colStr, this.text);
>, <Line: -  },
>, <Line: -  readNumber: function() {
>, <Line: -    var number = '';
>, <Line: -    var start = this.index;
>, <Line: -    while (this.index < this.text.length) {
>, <Line: -      var ch = lowercase(this.text.charAt(this.index));
>, <Line: -      if (ch == '.' || this.isNumber(ch)) {
>, <Line: -        number += ch;
>, <Line: -      } else {
>, <Line: -        var peekCh = this.peek();
>, <Line: -        if (ch == 'e' && this.isExpOperator(peekCh)) {
>, <Line: -          number += ch;
>, <Line: -        } else if (this.isExpOperator(ch) &&
>, <Line: -            peekCh && this.isNumber(peekCh) &&
>, <Line: -            number.charAt(number.length - 1) == 'e') {
>, <Line: -          number += ch;
>, <Line: -        } else if (this.isExpOperator(ch) &&
>, <Line: -            (!peekCh || !this.isNumber(peekCh)) &&
>, <Line: -            number.charAt(number.length - 1) == 'e') {
>, <Line: -          this.throwError('Invalid exponent');
>, <Line: -        } else {
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      this.index++;
>, <Line: -    }
>, <Line: -    this.tokens.push({
>, <Line: -      index: start,
>, <Line: -      text: number,
>, <Line: -      constant: true,
>, <Line: -      value: Number(number)
>, <Line: -    });
>, <Line: -  },
>, <Line: -  readIdent: function() {
>, <Line: -    var start = this.index;
>, <Line: -    while (this.index < this.text.length) {
>, <Line: -      var ch = this.text.charAt(this.index);
>, <Line: -      if (!(this.isIdent(ch) || this.isNumber(ch))) {
>, <Line: -        break;
>, <Line: -      }
>, <Line: -      this.index++;
>, <Line: -    }
>, <Line: -    this.tokens.push({
>, <Line: -      index: start,
>, <Line: -      text: this.text.slice(start, this.index),
>, <Line: -      identifier: true
>, <Line: -    });
>, <Line: -  },
>, <Line: -  readString: function(quote) {
>, <Line: -    var start = this.index;
>, <Line: -    this.index++;
>, <Line: -    var string = '';
>, <Line: -    var rawString = quote;
>, <Line: -    var escape = false;
>, <Line: -    while (this.index < this.text.length) {
>, <Line: -      var ch = this.text.charAt(this.index);
>, <Line: -      rawString += ch;
>, <Line: -      if (escape) {
>, <Line: -        if (ch === 'u') {
>, <Line: -          var hex = this.text.substring(this.index + 1, this.index + 5);
>, <Line: -          if (!hex.match(/[\da-f]{4}/i))
>, <Line: -            this.throwError('Invalid unicode escape [\\u' + hex + ']');
>, <Line: -          this.index += 4;
>, <Line: -          string += String.fromCharCode(parseInt(hex, 16));
>, <Line: -        } else {
>, <Line: -          var rep = ESCAPE[ch];
>, <Line: -          string = string + (rep || ch);
>, <Line: -        }
>, <Line: -        escape = false;
>, <Line: -      } else if (ch === '\\') {
>, <Line: -        escape = true;
>, <Line: -      } else if (ch === quote) {
>, <Line: -        this.index++;
>, <Line: -        this.tokens.push({
>, <Line: -          index: start,
>, <Line: -          text: rawString,
>, <Line: -          constant: true,
>, <Line: -          value: string
>, <Line: -        });
>, <Line: -        return;
>, <Line: -      } else {
>, <Line: -        string += ch;
>, <Line: -      }
>, <Line: -      this.index++;
>, <Line: -    }
>, <Line: -    this.throwError('Unterminated quote', start);
>, <Line: -  }
>, <Line: -};
>, <Line: -function isConstant(exp) {
>, <Line: -  return exp.constant;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @constructor
>, <Line: - */
>, <Line: -var Parser = function(lexer, $filter, options) {
>, <Line: -  this.lexer = lexer;
>, <Line: -  this.$filter = $filter;
>, <Line: -  this.options = options;
>, <Line: -};
>, <Line: -Parser.ZERO = extend(function() {
>, <Line: -  return 0;
>, <Line: -}, {
>, <Line: -  sharedGetter: true,
>, <Line: -  constant: true
>, <Line: -});
>, <Line: -Parser.prototype = {
>, <Line: -  constructor: Parser,
>, <Line: -  parse: function(text) {
>, <Line: -    this.text = text;
>, <Line: -    this.tokens = this.lexer.lex(text);
>, <Line: -    var value = this.statements();
>, <Line: -    if (this.tokens.length !== 0) {
>, <Line: -      this.throwError('is an unexpected token', this.tokens[0]);
>, <Line: -    }
>, <Line: -    value.literal = !!value.literal;
>, <Line: -    value.constant = !!value.constant;
>, <Line: -    return value;
>, <Line: -  },
>, <Line: -  primary: function() {
>, <Line: -    var primary;
>, <Line: -    if (this.expect('(')) {
>, <Line: -      primary = this.filterChain();
>, <Line: -      this.consume(')');
>, <Line: -    } else if (this.expect('[')) {
>, <Line: -      primary = this.arrayDeclaration();
>, <Line: -    } else if (this.expect('{')) {
>, <Line: -      primary = this.object();
>, <Line: -    } else if (this.peek().identifier) {
>, <Line: -      primary = this.identifier();
>, <Line: -    } else if (this.peek().constant) {
>, <Line: -      primary = this.constant();
>, <Line: -    } else {
>, <Line: -      this.throwError('not a primary expression', this.peek());
>, <Line: -    }
>, <Line: -    var next, context;
>, <Line: -    while ((next = this.expect('(', '[', '.'))) {
>, <Line: -      if (next.text === '(') {
>, <Line: -        primary = this.functionCall(primary, context);
>, <Line: -        context = null;
>, <Line: -      } else if (next.text === '[') {
>, <Line: -        context = primary;
>, <Line: -        primary = this.objectIndex(primary);
>, <Line: -      } else if (next.text === '.') {
>, <Line: -        context = primary;
>, <Line: -        primary = this.fieldAccess(primary);
>, <Line: -      } else {
>, <Line: -        this.throwError('IMPOSSIBLE');
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return primary;
>, <Line: -  },
>, <Line: -  throwError: function(msg, token) {
>, <Line: -    throw $parseMinErr('syntax',
>, <Line: -        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
>, <Line: -          token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
>, <Line: -  },
>, <Line: -  peekToken: function() {
>, <Line: -    if (this.tokens.length === 0)
>, <Line: -      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
>, <Line: -    return this.tokens[0];
>, <Line: -  },
>, <Line: -  peek: function(e1, e2, e3, e4) {
>, <Line: -    return this.peekAhead(0, e1, e2, e3, e4);
>, <Line: -  },
>, <Line: -  peekAhead: function(i, e1, e2, e3, e4) {
>, <Line: -    if (this.tokens.length > i) {
>, <Line: -      var token = this.tokens[i];
>, <Line: -      var t = token.text;
>, <Line: -      if (t === e1 || t === e2 || t === e3 || t === e4 ||
>, <Line: -          (!e1 && !e2 && !e3 && !e4)) {
>, <Line: -        return token;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return false;
>, <Line: -  },
>, <Line: -  expect: function(e1, e2, e3, e4) {
>, <Line: -    var token = this.peek(e1, e2, e3, e4);
>, <Line: -    if (token) {
>, <Line: -      this.tokens.shift();
>, <Line: -      return token;
>, <Line: -    }
>, <Line: -    return false;
>, <Line: -  },
>, <Line: -  consume: function(e1) {
>, <Line: -    if (this.tokens.length === 0) {
>, <Line: -      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
>, <Line: -    }
>, <Line: -    var token = this.expect(e1);
>, <Line: -    if (!token) {
>, <Line: -      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
>, <Line: -    }
>, <Line: -    return token;
>, <Line: -  },
>, <Line: -  unaryFn: function(op, right) {
>, <Line: -    var fn = OPERATORS[op];
>, <Line: -    return extend(function $parseUnaryFn(self, locals) {
>, <Line: -      return fn(self, locals, right);
>, <Line: -    }, {
>, <Line: -      constant:right.constant,
>, <Line: -      inputs: [right]
>, <Line: -    });
>, <Line: -  },
>, <Line: -  binaryFn: function(left, op, right, isBranching) {
>, <Line: -    var fn = OPERATORS[op];
>, <Line: -    return extend(function $parseBinaryFn(self, locals) {
>, <Line: -      return fn(self, locals, left, right);
>, <Line: -    }, {
>, <Line: -      constant: left.constant && right.constant,
>, <Line: -      inputs: !isBranching && [left, right]
>, <Line: -    });
>, <Line: -  },
>, <Line: -  identifier: function() {
>, <Line: -    var id = this.consume().text;
>, <Line: -    //Continue reading each `.identifier` unless it is a method invocation
>, <Line: -    while (this.peek('.') && this.peekAhead(1).identifier && !this.peekAhead(2, '(')) {
>, <Line: -      id += this.consume().text + this.consume().text;
>, <Line: -    }
>, <Line: -    return CONSTANTS[id] || getterFn(id, this.options, this.text);
>, <Line: -  },
>, <Line: -  constant: function() {
>, <Line: -    var value = this.consume().value;
>, <Line: -    return extend(function $parseConstant() {
>, <Line: -      return value;
>, <Line: -    }, {
>, <Line: -      constant: true,
>, <Line: -      literal: true
>, <Line: -    });
>, <Line: -  },
>, <Line: -  statements: function() {
>, <Line: -    var statements = [];
>, <Line: -    while (true) {
>, <Line: -      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
>, <Line: -        statements.push(this.filterChain());
>, <Line: -      if (!this.expect(';')) {
>, <Line: -        // optimize for the common case where there is only one statement.
>, <Line: -        // TODO(size): maybe we should not support multiple statements?
>, <Line: -        return (statements.length === 1)
>, <Line: -            ? statements[0]
>, <Line: -            : function $parseStatements(self, locals) {
>, <Line: -                var value;
>, <Line: -                for (var i = 0, ii = statements.length; i < ii; i++) {
>, <Line: -                  value = statements[i](self, locals);
>, <Line: -                }
>, <Line: -                return value;
>, <Line: -              };
>, <Line: -      }
>, <Line: -    }
>, <Line: -  },
>, <Line: -  filterChain: function() {
>, <Line: -    var left = this.expression();
>, <Line: -    var token;
>, <Line: -    while ((token = this.expect('|'))) {
>, <Line: -      left = this.filter(left);
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  filter: function(inputFn) {
>, <Line: -    var fn = this.$filter(this.consume().text);
>, <Line: -    var argsFn;
>, <Line: -    var args;
>, <Line: -    if (this.peek(':')) {
>, <Line: -      argsFn = [];
>, <Line: -      args = []; // we can safely reuse the array
>, <Line: -      while (this.expect(':')) {
>, <Line: -        argsFn.push(this.expression());
>, <Line: -      }
>, <Line: -    }
>, <Line: -    var inputs = [inputFn].concat(argsFn || []);
>, <Line: -    return extend(function $parseFilter(self, locals) {
>, <Line: -      var input = inputFn(self, locals);
>, <Line: -      if (args) {
>, <Line: -        args[0] = input;
>, <Line: -        var i = argsFn.length;
>, <Line: -        while (i--) {
>, <Line: -          args[i + 1] = argsFn[i](self, locals);
>, <Line: -        }
>, <Line: -        return fn.apply(undefined, args);
>, <Line: -      }
>, <Line: -      return fn(input);
>, <Line: -    }, {
>, <Line: -      constant: !fn.$stateful && inputs.every(isConstant),
>, <Line: -      inputs: !fn.$stateful && inputs
>, <Line: -    });
>, <Line: -  },
>, <Line: -  expression: function() {
>, <Line: -    return this.assignment();
>, <Line: -  },
>, <Line: -  assignment: function() {
>, <Line: -    var left = this.ternary();
>, <Line: -    var right;
>, <Line: -    var token;
>, <Line: -    if ((token = this.expect('='))) {
>, <Line: -      if (!left.assign) {
>, <Line: -        this.throwError('implies assignment but [' +
>, <Line: -            this.text.substring(0, token.index) + '] can not be assigned to', token);
>, <Line: -      }
>, <Line: -      right = this.ternary();
>, <Line: -      return extend(function $parseAssignment(scope, locals) {
>, <Line: -        return left.assign(scope, right(scope, locals), locals);
>, <Line: -      }, {
>, <Line: -        inputs: [left, right]
>, <Line: -      });
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  ternary: function() {
>, <Line: -    var left = this.logicalOR();
>, <Line: -    var middle;
>, <Line: -    var token;
>, <Line: -    if ((token = this.expect('?'))) {
>, <Line: -      middle = this.assignment();
>, <Line: -      if (this.consume(':')) {
>, <Line: -        var right = this.assignment();
>, <Line: -        return extend(function $parseTernary(self, locals) {
>, <Line: -          return left(self, locals) ? middle(self, locals) : right(self, locals);
>, <Line: -        }, {
>, <Line: -          constant: left.constant && middle.constant && right.constant
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  logicalOR: function() {
>, <Line: -    var left = this.logicalAND();
>, <Line: -    var token;
>, <Line: -    while ((token = this.expect('||'))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.logicalAND(), true);
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  logicalAND: function() {
>, <Line: -    var left = this.equality();
>, <Line: -    var token;
>, <Line: -    if ((token = this.expect('&&'))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.logicalAND(), true);
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  equality: function() {
>, <Line: -    var left = this.relational();
>, <Line: -    var token;
>, <Line: -    if ((token = this.expect('==','!=','===','!=='))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.equality());
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  relational: function() {
>, <Line: -    var left = this.additive();
>, <Line: -    var token;
>, <Line: -    if ((token = this.expect('<', '>', '<=', '>='))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.relational());
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  additive: function() {
>, <Line: -    var left = this.multiplicative();
>, <Line: -    var token;
>, <Line: -    while ((token = this.expect('+','-'))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.multiplicative());
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  multiplicative: function() {
>, <Line: -    var left = this.unary();
>, <Line: -    var token;
>, <Line: -    while ((token = this.expect('*','/','%'))) {
>, <Line: -      left = this.binaryFn(left, token.text, this.unary());
>, <Line: -    }
>, <Line: -    return left;
>, <Line: -  },
>, <Line: -  unary: function() {
>, <Line: -    var token;
>, <Line: -    if (this.expect('+')) {
>, <Line: -      return this.primary();
>, <Line: -    } else if ((token = this.expect('-'))) {
>, <Line: -      return this.binaryFn(Parser.ZERO, token.text, this.unary());
>, <Line: -    } else if ((token = this.expect('!'))) {
>, <Line: -      return this.unaryFn(token.text, this.unary());
>, <Line: -    } else {
>, <Line: -      return this.primary();
>, <Line: -    }
>, <Line: -  },
>, <Line: -  fieldAccess: function(object) {
>, <Line: -    var expression = this.text;
>, <Line: -    var field = this.consume().text;
>, <Line: -    var getter = getterFn(field, this.options, expression);
>, <Line: -    return extend(function $parseFieldAccess(scope, locals, self) {
>, <Line: -      return getter(self || object(scope, locals));
>, <Line: -    }, {
>, <Line: -      assign: function(scope, value, locals) {
>, <Line: -        var o = object(scope, locals);
>, <Line: -        if (!o) object.assign(scope, o = {});
>, <Line: -        return setter(o, field, value, expression);
>, <Line: -      }
>, <Line: -    });
>, <Line: -  },
>, <Line: -  objectIndex: function(obj) {
>, <Line: -    var expression = this.text;
>, <Line: -    var indexFn = this.expression();
>, <Line: -    this.consume(']');
>, <Line: -    return extend(function $parseObjectIndex(self, locals) {
>, <Line: -      var o = obj(self, locals),
>, <Line: -          i = indexFn(self, locals),
>, <Line: -          v;
>, <Line: -      ensureSafeMemberName(i, expression);
>, <Line: -      if (!o) return undefined;
>, <Line: -      v = ensureSafeObject(o[i], expression);
>, <Line: -      return v;
>, <Line: -    }, {
>, <Line: -      assign: function(self, value, locals) {
>, <Line: -        var key = ensureSafeMemberName(indexFn(self, locals), expression);
>, <Line: -        // prevent overwriting of Function.constructor which would break ensureSafeObject check
>, <Line: -        var o = ensureSafeObject(obj(self, locals), expression);
>, <Line: -        if (!o) obj.assign(self, o = {});
>, <Line: -        return o[key] = value;
>, <Line: -      }
>, <Line: -    });
>, <Line: -  },
>, <Line: -  functionCall: function(fnGetter, contextGetter) {
>, <Line: -    var argsFn = [];
>, <Line: -    if (this.peekToken().text !== ')') {
>, <Line: -      do {
>, <Line: -        argsFn.push(this.expression());
>, <Line: -      } while (this.expect(','));
>, <Line: -    }
>, <Line: -    this.consume(')');
>, <Line: -    var expressionText = this.text;
>, <Line: -    // we can safely reuse the array across invocations
>, <Line: -    var args = argsFn.length ? [] : null;
>, <Line: -    return function $parseFunctionCall(scope, locals) {
>, <Line: -      var context = contextGetter ? contextGetter(scope, locals) : scope;
>, <Line: -      var fn = fnGetter(scope, locals, context) || noop;
>, <Line: -      if (args) {
>, <Line: -        var i = argsFn.length;
>, <Line: -        while (i--) {
>, <Line: -          args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      ensureSafeObject(context, expressionText);
>, <Line: -      ensureSafeFunction(fn, expressionText);
>, <Line: -      // IE stupidity! (IE doesn't have apply for some native functions)
>, <Line: -      var v = fn.apply
>, <Line: -            ? fn.apply(context, args)
>, <Line: -            : fn(args[0], args[1], args[2], args[3], args[4]);
>, <Line: -      return ensureSafeObject(v, expressionText);
>, <Line: -    };
>, <Line: -  },
>, <Line: -  // This is used with json array declaration
>, <Line: -  arrayDeclaration: function() {
>, <Line: -    var elementFns = [];
>, <Line: -    if (this.peekToken().text !== ']') {
>, <Line: -      do {
>, <Line: -        if (this.peek(']')) {
>, <Line: -          // Support trailing commas per ES5.1.
>, <Line: -          break;
>, <Line: -        }
>, <Line: -        elementFns.push(this.expression());
>, <Line: -      } while (this.expect(','));
>, <Line: -    }
>, <Line: -    this.consume(']');
>, <Line: -    return extend(function $parseArrayLiteral(self, locals) {
>, <Line: -      var array = [];
>, <Line: -      for (var i = 0, ii = elementFns.length; i < ii; i++) {
>, <Line: -        array.push(elementFns[i](self, locals));
>, <Line: -      }
>, <Line: -      return array;
>, <Line: -    }, {
>, <Line: -      literal: true,
>, <Line: -      constant: elementFns.every(isConstant),
>, <Line: -      inputs: elementFns
>, <Line: -    });
>, <Line: -  },
>, <Line: -  object: function() {
>, <Line: -    var keys = [], valueFns = [];
>, <Line: -    if (this.peekToken().text !== '}') {
>, <Line: -      do {
>, <Line: -        if (this.peek('}')) {
>, <Line: -          // Support trailing commas per ES5.1.
>, <Line: -          break;
>, <Line: -        }
>, <Line: -        var token = this.consume();
>, <Line: -        if (token.constant) {
>, <Line: -          keys.push(token.value);
>, <Line: -        } else if (token.identifier) {
>, <Line: -          keys.push(token.text);
>, <Line: -        } else {
>, <Line: -          this.throwError("invalid key", token);
>, <Line: -        }
>, <Line: -        this.consume(':');
>, <Line: -        valueFns.push(this.expression());
>, <Line: -      } while (this.expect(','));
>, <Line: -    }
>, <Line: -    this.consume('}');
>, <Line: -    return extend(function $parseObjectLiteral(self, locals) {
>, <Line: -      var object = {};
>, <Line: -      for (var i = 0, ii = valueFns.length; i < ii; i++) {
>, <Line: -        object[keys[i]] = valueFns[i](self, locals);
>, <Line: -      }
>, <Line: -      return object;
>, <Line: -    }, {
>, <Line: -      literal: true,
>, <Line: -      constant: valueFns.every(isConstant),
>, <Line: -      inputs: valueFns
>, <Line: -    });
>, <Line: -  }
>, <Line: -};
>, <Line: -//////////////////////////////////////////////////
>, <Line: -// Parser helper functions
>, <Line: -//////////////////////////////////////////////////
>, <Line: -function setter(obj, path, setValue, fullExp) {
>, <Line: -  ensureSafeObject(obj, fullExp);
>, <Line: -  var element = path.split('.'), key;
>, <Line: -  for (var i = 0; element.length > 1; i++) {
>, <Line: -    key = ensureSafeMemberName(element.shift(), fullExp);
>, <Line: -    var propertyObj = ensureSafeObject(obj[key], fullExp);
>, <Line: -    if (!propertyObj) {
>, <Line: -      propertyObj = {};
>, <Line: -      obj[key] = propertyObj;
>, <Line: -    }
>, <Line: -    obj = propertyObj;
>, <Line: -  }
>, <Line: -  key = ensureSafeMemberName(element.shift(), fullExp);
>, <Line: -  ensureSafeObject(obj[key], fullExp);
>, <Line: -  obj[key] = setValue;
>, <Line: -  return setValue;
>, <Line: -}
>, <Line: -var getterFnCacheDefault = createMap();
>, <Line: -var getterFnCacheExpensive = createMap();
>, <Line: -function isPossiblyDangerousMemberName(name) {
>, <Line: -  return name == 'constructor';
>, <Line: -}
>, <Line: -/**
>, <Line: - * Implementation of the "Black Hole" variant from:
>, <Line: - * - http://jsperf.com/angularjs-parse-getter/4
>, <Line: - * - http://jsperf.com/path-evaluation-simplified/7
>, <Line: - */
>, <Line: -function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
>, <Line: -  ensureSafeMemberName(key0, fullExp);
>, <Line: -  ensureSafeMemberName(key1, fullExp);
>, <Line: -  ensureSafeMemberName(key2, fullExp);
>, <Line: -  ensureSafeMemberName(key3, fullExp);
>, <Line: -  ensureSafeMemberName(key4, fullExp);
>, <Line: -  var eso = function(o) {
>, <Line: -    return ensureSafeObject(o, fullExp);
>, <Line: -  };
>, <Line: -  var eso0 = (expensiveChecks || isPossiblyDangerousMemberName(key0)) ? eso : identity;
>, <Line: -  var eso1 = (expensiveChecks || isPossiblyDangerousMemberName(key1)) ? eso : identity;
>, <Line: -  var eso2 = (expensiveChecks || isPossiblyDangerousMemberName(key2)) ? eso : identity;
>, <Line: -  var eso3 = (expensiveChecks || isPossiblyDangerousMemberName(key3)) ? eso : identity;
>, <Line: -  var eso4 = (expensiveChecks || isPossiblyDangerousMemberName(key4)) ? eso : identity;
>, <Line: -  return function cspSafeGetter(scope, locals) {
>, <Line: -    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;
>, <Line: -    if (pathVal == null) return pathVal;
>, <Line: -    pathVal = eso0(pathVal[key0]);
>, <Line: -    if (!key1) return pathVal;
>, <Line: -    if (pathVal == null) return undefined;
>, <Line: -    pathVal = eso1(pathVal[key1]);
>, <Line: -    if (!key2) return pathVal;
>, <Line: -    if (pathVal == null) return undefined;
>, <Line: -    pathVal = eso2(pathVal[key2]);
>, <Line: -    if (!key3) return pathVal;
>, <Line: -    if (pathVal == null) return undefined;
>, <Line: -    pathVal = eso3(pathVal[key3]);
>, <Line: -    if (!key4) return pathVal;
>, <Line: -    if (pathVal == null) return undefined;
>, <Line: -    pathVal = eso4(pathVal[key4]);
>, <Line: -    return pathVal;
>, <Line: -  };
>, <Line: -}
>, <Line: -function getterFnWithEnsureSafeObject(fn, fullExpression) {
>, <Line: -  return function(s, l) {
>, <Line: -    return fn(s, l, ensureSafeObject, fullExpression);
>, <Line: -  };
>, <Line: -}
>, <Line: -function getterFn(path, options, fullExp) {
>, <Line: -  var expensiveChecks = options.expensiveChecks;
>, <Line: -  var getterFnCache = (expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault);
>, <Line: -  var fn = getterFnCache[path];
>, <Line: -  if (fn) return fn;
>, <Line: -  var pathKeys = path.split('.'),
>, <Line: -      pathKeysLength = pathKeys.length;
>, <Line: -  // http://jsperf.com/angularjs-parse-getter/6
>, <Line: -  if (options.csp) {
>, <Line: -    if (pathKeysLength < 6) {
>, <Line: -      fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks);
>, <Line: -    } else {
>, <Line: -      fn = function cspSafeGetter(scope, locals) {
>, <Line: -        var i = 0, val;
>, <Line: -        do {
>, <Line: -          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++],
>, <Line: -                                pathKeys[i++], fullExp, expensiveChecks)(scope, locals);
>, <Line: -          locals = undefined; // clear after first iteration
>, <Line: -          scope = val;
>, <Line: -        } while (i < pathKeysLength);
>, <Line: -        return val;
>, <Line: -      };
>, <Line: -    }
>, <Line: -  } else {
>, <Line: -    var code = '';
>, <Line: -    if (expensiveChecks) {
>, <Line: -      code += 's = eso(s, fe);\nl = eso(l, fe);\n';
>, <Line: -    }
>, <Line: -    var needsEnsureSafeObject = expensiveChecks;
>, <Line: -    forEach(pathKeys, function(key, index) {
>, <Line: -      ensureSafeMemberName(key, fullExp);
>, <Line: -      var lookupJs = (index
>, <Line: -                      // we simply dereference 's' on any .dot notation
>, <Line: -                      ? 's'
>, <Line: -                      // but if we are first then we check locals first, and if so read it first
>, <Line: -                      : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + '.' + key;
>, <Line: -      if (expensiveChecks || isPossiblyDangerousMemberName(key)) {
>, <Line: -        lookupJs = 'eso(' + lookupJs + ', fe)';
>, <Line: -        needsEnsureSafeObject = true;
>, <Line: -      }
>, <Line: -      code += 'if(s == null) return undefined;\n' +
>, <Line: -              's=' + lookupJs + ';\n';
>, <Line: -    });
>, <Line: -    code += 'return s;';
>, <Line: -    /* jshint -W054 */
>, <Line: -    var evaledFnGetter = new Function('s', 'l', 'eso', 'fe', code); // s=scope, l=locals, eso=ensureSafeObject
>, <Line: -    /* jshint +W054 */
>, <Line: -    evaledFnGetter.toString = valueFn(code);
>, <Line: -    if (needsEnsureSafeObject) {
>, <Line: -      evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp);
>, <Line: -    }
>, <Line: -    fn = evaledFnGetter;
>, <Line: -  }
>, <Line: -  fn.sharedGetter = true;
>, <Line: -  fn.assign = function(self, value) {
>, <Line: -    return setter(self, path, value, path);
>, <Line: -  };
>, <Line: -  getterFnCache[path] = fn;
>, <Line: -  return fn;
>, <Line: -}
>, <Line: -var objectValueOf = Object.prototype.valueOf;
>, <Line: -function getValueOf(value) {
>, <Line: -  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
>, <Line: -}
>, <Line: -///////////////////////////////////
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $parse
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Converts Angular {@link guide/expression expression} into a function.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   var getter = $parse('user.name');
>, <Line: - *   var setter = getter.assign;
>, <Line: - *   var context = {user:{name:'angular'}};
>, <Line: - *   var locals = {user:{name:'local'}};
>, <Line: - *
>, <Line: - *   expect(getter(context)).toEqual('angular');
>, <Line: - *   setter(context, 'newValue');
>, <Line: - *   expect(context.user.name).toEqual('newValue');
>, <Line: - *   expect(getter(context, locals)).toEqual('local');
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - * @param {string} expression String expression to compile.
>, <Line: - * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: - *
>, <Line: - *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: - *      are evaluated against (typically a scope object).
>, <Line: - *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: - *      `context`.
>, <Line: - *
>, <Line: - *    The returned function also has the following properties:
>, <Line: - *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript
>, <Line: - *        literal.
>, <Line: - *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript
>, <Line: - *        constant literals.
>, <Line: - *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be
>, <Line: - *        set to a function to change its value on the given context.
>, <Line: - *
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $parseProvider
>, <Line: - *
>, <Line: - * @description
>, <Line: - * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
>, <Line: - *  service.
>, <Line: - */
>, <Line: -function $ParseProvider() {
>, <Line: -  var cacheDefault = createMap();
>, <Line: -  var cacheExpensive = createMap();
>, <Line: -  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
>, <Line: -    var $parseOptions = {
>, <Line: -          csp: $sniffer.csp,
>, <Line: -          expensiveChecks: false
>, <Line: -        },
>, <Line: -        $parseOptionsExpensive = {
>, <Line: -          csp: $sniffer.csp,
>, <Line: -          expensiveChecks: true
>, <Line: -        };
>, <Line: -    function wrapSharedExpression(exp) {
>, <Line: -      var wrapped = exp;
>, <Line: -      if (exp.sharedGetter) {
>, <Line: -        wrapped = function $parseWrapper(self, locals) {
>, <Line: -          return exp(self, locals);
>, <Line: -        };
>, <Line: -        wrapped.literal = exp.literal;
>, <Line: -        wrapped.constant = exp.constant;
>, <Line: -        wrapped.assign = exp.assign;
>, <Line: -      }
>, <Line: -      return wrapped;
>, <Line: -    }
>, <Line: -    return function $parse(exp, interceptorFn, expensiveChecks) {
>, <Line: -      var parsedExpression, oneTime, cacheKey;
>, <Line: -      switch (typeof exp) {
>, <Line: -        case 'string':
>, <Line: -          cacheKey = exp = exp.trim();
>, <Line: -          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
>, <Line: -          parsedExpression = cache[cacheKey];
>, <Line: -          if (!parsedExpression) {
>, <Line: -            if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
>, <Line: -              oneTime = true;
>, <Line: -              exp = exp.substring(2);
>, <Line: -            }
>, <Line: -            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
>, <Line: -            var lexer = new Lexer(parseOptions);
>, <Line: -            var parser = new Parser(lexer, $filter, parseOptions);
>, <Line: -            parsedExpression = parser.parse(exp);
>, <Line: -            if (parsedExpression.constant) {
>, <Line: -              parsedExpression.$$watchDelegate = constantWatchDelegate;
>, <Line: -            } else if (oneTime) {
>, <Line: -              //oneTime is not part of the exp passed to the Parser so we may have to
>, <Line: -              //wrap the parsedExpression before adding a $$watchDelegate
>, <Line: -              parsedExpression = wrapSharedExpression(parsedExpression);
>, <Line: -              parsedExpression.$$watchDelegate = parsedExpression.literal ?
>, <Line: -                oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
>, <Line: -            } else if (parsedExpression.inputs) {
>, <Line: -              parsedExpression.$$watchDelegate = inputsWatchDelegate;
>, <Line: -            }
>, <Line: -            cache[cacheKey] = parsedExpression;
>, <Line: -          }
>, <Line: -          return addInterceptor(parsedExpression, interceptorFn);
>, <Line: -        case 'function':
>, <Line: -          return addInterceptor(exp, interceptorFn);
>, <Line: -        default:
>, <Line: -          return addInterceptor(noop, interceptorFn);
>, <Line: -      }
>, <Line: -    };
>, <Line: -    function collectExpressionInputs(inputs, list) {
>, <Line: -      for (var i = 0, ii = inputs.length; i < ii; i++) {
>, <Line: -        var input = inputs[i];
>, <Line: -        if (!input.constant) {
>, <Line: -          if (input.inputs) {
>, <Line: -            collectExpressionInputs(input.inputs, list);
>, <Line: -          } else if (list.indexOf(input) === -1) { // TODO(perf) can we do better?
>, <Line: -            list.push(input);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return list;
>, <Line: -    }
>, <Line: -    function expressionInputDirtyCheck(newValue, oldValueOfValue) {
>, <Line: -      if (newValue == null || oldValueOfValue == null) { // null/undefined
>, <Line: -        return newValue === oldValueOfValue;
>, <Line: -      }
>, <Line: -      if (typeof newValue === 'object') {
>, <Line: -        // attempt to convert the value to a primitive type
>, <Line: -        // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
>, <Line: -        //             be cheaply dirty-checked
>, <Line: -        newValue = getValueOf(newValue);
>, <Line: -        if (typeof newValue === 'object') {
>, <Line: -          // objects/arrays are not supported - deep-watching them would be too expensive
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -        // fall-through to the primitive equality check
>, <Line: -      }
>, <Line: -      //Primitive or NaN
>, <Line: -      return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
>, <Line: -    }
>, <Line: -    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: -      var inputExpressions = parsedExpression.$$inputs ||
>, <Line: -                    (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
>, <Line: -      var lastResult;
>, <Line: -      if (inputExpressions.length === 1) {
>, <Line: -        var oldInputValue = expressionInputDirtyCheck; // init to something unique so that equals check fails
>, <Line: -        inputExpressions = inputExpressions[0];
>, <Line: -        return scope.$watch(function expressionInputWatch(scope) {
>, <Line: -          var newInputValue = inputExpressions(scope);
>, <Line: -          if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {
>, <Line: -            lastResult = parsedExpression(scope);
>, <Line: -            oldInputValue = newInputValue && getValueOf(newInputValue);
>, <Line: -          }
>, <Line: -          return lastResult;
>, <Line: -        }, listener, objectEquality);
>, <Line: -      }
>, <Line: -      var oldInputValueOfValues = [];
>, <Line: -      for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
>, <Line: -        oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails
>, <Line: -      }
>, <Line: -      return scope.$watch(function expressionInputsWatch(scope) {
>, <Line: -        var changed = false;
>, <Line: -        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
>, <Line: -          var newInputValue = inputExpressions[i](scope);
>, <Line: -          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
>, <Line: -            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        if (changed) {
>, <Line: -          lastResult = parsedExpression(scope);
>, <Line: -        }
>, <Line: -        return lastResult;
>, <Line: -      }, listener, objectEquality);
>, <Line: -    }
>, <Line: -    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: -      var unwatch, lastValue;
>, <Line: -      return unwatch = scope.$watch(function oneTimeWatch(scope) {
>, <Line: -        return parsedExpression(scope);
>, <Line: -      }, function oneTimeListener(value, old, scope) {
>, <Line: -        lastValue = value;
>, <Line: -        if (isFunction(listener)) {
>, <Line: -          listener.apply(this, arguments);
>, <Line: -        }
>, <Line: -        if (isDefined(value)) {
>, <Line: -          scope.$$postDigest(function() {
>, <Line: -            if (isDefined(lastValue)) {
>, <Line: -              unwatch();
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -      }, objectEquality);
>, <Line: -    }
>, <Line: -    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: -      var unwatch, lastValue;
>, <Line: -      return unwatch = scope.$watch(function oneTimeWatch(scope) {
>, <Line: -        return parsedExpression(scope);
>, <Line: -      }, function oneTimeListener(value, old, scope) {
>, <Line: -        lastValue = value;
>, <Line: -        if (isFunction(listener)) {
>, <Line: -          listener.call(this, value, old, scope);
>, <Line: -        }
>, <Line: -        if (isAllDefined(value)) {
>, <Line: -          scope.$$postDigest(function() {
>, <Line: -            if (isAllDefined(lastValue)) unwatch();
>, <Line: -          });
>, <Line: -        }
>, <Line: -      }, objectEquality);
>, <Line: -      function isAllDefined(value) {
>, <Line: -        var allDefined = true;
>, <Line: -        forEach(value, function(val) {
>, <Line: -          if (!isDefined(val)) allDefined = false;
>, <Line: -        });
>, <Line: -        return allDefined;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
>, <Line: -      var unwatch;
>, <Line: -      return unwatch = scope.$watch(function constantWatch(scope) {
>, <Line: -        return parsedExpression(scope);
>, <Line: -      }, function constantListener(value, old, scope) {
>, <Line: -        if (isFunction(listener)) {
>, <Line: -          listener.apply(this, arguments);
>, <Line: -        }
>, <Line: -        unwatch();
>, <Line: -      }, objectEquality);
>, <Line: -    }
>, <Line: -    function addInterceptor(parsedExpression, interceptorFn) {
>, <Line: -      if (!interceptorFn) return parsedExpression;
>, <Line: -      var watchDelegate = parsedExpression.$$watchDelegate;
>, <Line: -      var regularWatch =
>, <Line: -          watchDelegate !== oneTimeLiteralWatchDelegate &&
>, <Line: -          watchDelegate !== oneTimeWatchDelegate;
>, <Line: -      var fn = regularWatch ? function regularInterceptedExpression(scope, locals) {
>, <Line: -        var value = parsedExpression(scope, locals);
>, <Line: -        return interceptorFn(value, scope, locals);
>, <Line: -      } : function oneTimeInterceptedExpression(scope, locals) {
>, <Line: -        var value = parsedExpression(scope, locals);
>, <Line: -        var result = interceptorFn(value, scope, locals);
>, <Line: -        // we only return the interceptor's result if the
>, <Line: -        // initial value is defined (for bind-once)
>, <Line: -        return isDefined(value) ? result : value;
>, <Line: -      };
>, <Line: -      // Propagate $$watchDelegates other then inputsWatchDelegate
>, <Line: -      if (parsedExpression.$$watchDelegate &&
>, <Line: -          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
>, <Line: -        fn.$$watchDelegate = parsedExpression.$$watchDelegate;
>, <Line: -      } else if (!interceptorFn.$stateful) {
>, <Line: -        // If there is an interceptor, but no watchDelegate then treat the interceptor like
>, <Line: -        // we treat filters - it is assumed to be a pure function unless flagged with $stateful
>, <Line: -        fn.$$watchDelegate = inputsWatchDelegate;
>, <Line: -        fn.inputs = [parsedExpression];
>, <Line: -      }
>, <Line: -      return fn;
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $q
>, <Line: - * @requires $rootScope
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A service that helps you run functions asynchronously, and use their return values (or exceptions)
>, <Line: - * when they are done processing.
>, <Line: - *
>, <Line: - * This is an implementation of promises/deferred objects inspired by
>, <Line: - * [Kris Kowal's Q](https://github.com/kriskowal/q).
>, <Line: - *
>, <Line: - * $q can be used in two fashions --- one which is more similar to Kris Kowal's Q or jQuery's Deferred
>, <Line: - * implementations, and the other which resembles ES6 promises to some degree.
>, <Line: - *
>, <Line: - * # $q constructor
>, <Line: - *
>, <Line: - * The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver`
>, <Line: - * function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,
>, <Line: - * see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
>, <Line: - *
>, <Line: - * While the constructor-style use is supported, not all of the supporting methods from ES6 Harmony promises are
>, <Line: - * available yet.
>, <Line: - *
>, <Line: - * It can be used like so:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
>, <Line: - *   // are available in the current lexical scope (they could have been injected or passed in).
>, <Line: - *
>, <Line: - *   function asyncGreet(name) {
>, <Line: - *     // perform some asynchronous operation, resolve or reject the promise when appropriate.
>, <Line: - *     return $q(function(resolve, reject) {
>, <Line: - *       setTimeout(function() {
>, <Line: - *         if (okToGreet(name)) {
>, <Line: - *           resolve('Hello, ' + name + '!');
>, <Line: - *         } else {
>, <Line: - *           reject('Greeting ' + name + ' is not allowed.');
>, <Line: - *         }
>, <Line: - *       }, 1000);
>, <Line: - *     });
>, <Line: - *   }
>, <Line: - *
>, <Line: - *   var promise = asyncGreet('Robin Hood');
>, <Line: - *   promise.then(function(greeting) {
>, <Line: - *     alert('Success: ' + greeting);
>, <Line: - *   }, function(reason) {
>, <Line: - *     alert('Failed: ' + reason);
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Note: progress/notify callbacks are not currently supported via the ES6-style interface.
>, <Line: - *
>, <Line: - * However, the more traditional CommonJS-style usage is still available, and documented below.
>, <Line: - *
>, <Line: - * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
>, <Line: - * interface for interacting with an object that represents the result of an action that is
>, <Line: - * performed asynchronously, and may or may not be finished at any given point in time.
>, <Line: - *
>, <Line: - * From the perspective of dealing with error handling, deferred and promise APIs are to
>, <Line: - * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
>, <Line: - *   // are available in the current lexical scope (they could have been injected or passed in).
>, <Line: - *
>, <Line: - *   function asyncGreet(name) {
>, <Line: - *     var deferred = $q.defer();
>, <Line: - *
>, <Line: - *     setTimeout(function() {
>, <Line: - *       deferred.notify('About to greet ' + name + '.');
>, <Line: - *
>, <Line: - *       if (okToGreet(name)) {
>, <Line: - *         deferred.resolve('Hello, ' + name + '!');
>, <Line: - *       } else {
>, <Line: - *         deferred.reject('Greeting ' + name + ' is not allowed.');
>, <Line: - *       }
>, <Line: - *     }, 1000);
>, <Line: - *
>, <Line: - *     return deferred.promise;
>, <Line: - *   }
>, <Line: - *
>, <Line: - *   var promise = asyncGreet('Robin Hood');
>, <Line: - *   promise.then(function(greeting) {
>, <Line: - *     alert('Success: ' + greeting);
>, <Line: - *   }, function(reason) {
>, <Line: - *     alert('Failed: ' + reason);
>, <Line: - *   }, function(update) {
>, <Line: - *     alert('Got notification: ' + update);
>, <Line: - *   });
>, <Line: - * ```
>, <Line: - *
>, <Line: - * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
>, <Line: - * comes in the way of guarantees that promise and deferred APIs make, see
>, <Line: - * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.
>, <Line: - *
>, <Line: - * Additionally the promise api allows for composition that is very hard to do with the
>, <Line: - * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
>, <Line: - * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
>, <Line: - * section on serial or parallel joining of promises.
>, <Line: - *
>, <Line: - * # The Deferred API
>, <Line: - *
>, <Line: - * A new instance of deferred is constructed by calling `$q.defer()`.
>, <Line: - *
>, <Line: - * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
>, <Line: - * that can be used for signaling the successful or unsuccessful completion, as well as the status
>, <Line: - * of the task.
>, <Line: - *
>, <Line: - * **Methods**
>, <Line: - *
>, <Line: - * - `resolve(value)`  resolves the derived promise with the `value`. If the value is a rejection
>, <Line: - *   constructed via `$q.reject`, the promise will be rejected instead.
>, <Line: - * - `reject(reason)`  rejects the derived promise with the `reason`. This is equivalent to
>, <Line: - *   resolving it with a rejection constructed via `$q.reject`.
>, <Line: - * - `notify(value)` - provides updates on the status of the promise's execution. This may be called
>, <Line: - *   multiple times before the promise is either resolved or rejected.
>, <Line: - *
>, <Line: - * **Properties**
>, <Line: - *
>, <Line: - * - promise  `{Promise}`  promise object associated with this deferred.
>, <Line: - *
>, <Line: - *
>, <Line: - * # The Promise API
>, <Line: - *
>, <Line: - * A new promise instance is created when a deferred instance is created and can be retrieved by
>, <Line: - * calling `deferred.promise`.
>, <Line: - *
>, <Line: - * The purpose of the promise object is to allow for interested parties to get access to the result
>, <Line: - * of the deferred task when it completes.
>, <Line: - *
>, <Line: - * **Methods**
>, <Line: - *
>, <Line: - * - `then(successCallback, errorCallback, notifyCallback)`  regardless of when the promise was or
>, <Line: - *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
>, <Line: - *   as soon as the result is available. The callbacks are called with a single argument: the result
>, <Line: - *   or rejection reason. Additionally, the notify callback may be called zero or more times to
>, <Line: - *   provide a progress indication, before the promise is resolved or rejected.
>, <Line: - *
>, <Line: - *   This method *returns a new promise* which is resolved or rejected via the return value of the
>, <Line: - *   `successCallback`, `errorCallback`. It also notifies via the return value of the
>, <Line: - *   `notifyCallback` method. The promise cannot be resolved or rejected from the notifyCallback
>, <Line: - *   method.
>, <Line: - *
>, <Line: - * - `catch(errorCallback)`  shorthand for `promise.then(null, errorCallback)`
>, <Line: - *
>, <Line: - * - `finally(callback, notifyCallback)`  allows you to observe either the fulfillment or rejection of a promise,
>, <Line: - *   but to do so without modifying the final value. This is useful to release resources or do some
>, <Line: - *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
>, <Line: - *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
>, <Line: - *   more information.
>, <Line: - *
>, <Line: - * # Chaining promises
>, <Line: - *
>, <Line: - * Because calling the `then` method of a promise returns a new derived promise, it is easily
>, <Line: - * possible to create a chain of promises:
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   promiseB = promiseA.then(function(result) {
>, <Line: - *     return result + 1;
>, <Line: - *   });
>, <Line: - *
>, <Line: - *   // promiseB will be resolved immediately after promiseA is resolved and its value
>, <Line: - *   // will be the result of promiseA incremented by 1
>, <Line: - * ```
>, <Line: - *
>, <Line: - * It is possible to create chains of any length and since a promise can be resolved with another
>, <Line: - * promise (which will defer its resolution further), it is possible to pause/defer resolution of
>, <Line: - * the promises at any point in the chain. This makes it possible to implement powerful APIs like
>, <Line: - * $http's response interceptors.
>, <Line: - *
>, <Line: - *
>, <Line: - * # Differences between Kris Kowal's Q and $q
>, <Line: - *
>, <Line: - *  There are two main differences:
>, <Line: - *
>, <Line: - * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
>, <Line: - *   mechanism in angular, which means faster propagation of resolution or rejection into your
>, <Line: - *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
>, <Line: - * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
>, <Line: - *   all the important functionality needed for common async tasks.
>, <Line: - *
>, <Line: - *  # Testing
>, <Line: - *
>, <Line: - *  ```js
>, <Line: - *    it('should simulate promise', inject(function($q, $rootScope) {
>, <Line: - *      var deferred = $q.defer();
>, <Line: - *      var promise = deferred.promise;
>, <Line: - *      var resolvedValue;
>, <Line: - *
>, <Line: - *      promise.then(function(value) { resolvedValue = value; });
>, <Line: - *      expect(resolvedValue).toBeUndefined();
>, <Line: - *
>, <Line: - *      // Simulate resolving of promise
>, <Line: - *      deferred.resolve(123);
>, <Line: - *      // Note that the 'then' function does not get called synchronously.
>, <Line: - *      // This is because we want the promise API to always be async, whether or not
>, <Line: - *      // it got called synchronously or asynchronously.
>, <Line: - *      expect(resolvedValue).toBeUndefined();
>, <Line: - *
>, <Line: - *      // Propagate promise resolution to 'then' functions using $apply().
>, <Line: - *      $rootScope.$apply();
>, <Line: - *      expect(resolvedValue).toEqual(123);
>, <Line: - *    }));
>, <Line: - *  ```
>, <Line: - *
>, <Line: - * @param {function(function, function)} resolver Function which is responsible for resolving or
>, <Line: - *   rejecting the newly created promise. The first parameter is a function which resolves the
>, <Line: - *   promise, the second parameter is a function which rejects the promise.
>, <Line: - *
>, <Line: - * @returns {Promise} The newly created promise.
>, <Line: - */
>, <Line: -function $QProvider() {
>, <Line: -  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
>, <Line: -    return qFactory(function(callback) {
>, <Line: -      $rootScope.$evalAsync(callback);
>, <Line: -    }, $exceptionHandler);
>, <Line: -  }];
>, <Line: -}
>, <Line: -function $$QProvider() {
>, <Line: -  this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
>, <Line: -    return qFactory(function(callback) {
>, <Line: -      $browser.defer(callback);
>, <Line: -    }, $exceptionHandler);
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * Constructs a promise manager.
>, <Line: - *
>, <Line: - * @param {function(function)} nextTick Function for executing functions in the next turn.
>, <Line: - * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
>, <Line: - *     debugging purposes.
>, <Line: - * @returns {object} Promise manager.
>, <Line: - */
>, <Line: -function qFactory(nextTick, exceptionHandler) {
>, <Line: -  var $qMinErr = minErr('$q', TypeError);
>, <Line: -  function callOnce(self, resolveFn, rejectFn) {
>, <Line: -    var called = false;
>, <Line: -    function wrap(fn) {
>, <Line: -      return function(value) {
>, <Line: -        if (called) return;
>, <Line: -        called = true;
>, <Line: -        fn.call(self, value);
>, <Line: -      };
>, <Line: -    }
>, <Line: -    return [wrap(resolveFn), wrap(rejectFn)];
>, <Line: -  }
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ng.$q#defer
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Creates a `Deferred` object which represents a task which will finish in the future.
>, <Line: -   *
>, <Line: -   * @returns {Deferred} Returns a new instance of deferred.
>, <Line: -   */
>, <Line: -  var defer = function() {
>, <Line: -    return new Deferred();
>, <Line: -  };
>, <Line: -  function Promise() {
>, <Line: -    this.$$state = { status: 0 };
>, <Line: -  }
>, <Line: -  Promise.prototype = {
>, <Line: -    then: function(onFulfilled, onRejected, progressBack) {
>, <Line: -      var result = new Deferred();
>, <Line: -      this.$$state.pending = this.$$state.pending || [];
>, <Line: -      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
>, <Line: -      if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
>, <Line: -      return result.promise;
>, <Line: -    },
>, <Line: -    "catch": function(callback) {
>, <Line: -      return this.then(null, callback);
>, <Line: -    },
>, <Line: -    "finally": function(callback, progressBack) {
>, <Line: -      return this.then(function(value) {
>, <Line: -        return handleCallback(value, true, callback);
>, <Line: -      }, function(error) {
>, <Line: -        return handleCallback(error, false, callback);
>, <Line: -      }, progressBack);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  //Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native
>, <Line: -  function simpleBind(context, fn) {
>, <Line: -    return function(value) {
>, <Line: -      fn.call(context, value);
>, <Line: -    };
>, <Line: -  }
>, <Line: -  function processQueue(state) {
>, <Line: -    var fn, promise, pending;
>, <Line: -    pending = state.pending;
>, <Line: -    state.processScheduled = false;
>, <Line: -    state.pending = undefined;
>, <Line: -    for (var i = 0, ii = pending.length; i < ii; ++i) {
>, <Line: -      promise = pending[i][0];
>, <Line: -      fn = pending[i][state.status];
>, <Line: -      try {
>, <Line: -        if (isFunction(fn)) {
>, <Line: -          promise.resolve(fn(state.value));
>, <Line: -        } else if (state.status === 1) {
>, <Line: -          promise.resolve(state.value);
>, <Line: -        } else {
>, <Line: -          promise.reject(state.value);
>, <Line: -        }
>, <Line: -      } catch (e) {
>, <Line: -        promise.reject(e);
>, <Line: -        exceptionHandler(e);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }
>, <Line: -  function scheduleProcessQueue(state) {
>, <Line: -    if (state.processScheduled || !state.pending) return;
>, <Line: -    state.processScheduled = true;
>, <Line: -    nextTick(function() { processQueue(state); });
>, <Line: -  }
>, <Line: -  function Deferred() {
>, <Line: -    this.promise = new Promise();
>, <Line: -    //Necessary to support unbound execution :/
>, <Line: -    this.resolve = simpleBind(this, this.resolve);
>, <Line: -    this.reject = simpleBind(this, this.reject);
>, <Line: -    this.notify = simpleBind(this, this.notify);
>, <Line: -  }
>, <Line: -  Deferred.prototype = {
>, <Line: -    resolve: function(val) {
>, <Line: -      if (this.promise.$$state.status) return;
>, <Line: -      if (val === this.promise) {
>, <Line: -        this.$$reject($qMinErr(
>, <Line: -          'qcycle',
>, <Line: -          "Expected promise to be resolved with value other than itself '{0}'",
>, <Line: -          val));
>, <Line: -      }
>, <Line: -      else {
>, <Line: -        this.$$resolve(val);
>, <Line: -      }
>, <Line: -    },
>, <Line: -    $$resolve: function(val) {
>, <Line: -      var then, fns;
>, <Line: -      fns = callOnce(this, this.$$resolve, this.$$reject);
>, <Line: -      try {
>, <Line: -        if ((isObject(val) || isFunction(val))) then = val && val.then;
>, <Line: -        if (isFunction(then)) {
>, <Line: -          this.promise.$$state.status = -1;
>, <Line: -          then.call(val, fns[0], fns[1], this.notify);
>, <Line: -        } else {
>, <Line: -          this.promise.$$state.value = val;
>, <Line: -          this.promise.$$state.status = 1;
>, <Line: -          scheduleProcessQueue(this.promise.$$state);
>, <Line: -        }
>, <Line: -      } catch (e) {
>, <Line: -        fns[1](e);
>, <Line: -        exceptionHandler(e);
>, <Line: -      }
>, <Line: -    },
>, <Line: -    reject: function(reason) {
>, <Line: -      if (this.promise.$$state.status) return;
>, <Line: -      this.$$reject(reason);
>, <Line: -    },
>, <Line: -    $$reject: function(reason) {
>, <Line: -      this.promise.$$state.value = reason;
>, <Line: -      this.promise.$$state.status = 2;
>, <Line: -      scheduleProcessQueue(this.promise.$$state);
>, <Line: -    },
>, <Line: -    notify: function(progress) {
>, <Line: -      var callbacks = this.promise.$$state.pending;
>, <Line: -      if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
>, <Line: -        nextTick(function() {
>, <Line: -          var callback, result;
>, <Line: -          for (var i = 0, ii = callbacks.length; i < ii; i++) {
>, <Line: -            result = callbacks[i][0];
>, <Line: -            callback = callbacks[i][3];
>, <Line: -            try {
>, <Line: -              result.notify(isFunction(callback) ? callback(progress) : progress);
>, <Line: -            } catch (e) {
>, <Line: -              exceptionHandler(e);
>, <Line: -            }
>, <Line: -          }
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $q#reject
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
>, <Line: -   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
>, <Line: -   * a promise chain, you don't need to worry about it.
>, <Line: -   *
>, <Line: -   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
>, <Line: -   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
>, <Line: -   * a promise error callback and you want to forward the error to the promise derived from the
>, <Line: -   * current promise, you have to "rethrow" the error by returning a rejection constructed via
>, <Line: -   * `reject`.
>, <Line: -   *
>, <Line: -   * ```js
>, <Line: -   *   promiseB = promiseA.then(function(result) {
>, <Line: -   *     // success: do something and resolve promiseB
>, <Line: -   *     //          with the old or a new result
>, <Line: -   *     return result;
>, <Line: -   *   }, function(reason) {
>, <Line: -   *     // error: handle the error if possible and
>, <Line: -   *     //        resolve promiseB with newPromiseOrValue,
>, <Line: -   *     //        otherwise forward the rejection to promiseB
>, <Line: -   *     if (canHandle(reason)) {
>, <Line: -   *      // handle the error and recover
>, <Line: -   *      return newPromiseOrValue;
>, <Line: -   *     }
>, <Line: -   *     return $q.reject(reason);
>, <Line: -   *   });
>, <Line: -   * ```
>, <Line: -   *
>, <Line: -   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
>, <Line: -   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
>, <Line: -   */
>, <Line: -  var reject = function(reason) {
>, <Line: -    var result = new Deferred();
>, <Line: -    result.reject(reason);
>, <Line: -    return result.promise;
>, <Line: -  };
>, <Line: -  var makePromise = function makePromise(value, resolved) {
>, <Line: -    var result = new Deferred();
>, <Line: -    if (resolved) {
>, <Line: -      result.resolve(value);
>, <Line: -    } else {
>, <Line: -      result.reject(value);
>, <Line: -    }
>, <Line: -    return result.promise;
>, <Line: -  };
>, <Line: -  var handleCallback = function handleCallback(value, isResolved, callback) {
>, <Line: -    var callbackOutput = null;
>, <Line: -    try {
>, <Line: -      if (isFunction(callback)) callbackOutput = callback();
>, <Line: -    } catch (e) {
>, <Line: -      return makePromise(e, false);
>, <Line: -    }
>, <Line: -    if (isPromiseLike(callbackOutput)) {
>, <Line: -      return callbackOutput.then(function() {
>, <Line: -        return makePromise(value, isResolved);
>, <Line: -      }, function(error) {
>, <Line: -        return makePromise(error, false);
>, <Line: -      });
>, <Line: -    } else {
>, <Line: -      return makePromise(value, isResolved);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $q#when
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
>, <Line: -   * This is useful when you are dealing with an object that might or might not be a promise, or if
>, <Line: -   * the promise comes from a source that can't be trusted.
>, <Line: -   *
>, <Line: -   * @param {*} value Value or a promise
>, <Line: -   * @returns {Promise} Returns a promise of the passed value or promise
>, <Line: -   */
>, <Line: -  var when = function(value, callback, errback, progressBack) {
>, <Line: -    var result = new Deferred();
>, <Line: -    result.resolve(value);
>, <Line: -    return result.promise.then(callback, errback, progressBack);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $q#all
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Combines multiple promises into a single promise that is resolved when all of the input
>, <Line: -   * promises are resolved.
>, <Line: -   *
>, <Line: -   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
>, <Line: -   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
>, <Line: -   *   each value corresponding to the promise at the same index/key in the `promises` array/hash.
>, <Line: -   *   If any of the promises is resolved with a rejection, this resulting promise will be rejected
>, <Line: -   *   with the same rejection value.
>, <Line: -   */
>, <Line: -  function all(promises) {
>, <Line: -    var deferred = new Deferred(),
>, <Line: -        counter = 0,
>, <Line: -        results = isArray(promises) ? [] : {};
>, <Line: -    forEach(promises, function(promise, key) {
>, <Line: -      counter++;
>, <Line: -      when(promise).then(function(value) {
>, <Line: -        if (results.hasOwnProperty(key)) return;
>, <Line: -        results[key] = value;
>, <Line: -        if (!(--counter)) deferred.resolve(results);
>, <Line: -      }, function(reason) {
>, <Line: -        if (results.hasOwnProperty(key)) return;
>, <Line: -        deferred.reject(reason);
>, <Line: -      });
>, <Line: -    });
>, <Line: -    if (counter === 0) {
>, <Line: -      deferred.resolve(results);
>, <Line: -    }
>, <Line: -    return deferred.promise;
>, <Line: -  }
>, <Line: -  var $Q = function Q(resolver) {
>, <Line: -    if (!isFunction(resolver)) {
>, <Line: -      throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
>, <Line: -    }
>, <Line: -    if (!(this instanceof Q)) {
>, <Line: -      // More useful when $Q is the Promise itself.
>, <Line: -      return new Q(resolver);
>, <Line: -    }
>, <Line: -    var deferred = new Deferred();
>, <Line: -    function resolveFn(value) {
>, <Line: -      deferred.resolve(value);
>, <Line: -    }
>, <Line: -    function rejectFn(reason) {
>, <Line: -      deferred.reject(reason);
>, <Line: -    }
>, <Line: -    resolver(resolveFn, rejectFn);
>, <Line: -    return deferred.promise;
>, <Line: -  };
>, <Line: -  $Q.defer = defer;
>, <Line: -  $Q.reject = reject;
>, <Line: -  $Q.when = when;
>, <Line: -  $Q.all = all;
>, <Line: -  return $Q;
>, <Line: -}
>, <Line: -function $$RAFProvider() { //rAF
>, <Line: -  this.$get = ['$window', '$timeout', function($window, $timeout) {
>, <Line: -    var requestAnimationFrame = $window.requestAnimationFrame ||
>, <Line: -                                $window.webkitRequestAnimationFrame ||
>, <Line: -                                $window.mozRequestAnimationFrame;
>, <Line: -    var cancelAnimationFrame = $window.cancelAnimationFrame ||
>, <Line: -                               $window.webkitCancelAnimationFrame ||
>, <Line: -                               $window.mozCancelAnimationFrame ||
>, <Line: -                               $window.webkitCancelRequestAnimationFrame;
>, <Line: -    var rafSupported = !!requestAnimationFrame;
>, <Line: -    var raf = rafSupported
>, <Line: -      ? function(fn) {
>, <Line: -          var id = requestAnimationFrame(fn);
>, <Line: -          return function() {
>, <Line: -            cancelAnimationFrame(id);
>, <Line: -          };
>, <Line: -        }
>, <Line: -      : function(fn) {
>, <Line: -          var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666
>, <Line: -          return function() {
>, <Line: -            $timeout.cancel(timer);
>, <Line: -          };
>, <Line: -        };
>, <Line: -    raf.supported = rafSupported;
>, <Line: -    return raf;
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * DESIGN NOTES
>, <Line: - *
>, <Line: - * The design decisions behind the scope are heavily favored for speed and memory consumption.
>, <Line: - *
>, <Line: - * The typical use of scope is to watch the expressions, which most of the time return the same
>, <Line: - * value as last time so we optimize the operation.
>, <Line: - *
>, <Line: - * Closures construction is expensive in terms of speed as well as memory:
>, <Line: - *   - No closures, instead use prototypical inheritance for API
>, <Line: - *   - Internal state needs to be stored on scope directly, which means that private state is
>, <Line: - *     exposed as $$____ properties
>, <Line: - *
>, <Line: - * Loop operations are optimized by using while(count--) { ... }
>, <Line: - *   - this means that in order to keep the same order of execution as addition we have to add
>, <Line: - *     items to the array at the beginning (unshift) instead of at the end (push)
>, <Line: - *
>, <Line: - * Child scopes are created and removed often
>, <Line: - *   - Using an array would be slow since inserts in middle are expensive so we use linked list
>, <Line: - *
>, <Line: - * There are few watches then a lot of observers. This is why you don't want the observer to be
>, <Line: - * implemented in the same way as watch. Watch requires return of initialization function which
>, <Line: - * are expensive to construct.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $rootScopeProvider
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Provider for the $rootScope service.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc method
>, <Line: - * @name $rootScopeProvider#digestTtl
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and
>, <Line: - * assuming that the model is unstable.
>, <Line: - *
>, <Line: - * The current default is 10 iterations.
>, <Line: - *
>, <Line: - * In complex applications it's possible that the dependencies between `$watch`s will result in
>, <Line: - * several digest iterations. However if an application needs more than the default 10 digest
>, <Line: - * iterations for its model to stabilize then you should investigate what is causing the model to
>, <Line: - * continuously change during the digest.
>, <Line: - *
>, <Line: - * Increasing the TTL could have performance implications, so you should not change it without
>, <Line: - * proper justification.
>, <Line: - *
>, <Line: - * @param {number} limit The number of digest iterations.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $rootScope
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Every application has a single root {@link ng.$rootScope.Scope scope}.
>, <Line: - * All other scopes are descendant scopes of the root scope. Scopes provide separation
>, <Line: - * between the model and the view, via a mechanism for watching the model for changes.
>, <Line: - * They also provide an event emission/broadcast and subscription facility. See the
>, <Line: - * {@link guide/scope developer guide on scopes}.
>, <Line: - */
>, <Line: -function $RootScopeProvider() {
>, <Line: -  var TTL = 10;
>, <Line: -  var $rootScopeMinErr = minErr('$rootScope');
>, <Line: -  var lastDirtyWatch = null;
>, <Line: -  var applyAsyncId = null;
>, <Line: -  this.digestTtl = function(value) {
>, <Line: -    if (arguments.length) {
>, <Line: -      TTL = value;
>, <Line: -    }
>, <Line: -    return TTL;
>, <Line: -  };
>, <Line: -  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
>, <Line: -      function($injector, $exceptionHandler, $parse, $browser) {
>, <Line: -    /**
>, <Line: -     * @ngdoc type
>, <Line: -     * @name $rootScope.Scope
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
>, <Line: -     * {@link auto.$injector $injector}. Child scopes are created using the
>, <Line: -     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
>, <Line: -     * compiled HTML template is executed.)
>, <Line: -     *
>, <Line: -     * Here is a simple scope snippet to show how you can interact with the scope.
>, <Line: -     * ```html
>, <Line: -     * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * # Inheritance
>, <Line: -     * A scope can inherit from a parent scope, as in this example:
>, <Line: -     * ```js
>, <Line: -         var parent = $rootScope;
>, <Line: -         var child = parent.$new();
>, <Line: -         parent.salutation = "Hello";
>, <Line: -         child.name = "World";
>, <Line: -         expect(child.salutation).toEqual('Hello');
>, <Line: -         child.salutation = "Welcome";
>, <Line: -         expect(child.salutation).toEqual('Welcome');
>, <Line: -         expect(parent.salutation).toEqual('Hello');
>, <Line: -     * ```
>, <Line: -     *
>, <Line: -     * When interacting with `Scope` in tests, additional helper methods are available on the
>, <Line: -     * instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional
>, <Line: -     * details.
>, <Line: -     *
>, <Line: -     *
>, <Line: -     * @param {Object.<string, function()>=} providers Map of service factory which need to be
>, <Line: -     *                                       provided for the current scope. Defaults to {@link ng}.
>, <Line: -     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
>, <Line: -     *                              append/override services provided by `providers`. This is handy
>, <Line: -     *                              when unit-testing and having the need to override a default
>, <Line: -     *                              service.
>, <Line: -     * @returns {Object} Newly created scope.
>, <Line: -     */
>, <Line: -    function Scope() {
>, <Line: -      this.$id = nextUid();
>, <Line: -      this.$$phase = this.$parent = this.$$watchers =
>, <Line: -                     this.$$nextSibling = this.$$prevSibling =
>, <Line: -                     this.$$childHead = this.$$childTail = null;
>, <Line: -      this.$root = this;
>, <Line: -      this.$$destroyed = false;
>, <Line: -      this.$$listeners = {};
>, <Line: -      this.$$listenerCount = {};
>, <Line: -      this.$$isolateBindings = null;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc property
>, <Line: -     * @name $rootScope.Scope#$id
>, <Line: -     * @description
>, <Line: -     * Unique scope ID (monotonically increasing) useful for debugging.
>, <Line: -     */
>, <Line: -     /**
>, <Line: -      * @ngdoc property
>, <Line: -      * @name $rootScope.Scope#$parent
>, <Line: -      * @description
>, <Line: -      * Reference to the parent scope.
>, <Line: -      */
>, <Line: -      /**
>, <Line: -       * @ngdoc property
>, <Line: -       * @name $rootScope.Scope#$root
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Reference to the root scope.
>, <Line: -       */
>, <Line: -    Scope.prototype = {
>, <Line: -      constructor: Scope,
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$new
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Creates a new child {@link ng.$rootScope.Scope scope}.
>, <Line: -       *
>, <Line: -       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} event.
>, <Line: -       * The scope can be removed from the scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
>, <Line: -       *
>, <Line: -       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is
>, <Line: -       * desired for the scope and its child scopes to be permanently detached from the parent and
>, <Line: -       * thus stop participating in model change detection and listener notification by invoking.
>, <Line: -       *
>, <Line: -       * @param {boolean} isolate If true, then the scope does not prototypically inherit from the
>, <Line: -       *         parent scope. The scope is isolated, as it can not see parent scope properties.
>, <Line: -       *         When creating widgets, it is useful for the widget to not accidentally read parent
>, <Line: -       *         state.
>, <Line: -       *
>, <Line: -       * @param {Scope} [parent=this] The {@link ng.$rootScope.Scope `Scope`} that will be the `$parent`
>, <Line: -       *                              of the newly created scope. Defaults to `this` scope if not provided.
>, <Line: -       *                              This is used when creating a transclude scope to correctly place it
>, <Line: -       *                              in the scope hierarchy while maintaining the correct prototypical
>, <Line: -       *                              inheritance.
>, <Line: -       *
>, <Line: -       * @returns {Object} The newly created child scope.
>, <Line: -       *
>, <Line: -       */
>, <Line: -      $new: function(isolate, parent) {
>, <Line: -        var child;
>, <Line: -        parent = parent || this;
>, <Line: -        if (isolate) {
>, <Line: -          child = new Scope();
>, <Line: -          child.$root = this.$root;
>, <Line: -        } else {
>, <Line: -          // Only create a child scope class if somebody asks for one,
>, <Line: -          // but cache it to allow the VM to optimize lookups.
>, <Line: -          if (!this.$$ChildScope) {
>, <Line: -            this.$$ChildScope = function ChildScope() {
>, <Line: -              this.$$watchers = this.$$nextSibling =
>, <Line: -                  this.$$childHead = this.$$childTail = null;
>, <Line: -              this.$$listeners = {};
>, <Line: -              this.$$listenerCount = {};
>, <Line: -              this.$id = nextUid();
>, <Line: -              this.$$ChildScope = null;
>, <Line: -            };
>, <Line: -            this.$$ChildScope.prototype = this;
>, <Line: -          }
>, <Line: -          child = new this.$$ChildScope();
>, <Line: -        }
>, <Line: -        child.$parent = parent;
>, <Line: -        child.$$prevSibling = parent.$$childTail;
>, <Line: -        if (parent.$$childHead) {
>, <Line: -          parent.$$childTail.$$nextSibling = child;
>, <Line: -          parent.$$childTail = child;
>, <Line: -        } else {
>, <Line: -          parent.$$childHead = parent.$$childTail = child;
>, <Line: -        }
>, <Line: -        // When the new scope is not isolated or we inherit from `this`, and
>, <Line: -        // the parent scope is destroyed, the property `$$destroyed` is inherited
>, <Line: -        // prototypically. In all other cases, this property needs to be set
>, <Line: -        // when the parent scope is destroyed.
>, <Line: -        // The listener needs to be added after the parent is set
>, <Line: -        if (isolate || parent != this) child.$on('$destroy', destroyChild);
>, <Line: -        return child;
>, <Line: -        function destroyChild() {
>, <Line: -          child.$$destroyed = true;
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$watch
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
>, <Line: -       *
>, <Line: -       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest
>, <Line: -       *   $digest()} and should return the value that will be watched. (Since
>, <Line: -       *   {@link ng.$rootScope.Scope#$digest $digest()} reruns when it detects changes the
>, <Line: -       *   `watchExpression` can execute multiple times per
>, <Line: -       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
>, <Line: -       * - The `listener` is called only when the value from the current `watchExpression` and the
>, <Line: -       *   previous call to `watchExpression` are not equal (with the exception of the initial run,
>, <Line: -       *   see below). Inequality is determined according to reference inequality,
>, <Line: -       *   [strict comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
>, <Line: -       *    via the `!==` Javascript operator, unless `objectEquality == true`
>, <Line: -       *   (see next point)
>, <Line: -       * - When `objectEquality == true`, inequality of the `watchExpression` is determined
>, <Line: -       *   according to the {@link angular.equals} function. To save the value of the object for
>, <Line: -       *   later comparison, the {@link angular.copy} function is used. This therefore means that
>, <Line: -       *   watching complex objects will have adverse memory and performance implications.
>, <Line: -       * - The watch `listener` may change the model, which may trigger other `listener`s to fire.
>, <Line: -       *   This is achieved by rerunning the watchers until no changes are detected. The rerun
>, <Line: -       *   iteration limit is 10 to prevent an infinite loop deadlock.
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
>, <Line: -       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
>, <Line: -       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a
>, <Line: -       * change is detected, be prepared for multiple calls to your listener.)
>, <Line: -       *
>, <Line: -       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
>, <Line: -       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
>, <Line: -       * watcher. In rare cases, this is undesirable because the listener is called when the result
>, <Line: -       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
>, <Line: -       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
>, <Line: -       * listener was called due to initialization.
>, <Line: -       *
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * # Example
>, <Line: -       * ```js
>, <Line: -           // let's assume that scope was dependency injected as the $rootScope
>, <Line: -           var scope = $rootScope;
>, <Line: -           scope.name = 'misko';
>, <Line: -           scope.counter = 0;
>, <Line: -           expect(scope.counter).toEqual(0);
>, <Line: -           scope.$watch('name', function(newValue, oldValue) {
>, <Line: -             scope.counter = scope.counter + 1;
>, <Line: -           });
>, <Line: -           expect(scope.counter).toEqual(0);
>, <Line: -           scope.$digest();
>, <Line: -           // the listener is always called during the first $digest loop after it was registered
>, <Line: -           expect(scope.counter).toEqual(1);
>, <Line: -           scope.$digest();
>, <Line: -           // but now it will not be called unless the value changes
>, <Line: -           expect(scope.counter).toEqual(1);
>, <Line: -           scope.name = 'adam';
>, <Line: -           scope.$digest();
>, <Line: -           expect(scope.counter).toEqual(2);
>, <Line: -           // Using a function as a watchExpression
>, <Line: -           var food;
>, <Line: -           scope.foodCounter = 0;
>, <Line: -           expect(scope.foodCounter).toEqual(0);
>, <Line: -           scope.$watch(
>, <Line: -             // This function returns the value being watched. It is called for each turn of the $digest loop
>, <Line: -             function() { return food; },
>, <Line: -             // This is the change listener, called when the value returned from the above function changes
>, <Line: -             function(newValue, oldValue) {
>, <Line: -               if ( newValue !== oldValue ) {
>, <Line: -                 // Only increment the counter if the value changed
>, <Line: -                 scope.foodCounter = scope.foodCounter + 1;
>, <Line: -               }
>, <Line: -             }
>, <Line: -           );
>, <Line: -           // No digest has been run so the counter will be zero
>, <Line: -           expect(scope.foodCounter).toEqual(0);
>, <Line: -           // Run the digest but since food has not changed count will still be zero
>, <Line: -           scope.$digest();
>, <Line: -           expect(scope.foodCounter).toEqual(0);
>, <Line: -           // Update food and run digest.  Now the counter will increment
>, <Line: -           food = 'cheeseburger';
>, <Line: -           scope.$digest();
>, <Line: -           expect(scope.foodCounter).toEqual(1);
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * @param {(function()|string)} watchExpression Expression that is evaluated on each
>, <Line: -       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers
>, <Line: -       *    a call to the `listener`.
>, <Line: -       *
>, <Line: -       *    - `string`: Evaluated as {@link guide/expression expression}
>, <Line: -       *    - `function(scope)`: called with current `scope` as a parameter.
>, <Line: -       * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value
>, <Line: -       *    of `watchExpression` changes.
>, <Line: -       *
>, <Line: -       *    - `newVal` contains the current value of the `watchExpression`
>, <Line: -       *    - `oldVal` contains the previous value of the `watchExpression`
>, <Line: -       *    - `scope` refers to the current scope
>, <Line: -       * @param {boolean=} objectEquality Compare for object equality using {@link angular.equals} instead of
>, <Line: -       *     comparing for reference equality.
>, <Line: -       * @returns {function()} Returns a deregistration function for this listener.
>, <Line: -       */
>, <Line: -      $watch: function(watchExp, listener, objectEquality) {
>, <Line: -        var get = $parse(watchExp);
>, <Line: -        if (get.$$watchDelegate) {
>, <Line: -          return get.$$watchDelegate(this, listener, objectEquality, get);
>, <Line: -        }
>, <Line: -        var scope = this,
>, <Line: -            array = scope.$$watchers,
>, <Line: -            watcher = {
>, <Line: -              fn: listener,
>, <Line: -              last: initWatchVal,
>, <Line: -              get: get,
>, <Line: -              exp: watchExp,
>, <Line: -              eq: !!objectEquality
>, <Line: -            };
>, <Line: -        lastDirtyWatch = null;
>, <Line: -        if (!isFunction(listener)) {
>, <Line: -          watcher.fn = noop;
>, <Line: -        }
>, <Line: -        if (!array) {
>, <Line: -          array = scope.$$watchers = [];
>, <Line: -        }
>, <Line: -        // we use unshift since we use a while loop in $digest for speed.
>, <Line: -        // the while loop reads in reverse order.
>, <Line: -        array.unshift(watcher);
>, <Line: -        return function deregisterWatch() {
>, <Line: -          arrayRemove(array, watcher);
>, <Line: -          lastDirtyWatch = null;
>, <Line: -        };
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$watchGroup
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`.
>, <Line: -       * If any one expression in the collection changes the `listener` is executed.
>, <Line: -       *
>, <Line: -       * - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every
>, <Line: -       *   call to $digest() to see if any items changes.
>, <Line: -       * - The `listener` is called whenever any expression in the `watchExpressions` array changes.
>, <Line: -       *
>, <Line: -       * @param {Array.<string|Function(scope)>} watchExpressions Array of expressions that will be individually
>, <Line: -       * watched using {@link ng.$rootScope.Scope#$watch $watch()}
>, <Line: -       *
>, <Line: -       * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any
>, <Line: -       *    expression in `watchExpressions` changes
>, <Line: -       *    The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching
>, <Line: -       *    those of `watchExpression`
>, <Line: -       *    and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching
>, <Line: -       *    those of `watchExpression`
>, <Line: -       *    The `scope` refers to the current scope.
>, <Line: -       * @returns {function()} Returns a de-registration function for all listeners.
>, <Line: -       */
>, <Line: -      $watchGroup: function(watchExpressions, listener) {
>, <Line: -        var oldValues = new Array(watchExpressions.length);
>, <Line: -        var newValues = new Array(watchExpressions.length);
>, <Line: -        var deregisterFns = [];
>, <Line: -        var self = this;
>, <Line: -        var changeReactionScheduled = false;
>, <Line: -        var firstRun = true;
>, <Line: -        if (!watchExpressions.length) {
>, <Line: -          // No expressions means we call the listener ASAP
>, <Line: -          var shouldCall = true;
>, <Line: -          self.$evalAsync(function() {
>, <Line: -            if (shouldCall) listener(newValues, newValues, self);
>, <Line: -          });
>, <Line: -          return function deregisterWatchGroup() {
>, <Line: -            shouldCall = false;
>, <Line: -          };
>, <Line: -        }
>, <Line: -        if (watchExpressions.length === 1) {
>, <Line: -          // Special case size of one
>, <Line: -          return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
>, <Line: -            newValues[0] = value;
>, <Line: -            oldValues[0] = oldValue;
>, <Line: -            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
>, <Line: -          });
>, <Line: -        }
>, <Line: -        forEach(watchExpressions, function(expr, i) {
>, <Line: -          var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
>, <Line: -            newValues[i] = value;
>, <Line: -            oldValues[i] = oldValue;
>, <Line: -            if (!changeReactionScheduled) {
>, <Line: -              changeReactionScheduled = true;
>, <Line: -              self.$evalAsync(watchGroupAction);
>, <Line: -            }
>, <Line: -          });
>, <Line: -          deregisterFns.push(unwatchFn);
>, <Line: -        });
>, <Line: -        function watchGroupAction() {
>, <Line: -          changeReactionScheduled = false;
>, <Line: -          if (firstRun) {
>, <Line: -            firstRun = false;
>, <Line: -            listener(newValues, newValues, self);
>, <Line: -          } else {
>, <Line: -            listener(newValues, oldValues, self);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        return function deregisterWatchGroup() {
>, <Line: -          while (deregisterFns.length) {
>, <Line: -            deregisterFns.shift()();
>, <Line: -          }
>, <Line: -        };
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$watchCollection
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Shallow watches the properties of an object and fires whenever any of the properties change
>, <Line: -       * (for arrays, this implies watching the array items; for object maps, this implies watching
>, <Line: -       * the properties). If a change is detected, the `listener` callback is fired.
>, <Line: -       *
>, <Line: -       * - The `obj` collection is observed via standard $watch operation and is examined on every
>, <Line: -       *   call to $digest() to see if any items have been added, removed, or moved.
>, <Line: -       * - The `listener` is called whenever anything within the `obj` has changed. Examples include
>, <Line: -       *   adding, removing, and moving items belonging to an object or array.
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * # Example
>, <Line: -       * ```js
>, <Line: -          $scope.names = ['igor', 'matias', 'misko', 'james'];
>, <Line: -          $scope.dataCount = 4;
>, <Line: -          $scope.$watchCollection('names', function(newNames, oldNames) {
>, <Line: -            $scope.dataCount = newNames.length;
>, <Line: -          });
>, <Line: -          expect($scope.dataCount).toEqual(4);
>, <Line: -          $scope.$digest();
>, <Line: -          //still at 4 ... no changes
>, <Line: -          expect($scope.dataCount).toEqual(4);
>, <Line: -          $scope.names.pop();
>, <Line: -          $scope.$digest();
>, <Line: -          //now there's been a change
>, <Line: -          expect($scope.dataCount).toEqual(3);
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The
>, <Line: -       *    expression value should evaluate to an object or an array which is observed on each
>, <Line: -       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the
>, <Line: -       *    collection will trigger a call to the `listener`.
>, <Line: -       *
>, <Line: -       * @param {function(newCollection, oldCollection, scope)} listener a callback function called
>, <Line: -       *    when a change is detected.
>, <Line: -       *    - The `newCollection` object is the newly modified data obtained from the `obj` expression
>, <Line: -       *    - The `oldCollection` object is a copy of the former collection data.
>, <Line: -       *      Due to performance considerations, the`oldCollection` value is computed only if the
>, <Line: -       *      `listener` function declares two or more arguments.
>, <Line: -       *    - The `scope` argument refers to the current scope.
>, <Line: -       *
>, <Line: -       * @returns {function()} Returns a de-registration function for this listener. When the
>, <Line: -       *    de-registration function is executed, the internal watch operation is terminated.
>, <Line: -       */
>, <Line: -      $watchCollection: function(obj, listener) {
>, <Line: -        $watchCollectionInterceptor.$stateful = true;
>, <Line: -        var self = this;
>, <Line: -        // the current value, updated on each dirty-check run
>, <Line: -        var newValue;
>, <Line: -        // a shallow copy of the newValue from the last dirty-check run,
>, <Line: -        // updated to match newValue during dirty-check run
>, <Line: -        var oldValue;
>, <Line: -        // a shallow copy of the newValue from when the last change happened
>, <Line: -        var veryOldValue;
>, <Line: -        // only track veryOldValue if the listener is asking for it
>, <Line: -        var trackVeryOldValue = (listener.length > 1);
>, <Line: -        var changeDetected = 0;
>, <Line: -        var changeDetector = $parse(obj, $watchCollectionInterceptor);
>, <Line: -        var internalArray = [];
>, <Line: -        var internalObject = {};
>, <Line: -        var initRun = true;
>, <Line: -        var oldLength = 0;
>, <Line: -        function $watchCollectionInterceptor(_value) {
>, <Line: -          newValue = _value;
>, <Line: -          var newLength, key, bothNaN, newItem, oldItem;
>, <Line: -          // If the new value is undefined, then return undefined as the watch may be a one-time watch
>, <Line: -          if (isUndefined(newValue)) return;
>, <Line: -          if (!isObject(newValue)) { // if primitive
>, <Line: -            if (oldValue !== newValue) {
>, <Line: -              oldValue = newValue;
>, <Line: -              changeDetected++;
>, <Line: -            }
>, <Line: -          } else if (isArrayLike(newValue)) {
>, <Line: -            if (oldValue !== internalArray) {
>, <Line: -              // we are transitioning from something which was not an array into array.
>, <Line: -              oldValue = internalArray;
>, <Line: -              oldLength = oldValue.length = 0;
>, <Line: -              changeDetected++;
>, <Line: -            }
>, <Line: -            newLength = newValue.length;
>, <Line: -            if (oldLength !== newLength) {
>, <Line: -              // if lengths do not match we need to trigger change notification
>, <Line: -              changeDetected++;
>, <Line: -              oldValue.length = oldLength = newLength;
>, <Line: -            }
>, <Line: -            // copy the items to oldValue and look for changes.
>, <Line: -            for (var i = 0; i < newLength; i++) {
>, <Line: -              oldItem = oldValue[i];
>, <Line: -              newItem = newValue[i];
>, <Line: -              bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
>, <Line: -              if (!bothNaN && (oldItem !== newItem)) {
>, <Line: -                changeDetected++;
>, <Line: -                oldValue[i] = newItem;
>, <Line: -              }
>, <Line: -            }
>, <Line: -          } else {
>, <Line: -            if (oldValue !== internalObject) {
>, <Line: -              // we are transitioning from something which was not an object into object.
>, <Line: -              oldValue = internalObject = {};
>, <Line: -              oldLength = 0;
>, <Line: -              changeDetected++;
>, <Line: -            }
>, <Line: -            // copy the items to oldValue and look for changes.
>, <Line: -            newLength = 0;
>, <Line: -            for (key in newValue) {
>, <Line: -              if (newValue.hasOwnProperty(key)) {
>, <Line: -                newLength++;
>, <Line: -                newItem = newValue[key];
>, <Line: -                oldItem = oldValue[key];
>, <Line: -                if (key in oldValue) {
>, <Line: -                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
>, <Line: -                  if (!bothNaN && (oldItem !== newItem)) {
>, <Line: -                    changeDetected++;
>, <Line: -                    oldValue[key] = newItem;
>, <Line: -                  }
>, <Line: -                } else {
>, <Line: -                  oldLength++;
>, <Line: -                  oldValue[key] = newItem;
>, <Line: -                  changeDetected++;
>, <Line: -                }
>, <Line: -              }
>, <Line: -            }
>, <Line: -            if (oldLength > newLength) {
>, <Line: -              // we used to have more keys, need to find them and destroy them.
>, <Line: -              changeDetected++;
>, <Line: -              for (key in oldValue) {
>, <Line: -                if (!newValue.hasOwnProperty(key)) {
>, <Line: -                  oldLength--;
>, <Line: -                  delete oldValue[key];
>, <Line: -                }
>, <Line: -              }
>, <Line: -            }
>, <Line: -          }
>, <Line: -          return changeDetected;
>, <Line: -        }
>, <Line: -        function $watchCollectionAction() {
>, <Line: -          if (initRun) {
>, <Line: -            initRun = false;
>, <Line: -            listener(newValue, newValue, self);
>, <Line: -          } else {
>, <Line: -            listener(newValue, veryOldValue, self);
>, <Line: -          }
>, <Line: -          // make a copy for the next time a collection is changed
>, <Line: -          if (trackVeryOldValue) {
>, <Line: -            if (!isObject(newValue)) {
>, <Line: -              //primitive
>, <Line: -              veryOldValue = newValue;
>, <Line: -            } else if (isArrayLike(newValue)) {
>, <Line: -              veryOldValue = new Array(newValue.length);
>, <Line: -              for (var i = 0; i < newValue.length; i++) {
>, <Line: -                veryOldValue[i] = newValue[i];
>, <Line: -              }
>, <Line: -            } else { // if object
>, <Line: -              veryOldValue = {};
>, <Line: -              for (var key in newValue) {
>, <Line: -                if (hasOwnProperty.call(newValue, key)) {
>, <Line: -                  veryOldValue[key] = newValue[key];
>, <Line: -                }
>, <Line: -              }
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        return this.$watch(changeDetector, $watchCollectionAction);
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$digest
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and
>, <Line: -       * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change
>, <Line: -       * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers}
>, <Line: -       * until no more listeners are firing. This means that it is possible to get into an infinite
>, <Line: -       * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of
>, <Line: -       * iterations exceeds 10.
>, <Line: -       *
>, <Line: -       * Usually, you don't call `$digest()` directly in
>, <Line: -       * {@link ng.directive:ngController controllers} or in
>, <Line: -       * {@link ng.$compileProvider#directive directives}.
>, <Line: -       * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within
>, <Line: -       * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`.
>, <Line: -       *
>, <Line: -       * If you want to be notified whenever `$digest()` is called,
>, <Line: -       * you can register a `watchExpression` function with
>, <Line: -       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.
>, <Line: -       *
>, <Line: -       * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.
>, <Line: -       *
>, <Line: -       * # Example
>, <Line: -       * ```js
>, <Line: -           var scope = ...;
>, <Line: -           scope.name = 'misko';
>, <Line: -           scope.counter = 0;
>, <Line: -           expect(scope.counter).toEqual(0);
>, <Line: -           scope.$watch('name', function(newValue, oldValue) {
>, <Line: -             scope.counter = scope.counter + 1;
>, <Line: -           });
>, <Line: -           expect(scope.counter).toEqual(0);
>, <Line: -           scope.$digest();
>, <Line: -           // the listener is always called during the first $digest loop after it was registered
>, <Line: -           expect(scope.counter).toEqual(1);
>, <Line: -           scope.$digest();
>, <Line: -           // but now it will not be called unless the value changes
>, <Line: -           expect(scope.counter).toEqual(1);
>, <Line: -           scope.name = 'adam';
>, <Line: -           scope.$digest();
>, <Line: -           expect(scope.counter).toEqual(2);
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       */
>, <Line: -      $digest: function() {
>, <Line: -        var watch, value, last,
>, <Line: -            watchers,
>, <Line: -            length,
>, <Line: -            dirty, ttl = TTL,
>, <Line: -            next, current, target = this,
>, <Line: -            watchLog = [],
>, <Line: -            logIdx, logMsg, asyncTask;
>, <Line: -        beginPhase('$digest');
>, <Line: -        // Check for changes to browser url that happened in sync before the call to $digest
>, <Line: -        $browser.$$checkUrlChange();
>, <Line: -        if (this === $rootScope && applyAsyncId !== null) {
>, <Line: -          // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then
>, <Line: -          // cancel the scheduled $apply and flush the queue of expressions to be evaluated.
>, <Line: -          $browser.defer.cancel(applyAsyncId);
>, <Line: -          flushApplyAsync();
>, <Line: -        }
>, <Line: -        lastDirtyWatch = null;
>, <Line: -        do { // "while dirty" loop
>, <Line: -          dirty = false;
>, <Line: -          current = target;
>, <Line: -          while (asyncQueue.length) {
>, <Line: -            try {
>, <Line: -              asyncTask = asyncQueue.shift();
>, <Line: -              asyncTask.scope.$eval(asyncTask.expression);
>, <Line: -            } catch (e) {
>, <Line: -              $exceptionHandler(e);
>, <Line: -            }
>, <Line: -            lastDirtyWatch = null;
>, <Line: -          }
>, <Line: -          traverseScopesLoop:
>, <Line: -          do { // "traverse the scopes" loop
>, <Line: -            if ((watchers = current.$$watchers)) {
>, <Line: -              // process our watches
>, <Line: -              length = watchers.length;
>, <Line: -              while (length--) {
>, <Line: -                try {
>, <Line: -                  watch = watchers[length];
>, <Line: -                  // Most common watches are on primitives, in which case we can short
>, <Line: -                  // circuit it with === operator, only when === fails do we use .equals
>, <Line: -                  if (watch) {
>, <Line: -                    if ((value = watch.get(current)) !== (last = watch.last) &&
>, <Line: -                        !(watch.eq
>, <Line: -                            ? equals(value, last)
>, <Line: -                            : (typeof value === 'number' && typeof last === 'number'
>, <Line: -                               && isNaN(value) && isNaN(last)))) {
>, <Line: -                      dirty = true;
>, <Line: -                      lastDirtyWatch = watch;
>, <Line: -                      watch.last = watch.eq ? copy(value, null) : value;
>, <Line: -                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
>, <Line: -                      if (ttl < 5) {
>, <Line: -                        logIdx = 4 - ttl;
>, <Line: -                        if (!watchLog[logIdx]) watchLog[logIdx] = [];
>, <Line: -                        watchLog[logIdx].push({
>, <Line: -                          msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
>, <Line: -                          newVal: value,
>, <Line: -                          oldVal: last
>, <Line: -                        });
>, <Line: -                      }
>, <Line: -                    } else if (watch === lastDirtyWatch) {
>, <Line: -                      // If the most recently dirty watcher is now clean, short circuit since the remaining watchers
>, <Line: -                      // have already been tested.
>, <Line: -                      dirty = false;
>, <Line: -                      break traverseScopesLoop;
>, <Line: -                    }
>, <Line: -                  }
>, <Line: -                } catch (e) {
>, <Line: -                  $exceptionHandler(e);
>, <Line: -                }
>, <Line: -              }
>, <Line: -            }
>, <Line: -            // Insanity Warning: scope depth-first traversal
>, <Line: -            // yes, this code is a bit crazy, but it works and we have tests to prove it!
>, <Line: -            // this piece should be kept in sync with the traversal in $broadcast
>, <Line: -            if (!(next = (current.$$childHead ||
>, <Line: -                (current !== target && current.$$nextSibling)))) {
>, <Line: -              while (current !== target && !(next = current.$$nextSibling)) {
>, <Line: -                current = current.$parent;
>, <Line: -              }
>, <Line: -            }
>, <Line: -          } while ((current = next));
>, <Line: -          // `break traverseScopesLoop;` takes us to here
>, <Line: -          if ((dirty || asyncQueue.length) && !(ttl--)) {
>, <Line: -            clearPhase();
>, <Line: -            throw $rootScopeMinErr('infdig',
>, <Line: -                '{0} $digest() iterations reached. Aborting!\n' +
>, <Line: -                'Watchers fired in the last 5 iterations: {1}',
>, <Line: -                TTL, watchLog);
>, <Line: -          }
>, <Line: -        } while (dirty || asyncQueue.length);
>, <Line: -        clearPhase();
>, <Line: -        while (postDigestQueue.length) {
>, <Line: -          try {
>, <Line: -            postDigestQueue.shift()();
>, <Line: -          } catch (e) {
>, <Line: -            $exceptionHandler(e);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc event
>, <Line: -       * @name $rootScope.Scope#$destroy
>, <Line: -       * @eventType broadcast on scope being destroyed
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Broadcasted when a scope and its children are being destroyed.
>, <Line: -       *
>, <Line: -       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
>, <Line: -       * clean up DOM bindings before an element is removed from the DOM.
>, <Line: -       */
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$destroy
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Removes the current scope (and all of its children) from the parent scope. Removal implies
>, <Line: -       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
>, <Line: -       * propagate to the current scope and its children. Removal also implies that the current
>, <Line: -       * scope is eligible for garbage collection.
>, <Line: -       *
>, <Line: -       * The `$destroy()` is usually used by directives such as
>, <Line: -       * {@link ng.directive:ngRepeat ngRepeat} for managing the
>, <Line: -       * unrolling of the loop.
>, <Line: -       *
>, <Line: -       * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.
>, <Line: -       * Application code can register a `$destroy` event handler that will give it a chance to
>, <Line: -       * perform any necessary cleanup.
>, <Line: -       *
>, <Line: -       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
>, <Line: -       * clean up DOM bindings before an element is removed from the DOM.
>, <Line: -       */
>, <Line: -      $destroy: function() {
>, <Line: -        // we can't destroy the root scope or a scope that has been already destroyed
>, <Line: -        if (this.$$destroyed) return;
>, <Line: -        var parent = this.$parent;
>, <Line: -        this.$broadcast('$destroy');
>, <Line: -        this.$$destroyed = true;
>, <Line: -        if (this === $rootScope) return;
>, <Line: -        for (var eventName in this.$$listenerCount) {
>, <Line: -          decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
>, <Line: -        }
>, <Line: -        // sever all the references to parent scopes (after this cleanup, the current scope should
>, <Line: -        // not be retained by any of our references and should be eligible for garbage collection)
>, <Line: -        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
>, <Line: -        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
>, <Line: -        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
>, <Line: -        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
>, <Line: -        // Disable listeners, watchers and apply/digest methods
>, <Line: -        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
>, <Line: -        this.$on = this.$watch = this.$watchGroup = function() { return noop; };
>, <Line: -        this.$$listeners = {};
>, <Line: -        // All of the code below is bogus code that works around V8's memory leak via optimized code
>, <Line: -        // and inline caches.
>, <Line: -        //
>, <Line: -        // see:
>, <Line: -        // - https://code.google.com/p/v8/issues/detail?id=2073#c26
>, <Line: -        // - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909
>, <Line: -        // - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
>, <Line: -        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
>, <Line: -            this.$$childTail = this.$root = this.$$watchers = null;
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$eval
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Executes the `expression` on the current scope and returns the result. Any exceptions in
>, <Line: -       * the expression are propagated (uncaught). This is useful when evaluating Angular
>, <Line: -       * expressions.
>, <Line: -       *
>, <Line: -       * # Example
>, <Line: -       * ```js
>, <Line: -           var scope = ng.$rootScope.Scope();
>, <Line: -           scope.a = 1;
>, <Line: -           scope.b = 2;
>, <Line: -           expect(scope.$eval('a+b')).toEqual(3);
>, <Line: -           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       * @param {(string|function())=} expression An angular expression to be executed.
>, <Line: -       *
>, <Line: -       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
>, <Line: -       *    - `function(scope)`: execute the function with the current `scope` parameter.
>, <Line: -       *
>, <Line: -       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
>, <Line: -       * @returns {*} The result of evaluating the expression.
>, <Line: -       */
>, <Line: -      $eval: function(expr, locals) {
>, <Line: -        return $parse(expr)(this, locals);
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$evalAsync
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Executes the expression on the current scope at a later point in time.
>, <Line: -       *
>, <Line: -       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
>, <Line: -       * that:
>, <Line: -       *
>, <Line: -       *   - it will execute after the function that scheduled the evaluation (preferably before DOM
>, <Line: -       *     rendering).
>, <Line: -       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after
>, <Line: -       *     `expression` execution.
>, <Line: -       *
>, <Line: -       * Any exceptions from the execution of the expression are forwarded to the
>, <Line: -       * {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: -       *
>, <Line: -       * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle
>, <Line: -       * will be scheduled. However, it is encouraged to always call code that changes the model
>, <Line: -       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
>, <Line: -       *
>, <Line: -       * @param {(string|function())=} expression An angular expression to be executed.
>, <Line: -       *
>, <Line: -       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: -       *    - `function(scope)`: execute the function with the current `scope` parameter.
>, <Line: -       *
>, <Line: -       */
>, <Line: -      $evalAsync: function(expr) {
>, <Line: -        // if we are outside of an $digest loop and this is the first time we are scheduling async
>, <Line: -        // task also schedule async auto-flush
>, <Line: -        if (!$rootScope.$$phase && !asyncQueue.length) {
>, <Line: -          $browser.defer(function() {
>, <Line: -            if (asyncQueue.length) {
>, <Line: -              $rootScope.$digest();
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -        asyncQueue.push({scope: this, expression: expr});
>, <Line: -      },
>, <Line: -      $$postDigest: function(fn) {
>, <Line: -        postDigestQueue.push(fn);
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$apply
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * `$apply()` is used to execute an expression in angular from outside of the angular
>, <Line: -       * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).
>, <Line: -       * Because we are calling into the angular framework we need to perform proper scope life
>, <Line: -       * cycle of {@link ng.$exceptionHandler exception handling},
>, <Line: -       * {@link ng.$rootScope.Scope#$digest executing watches}.
>, <Line: -       *
>, <Line: -       * ## Life cycle
>, <Line: -       *
>, <Line: -       * # Pseudo-Code of `$apply()`
>, <Line: -       * ```js
>, <Line: -           function $apply(expr) {
>, <Line: -             try {
>, <Line: -               return $eval(expr);
>, <Line: -             } catch (e) {
>, <Line: -               $exceptionHandler(e);
>, <Line: -             } finally {
>, <Line: -               $root.$digest();
>, <Line: -             }
>, <Line: -           }
>, <Line: -       * ```
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * Scope's `$apply()` method transitions through the following stages:
>, <Line: -       *
>, <Line: -       * 1. The {@link guide/expression expression} is executed using the
>, <Line: -       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
>, <Line: -       * 2. Any exceptions from the execution of the expression are forwarded to the
>, <Line: -       *    {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: -       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the
>, <Line: -       *    expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
>, <Line: -       *
>, <Line: -       *
>, <Line: -       * @param {(string|function())=} exp An angular expression to be executed.
>, <Line: -       *
>, <Line: -       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: -       *    - `function(scope)`: execute the function with current `scope` parameter.
>, <Line: -       *
>, <Line: -       * @returns {*} The result of evaluating the expression.
>, <Line: -       */
>, <Line: -      $apply: function(expr) {
>, <Line: -        try {
>, <Line: -          beginPhase('$apply');
>, <Line: -          return this.$eval(expr);
>, <Line: -        } catch (e) {
>, <Line: -          $exceptionHandler(e);
>, <Line: -        } finally {
>, <Line: -          clearPhase();
>, <Line: -          try {
>, <Line: -            $rootScope.$digest();
>, <Line: -          } catch (e) {
>, <Line: -            $exceptionHandler(e);
>, <Line: -            throw e;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$applyAsync
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Schedule the invokation of $apply to occur at a later time. The actual time difference
>, <Line: -       * varies across browsers, but is typically around ~10 milliseconds.
>, <Line: -       *
>, <Line: -       * This can be used to queue up multiple expressions which need to be evaluated in the same
>, <Line: -       * digest.
>, <Line: -       *
>, <Line: -       * @param {(string|function())=} exp An angular expression to be executed.
>, <Line: -       *
>, <Line: -       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
>, <Line: -       *    - `function(scope)`: execute the function with current `scope` parameter.
>, <Line: -       */
>, <Line: -      $applyAsync: function(expr) {
>, <Line: -        var scope = this;
>, <Line: -        expr && applyAsyncQueue.push($applyAsyncExpression);
>, <Line: -        scheduleApplyAsync();
>, <Line: -        function $applyAsyncExpression() {
>, <Line: -          scope.$eval(expr);
>, <Line: -        }
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$on
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for
>, <Line: -       * discussion of event life cycle.
>, <Line: -       *
>, <Line: -       * The event listener function format is: `function(event, args...)`. The `event` object
>, <Line: -       * passed into the listener has the following attributes:
>, <Line: -       *
>, <Line: -       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or
>, <Line: -       *     `$broadcast`-ed.
>, <Line: -       *   - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the
>, <Line: -       *     event propagates through the scope hierarchy, this property is set to null.
>, <Line: -       *   - `name` - `{string}`: name of the event.
>, <Line: -       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel
>, <Line: -       *     further event propagation (available only for events that were `$emit`-ed).
>, <Line: -       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag
>, <Line: -       *     to true.
>, <Line: -       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
>, <Line: -       *
>, <Line: -       * @param {string} name Event name to listen on.
>, <Line: -       * @param {function(event, ...args)} listener Function to call when the event is emitted.
>, <Line: -       * @returns {function()} Returns a deregistration function for this listener.
>, <Line: -       */
>, <Line: -      $on: function(name, listener) {
>, <Line: -        var namedListeners = this.$$listeners[name];
>, <Line: -        if (!namedListeners) {
>, <Line: -          this.$$listeners[name] = namedListeners = [];
>, <Line: -        }
>, <Line: -        namedListeners.push(listener);
>, <Line: -        var current = this;
>, <Line: -        do {
>, <Line: -          if (!current.$$listenerCount[name]) {
>, <Line: -            current.$$listenerCount[name] = 0;
>, <Line: -          }
>, <Line: -          current.$$listenerCount[name]++;
>, <Line: -        } while ((current = current.$parent));
>, <Line: -        var self = this;
>, <Line: -        return function() {
>, <Line: -          var indexOfListener = namedListeners.indexOf(listener);
>, <Line: -          if (indexOfListener !== -1) {
>, <Line: -            namedListeners[indexOfListener] = null;
>, <Line: -            decrementListenerCount(self, 1, name);
>, <Line: -          }
>, <Line: -        };
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$emit
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Dispatches an event `name` upwards through the scope hierarchy notifying the
>, <Line: -       * registered {@link ng.$rootScope.Scope#$on} listeners.
>, <Line: -       *
>, <Line: -       * The event life cycle starts at the scope on which `$emit` was called. All
>, <Line: -       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
>, <Line: -       * notified. Afterwards, the event traverses upwards toward the root scope and calls all
>, <Line: -       * registered listeners along the way. The event will stop propagating if one of the listeners
>, <Line: -       * cancels it.
>, <Line: -       *
>, <Line: -       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
>, <Line: -       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: -       *
>, <Line: -       * @param {string} name Event name to emit.
>, <Line: -       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
>, <Line: -       * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).
>, <Line: -       */
>, <Line: -      $emit: function(name, args) {
>, <Line: -        var empty = [],
>, <Line: -            namedListeners,
>, <Line: -            scope = this,
>, <Line: -            stopPropagation = false,
>, <Line: -            event = {
>, <Line: -              name: name,
>, <Line: -              targetScope: scope,
>, <Line: -              stopPropagation: function() {stopPropagation = true;},
>, <Line: -              preventDefault: function() {
>, <Line: -                event.defaultPrevented = true;
>, <Line: -              },
>, <Line: -              defaultPrevented: false
>, <Line: -            },
>, <Line: -            listenerArgs = concat([event], arguments, 1),
>, <Line: -            i, length;
>, <Line: -        do {
>, <Line: -          namedListeners = scope.$$listeners[name] || empty;
>, <Line: -          event.currentScope = scope;
>, <Line: -          for (i = 0, length = namedListeners.length; i < length; i++) {
>, <Line: -            // if listeners were deregistered, defragment the array
>, <Line: -            if (!namedListeners[i]) {
>, <Line: -              namedListeners.splice(i, 1);
>, <Line: -              i--;
>, <Line: -              length--;
>, <Line: -              continue;
>, <Line: -            }
>, <Line: -            try {
>, <Line: -              //allow all listeners attached to the current scope to run
>, <Line: -              namedListeners[i].apply(null, listenerArgs);
>, <Line: -            } catch (e) {
>, <Line: -              $exceptionHandler(e);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          //if any listener on the current scope stops propagation, prevent bubbling
>, <Line: -          if (stopPropagation) {
>, <Line: -            event.currentScope = null;
>, <Line: -            return event;
>, <Line: -          }
>, <Line: -          //traverse upwards
>, <Line: -          scope = scope.$parent;
>, <Line: -        } while (scope);
>, <Line: -        event.currentScope = null;
>, <Line: -        return event;
>, <Line: -      },
>, <Line: -      /**
>, <Line: -       * @ngdoc method
>, <Line: -       * @name $rootScope.Scope#$broadcast
>, <Line: -       * @kind function
>, <Line: -       *
>, <Line: -       * @description
>, <Line: -       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
>, <Line: -       * registered {@link ng.$rootScope.Scope#$on} listeners.
>, <Line: -       *
>, <Line: -       * The event life cycle starts at the scope on which `$broadcast` was called. All
>, <Line: -       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
>, <Line: -       * notified. Afterwards, the event propagates to all direct and indirect scopes of the current
>, <Line: -       * scope and calls all registered listeners along the way. The event cannot be canceled.
>, <Line: -       *
>, <Line: -       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
>, <Line: -       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: -       *
>, <Line: -       * @param {string} name Event name to broadcast.
>, <Line: -       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
>, <Line: -       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
>, <Line: -       */
>, <Line: -      $broadcast: function(name, args) {
>, <Line: -        var target = this,
>, <Line: -            current = target,
>, <Line: -            next = target,
>, <Line: -            event = {
>, <Line: -              name: name,
>, <Line: -              targetScope: target,
>, <Line: -              preventDefault: function() {
>, <Line: -                event.defaultPrevented = true;
>, <Line: -              },
>, <Line: -              defaultPrevented: false
>, <Line: -            };
>, <Line: -        if (!target.$$listenerCount[name]) return event;
>, <Line: -        var listenerArgs = concat([event], arguments, 1),
>, <Line: -            listeners, i, length;
>, <Line: -        //down while you can, then up and next sibling or up and next sibling until back at root
>, <Line: -        while ((current = next)) {
>, <Line: -          event.currentScope = current;
>, <Line: -          listeners = current.$$listeners[name] || [];
>, <Line: -          for (i = 0, length = listeners.length; i < length; i++) {
>, <Line: -            // if listeners were deregistered, defragment the array
>, <Line: -            if (!listeners[i]) {
>, <Line: -              listeners.splice(i, 1);
>, <Line: -              i--;
>, <Line: -              length--;
>, <Line: -              continue;
>, <Line: -            }
>, <Line: -            try {
>, <Line: -              listeners[i].apply(null, listenerArgs);
>, <Line: -            } catch (e) {
>, <Line: -              $exceptionHandler(e);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          // Insanity Warning: scope depth-first traversal
>, <Line: -          // yes, this code is a bit crazy, but it works and we have tests to prove it!
>, <Line: -          // this piece should be kept in sync with the traversal in $digest
>, <Line: -          // (though it differs due to having the extra check for $$listenerCount)
>, <Line: -          if (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
>, <Line: -              (current !== target && current.$$nextSibling)))) {
>, <Line: -            while (current !== target && !(next = current.$$nextSibling)) {
>, <Line: -              current = current.$parent;
>, <Line: -            }
>, <Line: -          }
>, <Line: -        }
>, <Line: -        event.currentScope = null;
>, <Line: -        return event;
>, <Line: -      }
>, <Line: -    };
>, <Line: -    var $rootScope = new Scope();
>, <Line: -    //The internal queues. Expose them on the $rootScope for debugging/testing purposes.
>, <Line: -    var asyncQueue = $rootScope.$$asyncQueue = [];
>, <Line: -    var postDigestQueue = $rootScope.$$postDigestQueue = [];
>, <Line: -    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
>, <Line: -    return $rootScope;
>, <Line: -    function beginPhase(phase) {
>, <Line: -      if ($rootScope.$$phase) {
>, <Line: -        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
>, <Line: -      }
>, <Line: -      $rootScope.$$phase = phase;
>, <Line: -    }
>, <Line: -    function clearPhase() {
>, <Line: -      $rootScope.$$phase = null;
>, <Line: -    }
>, <Line: -    function decrementListenerCount(current, count, name) {
>, <Line: -      do {
>, <Line: -        current.$$listenerCount[name] -= count;
>, <Line: -        if (current.$$listenerCount[name] === 0) {
>, <Line: -          delete current.$$listenerCount[name];
>, <Line: -        }
>, <Line: -      } while ((current = current.$parent));
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * function used as an initial value for watchers.
>, <Line: -     * because it's unique we can easily tell it apart from other values
>, <Line: -     */
>, <Line: -    function initWatchVal() {}
>, <Line: -    function flushApplyAsync() {
>, <Line: -      while (applyAsyncQueue.length) {
>, <Line: -        try {
>, <Line: -          applyAsyncQueue.shift()();
>, <Line: -        } catch (e) {
>, <Line: -          $exceptionHandler(e);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      applyAsyncId = null;
>, <Line: -    }
>, <Line: -    function scheduleApplyAsync() {
>, <Line: -      if (applyAsyncId === null) {
>, <Line: -        applyAsyncId = $browser.defer(function() {
>, <Line: -          $rootScope.$apply(flushApplyAsync);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @description
>, <Line: - * Private service to sanitize uris for links and images. Used by $compile and $sanitize.
>, <Line: - */
>, <Line: -function $$SanitizeUriProvider() {
>, <Line: -  var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
>, <Line: -    imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
>, <Line: -  /**
>, <Line: -   * @description
>, <Line: -   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: -   * urls during a[href] sanitization.
>, <Line: -   *
>, <Line: -   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: -   *
>, <Line: -   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
>, <Line: -   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
>, <Line: -   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: -   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: -   *
>, <Line: -   * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: -   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: -   *    chaining otherwise.
>, <Line: -   */
>, <Line: -  this.aHrefSanitizationWhitelist = function(regexp) {
>, <Line: -    if (isDefined(regexp)) {
>, <Line: -      aHrefSanitizationWhitelist = regexp;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    return aHrefSanitizationWhitelist;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @description
>, <Line: -   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
>, <Line: -   * urls during img[src] sanitization.
>, <Line: -   *
>, <Line: -   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
>, <Line: -   *
>, <Line: -   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
>, <Line: -   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
>, <Line: -   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
>, <Line: -   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
>, <Line: -   *
>, <Line: -   * @param {RegExp=} regexp New regexp to whitelist urls with.
>, <Line: -   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
>, <Line: -   *    chaining otherwise.
>, <Line: -   */
>, <Line: -  this.imgSrcSanitizationWhitelist = function(regexp) {
>, <Line: -    if (isDefined(regexp)) {
>, <Line: -      imgSrcSanitizationWhitelist = regexp;
>, <Line: -      return this;
>, <Line: -    }
>, <Line: -    return imgSrcSanitizationWhitelist;
>, <Line: -  };
>, <Line: -  this.$get = function() {
>, <Line: -    return function sanitizeUri(uri, isImage) {
>, <Line: -      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
>, <Line: -      var normalizedVal;
>, <Line: -      normalizedVal = urlResolve(uri).href;
>, <Line: -      if (normalizedVal !== '' && !normalizedVal.match(regex)) {
>, <Line: -        return 'unsafe:' + normalizedVal;
>, <Line: -      }
>, <Line: -      return uri;
>, <Line: -    };
>, <Line: -  };
>, <Line: -}
>, <Line: -var $sceMinErr = minErr('$sce');
>, <Line: -var SCE_CONTEXTS = {
>, <Line: -  HTML: 'html',
>, <Line: -  CSS: 'css',
>, <Line: -  URL: 'url',
>, <Line: -  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
>, <Line: -  // url.  (e.g. ng-include, script src, templateUrl)
>, <Line: -  RESOURCE_URL: 'resourceUrl',
>, <Line: -  JS: 'js'
>, <Line: -};
>, <Line: -function adjustMatcher(matcher) {
>, <Line: -  if (matcher === 'self') {
>, <Line: -    return matcher;
>, <Line: -  } else if (isString(matcher)) {
>, <Line: -    // Strings match exactly except for 2 wildcards - '*' and '**'.
>, <Line: -    // '*' matches any character except those from the set ':/.?&'.
>, <Line: -    // '**' matches any character (like .* in a RegExp).
>, <Line: -    // More than 2 *'s raises an error as it's ill defined.
>, <Line: -    if (matcher.indexOf('***') > -1) {
>, <Line: -      throw $sceMinErr('iwcard',
>, <Line: -          'Illegal sequence *** in string matcher.  String: {0}', matcher);
>, <Line: -    }
>, <Line: -    matcher = escapeForRegexp(matcher).
>, <Line: -                  replace('\\*\\*', '.*').
>, <Line: -                  replace('\\*', '[^:/.?&;]*');
>, <Line: -    return new RegExp('^' + matcher + '$');
>, <Line: -  } else if (isRegExp(matcher)) {
>, <Line: -    // The only other type of matcher allowed is a Regexp.
>, <Line: -    // Match entire URL / disallow partial matches.
>, <Line: -    // Flags are reset (i.e. no global, ignoreCase or multiline)
>, <Line: -    return new RegExp('^' + matcher.source + '$');
>, <Line: -  } else {
>, <Line: -    throw $sceMinErr('imatcher',
>, <Line: -        'Matchers may only be "self", string patterns or RegExp objects');
>, <Line: -  }
>, <Line: -}
>, <Line: -function adjustMatchers(matchers) {
>, <Line: -  var adjustedMatchers = [];
>, <Line: -  if (isDefined(matchers)) {
>, <Line: -    forEach(matchers, function(matcher) {
>, <Line: -      adjustedMatchers.push(adjustMatcher(matcher));
>, <Line: -    });
>, <Line: -  }
>, <Line: -  return adjustedMatchers;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $sceDelegate
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
>, <Line: - *
>, <Line: - * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
>, <Line: - * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
>, <Line: - * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
>, <Line: - * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
>, <Line: - * work because `$sce` delegates to `$sceDelegate` for these operations.
>, <Line: - *
>, <Line: - * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
>, <Line: - *
>, <Line: - * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
>, <Line: - * can override it completely to change the behavior of `$sce`, the common case would
>, <Line: - * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
>, <Line: - * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
>, <Line: - * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist
>, <Line: - * ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $sceDelegateProvider
>, <Line: - * @description
>, <Line: - *
>, <Line: - * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
>, <Line: - * that the URLs used for sourcing Angular templates are safe.  Refer {@link
>, <Line: - * ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
>, <Line: - * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
>, <Line: - *
>, <Line: - * For the general details about this service in Angular, read the main page for {@link ng.$sce
>, <Line: - *
>, <Line: - * **Example**:  Consider the following case. <a name="example"></a>
>, <Line: - *
>, <Line: - * - your app is hosted at url `http://myapp.example.com/`
>, <Line: - * - but some of your templates are hosted on other domains you control such as
>, <Line: - *   `http://srv01.assets.example.com/`, `http://srv02.assets.example.com/`, etc.
>, <Line: - * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
>, <Line: - *
>, <Line: - * Here is what a secure configuration for this scenario might look like:
>, <Line: - *
>, <Line: - * ```
>, <Line: - *  angular.module('myApp', []).config(function($sceDelegateProvider) {
>, <Line: - * ```
>, <Line: - */
>, <Line: -function $SceDelegateProvider() {
>, <Line: -  this.SCE_CONTEXTS = SCE_CONTEXTS;
>, <Line: -  // Resource URLs can also be trusted by policy.
>, <Line: -  var resourceUrlWhitelist = ['self'],
>, <Line: -      resourceUrlBlacklist = [];
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $sceDelegateProvider#resourceUrlWhitelist
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
>, <Line: -   *     provided.  This must be an array or null.  A snapshot of this array is used so further
>, <Line: -   *     changes to the array are ignored.
>, <Line: -   *
>, <Line: -   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
>, <Line: -   *     allowed in this array.
>, <Line: -   *
>, <Line: -   *     Note: **an empty whitelist array will block all URLs**!
>, <Line: -   *
>, <Line: -   * @return {Array} the currently set whitelist array.
>, <Line: -   *
>, <Line: -   * The **default value** when no whitelist has been explicitly set is `['self']` allowing only
>, <Line: -   * same origin resource requests.
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets/Gets the whitelist of trusted resource URLs.
>, <Line: -   */
>, <Line: -  this.resourceUrlWhitelist = function(value) {
>, <Line: -    if (arguments.length) {
>, <Line: -      resourceUrlWhitelist = adjustMatchers(value);
>, <Line: -    }
>, <Line: -    return resourceUrlWhitelist;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $sceDelegateProvider#resourceUrlBlacklist
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
>, <Line: -   *     provided.  This must be an array or null.  A snapshot of this array is used so further
>, <Line: -   *     changes to the array are ignored.
>, <Line: -   *
>, <Line: -   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
>, <Line: -   *     allowed in this array.
>, <Line: -   *
>, <Line: -   *     The typical usage for the blacklist is to **block
>, <Line: -   *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
>, <Line: -   *     these would otherwise be trusted but actually return content from the redirected domain.
>, <Line: -   *
>, <Line: -   *     Finally, **the blacklist overrides the whitelist** and has the final say.
>, <Line: -   *
>, <Line: -   * @return {Array} the currently set blacklist array.
>, <Line: -   *
>, <Line: -   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there
>, <Line: -   * is no blacklist.)
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets/Gets the blacklist of trusted resource URLs.
>, <Line: -   */
>, <Line: -  this.resourceUrlBlacklist = function(value) {
>, <Line: -    if (arguments.length) {
>, <Line: -      resourceUrlBlacklist = adjustMatchers(value);
>, <Line: -    }
>, <Line: -    return resourceUrlBlacklist;
>, <Line: -  };
>, <Line: -  this.$get = ['$injector', function($injector) {
>, <Line: -    var htmlSanitizer = function htmlSanitizer(html) {
>, <Line: -      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
>, <Line: -    };
>, <Line: -    if ($injector.has('$sanitize')) {
>, <Line: -      htmlSanitizer = $injector.get('$sanitize');
>, <Line: -    }
>, <Line: -    function matchUrl(matcher, parsedUrl) {
>, <Line: -      if (matcher === 'self') {
>, <Line: -        return urlIsSameOrigin(parsedUrl);
>, <Line: -      } else {
>, <Line: -        // definitely a regex.  See adjustMatchers()
>, <Line: -        return !!matcher.exec(parsedUrl.href);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function isResourceUrlAllowedByPolicy(url) {
>, <Line: -      var parsedUrl = urlResolve(url.toString());
>, <Line: -      var i, n, allowed = false;
>, <Line: -      // Ensure that at least one item from the whitelist allows this url.
>, <Line: -      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
>, <Line: -        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
>, <Line: -          allowed = true;
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (allowed) {
>, <Line: -        // Ensure that no item from the blacklist blocked this url.
>, <Line: -        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
>, <Line: -          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
>, <Line: -            allowed = false;
>, <Line: -            break;
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return allowed;
>, <Line: -    }
>, <Line: -    function generateHolderType(Base) {
>, <Line: -      var holderType = function TrustedValueHolderType(trustedValue) {
>, <Line: -        this.$$unwrapTrustedValue = function() {
>, <Line: -          return trustedValue;
>, <Line: -        };
>, <Line: -      };
>, <Line: -      if (Base) {
>, <Line: -        holderType.prototype = new Base();
>, <Line: -      }
>, <Line: -      holderType.prototype.valueOf = function sceValueOf() {
>, <Line: -        return this.$$unwrapTrustedValue();
>, <Line: -      };
>, <Line: -      holderType.prototype.toString = function sceToString() {
>, <Line: -        return this.$$unwrapTrustedValue().toString();
>, <Line: -      };
>, <Line: -      return holderType;
>, <Line: -    }
>, <Line: -    var trustedValueHolderBase = generateHolderType(),
>, <Line: -        byType = {};
>, <Line: -    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
>, <Line: -    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
>, <Line: -    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
>, <Line: -    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
>, <Line: -    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sceDelegate#trustAs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Returns an object that is trusted by angular for use in specified strict
>, <Line: -     * contextual escaping contexts (such as ng-bind-html, ng-include, any src
>, <Line: -     * attribute interpolation, any dom event binding attribute interpolation
>, <Line: -     * such as for onclick,  etc.) that uses the provided value.
>, <Line: -     * See {@link ng.$sce $sce} for enabling strict contextual escaping.
>, <Line: -     *
>, <Line: -     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
>, <Line: -     *   resourceUrl, html, js and css.
>, <Line: -     * @param {*} value The value that that should be considered trusted/safe.
>, <Line: -     * @returns {*} A value that can be used to stand in for the provided `value` in places
>, <Line: -     * where Angular expects a $sce.trustAs() return value.
>, <Line: -     */
>, <Line: -    function trustAs(type, trustedValue) {
>, <Line: -      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
>, <Line: -      if (!Constructor) {
>, <Line: -        throw $sceMinErr('icontext',
>, <Line: -            'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
>, <Line: -            type, trustedValue);
>, <Line: -      }
>, <Line: -      if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
>, <Line: -        return trustedValue;
>, <Line: -      }
>, <Line: -      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
>, <Line: -      // mutable objects, we ensure here that the value passed in is actually a string.
>, <Line: -      if (typeof trustedValue !== 'string') {
>, <Line: -        throw $sceMinErr('itype',
>, <Line: -            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
>, <Line: -            type);
>, <Line: -      }
>, <Line: -      return new Constructor(trustedValue);
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sceDelegate#valueOf
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
>, <Line: -     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
>, <Line: -     *
>, <Line: -     * If the passed parameter is not a value that had been returned by {@link
>, <Line: -     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.
>, <Line: -     *
>, <Line: -     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
>, <Line: -     *      call or anything else.
>, <Line: -     * @returns {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs
>, <Line: -     *     `value` unchanged.
>, <Line: -     */
>, <Line: -    function valueOf(maybeTrusted) {
>, <Line: -      if (maybeTrusted instanceof trustedValueHolderBase) {
>, <Line: -        return maybeTrusted.$$unwrapTrustedValue();
>, <Line: -      } else {
>, <Line: -        return maybeTrusted;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sceDelegate#getTrusted
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and
>, <Line: -     * returns the originally supplied value if the queried context type is a supertype of the
>, <Line: -     * created type.  If this condition isn't satisfied, throws an exception.
>, <Line: -     *
>, <Line: -     * @param {string} type The kind of context in which this value is to be used.
>, <Line: -     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
>, <Line: -     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
>, <Line: -     */
>, <Line: -    function getTrusted(type, maybeTrusted) {
>, <Line: -      if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
>, <Line: -        return maybeTrusted;
>, <Line: -      }
>, <Line: -      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
>, <Line: -      if (constructor && maybeTrusted instanceof constructor) {
>, <Line: -        return maybeTrusted.$$unwrapTrustedValue();
>, <Line: -      }
>, <Line: -      // If we get here, then we may only take one of two actions.
>, <Line: -      // 1. sanitize the value for the requested type, or
>, <Line: -      // 2. throw an exception.
>, <Line: -      if (type === SCE_CONTEXTS.RESOURCE_URL) {
>, <Line: -        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
>, <Line: -          return maybeTrusted;
>, <Line: -        } else {
>, <Line: -          throw $sceMinErr('insecurl',
>, <Line: -              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
>, <Line: -              maybeTrusted.toString());
>, <Line: -        }
>, <Line: -      } else if (type === SCE_CONTEXTS.HTML) {
>, <Line: -        return htmlSanitizer(maybeTrusted);
>, <Line: -      }
>, <Line: -      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
>, <Line: -    }
>, <Line: -    return { trustAs: trustAs,
>, <Line: -             getTrusted: getTrusted,
>, <Line: -             valueOf: valueOf };
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $sceProvider
>, <Line: - * @description
>, <Line: - *
>, <Line: - * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
>, <Line: - * -   enable/disable Strict Contextual Escaping (SCE) in a module
>, <Line: - * -   override the default implementation with a custom delegate
>, <Line: - *
>, <Line: - * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
>, <Line: - */
>, <Line: -/* jshint maxlen: false*/
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $sce
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
>, <Line: - *
>, <Line: - * # Strict Contextual Escaping
>, <Line: - *
>, <Line: - * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
>, <Line: - * contexts to result in a value that is marked as safe to use for that context.  One example of
>, <Line: - * such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer
>, <Line: - * to these contexts as privileged or SCE contexts.
>, <Line: - *
>, <Line: - * As of version 1.2, Angular ships with SCE enabled by default.
>, <Line: - *
>, <Line: - * Note:  When enabled (the default), IE<11 in quirks mode is not supported.  In this mode, IE<11 allow
>, <Line: - * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
>, <Line: - * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
>, <Line: - * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
>, <Line: - * to the top of your HTML document.
>, <Line: - *
>, <Line: - * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
>, <Line: - * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
>, <Line: - *
>, <Line: - * Here's an example of a binding in a privileged context:
>, <Line: - *
>, <Line: - * ```
>, <Line: - * <input ng-model="userHtml">
>, <Line: - * <div ng-bind-html="userHtml"></div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE
>, <Line: - * disabled, this application allows the user to render arbitrary HTML into the DIV.
>, <Line: - * In a more realistic example, one may be rendering user comments, blog articles, etc. via
>, <Line: - * bindings.  (HTML is just one example of a context where rendering user controlled input creates
>, <Line: - * security vulnerabilities.)
>, <Line: - *
>, <Line: - * For the case of HTML, you might use a library, either on the client side, or on the server side,
>, <Line: - * to sanitize unsafe HTML before binding to the value and rendering it in the document.
>, <Line: - *
>, <Line: - * How would you ensure that every place that used these types of bindings was bound to a value that
>, <Line: - * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
>, <Line: - * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
>, <Line: - * properties/fields and forgot to update the binding to the sanitized value?
>, <Line: - *
>, <Line: - * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
>, <Line: - * determine that something explicitly says it's safe to use a value for binding in that
>, <Line: - * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
>, <Line: - * for those values that you can easily tell are safe - because they were received from your server,
>, <Line: - * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
>, <Line: - * allowing only the files in a specific directory to do this.  Ensuring that the internal API
>, <Line: - * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
>, <Line: - *
>, <Line: - * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs}
>, <Line: - * (and shorthand methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to
>, <Line: - * obtain values that will be accepted by SCE / privileged contexts.
>, <Line: - *
>, <Line: - *
>, <Line: - * ## How does it work?
>, <Line: - *
>, <Line: - * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted
>, <Line: - * ng.$sce#parseAs $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
>, <Line: - * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
>, <Line: - *
>, <Line: - * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
>, <Line: - * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
>, <Line: - * simplified):
>, <Line: - *
>, <Line: - * ```
>, <Line: - * var ngBindHtmlDirective = ['$sce', function($sce) {
>, <Line: - *     });
>, <Line: - *   };
>, <Line: - * }];
>, <Line: - * ```
>, <Line: - *
>, <Line: - * ## Impact on loading templates
>, <Line: - *
>, <Line: - * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
>, <Line: - * `templateUrl`'s specified by {@link guide/directive directives}.
>, <Line: - *
>, <Line: - * By default, Angular only loads templates from the same domain and protocol as the application
>, <Line: - * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
>, <Line: - * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
>, <Line: - * protocols, you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist
>, <Line: - * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.
>, <Line: - *
>, <Line: - * *Please note*:
>, <Line: - * The browser's
>, <Line: - * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
>, <Line: - * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
>, <Line: - * policy apply in addition to this and may further restrict whether the template is successfully
>, <Line: - * loaded.  This means that without the right CORS policy, loading templates from a different domain
>, <Line: - * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
>, <Line: - * browsers.
>, <Line: - *
>, <Line: - * ## This feels like too much overhead
>, <Line: - *
>, <Line: - * It's important to remember that SCE only applies to interpolation expressions.
>, <Line: - *
>, <Line: - * If your expressions are constant literals, they're automatically trusted and you don't need to
>, <Line: - * call `$sce.trustAs` on them (remember to include the `ngSanitize` module) (e.g.
>, <Line: - * `<div ng-bind-html="'<b>implicitly trusted</b>'"></div>`) just works.
>, <Line: - *
>, <Line: - * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
>, <Line: - * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
>, <Line: - *
>, <Line: - * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
>, <Line: - * templates in `ng-include` from your application's domain without having to even know about SCE.
>, <Line: - * It blocks loading templates from other domains or loading templates over http from an https
>, <Line: - * served document.  You can change these by setting your own custom {@link
>, <Line: - * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link
>, <Line: - * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.
>, <Line: - *
>, <Line: - * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
>, <Line: - * application that's secure and can be audited to verify that with much more ease than bolting
>, <Line: - * security onto an application later.
>, <Line: - *
>, <Line: - * <a name="contexts"></a>
>, <Line: - * ## What trusted context types are supported?
>, <Line: - *
>, <Line: - * | Context             | Notes          |
>, <Line: - * |---------------------|----------------|
>, <Line: - * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. If an unsafe value is encountered and the {@link ngSanitize $sanitize} module is present this will sanitize the value instead of throwing an error. |
>, <Line: - * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
>, <Line: - * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't constitute an SCE context. |
>, <Line: - * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contents are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
>, <Line: - * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
>, <Line: - *
>, <Line: - * ## Format of items in {@link ng.$sceDelegateProvider#resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>
>, <Line: - *
>, <Line: - *  Each element in these arrays must be one of the following:
>, <Line: - *
>, <Line: - *  - **'self'**
>, <Line: - *    - The special **string**, `'self'`, can be used to match against all URLs of the **same
>, <Line: - *      domain** as the application document using the **same protocol**.
>, <Line: - *  - **String** (except the special value `'self'`)
>, <Line: - *    - The string is matched against the full *normalized / absolute URL* of the resource
>, <Line: - *      being tested (substring matches are not good enough.)
>, <Line: - *    - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters
>, <Line: - *      match themselves.
>, <Line: - *    - `*`: matches zero or more occurrences of any character other than one of the following 6
>, <Line: - *      characters: '`:`', '`/`', '`.`', '`?`', '`&`' and ';'.  It's a useful wildcard for use
>, <Line: - *      in a whitelist.
>, <Line: - *    - `**`: matches zero or more occurrences of *any* character.  As such, it's not
>, <Line: - *      not appropriate to use in for a scheme, domain, etc. as it would match too much.  (e.g.
>, <Line: - *      http://**.example.com/ would match http://evil.com/?ignore=.example.com/ and that might
>, <Line: - *      not have been the intention.)  Its usage at the very end of the path is ok.  (e.g.
>, <Line: - *      http://foo.example.com/templates/**).
>, <Line: - *  - **RegExp** (*see caveat below*)
>, <Line: - *    - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax
>, <Line: - *      (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to
>, <Line: - *      accidentally introduce a bug when one updates a complex expression (imho, all regexes should
>, <Line: - *      have good test coverage.).  For instance, the use of `.` in the regex is correct only in a
>, <Line: - *      small number of cases.  A `.` character in the regex used when matching the scheme or a
>, <Line: - *      subdomain could be matched against a `:` or literal `.` that was likely not intended.   It
>, <Line: - *      is highly recommended to use the string patterns and only fall back to regular expressions
>, <Line: - *      if they as a last resort.
>, <Line: - *    - The regular expression must be an instance of RegExp (i.e. not a string.)  It is
>, <Line: - *      matched against the **entire** *normalized / absolute URL* of the resource being tested
>, <Line: - *      (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags
>, <Line: - *      present on the RegExp (such as multiline, global, ignoreCase) are ignored.
>, <Line: - *    - If you are generating your JavaScript from some other templating engine (not
>, <Line: - *      recommended, e.g. in issue [#4006](https://github.com/angular/angular.js/issues/4006)),
>, <Line: - *      remember to escape your regular expression (and be aware that you might need more than
>, <Line: - *      one level of escaping depending on your templating engine and the way you interpolated
>, <Line: - *      the value.)  Do make use of your platform's escaping mechanism as it might be good
>, <Line: - *      enough before coding your own.  e.g. Ruby has
>, <Line: - *      [Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)
>, <Line: - *      and Python has [re.escape](http://docs.python.org/library/re.html#re.escape).
>, <Line: - *      Javascript lacks a similar built in function for escaping.  Take a look at Google
>, <Line: - *      Closure library's [goog.string.regExpEscape(s)](
>, <Line: - *      http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).
>, <Line: - *
>, <Line: - * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an example.
>, <Line: - *
>, <Line: - * ## Show me an example using SCE.
>, <Line: - *
>, <Line: - * <example module="mySceApp" deps="angular-sanitize.js">
>, <Line: - * <file name="index.html">
>, <Line: - *   <div ng-controller="AppController as myCtrl">
>, <Line: - *     <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
>, <Line: - *     <b>User comments</b><br>
>, <Line: - *     By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when
>, <Line: - *     $sanitize is available.  If $sanitize isn't available, this results in an error instead of an
>, <Line: - *     exploit.
>, <Line: - *     <div class="well">
>, <Line: - *       <div ng-repeat="userComment in myCtrl.userComments">
>, <Line: - *         <b>{{userComment.name}}</b>:
>, <Line: - *         <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
>, <Line: - *         <br>
>, <Line: - *       </div>
>, <Line: - *     </div>
>, <Line: - *   </div>
>, <Line: - * </file>
>, <Line: - *
>, <Line: - * <file name="script.js">
>, <Line: - *   angular.module('mySceApp', ['ngSanitize'])
>, <Line: - *     .controller('AppController', ['$http', '$templateCache', '$sce',
>, <Line: - *       function($http, $templateCache, $sce) {
>, <Line: - * </file>
>, <Line: - *
>, <Line: - * <file name="test_data.json">
>, <Line: - * [
>, <Line: - *   { "name": "Alice",
>, <Line: - *   { "name": "Bob",
>, <Line: - * ]
>, <Line: - * </file>
>, <Line: - *
>, <Line: - * <file name="protractor.js" type="protractor">
>, <Line: - *   describe('SCE doc demo', function() {
>, <Line: - * </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - *
>, <Line: - *
>, <Line: - * ## Can I disable SCE completely?
>, <Line: - *
>, <Line: - * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
>, <Line: - * for little coding overhead.  It will be much harder to take an SCE disabled application and
>, <Line: - * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
>, <Line: - * for cases where you have a lot of existing code that was written before SCE was introduced and
>, <Line: - * you're migrating them a module at a time.
>, <Line: - *
>, <Line: - * That said, here's how you can completely disable SCE:
>, <Line: - *
>, <Line: - * ```
>, <Line: - * angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - */
>, <Line: -/* jshint maxlen: 100 */
>, <Line: -function $SceProvider() {
>, <Line: -  var enabled = true;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $sceProvider#enabled
>, <Line: -   * @kind function
>, <Line: -   *
>, <Line: -   * @param {boolean=} value If provided, then enables/disables SCE.
>, <Line: -   * @return {boolean} true if SCE is enabled, false otherwise.
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Enables/disables SCE and returns the current value.
>, <Line: -   */
>, <Line: -  this.enabled = function(value) {
>, <Line: -    if (arguments.length) {
>, <Line: -      enabled = !!value;
>, <Line: -    }
>, <Line: -    return enabled;
>, <Line: -  };
>, <Line: -  /* Design notes on the default implementation for SCE.
>, <Line: -   *
>, <Line: -   * The API contract for the SCE delegate
>, <Line: -   * -------------------------------------
>, <Line: -   * The SCE delegate object must provide the following 3 methods:
>, <Line: -   *
>, <Line: -   * - trustAs(contextEnum, value)
>, <Line: -   *     This method is used to tell the SCE service that the provided value is OK to use in the
>, <Line: -   *     contexts specified by contextEnum.  It must return an object that will be accepted by
>, <Line: -   *     getTrusted() for a compatible contextEnum and return this value.
>, <Line: -   *
>, <Line: -   * - valueOf(value)
>, <Line: -   *     For values that were not produced by trustAs(), return them as is.  For values that were
>, <Line: -   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
>, <Line: -   *     trustAs is wrapping the given values into some type, this operation unwraps it when given
>, <Line: -   *     such a value.
>, <Line: -   *
>, <Line: -   * - getTrusted(contextEnum, value)
>, <Line: -   *     This function should return the a value that is safe to use in the context specified by
>, <Line: -   *     contextEnum or throw and exception otherwise.
>, <Line: -   *
>, <Line: -   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be
>, <Line: -   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For
>, <Line: -   * instance, an implementation could maintain a registry of all trusted objects by context.  In
>, <Line: -   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would
>, <Line: -   * return the same object passed in if it was found in the registry under a compatible context or
>, <Line: -   * throw an exception otherwise.  An implementation might only wrap values some of the time based
>, <Line: -   * on some criteria.  getTrusted() might return a value and not throw an exception for special
>, <Line: -   * constants or objects even if not wrapped.  All such implementations fulfill this contract.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * A note on the inheritance model for SCE contexts
>, <Line: -   * ------------------------------------------------
>, <Line: -   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
>, <Line: -   * is purely an implementation details.
>, <Line: -   *
>, <Line: -   * The contract is simply this:
>, <Line: -   *
>, <Line: -   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
>, <Line: -   *     will also succeed.
>, <Line: -   *
>, <Line: -   * Inheritance happens to capture this in a natural way.  In some future, we
>, <Line: -   * may not use inheritance anymore.  That is OK because no code outside of
>, <Line: -   * sce.js and sceSpecs.js would need to be aware of this detail.
>, <Line: -   */
>, <Line: -  this.$get = ['$parse', '$sceDelegate', function(
>, <Line: -                $parse,   $sceDelegate) {
>, <Line: -    // Prereq: Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow
>, <Line: -    // the "expression(javascript expression)" syntax which is insecure.
>, <Line: -    if (enabled && msie < 8) {
>, <Line: -      throw $sceMinErr('iequirks',
>, <Line: -        'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' +
>, <Line: -        'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
>, <Line: -        'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
>, <Line: -    }
>, <Line: -    var sce = shallowCopy(SCE_CONTEXTS);
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#isEnabled
>, <Line: -     * @kind function
>, <Line: -     *
>, <Line: -     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
>, <Line: -     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Returns a boolean indicating if SCE is enabled.
>, <Line: -     */
>, <Line: -    sce.isEnabled = function() {
>, <Line: -      return enabled;
>, <Line: -    };
>, <Line: -    sce.trustAs = $sceDelegate.trustAs;
>, <Line: -    sce.getTrusted = $sceDelegate.getTrusted;
>, <Line: -    sce.valueOf = $sceDelegate.valueOf;
>, <Line: -    if (!enabled) {
>, <Line: -      sce.trustAs = sce.getTrusted = function(type, value) { return value; };
>, <Line: -      sce.valueOf = identity;
>, <Line: -    }
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
>, <Line: -     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
>, <Line: -     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
>, <Line: -     *
>, <Line: -     * @param {string} type The kind of SCE context in which this result will be used.
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    sce.parseAs = function sceParseAs(type, expr) {
>, <Line: -      var parsed = $parse(expr);
>, <Line: -      if (parsed.literal && parsed.constant) {
>, <Line: -        return parsed;
>, <Line: -      } else {
>, <Line: -        return $parse(expr, function(value) {
>, <Line: -          return sce.getTrusted(type, value);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#trustAs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,
>, <Line: -     * returns an object that is trusted by angular for use in specified strict contextual
>, <Line: -     * escaping contexts (such as ng-bind-html, ng-include, any src attribute
>, <Line: -     * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)
>, <Line: -     * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual
>, <Line: -     * escaping.
>, <Line: -     *
>, <Line: -     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
>, <Line: -     *   resource_url, html, js and css.
>, <Line: -     * @param {*} value The value that that should be considered trusted/safe.
>, <Line: -     * @returns {*} A value that can be used to stand in for the provided `value` in places
>, <Line: -     * where Angular expects a $sce.trustAs() return value.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#trustAsHtml
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.trustAsHtml(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to trustAs.
>, <Line: -     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
>, <Line: -     *     only accept expressions that are either literal constants or are the
>, <Line: -     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#trustAsUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.trustAsUrl(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to trustAs.
>, <Line: -     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
>, <Line: -     *     only accept expressions that are either literal constants or are the
>, <Line: -     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#trustAsResourceUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.trustAsResourceUrl(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to trustAs.
>, <Line: -     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
>, <Line: -     *     only accept expressions that are either literal constants or are the return
>, <Line: -     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#trustAsJs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.trustAsJs(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to trustAs.
>, <Line: -     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
>, <Line: -     *     only accept expressions that are either literal constants or are the
>, <Line: -     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrusted
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
>, <Line: -     * takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the
>, <Line: -     * originally supplied value if the queried context type is a supertype of the created type.
>, <Line: -     * If this condition isn't satisfied, throws an exception.
>, <Line: -     *
>, <Line: -     * @param {string} type The kind of context in which this value is to be used.
>, <Line: -     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`}
>, <Line: -     *                         call.
>, <Line: -     * @returns {*} The value the was originally provided to
>, <Line: -     *              {@link ng.$sce#trustAs `$sce.trustAs`} if valid in this context.
>, <Line: -     *              Otherwise, throws an exception.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrustedHtml
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.getTrustedHtml(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: -     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrustedCss
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.getTrustedCss(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: -     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrustedUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.getTrustedUrl(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: -     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrustedResourceUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
>, <Line: -     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#getTrustedJs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.getTrustedJs(value)` 
>, <Line: -     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
>, <Line: -     *
>, <Line: -     * @param {*} value The value to pass to `$sce.getTrusted`.
>, <Line: -     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAsHtml
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.parseAsHtml(expression string)` 
>, <Line: -     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}
>, <Line: -     *
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAsCss
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.parseAsCss(value)` 
>, <Line: -     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}
>, <Line: -     *
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAsUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.parseAsUrl(value)` 
>, <Line: -     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAsResourceUrl
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.parseAsResourceUrl(value)` 
>, <Line: -     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}
>, <Line: -     *
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    /**
>, <Line: -     * @ngdoc method
>, <Line: -     * @name $sce#parseAsJs
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shorthand method.  `$sce.parseAsJs(value)` 
>, <Line: -     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}
>, <Line: -     *
>, <Line: -     * @param {string} expression String expression to compile.
>, <Line: -     * @returns {function(context, locals)} a function which represents the compiled expression:
>, <Line: -     *
>, <Line: -     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
>, <Line: -     *      are evaluated against (typically a scope object).
>, <Line: -     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
>, <Line: -     *      `context`.
>, <Line: -     */
>, <Line: -    // Shorthand delegations.
>, <Line: -    var parse = sce.parseAs,
>, <Line: -        getTrusted = sce.getTrusted,
>, <Line: -        trustAs = sce.trustAs;
>, <Line: -    forEach(SCE_CONTEXTS, function(enumValue, name) {
>, <Line: -      var lName = lowercase(name);
>, <Line: -      sce[camelCase("parse_as_" + lName)] = function(expr) {
>, <Line: -        return parse(enumValue, expr);
>, <Line: -      };
>, <Line: -      sce[camelCase("get_trusted_" + lName)] = function(value) {
>, <Line: -        return getTrusted(enumValue, value);
>, <Line: -      };
>, <Line: -      sce[camelCase("trust_as_" + lName)] = function(value) {
>, <Line: -        return trustAs(enumValue, value);
>, <Line: -      };
>, <Line: -    });
>, <Line: -    return sce;
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * !!! This is an undocumented "private" service !!!
>, <Line: - *
>, <Line: - * @name $sniffer
>, <Line: - * @requires $window
>, <Line: - * @requires $document
>, <Line: - *
>, <Line: - * @property {boolean} history Does the browser support html5 history api ?
>, <Line: - * @property {boolean} transitions Does the browser support CSS transition events ?
>, <Line: - * @property {boolean} animations Does the browser support CSS animation events ?
>, <Line: - *
>, <Line: - * @description
>, <Line: - * This is very simple implementation of testing browser's features.
>, <Line: - */
>, <Line: -function $SnifferProvider() {
>, <Line: -  this.$get = ['$window', '$document', function($window, $document) {
>, <Line: -    var eventSupport = {},
>, <Line: -        android =
>, <Line: -          int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
>, <Line: -        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
>, <Line: -        document = $document[0] || {},
>, <Line: -        vendorPrefix,
>, <Line: -        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
>, <Line: -        bodyStyle = document.body && document.body.style,
>, <Line: -        transitions = false,
>, <Line: -        animations = false,
>, <Line: -        match;
>, <Line: -    if (bodyStyle) {
>, <Line: -      for (var prop in bodyStyle) {
>, <Line: -        if (match = vendorRegex.exec(prop)) {
>, <Line: -          vendorPrefix = match[0];
>, <Line: -          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      if (!vendorPrefix) {
>, <Line: -        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
>, <Line: -      }
>, <Line: -      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
>, <Line: -      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
>, <Line: -      if (android && (!transitions ||  !animations)) {
>, <Line: -        transitions = isString(document.body.style.webkitTransition);
>, <Line: -        animations = isString(document.body.style.webkitAnimation);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return {
>, <Line: -      // Android has history.pushState, but it does not update location correctly
>, <Line: -      // so let's not use the history API at all.
>, <Line: -      // http://code.google.com/p/android/issues/detail?id=17471
>, <Line: -      // https://github.com/angular/angular.js/issues/904
>, <Line: -      // older webkit browser (533.9) on Boxee box has exactly the same problem as Android has
>, <Line: -      // so let's not use the history API also
>, <Line: -      // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined
>, <Line: -      // jshint -W018
>, <Line: -      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
>, <Line: -      // jshint +W018
>, <Line: -      hasEvent: function(event) {
>, <Line: -        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
>, <Line: -        // it. In particular the event is not fired when backspace or delete key are pressed or
>, <Line: -        // when cut operation is performed.
>, <Line: -        if (event == 'input' && msie == 9) return false;
>, <Line: -        if (isUndefined(eventSupport[event])) {
>, <Line: -          var divElm = document.createElement('div');
>, <Line: -          eventSupport[event] = 'on' + event in divElm;
>, <Line: -        }
>, <Line: -        return eventSupport[event];
>, <Line: -      },
>, <Line: -      csp: csp(),
>, <Line: -      vendorPrefix: vendorPrefix,
>, <Line: -      transitions: transitions,
>, <Line: -      animations: animations,
>, <Line: -      android: android
>, <Line: -    };
>, <Line: -  }];
>, <Line: -}
>, <Line: -var $compileMinErr = minErr('$compile');
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $templateRequest
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `$templateRequest` service downloads the provided template using `$http` and, upon success,
>, <Line: - * stores the contents inside of `$templateCache`. If the HTTP request fails or the response data
>, <Line: - * of the HTTP request is empty then a `$compile` error will be thrown (the exception can be thwarted
>, <Line: - * by setting the 2nd parameter of the function to true).
>, <Line: - *
>, <Line: - * @param {string} tpl The HTTP request template URL
>, <Line: - * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty
>, <Line: - *
>, <Line: - * @return {Promise} the HTTP Promise for the given.
>, <Line: - *
>, <Line: - * @property {number} totalPendingRequests total amount of pending template requests being downloaded.
>, <Line: - */
>, <Line: -function $TemplateRequestProvider() {
>, <Line: -  this.$get = ['$templateCache', '$http', '$q', function($templateCache, $http, $q) {
>, <Line: -    function handleRequestFn(tpl, ignoreRequestError) {
>, <Line: -      var self = handleRequestFn;
>, <Line: -      self.totalPendingRequests++;
>, <Line: -      var transformResponse = $http.defaults && $http.defaults.transformResponse;
>, <Line: -      if (isArray(transformResponse)) {
>, <Line: -        var original = transformResponse;
>, <Line: -        transformResponse = [];
>, <Line: -        for (var i = 0; i < original.length; ++i) {
>, <Line: -          var transformer = original[i];
>, <Line: -          if (transformer !== defaultHttpResponseTransform) {
>, <Line: -            transformResponse.push(transformer);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      } else if (transformResponse === defaultHttpResponseTransform) {
>, <Line: -        transformResponse = null;
>, <Line: -      }
>, <Line: -      var httpOptions = {
>, <Line: -        cache: $templateCache,
>, <Line: -        transformResponse: transformResponse
>, <Line: -      };
>, <Line: -      return $http.get(tpl, httpOptions)
>, <Line: -        .then(function(response) {
>, <Line: -          var html = response.data;
>, <Line: -          self.totalPendingRequests--;
>, <Line: -          $templateCache.put(tpl, html);
>, <Line: -          return html;
>, <Line: -        }, handleError);
>, <Line: -      function handleError() {
>, <Line: -        self.totalPendingRequests--;
>, <Line: -        if (!ignoreRequestError) {
>, <Line: -          throw $compileMinErr('tpload', 'Failed to load template: {0}', tpl);
>, <Line: -        }
>, <Line: -        return $q.reject();
>, <Line: -      }
>, <Line: -    }
>, <Line: -    handleRequestFn.totalPendingRequests = 0;
>, <Line: -    return handleRequestFn;
>, <Line: -  }];
>, <Line: -}
>, <Line: -function $$TestabilityProvider() {
>, <Line: -  this.$get = ['$rootScope', '$browser', '$location',
>, <Line: -       function($rootScope,   $browser,   $location) {
>, <Line: -    /**
>, <Line: -     * @name $testability
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * The private $$testability service provides a collection of methods for use when debugging
>, <Line: -     * or by automated test and debugging tools.
>, <Line: -     */
>, <Line: -    var testability = {};
>, <Line: -    /**
>, <Line: -     * @name $$testability#findBindings
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Returns an array of elements that are bound (via ng-bind or {{}})
>, <Line: -     * to expressions matching the input.
>, <Line: -     *
>, <Line: -     * @param {Element} element The element root to search from.
>, <Line: -     * @param {string} expression The binding expression to match.
>, <Line: -     * @param {boolean} opt_exactMatch If true, only returns exact matches
>, <Line: -     *     for the expression. Filters and whitespace are ignored.
>, <Line: -     */
>, <Line: -    testability.findBindings = function(element, expression, opt_exactMatch) {
>, <Line: -      var bindings = element.getElementsByClassName('ng-binding');
>, <Line: -      var matches = [];
>, <Line: -      forEach(bindings, function(binding) {
>, <Line: -        var dataBinding = angular.element(binding).data('$binding');
>, <Line: -        if (dataBinding) {
>, <Line: -          forEach(dataBinding, function(bindingName) {
>, <Line: -            if (opt_exactMatch) {
>, <Line: -              var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
>, <Line: -              if (matcher.test(bindingName)) {
>, <Line: -                matches.push(binding);
>, <Line: -              }
>, <Line: -            } else {
>, <Line: -              if (bindingName.indexOf(expression) != -1) {
>, <Line: -                matches.push(binding);
>, <Line: -              }
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -      });
>, <Line: -      return matches;
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @name $$testability#findModels
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Returns an array of elements that are two-way found via ng-model to
>, <Line: -     * expressions matching the input.
>, <Line: -     *
>, <Line: -     * @param {Element} element The element root to search from.
>, <Line: -     * @param {string} expression The model expression to match.
>, <Line: -     * @param {boolean} opt_exactMatch If true, only returns exact matches
>, <Line: -     *     for the expression.
>, <Line: -     */
>, <Line: -    testability.findModels = function(element, expression, opt_exactMatch) {
>, <Line: -      var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
>, <Line: -      for (var p = 0; p < prefixes.length; ++p) {
>, <Line: -        var attributeEquals = opt_exactMatch ? '=' : '*=';
>, <Line: -        var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
>, <Line: -        var elements = element.querySelectorAll(selector);
>, <Line: -        if (elements.length) {
>, <Line: -          return elements;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @name $$testability#getLocation
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut for getting the location in a browser agnostic way. Returns
>, <Line: -     *     the path, search, and hash. (e.g. /path?a=b#hash)
>, <Line: -     */
>, <Line: -    testability.getLocation = function() {
>, <Line: -      return $location.url();
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @name $$testability#setLocation
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Shortcut for navigating to a location without doing a full page reload.
>, <Line: -     *
>, <Line: -     * @param {string} url The location url (path, search and hash,
>, <Line: -     *     e.g. /path?a=b#hash) to go to.
>, <Line: -     */
>, <Line: -    testability.setLocation = function(url) {
>, <Line: -      if (url !== $location.url()) {
>, <Line: -        $location.url(url);
>, <Line: -        $rootScope.$digest();
>, <Line: -      }
>, <Line: -    };
>, <Line: -    /**
>, <Line: -     * @name $$testability#whenStable
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Calls the callback when $timeout and $http requests are completed.
>, <Line: -     *
>, <Line: -     * @param {function} callback
>, <Line: -     */
>, <Line: -    testability.whenStable = function(callback) {
>, <Line: -      $browser.notifyWhenNoOutstandingRequests(callback);
>, <Line: -    };
>, <Line: -    return testability;
>, <Line: -  }];
>, <Line: -}
>, <Line: -function $TimeoutProvider() {
>, <Line: -  this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler',
>, <Line: -       function($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) {
>, <Line: -    var deferreds = {};
>, <Line: -     /**
>, <Line: -      * @ngdoc service
>, <Line: -      * @name $timeout
>, <Line: -      *
>, <Line: -      * @description
>, <Line: -      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
>, <Line: -      * block and delegates any exceptions to
>, <Line: -      * {@link ng.$exceptionHandler $exceptionHandler} service.
>, <Line: -      *
>, <Line: -      * The return value of registering a timeout function is a promise, which will be resolved when
>, <Line: -      * the timeout is reached and the timeout function is executed.
>, <Line: -      *
>, <Line: -      * To cancel a timeout request, call `$timeout.cancel(promise)`.
>, <Line: -      *
>, <Line: -      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
>, <Line: -      * synchronously flush the queue of deferred functions.
>, <Line: -      *
>, <Line: -      * @param {function()} fn A function, whose execution should be delayed.
>, <Line: -      * @param {number=} [delay=0] Delay in milliseconds.
>, <Line: -      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
>, <Line: -      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
>, <Line: -      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
>, <Line: -      *   promise will be resolved with is the return value of the `fn` function.
>, <Line: -      *
>, <Line: -      */
>, <Line: -    function timeout(fn, delay, invokeApply) {
>, <Line: -      var skipApply = (isDefined(invokeApply) && !invokeApply),
>, <Line: -          deferred = (skipApply ? $$q : $q).defer(),
>, <Line: -          promise = deferred.promise,
>, <Line: -          timeoutId;
>, <Line: -      timeoutId = $browser.defer(function() {
>, <Line: -        try {
>, <Line: -          deferred.resolve(fn());
>, <Line: -        } catch (e) {
>, <Line: -          deferred.reject(e);
>, <Line: -          $exceptionHandler(e);
>, <Line: -        }
>, <Line: -        finally {
>, <Line: -          delete deferreds[promise.$$timeoutId];
>, <Line: -        }
>, <Line: -        if (!skipApply) $rootScope.$apply();
>, <Line: -      }, delay);
>, <Line: -      promise.$$timeoutId = timeoutId;
>, <Line: -      deferreds[timeoutId] = deferred;
>, <Line: -      return promise;
>, <Line: -    }
>, <Line: -     /**
>, <Line: -      * @ngdoc method
>, <Line: -      * @name $timeout#cancel
>, <Line: -      *
>, <Line: -      * @description
>, <Line: -      * Cancels a task associated with the `promise`. As a result of this, the promise will be
>, <Line: -      * resolved with a rejection.
>, <Line: -      *
>, <Line: -      * @param {Promise=} promise Promise returned by the `$timeout` function.
>, <Line: -      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
>, <Line: -      *   canceled.
>, <Line: -      */
>, <Line: -    timeout.cancel = function(promise) {
>, <Line: -      if (promise && promise.$$timeoutId in deferreds) {
>, <Line: -        deferreds[promise.$$timeoutId].reject('canceled');
>, <Line: -        delete deferreds[promise.$$timeoutId];
>, <Line: -        return $browser.defer.cancel(promise.$$timeoutId);
>, <Line: -      }
>, <Line: -      return false;
>, <Line: -    };
>, <Line: -    return timeout;
>, <Line: -  }];
>, <Line: -}
>, <Line: -var urlParsingNode = document.createElement("a");
>, <Line: -var originUrl = urlResolve(window.location.href);
>, <Line: -/**
>, <Line: - *
>, <Line: - * Implementation Notes for non-IE browsers
>, <Line: - * ----------------------------------------
>, <Line: - * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
>, <Line: - * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
>, <Line: - * URL will be resolved into an absolute URL in the context of the application document.
>, <Line: - * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
>, <Line: - * properties are all populated to reflect the normalized URL.  This approach has wide
>, <Line: - * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
>, <Line: - * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
>, <Line: - *
>, <Line: - * Implementation Notes for IE
>, <Line: - * ---------------------------
>, <Line: - * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
>, <Line: - * browsers.  However, the parsed components will not be set if the URL assigned did not specify
>, <Line: - * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
>, <Line: - * work around that by performing the parsing in a 2nd step by taking a previously normalized
>, <Line: - * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the
>, <Line: - * properties such as protocol, hostname, port, etc.
>, <Line: - *
>, <Line: - * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
>, <Line: - * uses the inner HTML approach to assign the URL as part of an HTML snippet -
>, <Line: - * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
>, <Line: - * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
>, <Line: - * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
>, <Line: - * method and IE < 8 is unsupported.
>, <Line: - *
>, <Line: - * References:
>, <Line: - *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
>, <Line: - *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
>, <Line: - *   http://url.spec.whatwg.org/#urlutils
>, <Line: - *   https://github.com/angular/angular.js/pull/2902
>, <Line: - *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
>, <Line: - *
>, <Line: - * @kind function
>, <Line: - * @param {string} url The URL to be parsed.
>, <Line: - * @description Normalizes and parses a URL.
>, <Line: - * @returns {object} Returns the normalized URL as a dictionary.
>, <Line: - *
>, <Line: - *   | member name   | Description    |
>, <Line: - *   |---------------|----------------|
>, <Line: - *   | href          | A normalized version of the provided URL if it was not an absolute URL |
>, <Line: - *   | protocol      | The protocol including the trailing colon                              |
>, <Line: - *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
>, <Line: - *   | search        | The search params, minus the question mark                             |
>, <Line: - *   | hash          | The hash string, minus the hash symbol
>, <Line: - *   | hostname      | The hostname
>, <Line: - *   | port          | The port, without ":"
>, <Line: - *   | pathname      | The pathname, beginning with "/"
>, <Line: - *
>, <Line: - */
>, <Line: -function urlResolve(url) {
>, <Line: -  var href = url;
>, <Line: -  if (msie) {
>, <Line: -    // Normalize before parse.  Refer Implementation Notes on why this is
>, <Line: -    // done in two steps on IE.
>, <Line: -    urlParsingNode.setAttribute("href", href);
>, <Line: -    href = urlParsingNode.href;
>, <Line: -  }
>, <Line: -  urlParsingNode.setAttribute('href', href);
>, <Line: -  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
>, <Line: -  return {
>, <Line: -    href: urlParsingNode.href,
>, <Line: -    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
>, <Line: -    host: urlParsingNode.host,
>, <Line: -    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
>, <Line: -    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
>, <Line: -    hostname: urlParsingNode.hostname,
>, <Line: -    port: urlParsingNode.port,
>, <Line: -    pathname: (urlParsingNode.pathname.charAt(0) === '/')
>, <Line: -      ? urlParsingNode.pathname
>, <Line: -      : '/' + urlParsingNode.pathname
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * Parse a request URL and determine whether this is a same-origin request as the application document.
>, <Line: - *
>, <Line: - * @param {string|object} requestUrl The url of the request as a string that will be resolved
>, <Line: - * or a parsed URL object.
>, <Line: - * @returns {boolean} Whether the request is for the same origin as the application document.
>, <Line: - */
>, <Line: -function urlIsSameOrigin(requestUrl) {
>, <Line: -  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
>, <Line: -  return (parsed.protocol === originUrl.protocol &&
>, <Line: -          parsed.host === originUrl.host);
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $window
>, <Line: - *
>, <Line: - * @description
>, <Line: - * A reference to the browser's `window` object. While `window`
>, <Line: - * is globally available in JavaScript, it causes testability problems, because
>, <Line: - * it is a global variable. In angular we always refer to it through the
>, <Line: - * `$window` service, so it may be overridden, removed or mocked for testing.
>, <Line: - *
>, <Line: - * Expressions, like the one defined for the `ngClick` directive in the example
>, <Line: - * below, are evaluated with respect to the current scope.  Therefore, there is
>, <Line: - * no risk of inadvertently coding in a dependency on a global value in such an
>, <Line: - * expression.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="windowExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('windowExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', '$window', function($scope, $window) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <input type="text" ng-model="greeting" />
>, <Line: -         <button ng-click="doGreeting(greeting)">ALERT</button>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -      it('should display the greeting in the input box', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -function $WindowProvider() {
>, <Line: -  this.$get = valueFn(window);
>, <Line: -}
>, <Line: -/* global currencyFilter: true,
>, <Line: - dateFilter: true,
>, <Line: - filterFilter: true,
>, <Line: - jsonFilter: true,
>, <Line: - limitToFilter: true,
>, <Line: - lowercaseFilter: true,
>, <Line: - numberFilter: true,
>, <Line: - orderByFilter: true,
>, <Line: - uppercaseFilter: true,
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc provider
>, <Line: - * @name $filterProvider
>, <Line: - * @description
>, <Line: - *
>, <Line: - * Filters are just functions which transform input to an output. However filters need to be
>, <Line: - * Dependency Injected. To achieve this a filter definition consists of a factory function which is
>, <Line: - * annotated with dependencies and is responsible for creating a filter function.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   // Filter registration
>, <Line: - *   function MyModule($provide, $filterProvider) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The filter function is registered with the `$injector` under the filter name suffix with
>, <Line: - * `Filter`.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - *   it('should be the same instance', inject(
>, <Line: - *     function($filterProvider) {
>, <Line: - *     function($filter, reverseFilter) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - * For more information about how angular filters work, and how to create your own filters, see
>, <Line: - * {@link guide/filter Filters} in the Angular Developer Guide.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc service
>, <Line: - * @name $filter
>, <Line: - * @kind function
>, <Line: - * @description
>, <Line: - * Filters are used for formatting data displayed to the user.
>, <Line: - *
>, <Line: - * The general syntax in templates is as follows:
>, <Line: - *
>, <Line: - *         {{ expression [| filter_name[:parameter_value] ... ] }}
>, <Line: - *
>, <Line: - * @param {String} name Name of the filter function to retrieve
>, <Line: - * @return {Function} the filter function
>, <Line: - * @example
>, <Line: -   <example name="$filter" module="filterExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="MainCtrl">
>, <Line: -        <h3>{{ originalText }}</h3>
>, <Line: -        <h3>{{ filteredText }}</h3>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="script.js">
>, <Line: -      angular.module('filterExample', [])
>, <Line: -      .controller('MainCtrl', function($scope, $filter) {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: -  */
>, <Line: -$FilterProvider.$inject = ['$provide'];
>, <Line: -function $FilterProvider($provide) {
>, <Line: -  var suffix = 'Filter';
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name $filterProvider#register
>, <Line: -   * @param {string|Object} name Name of the filter function, or an object map of filters where
>, <Line: -   *    the keys are the filter names and the values are the filter factories.
>, <Line: -   * @returns {Object} Registered filter instance, or if a map of filters was provided then a map
>, <Line: -   *    of the registered filter instances.
>, <Line: -   */
>, <Line: -  function register(name, factory) {
>, <Line: -    if (isObject(name)) {
>, <Line: -      var filters = {};
>, <Line: -      forEach(name, function(filter, key) {
>, <Line: -        filters[key] = register(key, filter);
>, <Line: -      });
>, <Line: -      return filters;
>, <Line: -    } else {
>, <Line: -      return $provide.factory(name + suffix, factory);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  this.register = register;
>, <Line: -  this.$get = ['$injector', function($injector) {
>, <Line: -    return function(name) {
>, <Line: -      return $injector.get(name + suffix);
>, <Line: -    };
>, <Line: -  }];
>, <Line: -  ////////////////////////////////////////
>, <Line: -  /* global
>, <Line: -    currencyFilter: false,
>, <Line: -    dateFilter: false,
>, <Line: -    filterFilter: false,
>, <Line: -    jsonFilter: false,
>, <Line: -    limitToFilter: false,
>, <Line: -    lowercaseFilter: false,
>, <Line: -    numberFilter: false,
>, <Line: -    orderByFilter: false,
>, <Line: -    uppercaseFilter: false,
>, <Line: -  */
>, <Line: -  register('currency', currencyFilter);
>, <Line: -  register('date', dateFilter);
>, <Line: -  register('filter', filterFilter);
>, <Line: -  register('json', jsonFilter);
>, <Line: -  register('limitTo', limitToFilter);
>, <Line: -  register('lowercase', lowercaseFilter);
>, <Line: -  register('number', numberFilter);
>, <Line: -  register('orderBy', orderByFilter);
>, <Line: -  register('uppercase', uppercaseFilter);
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name filter
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Selects a subset of items from `array` and returns it as a new array.
>, <Line: - *
>, <Line: - * @param {Array} array The source array.
>, <Line: - * @param {string|Object|function()} expression The predicate to be used for selecting items from
>, <Line: - *   `array`.
>, <Line: - *
>, <Line: - *   Can be one of:
>, <Line: - *
>, <Line: - *   - `string`: The string is evaluated as an expression and the resulting value is used for substring match against
>, <Line: - *     the contents of the `array`. All strings or objects with string properties in `array` that contain this string
>, <Line: - *     will be returned. The predicate can be negated by prefixing the string with `!`.
>, <Line: - *
>, <Line: - *   - `Object`: A pattern object can be used to filter specific properties on objects contained
>, <Line: - *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
>, <Line: - *     which have property `name` containing "M" and property `phone` containing "1". A special
>, <Line: - *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
>, <Line: - *     property of the object. That's equivalent to the simple substring match with a `string`
>, <Line: - *     as described above. The predicate can be negated by prefixing the string with `!`.
>, <Line: - *     For Example `{name: "!M"}` predicate will return an array of items which have property `name`
>, <Line: - *     not containing "M".
>, <Line: - *
>, <Line: - *   - `function(value, index)`: A predicate function can be used to write arbitrary filters. The
>, <Line: - *     function is called for each element of `array`. The final result is an array of those
>, <Line: - *     elements that the predicate returned true for.
>, <Line: - *
>, <Line: - * @param {function(actual, expected)|true|undefined} comparator Comparator which is used in
>, <Line: - *     determining if the expected value (from the filter expression) and actual value (from
>, <Line: - *     the object in the array) should be considered a match.
>, <Line: - *
>, <Line: - *   Can be one of:
>, <Line: - *
>, <Line: - *   - `function(actual, expected)`:
>, <Line: - *     The function will be given the object value and the predicate value to compare and
>, <Line: - *     should return true if the item should be included in filtered result.
>, <Line: - *
>, <Line: - *   - `true`: A shorthand for `function(actual, expected) { return angular.equals(expected, actual)}`.
>, <Line: - *     this is essentially strict comparison of expected and actual.
>, <Line: - *
>, <Line: - *   - `false|undefined`: A short hand for a function which will look for a substring match in case
>, <Line: - *     insensitive way.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-init="friends = [{name:'John', phone:'555-1276'},
>, <Line: -                                {name:'Mary', phone:'800-BIG-MARY'},
>, <Line: -                                {name:'Mike', phone:'555-4321'},
>, <Line: -                                {name:'Adam', phone:'555-5678'},
>, <Line: -                                {name:'Julie', phone:'555-8765'},
>, <Line: -                                {name:'Juliette', phone:'555-5678'}]"></div>
>, <Line: -       Search: <input ng-model="searchText">
>, <Line: -       <table id="searchTextResults">
>, <Line: -         <tr><th>Name</th><th>Phone</th></tr>
>, <Line: -         <tr ng-repeat="friend in friends | filter:searchText">
>, <Line: -           <td>{{friend.name}}</td>
>, <Line: -           <td>{{friend.phone}}</td>
>, <Line: -         </tr>
>, <Line: -       </table>
>, <Line: -       <hr>
>, <Line: -       Any: <input ng-model="search.$"> <br>
>, <Line: -       Name only <input ng-model="search.name"><br>
>, <Line: -       Phone only <input ng-model="search.phone"><br>
>, <Line: -       Equality <input type="checkbox" ng-model="strict"><br>
>, <Line: -       <table id="searchObjResults">
>, <Line: -         <tr><th>Name</th><th>Phone</th></tr>
>, <Line: -         <tr ng-repeat="friendObj in friends | filter:search:strict">
>, <Line: -           <td>{{friendObj.name}}</td>
>, <Line: -           <td>{{friendObj.phone}}</td>
>, <Line: -         </tr>
>, <Line: -       </table>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       var expectFriendNames = function(expectedNames, key) {
>, <Line: -       it('should search across all fields when filtering with a string', function() {
>, <Line: -         searchText.sendKeys('76');
>, <Line: -         expectFriendNames(['John', 'Julie'], 'friend');
>, <Line: -       });
>, <Line: -       it('should search in specific fields when filtering with a predicate object', function() {
>, <Line: -         var searchAny = element(by.model('search.$'));
>, <Line: -         searchAny.clear();
>, <Line: -         searchAny.sendKeys('i');
>, <Line: -         expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], 'friendObj');
>, <Line: -       });
>, <Line: -       it('should use a equal comparison when comparator is true', function() {
>, <Line: -         var searchName = element(by.model('search.name'));
>, <Line: -         var strict = element(by.model('strict'));
>, <Line: -         searchName.clear();
>, <Line: -         searchName.sendKeys('Julie');
>, <Line: -         strict.click();
>, <Line: -         expectFriendNames(['Julie'], 'friendObj');
>, <Line: -       });
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -function filterFilter() {
>, <Line: -  return function(array, expression, comparator) {
>, <Line: -    if (!isArray(array)) return array;
>, <Line: -    var comparatorType = typeof(comparator),
>, <Line: -        predicates = [];
>, <Line: -    predicates.check = function(value, index) {
>, <Line: -      for (var j = 0; j < predicates.length; j++) {
>, <Line: -        if (!predicates[j](value, index)) {
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return true;
>, <Line: -    };
>, <Line: -    if (comparatorType !== 'function') {
>, <Line: -      if (comparatorType === 'boolean' && comparator) {
>, <Line: -        comparator = function(obj, text) {
>, <Line: -          return angular.equals(obj, text);
>, <Line: -        };
>, <Line: -      } else {
>, <Line: -        comparator = function(obj, text) {
>, <Line: -          if (obj && text && typeof obj === 'object' && typeof text === 'object') {
>, <Line: -            for (var objKey in obj) {
>, <Line: -              if (objKey.charAt(0) !== '$' && hasOwnProperty.call(obj, objKey) &&
>, <Line: -                  comparator(obj[objKey], text[objKey])) {
>, <Line: -                return true;
>, <Line: -              }
>, <Line: -            }
>, <Line: -            return false;
>, <Line: -          }
>, <Line: -          text = ('' + text).toLowerCase();
>, <Line: -          return ('' + obj).toLowerCase().indexOf(text) > -1;
>, <Line: -        };
>, <Line: -      }
>, <Line: -    }
>, <Line: -    var search = function(obj, text) {
>, <Line: -      if (typeof text === 'string' && text.charAt(0) === '!') {
>, <Line: -        return !search(obj, text.substr(1));
>, <Line: -      }
>, <Line: -      switch (typeof obj) {
>, <Line: -        case 'boolean':
>, <Line: -        case 'number':
>, <Line: -        case 'string':
>, <Line: -          return comparator(obj, text);
>, <Line: -        case 'object':
>, <Line: -          switch (typeof text) {
>, <Line: -            case 'object':
>, <Line: -              return comparator(obj, text);
>, <Line: -            default:
>, <Line: -              for (var objKey in obj) {
>, <Line: -                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
>, <Line: -                  return true;
>, <Line: -                }
>, <Line: -              }
>, <Line: -              break;
>, <Line: -          }
>, <Line: -          return false;
>, <Line: -        case 'array':
>, <Line: -          for (var i = 0; i < obj.length; i++) {
>, <Line: -            if (search(obj[i], text)) {
>, <Line: -              return true;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          return false;
>, <Line: -        default:
>, <Line: -          return false;
>, <Line: -      }
>, <Line: -    };
>, <Line: -    switch (typeof expression) {
>, <Line: -      case 'boolean':
>, <Line: -      case 'number':
>, <Line: -      case 'string':
>, <Line: -        // Set up expression object and fall through
>, <Line: -        expression = {$:expression};
>, <Line: -        // jshint -W086
>, <Line: -      case 'object':
>, <Line: -        // jshint +W086
>, <Line: -        for (var key in expression) {
>, <Line: -          (function(path) {
>, <Line: -            if (typeof expression[path] === 'undefined') return;
>, <Line: -            predicates.push(function(value) {
>, <Line: -              return search(path == '$' ? value : (value && value[path]), expression[path]);
>, <Line: -            });
>, <Line: -          })(key);
>, <Line: -        }
>, <Line: -        break;
>, <Line: -      case 'function':
>, <Line: -        predicates.push(expression);
>, <Line: -        break;
>, <Line: -      default:
>, <Line: -        return array;
>, <Line: -    }
>, <Line: -    var filtered = [];
>, <Line: -    for (var j = 0; j < array.length; j++) {
>, <Line: -      var value = array[j];
>, <Line: -      if (predicates.check(value, j)) {
>, <Line: -        filtered.push(value);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return filtered;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name currency
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
>, <Line: - * symbol for current locale is used.
>, <Line: - *
>, <Line: - * @param {number} amount Input to filter.
>, <Line: - * @param {string=} symbol Currency symbol or identifier to be displayed.
>, <Line: - * @param {number=} fractionSize Number of decimal places to round the amount to, defaults to default max fraction size for current locale
>, <Line: - * @returns {string} Formatted number.
>, <Line: - *
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="currencyExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('currencyExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <input type="number" ng-model="amount"> <br>
>, <Line: -         default currency symbol ($): <span id="currency-default">{{amount | currency}}</span><br>
>, <Line: -         custom currency identifier (USD$): <span id="currency-custom">{{amount | currency:"USD$"}}</span>
>, <Line: -         no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should init with 1234.56', function() {
>, <Line: -       it('should update', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -currencyFilter.$inject = ['$locale'];
>, <Line: -function currencyFilter($locale) {
>, <Line: -  var formats = $locale.NUMBER_FORMATS;
>, <Line: -  return function(amount, currencySymbol, fractionSize) {
>, <Line: -    if (isUndefined(currencySymbol)) {
>, <Line: -      currencySymbol = formats.CURRENCY_SYM;
>, <Line: -    }
>, <Line: -    if (isUndefined(fractionSize)) {
>, <Line: -      fractionSize = formats.PATTERNS[1].maxFrac;
>, <Line: -    }
>, <Line: -    // if null or undefined pass it through
>, <Line: -    return (amount == null)
>, <Line: -        ? amount
>, <Line: -        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
>, <Line: -            replace(/\u00A4/g, currencySymbol);
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name number
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Formats a number as text.
>, <Line: - *
>, <Line: - * If the input is not a number an empty string is returned.
>, <Line: - *
>, <Line: - * @param {number|string} number Number to format.
>, <Line: - * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
>, <Line: - * If this is not provided then the fraction size is computed from the current locale's number
>, <Line: - * formatting pattern. In the case of the default locale, it will be 3.
>, <Line: - * @returns {string} Number rounded to decimalPlaces and places a , after each third digit.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="numberFilterExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('numberFilterExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         Enter number: <input ng-model='val'><br>
>, <Line: -         Default formatting: <span id='number-default'>{{val | number}}</span><br>
>, <Line: -         No fractions: <span>{{val | number:0}}</span><br>
>, <Line: -         Negative number: <span>{{-val | number:4}}</span>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should format numbers', function() {
>, <Line: -       it('should update', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -numberFilter.$inject = ['$locale'];
>, <Line: -function numberFilter($locale) {
>, <Line: -  var formats = $locale.NUMBER_FORMATS;
>, <Line: -  return function(number, fractionSize) {
>, <Line: -    // if null or undefined pass it through
>, <Line: -    return (number == null)
>, <Line: -        ? number
>, <Line: -        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
>, <Line: -                       fractionSize);
>, <Line: -  };
>, <Line: -}
>, <Line: -var DECIMAL_SEP = '.';
>, <Line: -function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
>, <Line: -  if (!isFinite(number) || isObject(number)) return '';
>, <Line: -  var isNegative = number < 0;
>, <Line: -  number = Math.abs(number);
>, <Line: -  var numStr = number + '',
>, <Line: -      formatedText = '',
>, <Line: -      parts = [];
>, <Line: -  var hasExponent = false;
>, <Line: -  if (numStr.indexOf('e') !== -1) {
>, <Line: -    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
>, <Line: -    if (match && match[2] == '-' && match[3] > fractionSize + 1) {
>, <Line: -      numStr = '0';
>, <Line: -      number = 0;
>, <Line: -    } else {
>, <Line: -      formatedText = numStr;
>, <Line: -      hasExponent = true;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  if (!hasExponent) {
>, <Line: -    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
>, <Line: -    // determine fractionSize if it is not specified
>, <Line: -    if (isUndefined(fractionSize)) {
>, <Line: -      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
>, <Line: -    }
>, <Line: -    // safely round numbers in JS without hitting imprecisions of floating-point arithmetics
>, <Line: -    // inspired by:
>, <Line: -    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
>, <Line: -    number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
>, <Line: -    if (number === 0) {
>, <Line: -      isNegative = false;
>, <Line: -    }
>, <Line: -    var fraction = ('' + number).split(DECIMAL_SEP);
>, <Line: -    var whole = fraction[0];
>, <Line: -    fraction = fraction[1] || '';
>, <Line: -    var i, pos = 0,
>, <Line: -        lgroup = pattern.lgSize,
>, <Line: -        group = pattern.gSize;
>, <Line: -    if (whole.length >= (lgroup + group)) {
>, <Line: -      pos = whole.length - lgroup;
>, <Line: -      for (i = 0; i < pos; i++) {
>, <Line: -        if ((pos - i) % group === 0 && i !== 0) {
>, <Line: -          formatedText += groupSep;
>, <Line: -        }
>, <Line: -        formatedText += whole.charAt(i);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    for (i = pos; i < whole.length; i++) {
>, <Line: -      if ((whole.length - i) % lgroup === 0 && i !== 0) {
>, <Line: -        formatedText += groupSep;
>, <Line: -      }
>, <Line: -      formatedText += whole.charAt(i);
>, <Line: -    }
>, <Line: -    // format fraction part.
>, <Line: -    while (fraction.length < fractionSize) {
>, <Line: -      fraction += '0';
>, <Line: -    }
>, <Line: -    if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
>, <Line: -  } else {
>, <Line: -    if (fractionSize > 0 && number > -1 && number < 1) {
>, <Line: -      formatedText = number.toFixed(fractionSize);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  parts.push(isNegative ? pattern.negPre : pattern.posPre,
>, <Line: -             formatedText,
>, <Line: -             isNegative ? pattern.negSuf : pattern.posSuf);
>, <Line: -  return parts.join('');
>, <Line: -}
>, <Line: -function padNumber(num, digits, trim) {
>, <Line: -  var neg = '';
>, <Line: -  if (num < 0) {
>, <Line: -    neg =  '-';
>, <Line: -    num = -num;
>, <Line: -  }
>, <Line: -  num = '' + num;
>, <Line: -  while (num.length < digits) num = '0' + num;
>, <Line: -  if (trim)
>, <Line: -    num = num.substr(num.length - digits);
>, <Line: -  return neg + num;
>, <Line: -}
>, <Line: -function dateGetter(name, size, offset, trim) {
>, <Line: -  offset = offset || 0;
>, <Line: -  return function(date) {
>, <Line: -    var value = date['get' + name]();
>, <Line: -    if (offset > 0 || value > -offset)
>, <Line: -      value += offset;
>, <Line: -    if (value === 0 && offset == -12) value = 12;
>, <Line: -    return padNumber(value, size, trim);
>, <Line: -  };
>, <Line: -}
>, <Line: -function dateStrGetter(name, shortForm) {
>, <Line: -  return function(date, formats) {
>, <Line: -    var value = date['get' + name]();
>, <Line: -    var get = uppercase(shortForm ? ('SHORT' + name) : name);
>, <Line: -    return formats[get][value];
>, <Line: -  };
>, <Line: -}
>, <Line: -function timeZoneGetter(date) {
>, <Line: -  var zone = -1 * date.getTimezoneOffset();
>, <Line: -  var paddedZone = (zone >= 0) ? "+" : "";
>, <Line: -  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
>, <Line: -                padNumber(Math.abs(zone % 60), 2);
>, <Line: -  return paddedZone;
>, <Line: -}
>, <Line: -function getFirstThursdayOfYear(year) {
>, <Line: -    // 0 = index of January
>, <Line: -    var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
>, <Line: -    // 4 = index of Thursday (+1 to account for 1st = 5)
>, <Line: -    // 11 = index of *next* Thursday (+1 account for 1st = 12)
>, <Line: -    return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
>, <Line: -}
>, <Line: -function getThursdayThisWeek(datetime) {
>, <Line: -    return new Date(datetime.getFullYear(), datetime.getMonth(),
>, <Line: -      // 4 = index of Thursday
>, <Line: -      datetime.getDate() + (4 - datetime.getDay()));
>, <Line: -}
>, <Line: -function weekGetter(size) {
>, <Line: -   return function(date) {
>, <Line: -      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
>, <Line: -         thisThurs = getThursdayThisWeek(date);
>, <Line: -      var diff = +thisThurs - +firstThurs,
>, <Line: -         result = 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per week
>, <Line: -      return padNumber(result, size);
>, <Line: -   };
>, <Line: -}
>, <Line: -function ampmGetter(date, formats) {
>, <Line: -  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
>, <Line: -}
>, <Line: -var DATE_FORMATS = {
>, <Line: -  yyyy: dateGetter('FullYear', 4),
>, <Line: -    yy: dateGetter('FullYear', 2, 0, true),
>, <Line: -     y: dateGetter('FullYear', 1),
>, <Line: -  MMMM: dateStrGetter('Month'),
>, <Line: -   MMM: dateStrGetter('Month', true),
>, <Line: -    MM: dateGetter('Month', 2, 1),
>, <Line: -     M: dateGetter('Month', 1, 1),
>, <Line: -    dd: dateGetter('Date', 2),
>, <Line: -     d: dateGetter('Date', 1),
>, <Line: -    HH: dateGetter('Hours', 2),
>, <Line: -     H: dateGetter('Hours', 1),
>, <Line: -    hh: dateGetter('Hours', 2, -12),
>, <Line: -     h: dateGetter('Hours', 1, -12),
>, <Line: -    mm: dateGetter('Minutes', 2),
>, <Line: -     m: dateGetter('Minutes', 1),
>, <Line: -    ss: dateGetter('Seconds', 2),
>, <Line: -     s: dateGetter('Seconds', 1),
>, <Line: -     // while ISO 8601 requires fractions to be prefixed with `.` or `,`
>, <Line: -     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
>, <Line: -   sss: dateGetter('Milliseconds', 3),
>, <Line: -  EEEE: dateStrGetter('Day'),
>, <Line: -   EEE: dateStrGetter('Day', true),
>, <Line: -     a: ampmGetter,
>, <Line: -     Z: timeZoneGetter,
>, <Line: -    ww: weekGetter(2),
>, <Line: -     w: weekGetter(1)
>, <Line: -};
>, <Line: -var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/,
>, <Line: -    NUMBER_STRING = /^\-?\d+$/;
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name date
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *   Formats `date` to a string based on the requested `format`.
>, <Line: - *
>, <Line: - *   `format` string can be composed of the following elements:
>, <Line: - *
>, <Line: - *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
>, <Line: - *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
>, <Line: - *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
>, <Line: - *   * `'MMMM'`: Month in year (January-December)
>, <Line: - *   * `'MMM'`: Month in year (Jan-Dec)
>, <Line: - *   * `'MM'`: Month in year, padded (01-12)
>, <Line: - *   * `'M'`: Month in year (1-12)
>, <Line: - *   * `'dd'`: Day in month, padded (01-31)
>, <Line: - *   * `'d'`: Day in month (1-31)
>, <Line: - *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
>, <Line: - *   * `'EEE'`: Day in Week, (Sun-Sat)
>, <Line: - *   * `'HH'`: Hour in day, padded (00-23)
>, <Line: - *   * `'H'`: Hour in day (0-23)
>, <Line: - *   * `'hh'`: Hour in AM/PM, padded (01-12)
>, <Line: - *   * `'h'`: Hour in AM/PM, (1-12)
>, <Line: - *   * `'mm'`: Minute in hour, padded (00-59)
>, <Line: - *   * `'m'`: Minute in hour (0-59)
>, <Line: - *   * `'ss'`: Second in minute, padded (00-59)
>, <Line: - *   * `'s'`: Second in minute (0-59)
>, <Line: - *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
>, <Line: - *   * `'a'`: AM/PM marker
>, <Line: - *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
>, <Line: - *   * `'ww'`: ISO-8601 week of year (00-53)
>, <Line: - *   * `'w'`: ISO-8601 week of year (0-53)
>, <Line: - *
>, <Line: - *   `format` string can also be one of the following predefined
>, <Line: - *   {@link guide/i18n localizable formats}:
>, <Line: - *
>, <Line: - *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
>, <Line: - *     (e.g. Sep 3, 2010 12:05:08 PM)
>, <Line: - *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 PM)
>, <Line: - *   * `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` for en_US  locale
>, <Line: - *     (e.g. Friday, September 3, 2010)
>, <Line: - *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
>, <Line: - *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
>, <Line: - *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
>, <Line: - *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 PM)
>, <Line: - *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 PM)
>, <Line: - *
>, <Line: - *   `format` string can contain literal values. These need to be escaped by surrounding with single quotes (e.g.
>, <Line: - *   `"h 'in the morning'"`). In order to output a single quote, escape it - i.e., two single quotes in a sequence
>, <Line: - *   (e.g. `"h 'o''clock'"`).
>, <Line: - *
>, <Line: - * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
>, <Line: - *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.sssZ and its
>, <Line: - *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
>, <Line: - *    specified in the string input, the time is considered to be in the local timezone.
>, <Line: - * @param {string=} format Formatting rules (see Description). If not specified,
>, <Line: - *    `mediumDate` is used.
>, <Line: - * @param {string=} timezone Timezone to be used for formatting. Right now, only `'UTC'` is supported.
>, <Line: - *    If not specified, the timezone of the browser will be used.
>, <Line: - * @returns {string} Formatted string or the input if input is not recognized as date/millis.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
>, <Line: -           <span>{{1288323623006 | date:'medium'}}</span><br>
>, <Line: -       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
>, <Line: -          <span>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span><br>
>, <Line: -       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
>, <Line: -          <span>{{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}</span><br>
>, <Line: -       <span ng-non-bindable>{{1288323623006 | date:"MM/dd/yyyy 'at' h:mma"}}</span>:
>, <Line: -          <span>{{'1288323623006' | date:"MM/dd/yyyy 'at' h:mma"}}</span><br>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should format date', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -dateFilter.$inject = ['$locale'];
>, <Line: -function dateFilter($locale) {
>, <Line: -  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
>, <Line: -                     // 1        2       3         4          5          6          7          8  9     10      11
>, <Line: -  function jsonStringToDate(string) {
>, <Line: -    var match;
>, <Line: -    if (match = string.match(R_ISO8601_STR)) {
>, <Line: -      var date = new Date(0),
>, <Line: -          tzHour = 0,
>, <Line: -          tzMin  = 0,
>, <Line: -          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
>, <Line: -          timeSetter = match[8] ? date.setUTCHours : date.setHours;
>, <Line: -      if (match[9]) {
>, <Line: -        tzHour = int(match[9] + match[10]);
>, <Line: -        tzMin = int(match[9] + match[11]);
>, <Line: -      }
>, <Line: -      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
>, <Line: -      var h = int(match[4] || 0) - tzHour;
>, <Line: -      var m = int(match[5] || 0) - tzMin;
>, <Line: -      var s = int(match[6] || 0);
>, <Line: -      var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
>, <Line: -      timeSetter.call(date, h, m, s, ms);
>, <Line: -      return date;
>, <Line: -    }
>, <Line: -    return string;
>, <Line: -  }
>, <Line: -  return function(date, format, timezone) {
>, <Line: -    var text = '',
>, <Line: -        parts = [],
>, <Line: -        fn, match;
>, <Line: -    format = format || 'mediumDate';
>, <Line: -    format = $locale.DATETIME_FORMATS[format] || format;
>, <Line: -    if (isString(date)) {
>, <Line: -      date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
>, <Line: -    }
>, <Line: -    if (isNumber(date)) {
>, <Line: -      date = new Date(date);
>, <Line: -    }
>, <Line: -    if (!isDate(date)) {
>, <Line: -      return date;
>, <Line: -    }
>, <Line: -    while (format) {
>, <Line: -      match = DATE_FORMATS_SPLIT.exec(format);
>, <Line: -      if (match) {
>, <Line: -        parts = concat(parts, match, 1);
>, <Line: -        format = parts.pop();
>, <Line: -      } else {
>, <Line: -        parts.push(format);
>, <Line: -        format = null;
>, <Line: -      }
>, <Line: -    }
>, <Line: -    if (timezone && timezone === 'UTC') {
>, <Line: -      date = new Date(date.getTime());
>, <Line: -      date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
>, <Line: -    }
>, <Line: -    forEach(parts, function(value) {
>, <Line: -      fn = DATE_FORMATS[value];
>, <Line: -      text += fn ? fn(date, $locale.DATETIME_FORMATS)
>, <Line: -                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
>, <Line: -    });
>, <Line: -    return text;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name json
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - *   Allows you to convert a JavaScript object into JSON string.
>, <Line: - *
>, <Line: - *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
>, <Line: - *   the binding is automatically converted to JSON.
>, <Line: - *
>, <Line: - * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
>, <Line: - * @returns {string} JSON string.
>, <Line: - *
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -       <pre>{{ {'name':'value'} | json }}</pre>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should jsonify filtered objects', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - *
>, <Line: - */
>, <Line: -function jsonFilter() {
>, <Line: -  return function(object) {
>, <Line: -    return toJson(object, true);
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name lowercase
>, <Line: - * @kind function
>, <Line: - * @description
>, <Line: - * Converts string to lowercase.
>, <Line: - * @see angular.lowercase
>, <Line: - */
>, <Line: -var lowercaseFilter = valueFn(lowercase);
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name uppercase
>, <Line: - * @kind function
>, <Line: - * @description
>, <Line: - * Converts string to uppercase.
>, <Line: - * @see angular.uppercase
>, <Line: - */
>, <Line: -var uppercaseFilter = valueFn(uppercase);
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name limitTo
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Creates a new array or string containing only a specified number of elements. The elements
>, <Line: - * are taken from either the beginning or the end of the source array, string or number, as specified by
>, <Line: - * the value and sign (positive or negative) of `limit`. If a number is used as input, it is
>, <Line: - * converted to a string.
>, <Line: - *
>, <Line: - * @param {Array|string|number} input Source array, string or number to be limited.
>, <Line: - * @param {string|number} limit The length of the returned array or string. If the `limit` number
>, <Line: - *     is positive, `limit` number of items from the beginning of the source array/string are copied.
>, <Line: - *     If the number is negative, `limit` number  of items from the end of the source array/string
>, <Line: - *     are copied. The `limit` will be trimmed if it exceeds `array.length`
>, <Line: - * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
>, <Line: - *     had less than `limit` elements.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="limitToExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('limitToExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         Limit {{numbers}} to: <input type="number" step="1" ng-model="numLimit">
>, <Line: -         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
>, <Line: -         Limit {{letters}} to: <input type="number" step="1" ng-model="letterLimit">
>, <Line: -         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
>, <Line: -         Limit {{longNumber}} to: <input type="number" step="1" ng-model="longNumberLimit">
>, <Line: -         <p>Output long number: {{ longNumber | limitTo:longNumberLimit }}</p>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       var numLimitInput = element(by.model('numLimit'));
>, <Line: -       var letterLimitInput = element(by.model('letterLimit'));
>, <Line: -       var longNumberLimitInput = element(by.model('longNumberLimit'));
>, <Line: -       var limitedNumbers = element(by.binding('numbers | limitTo:numLimit'));
>, <Line: -       var limitedLetters = element(by.binding('letters | limitTo:letterLimit'));
>, <Line: -       var limitedLongNumber = element(by.binding('longNumber | limitTo:longNumberLimit'));
>, <Line: -       it('should limit the number array to first three items', function() {
>, <Line: -       // There is a bug in safari and protractor that doesn't like the minus key
>, <Line: -       // it('should update the output when -3 is entered', function() {
>, <Line: -       it('should not exceed the maximum size of input array', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: -*/
>, <Line: -function limitToFilter() {
>, <Line: -  return function(input, limit) {
>, <Line: -    if (isNumber(input)) input = input.toString();
>, <Line: -    if (!isArray(input) && !isString(input)) return input;
>, <Line: -    if (Math.abs(Number(limit)) === Infinity) {
>, <Line: -      limit = Number(limit);
>, <Line: -    } else {
>, <Line: -      limit = int(limit);
>, <Line: -    }
>, <Line: -    if (isString(input)) {
>, <Line: -      //NaN check on limit
>, <Line: -      if (limit) {
>, <Line: -        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
>, <Line: -      } else {
>, <Line: -        return "";
>, <Line: -      }
>, <Line: -    }
>, <Line: -    var out = [],
>, <Line: -      i, n;
>, <Line: -    // if abs(limit) exceeds maximum length, trim it
>, <Line: -    if (limit > input.length)
>, <Line: -      limit = input.length;
>, <Line: -    else if (limit < -input.length)
>, <Line: -      limit = -input.length;
>, <Line: -    if (limit > 0) {
>, <Line: -      i = 0;
>, <Line: -      n = limit;
>, <Line: -    } else {
>, <Line: -      i = input.length + limit;
>, <Line: -      n = input.length;
>, <Line: -    }
>, <Line: -    for (; i < n; i++) {
>, <Line: -      out.push(input[i]);
>, <Line: -    }
>, <Line: -    return out;
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc filter
>, <Line: - * @name orderBy
>, <Line: - * @kind function
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Orders a specified `array` by the `expression` predicate. It is ordered alphabetically
>, <Line: - * for strings and numerically for numbers. Note: if you notice numbers are not being sorted
>, <Line: - * correctly, make sure they are actually being saved as numbers and not strings.
>, <Line: - *
>, <Line: - * @param {Array} array The array to sort.
>, <Line: - * @param {function(*)|string|Array.<(function(*)|string)>=} expression A predicate to be
>, <Line: - *    used by the comparator to determine the order of elements.
>, <Line: - *
>, <Line: - *    Can be one of:
>, <Line: - *
>, <Line: - *    - `function`: Getter function. The result of this function will be sorted using the
>, <Line: - *      `<`, `=`, `>` operator.
>, <Line: - *    - `string`: An Angular expression. The result of this expression is used to compare elements
>, <Line: - *      (for example `name` to sort by a property called `name` or `name.substr(0, 3)` to sort by
>, <Line: - *      3 first characters of a property called `name`). The result of a constant expression
>, <Line: - *      is interpreted as a property name to be used in comparisons (for example `"special name"`
>, <Line: - *      to sort object by the value of their `special name` property). An expression can be
>, <Line: - *      optionally prefixed with `+` or `-` to control ascending or descending sort order
>, <Line: - *      (for example, `+name` or `-name`). If no property is provided, (e.g. `'+'`) then the array
>, <Line: - *      element itself is used to compare where sorting.
>, <Line: - *    - `Array`: An array of function or string predicates. The first predicate in the array
>, <Line: - *      is used for sorting, but when two items are equivalent, the next predicate is used.
>, <Line: - *
>, <Line: - *    If the predicate is missing or empty then it defaults to `'+'`.
>, <Line: - *
>, <Line: - * @param {boolean=} reverse Reverse the order of the array.
>, <Line: - * @returns {Array} Sorted copy of the source array.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="orderByExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('orderByExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
>, <Line: -         <hr/>
>, <Line: -         [ <a href="" ng-click="predicate=''">unsorted</a> ]
>, <Line: -         <table class="friend">
>, <Line: -           <tr>
>, <Line: -             <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
>, <Line: -                 (<a href="" ng-click="predicate = '-name'; reverse=false">^</a>)</th>
>, <Line: -             <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
>, <Line: -             <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
>, <Line: -           </tr>
>, <Line: -           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
>, <Line: -             <td>{{friend.name}}</td>
>, <Line: -             <td>{{friend.phone}}</td>
>, <Line: -             <td>{{friend.age}}</td>
>, <Line: -           </tr>
>, <Line: -         </table>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - *
>, <Line: - * It's also possible to call the orderBy filter manually, by injecting `$filter`, retrieving the
>, <Line: - * filter routine with `$filter('orderBy')`, and calling the returned filter routine with the
>, <Line: - * desired parameters.
>, <Line: - *
>, <Line: - * Example:
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="orderByExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-controller="ExampleController">
>, <Line: -        <table class="friend">
>, <Line: -          <tr>
>, <Line: -            <th><a href="" ng-click="reverse=false;order('name', false)">Name</a>
>, <Line: -              (<a href="" ng-click="order('-name',false)">^</a>)</th>
>, <Line: -            <th><a href="" ng-click="reverse=!reverse;order('phone', reverse)">Phone Number</a></th>
>, <Line: -            <th><a href="" ng-click="reverse=!reverse;order('age',reverse)">Age</a></th>
>, <Line: -          </tr>
>, <Line: -          <tr ng-repeat="friend in friends">
>, <Line: -            <td>{{friend.name}}</td>
>, <Line: -            <td>{{friend.phone}}</td>
>, <Line: -            <td>{{friend.age}}</td>
>, <Line: -          </tr>
>, <Line: -        </table>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="script.js">
>, <Line: -      angular.module('orderByExample', [])
>, <Line: -        .controller('ExampleController', ['$scope', '$filter', function($scope, $filter) {
>, <Line: -    </file>
>, <Line: -</example>
>, <Line: - */
>, <Line: -orderByFilter.$inject = ['$parse'];
>, <Line: -function orderByFilter($parse) {
>, <Line: -  return function(array, sortPredicate, reverseOrder) {
>, <Line: -    if (!(isArrayLike(array))) return array;
>, <Line: -    sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
>, <Line: -    if (sortPredicate.length === 0) { sortPredicate = ['+']; }
>, <Line: -    sortPredicate = sortPredicate.map(function(predicate) {
>, <Line: -      var descending = false, get = predicate || identity;
>, <Line: -      if (isString(predicate)) {
>, <Line: -        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
>, <Line: -          descending = predicate.charAt(0) == '-';
>, <Line: -          predicate = predicate.substring(1);
>, <Line: -        }
>, <Line: -        if (predicate === '') {
>, <Line: -          // Effectively no predicate was passed so we compare identity
>, <Line: -          return reverseComparator(function(a, b) {
>, <Line: -            return compare(a, b);
>, <Line: -          }, descending);
>, <Line: -        }
>, <Line: -        get = $parse(predicate);
>, <Line: -        if (get.constant) {
>, <Line: -          var key = get();
>, <Line: -          return reverseComparator(function(a, b) {
>, <Line: -            return compare(a[key], b[key]);
>, <Line: -          }, descending);
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return reverseComparator(function(a, b) {
>, <Line: -        return compare(get(a),get(b));
>, <Line: -      }, descending);
>, <Line: -    });
>, <Line: -    return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
>, <Line: -    function comparator(o1, o2) {
>, <Line: -      for (var i = 0; i < sortPredicate.length; i++) {
>, <Line: -        var comp = sortPredicate[i](o1, o2);
>, <Line: -        if (comp !== 0) return comp;
>, <Line: -      }
>, <Line: -      return 0;
>, <Line: -    }
>, <Line: -    function reverseComparator(comp, descending) {
>, <Line: -      return descending
>, <Line: -          ? function(a, b) {return comp(b,a);}
>, <Line: -          : comp;
>, <Line: -    }
>, <Line: -    function compare(v1, v2) {
>, <Line: -      var t1 = typeof v1;
>, <Line: -      var t2 = typeof v2;
>, <Line: -      if (t1 == t2) {
>, <Line: -        if (isDate(v1) && isDate(v2)) {
>, <Line: -          v1 = v1.valueOf();
>, <Line: -          v2 = v2.valueOf();
>, <Line: -        }
>, <Line: -        if (t1 == "string") {
>, <Line: -           v1 = v1.toLowerCase();
>, <Line: -           v2 = v2.toLowerCase();
>, <Line: -        }
>, <Line: -        if (v1 === v2) return 0;
>, <Line: -        return v1 < v2 ? -1 : 1;
>, <Line: -      } else {
>, <Line: -        return t1 < t2 ? -1 : 1;
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}
>, <Line: -function ngDirective(directive) {
>, <Line: -  if (isFunction(directive)) {
>, <Line: -    directive = {
>, <Line: -      link: directive
>, <Line: -    };
>, <Line: -  }
>, <Line: -  directive.restrict = directive.restrict || 'AC';
>, <Line: -  return valueFn(directive);
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name a
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Modifies the default behavior of the html A tag so that the default action is prevented when
>, <Line: - * the href attribute is empty.
>, <Line: - *
>, <Line: - * This change permits the easy creation of action links with the `ngClick` directive
>, <Line: - * without changing the location or causing page reloads, e.g.:
>, <Line: - * `<a href="" ng-click="list.addItem()">Add Item</a>`
>, <Line: - */
>, <Line: -var htmlAnchorDirective = valueFn({
>, <Line: -  restrict: 'E',
>, <Line: -  compile: function(element, attr) {
>, <Line: -    if (!attr.href && !attr.xlinkHref && !attr.name) {
>, <Line: -      return function(scope, element) {
>, <Line: -        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
>, <Line: -        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
>, <Line: -                   'xlink:href' : 'href';
>, <Line: -        element.on('click', function(event) {
>, <Line: -          // if we have no href url, then don't navigate anywhere.
>, <Line: -          if (!element.attr(href)) {
>, <Line: -            event.preventDefault();
>, <Line: -          }
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  }
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngHref
>, <Line: - * @restrict A
>, <Line: - * @priority 99
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Using Angular markup like `{{hash}}` in an href attribute will
>, <Line: - * make the link go to the wrong URL if the user clicks it before
>, <Line: - * Angular has a chance to replace the `{{hash}}` markup with its
>, <Line: - * value. Until Angular replaces the markup the link will be broken
>, <Line: - * and will most likely return a 404 error.
>, <Line: - *
>, <Line: - * The `ngHref` directive solves this problem.
>, <Line: - *
>, <Line: - * The wrong way to write it:
>, <Line: - * ```html
>, <Line: - * <a href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The correct way to write it:
>, <Line: - * ```html
>, <Line: - * <a ng-href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @element A
>, <Line: - * @param {template} ngHref any string which can contain `{{}}` markup.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
>, <Line: - * in links and their different behaviors:
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        <input ng-model="value" /><br />
>, <Line: -        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
>, <Line: -        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
>, <Line: -        <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
>, <Line: -        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
>, <Line: -        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
>, <Line: -        <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should execute ng-click but not reload when href without value', function() {
>, <Line: -        it('should execute ng-click but not reload when href empty string', function() {
>, <Line: -        it('should execute ng-click and change url when ng-href specified', function() {
>, <Line: -        });
>, <Line: -        xit('should execute ng-click but not reload when href empty string and name specified', function() {
>, <Line: -          element(by.id('link-4')).click();
>, <Line: -          expect(element(by.model('value')).getAttribute('value')).toEqual('4');
>, <Line: -          expect(element(by.id('link-4')).getAttribute('href')).toBe('');
>, <Line: -        });
>, <Line: -        it('should execute ng-click but not reload when no href but name specified', function() {
>, <Line: -          element(by.id('link-5')).click();
>, <Line: -          expect(element(by.model('value')).getAttribute('value')).toEqual('5');
>, <Line: -          expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
>, <Line: -        });
>, <Line: -        it('should only change url when only ng-href', function() {
>, <Line: -          element(by.model('value')).clear();
>, <Line: -          element(by.model('value')).sendKeys('6');
>, <Line: -          expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);
>, <Line: -          element(by.id('link-6')).click();
>, <Line: -          // At this point, we navigate away from an Angular page, so we need
>, <Line: -          // to use browser.driver to get the base webdriver.
>, <Line: -          browser.wait(function() {
>, <Line: -            return browser.driver.getCurrentUrl().then(function(url) {
>, <Line: -              return url.match(/\/6$/);
>, <Line: -            });
>, <Line: -          }, 5000, 'page should navigate to /6');
>, <Line: -        });
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngSrc
>, <Line: - * @restrict A
>, <Line: - * @priority 99
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
>, <Line: - * work right: The browser will fetch from the URL with the literal
>, <Line: - * text `{{hash}}` until Angular replaces the expression inside
>, <Line: - * `{{hash}}`. The `ngSrc` directive solves this problem.
>, <Line: - *
>, <Line: - * The buggy way to write it:
>, <Line: - * ```html
>, <Line: - * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The correct way to write it:
>, <Line: - * ```html
>, <Line: - * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @element IMG
>, <Line: - * @param {template} ngSrc any string which can contain `{{}}` markup.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngSrcset
>, <Line: - * @restrict A
>, <Line: - * @priority 99
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
>, <Line: - * work right: The browser will fetch from the URL with the literal
>, <Line: - * text `{{hash}}` until Angular replaces the expression inside
>, <Line: - * `{{hash}}`. The `ngSrcset` directive solves this problem.
>, <Line: - *
>, <Line: - * The buggy way to write it:
>, <Line: - * ```html
>, <Line: - * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The correct way to write it:
>, <Line: - * ```html
>, <Line: - * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @element IMG
>, <Line: - * @param {template} ngSrcset any string which can contain `{{}}` markup.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngDisabled
>, <Line: - * @restrict A
>, <Line: - * @priority 100
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * We shouldn't do this, because it will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
>, <Line: - * ```html
>, <Line: - * <div ng-init="scope = { isDisabled: false }">
>, <Line: - *  <button disabled="{{scope.isDisabled}}">Disabled</button>
>, <Line: - * </div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: - * such as disabled. (Their presence means true and their absence means false.)
>, <Line: - * If we put an Angular interpolation expression into such an attribute then the
>, <Line: - * binding information would be lost when the browser removes the attribute.
>, <Line: - * The `ngDisabled` directive solves this problem for the `disabled` attribute.
>, <Line: - * This complementary directive is not removed by the browser and so provides
>, <Line: - * a permanent reliable place to store the binding information.
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
>, <Line: -        <button ng-model="button" ng-disabled="checked">Button</button>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should toggle button', function() {
>, <Line: -          expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
>, <Line: -          element(by.model('checked')).click();
>, <Line: -          expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();
>, <Line: -        });
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - *
>, <Line: - * @element INPUT
>, <Line: - * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy,
>, <Line: - *     then special attribute "disabled" will be set on the element
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngChecked
>, <Line: - * @restrict A
>, <Line: - * @priority 100
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: - * such as checked. (Their presence means true and their absence means false.)
>, <Line: - * If we put an Angular interpolation expression into such an attribute then the
>, <Line: - * binding information would be lost when the browser removes the attribute.
>, <Line: - * The `ngChecked` directive solves this problem for the `checked` attribute.
>, <Line: - * This complementary directive is not removed by the browser and so provides
>, <Line: - * a permanent reliable place to store the binding information.
>, <Line: - * @example
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        Check me to check both: <input type="checkbox" ng-model="master"><br/>
>, <Line: -        <input id="checkSlave" type="checkbox" ng-checked="master">
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should check both checkBoxes', function() {
>, <Line: -          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
>, <Line: -          element(by.model('master')).click();
>, <Line: -          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy();
>, <Line: -        });
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - *
>, <Line: - * @element INPUT
>, <Line: - * @param {expression} ngChecked If the {@link guide/expression expression} is truthy,
>, <Line: - *     then special attribute "checked" will be set on the element
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngReadonly
>, <Line: - * @restrict A
>, <Line: - * @priority 100
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: - * such as readonly. (Their presence means true and their absence means false.)
>, <Line: - * If we put an Angular interpolation expression into such an attribute then the
>, <Line: - * binding information would be lost when the browser removes the attribute.
>, <Line: - * The `ngReadonly` directive solves this problem for the `readonly` attribute.
>, <Line: - * This complementary directive is not removed by the browser and so provides
>, <Line: - * a permanent reliable place to store the binding information.
>, <Line: - * @example
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
>, <Line: -        <input type="text" ng-readonly="checked" value="I'm Angular"/>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should toggle readonly attr', function() {
>, <Line: -          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeFalsy();
>, <Line: -          element(by.model('checked')).click();
>, <Line: -          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeTruthy();
>, <Line: -        });
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - *
>, <Line: - * @element INPUT
>, <Line: - * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy,
>, <Line: - *     then special attribute "readonly" will be set on the element
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngSelected
>, <Line: - * @restrict A
>, <Line: - * @priority 100
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: - * such as selected. (Their presence means true and their absence means false.)
>, <Line: - * If we put an Angular interpolation expression into such an attribute then the
>, <Line: - * binding information would be lost when the browser removes the attribute.
>, <Line: - * The `ngSelected` directive solves this problem for the `selected` attribute.
>, <Line: - * This complementary directive is not removed by the browser and so provides
>, <Line: - * a permanent reliable place to store the binding information.
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        Check me to select: <input type="checkbox" ng-model="selected"><br/>
>, <Line: -        <select>
>, <Line: -          <option>Hello!</option>
>, <Line: -          <option id="greet" ng-selected="selected">Greetings!</option>
>, <Line: -        </select>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should select Greetings!', function() {
>, <Line: -          expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
>, <Line: -          element(by.model('selected')).click();
>, <Line: -          expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();
>, <Line: -        });
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - *
>, <Line: - * @element OPTION
>, <Line: - * @param {expression} ngSelected If the {@link guide/expression expression} is truthy,
>, <Line: - *     then special attribute "selected" will be set on the element
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngOpen
>, <Line: - * @restrict A
>, <Line: - * @priority 100
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The HTML specification does not require browsers to preserve the values of boolean attributes
>, <Line: - * such as open. (Their presence means true and their absence means false.)
>, <Line: - * If we put an Angular interpolation expression into such an attribute then the
>, <Line: - * binding information would be lost when the browser removes the attribute.
>, <Line: - * The `ngOpen` directive solves this problem for the `open` attribute.
>, <Line: - * This complementary directive is not removed by the browser and so provides
>, <Line: - * a permanent reliable place to store the binding information.
>, <Line: - * @example
>, <Line: -     <example>
>, <Line: -       <file name="index.html">
>, <Line: -         Check me check multiple: <input type="checkbox" ng-model="open"><br/>
>, <Line: -         <details id="details" ng-open="open">
>, <Line: -            <summary>Show/Hide me</summary>
>, <Line: -         </details>
>, <Line: -       </file>
>, <Line: -       <file name="protractor.js" type="protractor">
>, <Line: -         it('should toggle open', function() {
>, <Line: -           expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
>, <Line: -           element(by.model('open')).click();
>, <Line: -           expect(element(by.id('details')).getAttribute('open')).toBeTruthy();
>, <Line: -         });
>, <Line: -       </file>
>, <Line: -     </example>
>, <Line: - *
>, <Line: - * @element DETAILS
>, <Line: - * @param {expression} ngOpen If the {@link guide/expression expression} is truthy,
>, <Line: - *     then special attribute "open" will be set on the element
>, <Line: - */
>, <Line: -var ngAttributeAliasDirectives = {};
>, <Line: -// boolean attrs are evaluated
>, <Line: -forEach(BOOLEAN_ATTR, function(propName, attrName) {
>, <Line: -  // binding to multiple is not supported
>, <Line: -  if (propName == "multiple") return;
>, <Line: -  var normalized = directiveNormalize('ng-' + attrName);
>, <Line: -  ngAttributeAliasDirectives[normalized] = function() {
>, <Line: -    return {
>, <Line: -      restrict: 'A',
>, <Line: -      priority: 100,
>, <Line: -      link: function(scope, element, attr) {
>, <Line: -        scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
>, <Line: -          attr.$set(attrName, !!value);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -  };
>, <Line: -});
>, <Line: -// aliased input attrs are evaluated
>, <Line: -forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
>, <Line: -  ngAttributeAliasDirectives[ngAttr] = function() {
>, <Line: -    return {
>, <Line: -      priority: 100,
>, <Line: -      link: function(scope, element, attr) {
>, <Line: -        //special case ngPattern when a literal regular expression value
>, <Line: -        //is used as the expression (this way we don't have to watch anything).
>, <Line: -        if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
>, <Line: -          var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
>, <Line: -          if (match) {
>, <Line: -            attr.$set("ngPattern", new RegExp(match[1], match[2]));
>, <Line: -            return;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
>, <Line: -          attr.$set(ngAttr, value);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -  };
>, <Line: -});
>, <Line: -// ng-src, ng-srcset, ng-href are interpolated
>, <Line: -forEach(['src', 'srcset', 'href'], function(attrName) {
>, <Line: -  var normalized = directiveNormalize('ng-' + attrName);
>, <Line: -  ngAttributeAliasDirectives[normalized] = function() {
>, <Line: -    return {
>, <Line: -      priority: 99, // it needs to run after the attributes are interpolated
>, <Line: -      link: function(scope, element, attr) {
>, <Line: -        var propName = attrName,
>, <Line: -            name = attrName;
>, <Line: -        if (attrName === 'href' &&
>, <Line: -            toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
>, <Line: -          name = 'xlinkHref';
>, <Line: -          attr.$attr[name] = 'xlink:href';
>, <Line: -          propName = null;
>, <Line: -        }
>, <Line: -        attr.$observe(normalized, function(value) {
>, <Line: -          if (!value) {
>, <Line: -            if (attrName === 'href') {
>, <Line: -              attr.$set(name, null);
>, <Line: -            }
>, <Line: -            return;
>, <Line: -          }
>, <Line: -          attr.$set(name, value);
>, <Line: -          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
>, <Line: -          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
>, <Line: -          // to set the property as well to achieve the desired effect.
>, <Line: -          // we use attr[attrName] value since $set can sanitize the url.
>, <Line: -          if (msie && propName) element.prop(propName, attr[name]);
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -  };
>, <Line: -});
>, <Line: -/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true
>, <Line: - */
>, <Line: -var nullFormCtrl = {
>, <Line: -  $addControl: noop,
>, <Line: -  $$renameControl: nullFormRenameControl,
>, <Line: -  $removeControl: noop,
>, <Line: -  $setValidity: noop,
>, <Line: -  $setDirty: noop,
>, <Line: -  $setPristine: noop,
>, <Line: -  $setSubmitted: noop
>, <Line: -},
>, <Line: -SUBMITTED_CLASS = 'ng-submitted';
>, <Line: -function nullFormRenameControl(control, name) {
>, <Line: -  control.$name = name;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name form.FormController
>, <Line: - *
>, <Line: - * @property {boolean} $pristine True if user has not interacted with the form yet.
>, <Line: - * @property {boolean} $dirty True if user has already interacted with the form.
>, <Line: - * @property {boolean} $valid True if all of the containing forms and controls are valid.
>, <Line: - * @property {boolean} $invalid True if at least one containing control or form is invalid.
>, <Line: - * @property {boolean} $submitted True if user has submitted the form even if its invalid.
>, <Line: - *
>, <Line: - * @property {Object} $error Is an object hash, containing references to controls or
>, <Line: - *  forms with failing validators, where:
>, <Line: - *
>, <Line: - *  - keys are validation tokens (error names),
>, <Line: - *  - values are arrays of controls or forms that have a failing validator for given error name.
>, <Line: - *
>, <Line: - *  Built-in validation tokens:
>, <Line: - *
>, <Line: - *  - `email`
>, <Line: - *  - `max`
>, <Line: - *  - `maxlength`
>, <Line: - *  - `min`
>, <Line: - *  - `minlength`
>, <Line: - *  - `number`
>, <Line: - *  - `pattern`
>, <Line: - *  - `required`
>, <Line: - *  - `url`
>, <Line: - *  - `date`
>, <Line: - *  - `datetimelocal`
>, <Line: - *  - `time`
>, <Line: - *  - `week`
>, <Line: - *  - `month`
>, <Line: - *
>, <Line: - * @description
>, <Line: - * `FormController` keeps track of all its controls and nested forms as well as the state of them,
>, <Line: - * such as being valid/invalid or dirty/pristine.
>, <Line: - *
>, <Line: - * Each {@link ng.directive:form form} directive creates an instance
>, <Line: - * of `FormController`.
>, <Line: - *
>, <Line: - */
>, <Line: -//asks for $scope to fool the BC controller module
>, <Line: -FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
>, <Line: -function FormController(element, attrs, $scope, $animate, $interpolate) {
>, <Line: -  var form = this,
>, <Line: -      controls = [];
>, <Line: -  var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
>, <Line: -  // init state
>, <Line: -  form.$error = {};
>, <Line: -  form.$$success = {};
>, <Line: -  form.$pending = undefined;
>, <Line: -  form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
>, <Line: -  form.$dirty = false;
>, <Line: -  form.$pristine = true;
>, <Line: -  form.$valid = true;
>, <Line: -  form.$invalid = false;
>, <Line: -  form.$submitted = false;
>, <Line: -  parentForm.$addControl(form);
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$rollbackViewValue
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Rollback all form controls pending updates to the `$modelValue`.
>, <Line: -   *
>, <Line: -   * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: -   * event defined in `ng-model-options`. This method is typically needed by the reset button of
>, <Line: -   * a form that uses `ng-model-options` to pend updates.
>, <Line: -   */
>, <Line: -  form.$rollbackViewValue = function() {
>, <Line: -    forEach(controls, function(control) {
>, <Line: -      control.$rollbackViewValue();
>, <Line: -    });
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$commitViewValue
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Commit all form controls pending updates to the `$modelValue`.
>, <Line: -   *
>, <Line: -   * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: -   * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
>, <Line: -   * usually handles calling this in response to input events.
>, <Line: -   */
>, <Line: -  form.$commitViewValue = function() {
>, <Line: -    forEach(controls, function(control) {
>, <Line: -      control.$commitViewValue();
>, <Line: -    });
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$addControl
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Register a control with the form.
>, <Line: -   *
>, <Line: -   * Input elements using ngModelController do this automatically when they are linked.
>, <Line: -   */
>, <Line: -  form.$addControl = function(control) {
>, <Line: -    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
>, <Line: -    // and not added to the scope.  Now we throw an error.
>, <Line: -    assertNotHasOwnProperty(control.$name, 'input');
>, <Line: -    controls.push(control);
>, <Line: -    if (control.$name) {
>, <Line: -      form[control.$name] = control;
>, <Line: -    }
>, <Line: -  };
>, <Line: -  // Private API: rename a form control
>, <Line: -  form.$$renameControl = function(control, newName) {
>, <Line: -    var oldName = control.$name;
>, <Line: -    if (form[oldName] === control) {
>, <Line: -      delete form[oldName];
>, <Line: -    }
>, <Line: -    form[newName] = control;
>, <Line: -    control.$name = newName;
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$removeControl
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Deregister a control from the form.
>, <Line: -   *
>, <Line: -   * Input elements using ngModelController do this automatically when they are destroyed.
>, <Line: -   */
>, <Line: -  form.$removeControl = function(control) {
>, <Line: -    if (control.$name && form[control.$name] === control) {
>, <Line: -      delete form[control.$name];
>, <Line: -    }
>, <Line: -    forEach(form.$pending, function(value, name) {
>, <Line: -      form.$setValidity(name, null, control);
>, <Line: -    });
>, <Line: -    forEach(form.$error, function(value, name) {
>, <Line: -      form.$setValidity(name, null, control);
>, <Line: -    });
>, <Line: -    arrayRemove(controls, control);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$setValidity
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the validity of a form control.
>, <Line: -   *
>, <Line: -   * This method will also propagate to parent forms.
>, <Line: -   */
>, <Line: -  addSetValidityMethod({
>, <Line: -    ctrl: this,
>, <Line: -    $element: element,
>, <Line: -    set: function(object, property, control) {
>, <Line: -      var list = object[property];
>, <Line: -      if (!list) {
>, <Line: -        object[property] = [control];
>, <Line: -      } else {
>, <Line: -        var index = list.indexOf(control);
>, <Line: -        if (index === -1) {
>, <Line: -          list.push(control);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    },
>, <Line: -    unset: function(object, property, control) {
>, <Line: -      var list = object[property];
>, <Line: -      if (!list) {
>, <Line: -        return;
>, <Line: -      }
>, <Line: -      arrayRemove(list, control);
>, <Line: -      if (list.length === 0) {
>, <Line: -        delete object[property];
>, <Line: -      }
>, <Line: -    },
>, <Line: -    parentForm: parentForm,
>, <Line: -    $animate: $animate
>, <Line: -  });
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$setDirty
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the form to a dirty state.
>, <Line: -   *
>, <Line: -   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
>, <Line: -   * state (ng-dirty class). This method will also propagate to parent forms.
>, <Line: -   */
>, <Line: -  form.$setDirty = function() {
>, <Line: -    $animate.removeClass(element, PRISTINE_CLASS);
>, <Line: -    $animate.addClass(element, DIRTY_CLASS);
>, <Line: -    form.$dirty = true;
>, <Line: -    form.$pristine = false;
>, <Line: -    parentForm.$setDirty();
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$setPristine
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the form to its pristine state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
>, <Line: -   * state (ng-pristine class). This method will also propagate to all the controls contained
>, <Line: -   * in this form.
>, <Line: -   *
>, <Line: -   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
>, <Line: -   * saving or resetting it.
>, <Line: -   */
>, <Line: -  form.$setPristine = function() {
>, <Line: -    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
>, <Line: -    form.$dirty = false;
>, <Line: -    form.$pristine = true;
>, <Line: -    form.$submitted = false;
>, <Line: -    forEach(controls, function(control) {
>, <Line: -      control.$setPristine();
>, <Line: -    });
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$setUntouched
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the form to its untouched state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the 'ng-touched' class and set the form controls to their
>, <Line: -   * untouched state (ng-untouched class).
>, <Line: -   *
>, <Line: -   * Setting a form controls back to their untouched state is often useful when setting the form
>, <Line: -   * back to its pristine state.
>, <Line: -   */
>, <Line: -  form.$setUntouched = function() {
>, <Line: -    forEach(controls, function(control) {
>, <Line: -      control.$setUntouched();
>, <Line: -    });
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name form.FormController#$setSubmitted
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the form to its submitted state.
>, <Line: -   */
>, <Line: -  form.$setSubmitted = function() {
>, <Line: -    $animate.addClass(element, SUBMITTED_CLASS);
>, <Line: -    form.$submitted = true;
>, <Line: -    parentForm.$setSubmitted();
>, <Line: -  };
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngForm
>, <Line: - * @restrict EAC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Nestable alias of {@link ng.directive:form `form`} directive. HTML
>, <Line: - * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
>, <Line: - * sub-group of controls needs to be determined.
>, <Line: - *
>, <Line: - * Note: the purpose of `ngForm` is to group controls,
>, <Line: - * but not to be a replacement for the `<form>` tag with all of its capabilities
>, <Line: - * (e.g. posting to the server, ...).
>, <Line: - *
>, <Line: - * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into
>, <Line: - *                       related scope, under this name.
>, <Line: - *
>, <Line: - */
>, <Line: - /**
>, <Line: - * @ngdoc directive
>, <Line: - * @name form
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Directive that instantiates
>, <Line: - * {@link form.FormController FormController}.
>, <Line: - *
>, <Line: - * If the `name` attribute is specified, the form controller is published onto the current scope under
>, <Line: - * this name.
>, <Line: - *
>, <Line: - * # Alias: {@link ng.directive:ngForm `ngForm`}
>, <Line: - *
>, <Line: - * In Angular forms can be nested. This means that the outer form is valid when all of the child
>, <Line: - * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
>, <Line: - * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to
>, <Line: - * `<form>` but can be nested.  This allows you to have nested forms, which is very useful when
>, <Line: - * using Angular validation directives in forms that are dynamically generated using the
>, <Line: - * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`
>, <Line: - * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
>, <Line: - * `ngForm` directive and nest these in an outer `form` element.
>, <Line: - *
>, <Line: - *
>, <Line: - * # CSS classes
>, <Line: - *  - `ng-valid` is set if the form is valid.
>, <Line: - *  - `ng-invalid` is set if the form is invalid.
>, <Line: - *  - `ng-pristine` is set if the form is pristine.
>, <Line: - *  - `ng-dirty` is set if the form is dirty.
>, <Line: - *  - `ng-submitted` is set if the form was submitted.
>, <Line: - *
>, <Line: - * Keep in mind that ngAnimate can detect each of these classes when added and removed.
>, <Line: - *
>, <Line: - *
>, <Line: - * # Submitting a form and preventing the default action
>, <Line: - *
>, <Line: - * Since the role of forms in client-side Angular applications is different than in classical
>, <Line: - * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
>, <Line: - * page reload that sends the data to the server. Instead some javascript logic should be triggered
>, <Line: - * to handle the form submission in an application-specific way.
>, <Line: - *
>, <Line: - * For this reason, Angular prevents the default action (form submission to the server) unless the
>, <Line: - * `<form>` element has an `action` attribute specified.
>, <Line: - *
>, <Line: - * You can use one of the following two ways to specify what javascript method should be called when
>, <Line: - * a form is submitted:
>, <Line: - *
>, <Line: - * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
>, <Line: - * - {@link ng.directive:ngClick ngClick} directive on the first
>, <Line: -  *  button or input field of type submit (input[type=submit])
>, <Line: - *
>, <Line: - * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
>, <Line: - * or {@link ng.directive:ngClick ngClick} directives.
>, <Line: - * This is because of the following form submission rules in the HTML specification:
>, <Line: - *
>, <Line: - * - If a form has only one input field then hitting enter in this field triggers form submit
>, <Line: - * (`ngSubmit`)
>, <Line: - * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
>, <Line: - * doesn't trigger submit
>, <Line: - * - if a form has one or more input fields and one or more buttons or input[type=submit] then
>, <Line: - * hitting enter in any of the input fields will trigger the click handler on the *first* button or
>, <Line: - * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
>, <Line: - *
>, <Line: - * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
>, <Line: - * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
>, <Line: - * to have access to the updated model.
>, <Line: - *
>, <Line: - * ## Animation Hooks
>, <Line: - *
>, <Line: - * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.
>, <Line: - * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any
>, <Line: - * other validations that are performed within the form. Animations in ngForm are similar to how
>, <Line: - * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well
>, <Line: - * as JS animations.
>, <Line: - *
>, <Line: - * The following example shows a simple way to utilize CSS transitions to style a form element
>, <Line: - * that has been rendered as invalid after it has been validated:
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * //be sure to include ngAnimate as a module to hook into more
>, <Line: - * //advanced animations
>, <Line: - * .my-form {
>, <Line: - * .my-form.ng-invalid {
>, <Line: - * </pre>
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example deps="angular-animate.js" animations="true" fixBase="true" module="formExample">
>, <Line: -      <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('formExample', [])
>, <Line: -           .controller('FormController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <style>
>, <Line: -        .my-form {
>, <Line: -        .my-form.ng-invalid {
>, <Line: -       </style>
>, <Line: -       <form name="myForm" ng-controller="FormController" class="my-form">
>, <Line: -         userType: <input name="input" ng-model="userType" required>
>, <Line: -         <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
>, <Line: -         <tt>userType = {{userType}}</tt><br>
>, <Line: -         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
>, <Line: -         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
>, <Line: -         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
>, <Line: -         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
>, <Line: -        </form>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should initialize to model', function() {
>, <Line: -        it('should be invalid if empty', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - *
>, <Line: - * @param {string=} name Name of the form. If specified, the form controller will be published into
>, <Line: - *                       related scope, under this name.
>, <Line: - */
>, <Line: -var formDirectiveFactory = function(isNgForm) {
>, <Line: -  return ['$timeout', function($timeout) {
>, <Line: -    var formDirective = {
>, <Line: -      name: 'form',
>, <Line: -      restrict: isNgForm ? 'EAC' : 'E',
>, <Line: -      controller: FormController,
>, <Line: -      compile: function ngFormCompile(formElement) {
>, <Line: -        // Setup initial state of the control
>, <Line: -        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
>, <Line: -        return {
>, <Line: -          pre: function ngFormPreLink(scope, formElement, attr, controller) {
>, <Line: -            // if `action` attr is not present on the form, prevent the default action (submission)
>, <Line: -            if (!('action' in attr)) {
>, <Line: -              // we can't use jq events because if a form is destroyed during submission the default
>, <Line: -              // action is not prevented. see #1238
>, <Line: -              //
>, <Line: -              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
>, <Line: -              // page reload if the form was destroyed by submission of the form via a click handler
>, <Line: -              // on a button in the form. Looks like an IE9 specific bug.
>, <Line: -              var handleFormSubmission = function(event) {
>, <Line: -                scope.$apply(function() {
>, <Line: -                  controller.$commitViewValue();
>, <Line: -                  controller.$setSubmitted();
>, <Line: -                });
>, <Line: -                event.preventDefault();
>, <Line: -              };
>, <Line: -              addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
>, <Line: -              // unregister the preventDefault listener so that we don't not leak memory but in a
>, <Line: -              // way that will achieve the prevention of the default action.
>, <Line: -              formElement.on('$destroy', function() {
>, <Line: -                $timeout(function() {
>, <Line: -                  removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
>, <Line: -                }, 0, false);
>, <Line: -              });
>, <Line: -            }
>, <Line: -            var parentFormCtrl = controller.$$parentForm,
>, <Line: -                alias = controller.$name;
>, <Line: -            if (alias) {
>, <Line: -              setter(scope, alias, controller, alias);
>, <Line: -              attr.$observe(attr.name ? 'name' : 'ngForm', function(newValue) {
>, <Line: -                if (alias === newValue) return;
>, <Line: -                setter(scope, alias, undefined, alias);
>, <Line: -                alias = newValue;
>, <Line: -                setter(scope, alias, controller, alias);
>, <Line: -                parentFormCtrl.$$renameControl(controller, alias);
>, <Line: -              });
>, <Line: -            }
>, <Line: -            formElement.on('$destroy', function() {
>, <Line: -              parentFormCtrl.$removeControl(controller);
>, <Line: -              if (alias) {
>, <Line: -                setter(scope, alias, undefined, alias);
>, <Line: -              }
>, <Line: -              extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
>, <Line: -            });
>, <Line: -          }
>, <Line: -        };
>, <Line: -      }
>, <Line: -    };
>, <Line: -    return formDirective;
>, <Line: -  }];
>, <Line: -};
>, <Line: -var formDirective = formDirectiveFactory();
>, <Line: -var ngFormDirective = formDirectiveFactory(true);
>, <Line: -/* global VALID_CLASS: true,
>, <Line: -  INVALID_CLASS: true,
>, <Line: -  PRISTINE_CLASS: true,
>, <Line: -  DIRTY_CLASS: true,
>, <Line: -  UNTOUCHED_CLASS: true,
>, <Line: -  TOUCHED_CLASS: true,
>, <Line: -*/
>, <Line: -var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
>, <Line: -var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
>, <Line: -var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
>, <Line: -var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
>, <Line: -var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
>, <Line: -var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
>, <Line: -var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
>, <Line: -var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
>, <Line: -var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
>, <Line: -var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
>, <Line: -var $ngModelMinErr = new minErr('ngModel');
>, <Line: -var inputType = {
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[text]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Standard HTML text input with angular data binding, inherited by most of the `input` elements.
>, <Line: -   *
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} required Adds `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: -   *    minlength.
>, <Line: -   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: -   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: -   *    any length.
>, <Line: -   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: -   *    that contains the regular expression body that will be converted to a regular expression
>, <Line: -   *    as in the ngPattern directive.
>, <Line: -   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: -   *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: -   *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: -   *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: -   *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: -   *    This parameter is ignored for input[type=password] controls, which will never trim the
>, <Line: -   *    input.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="text-input-directive" module="textInputExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('textInputExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -         </script>
>, <Line: -         <form name="myForm" ng-controller="ExampleController">
>, <Line: -           Single word: <input type="text" name="input" ng-model="text"
>, <Line: -                               ng-pattern="word" required ng-trim="false">
>, <Line: -           <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -             Required!</span>
>, <Line: -           <span class="error" ng-show="myForm.input.$error.pattern">
>, <Line: -             Single word only!</span>
>, <Line: -           <tt>text = {{text}}</tt><br/>
>, <Line: -           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -          </form>
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          var text = element(by.binding('text'));
>, <Line: -          var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -          var input = element(by.model('text'));
>, <Line: -          it('should initialize to model', function() {
>, <Line: -          it('should be invalid if empty', function() {
>, <Line: -          it('should be invalid if multi word', function() {
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'text': textInputType,
>, <Line: -    /**
>, <Line: -     * @ngdoc input
>, <Line: -     * @name input[date]
>, <Line: -     *
>, <Line: -     * @description
>, <Line: -     * Input with date validation and transformation. In browsers that do not yet support
>, <Line: -     * the HTML5 date input, a text element will be used. In that case, text must be entered in a valid ISO-8601
>, <Line: -     * date format (yyyy-MM-dd), for example: `2009-01-06`. Since many
>, <Line: -     * modern browsers do not yet support this input type, it is important to provide cues to users on the
>, <Line: -     * expected input format via a placeholder or label.
>, <Line: -     *
>, <Line: -     * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: -     * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: -     *
>, <Line: -     * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: -     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: -     *
>, <Line: -     * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -     * @param {string=} name Property name of the form under which the control is published.
>, <Line: -     * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: -     * valid ISO date string (yyyy-MM-dd).
>, <Line: -     * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: -     * a valid ISO date string (yyyy-MM-dd).
>, <Line: -     * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -     *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -     * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -     *    interaction with the input element.
>, <Line: -     *
>, <Line: -     * @example
>, <Line: -     <example name="date-input-directive" module="dateInputExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -          angular.module('dateInputExample', [])
>, <Line: -            .controller('DateController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: -          Pick a date in 2013:
>, <Line: -          <input type="date" id="exampleInput" name="input" ng-model="value"
>, <Line: -              placeholder="yyyy-MM-dd" min="2013-01-01" max="2013-12-31" required />
>, <Line: -          <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -              Required!</span>
>, <Line: -          <span class="error" ng-show="myForm.input.$error.date">
>, <Line: -              Not a valid date!</span>
>, <Line: -           <tt>value = {{value | date: "yyyy-MM-dd"}}</tt><br/>
>, <Line: -           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -       </form>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -        var value = element(by.binding('value | date: "yyyy-MM-dd"'));
>, <Line: -        var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -        var input = element(by.model('value'));
>, <Line: -        // currently protractor/webdriver does not support
>, <Line: -        // sending keys to all known HTML5 input controls
>, <Line: -        // for various browsers (see https://github.com/angular/protractor/issues/562).
>, <Line: -        function setInput(val) {
>, <Line: -        it('should initialize to model', function() {
>, <Line: -        it('should be invalid if empty', function() {
>, <Line: -        it('should be invalid if over max', function() {
>, <Line: -     </file>
>, <Line: -     </example>
>, <Line: -     */
>, <Line: -  'date': createDateInputType('date', DATE_REGEXP,
>, <Line: -         createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),
>, <Line: -         'yyyy-MM-dd'),
>, <Line: -   /**
>, <Line: -    * @ngdoc input
>, <Line: -    * @name input[datetime-local]
>, <Line: -    *
>, <Line: -    * @description
>, <Line: -    * Input with datetime validation and transformation. In browsers that do not yet support
>, <Line: -    * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: -    * local datetime format (yyyy-MM-ddTHH:mm:ss), for example: `2010-12-28T14:57:00`.
>, <Line: -    *
>, <Line: -    * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: -    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: -    *
>, <Line: -    * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: -    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: -    *
>, <Line: -    * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -    * @param {string=} name Property name of the form under which the control is published.
>, <Line: -    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: -    * valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).
>, <Line: -    * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: -    * a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).
>, <Line: -    * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -    *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -    * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -    *    interaction with the input element.
>, <Line: -    *
>, <Line: -    * @example
>, <Line: -    <example name="datetimelocal-input-directive" module="dateExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <script>
>, <Line: -        angular.module('dateExample', [])
>, <Line: -          .controller('DateController', ['$scope', function($scope) {
>, <Line: -      </script>
>, <Line: -      <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: -        Pick a date between in 2013:
>, <Line: -        <input type="datetime-local" id="exampleInput" name="input" ng-model="value"
>, <Line: -            placeholder="yyyy-MM-ddTHH:mm:ss" min="2001-01-01T00:00:00" max="2013-12-31T00:00:00" required />
>, <Line: -        <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -            Required!</span>
>, <Line: -        <span class="error" ng-show="myForm.input.$error.datetimelocal">
>, <Line: -            Not a valid date!</span>
>, <Line: -        <tt>value = {{value | date: "yyyy-MM-ddTHH:mm:ss"}}</tt><br/>
>, <Line: -        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -      </form>
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var value = element(by.binding('value | date: "yyyy-MM-ddTHH:mm:ss"'));
>, <Line: -      var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -      var input = element(by.model('value'));
>, <Line: -      // currently protractor/webdriver does not support
>, <Line: -      // sending keys to all known HTML5 input controls
>, <Line: -      // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: -      function setInput(val) {
>, <Line: -      it('should initialize to model', function() {
>, <Line: -      it('should be invalid if empty', function() {
>, <Line: -      it('should be invalid if over max', function() {
>, <Line: -    </file>
>, <Line: -    </example>
>, <Line: -    */
>, <Line: -  'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP,
>, <Line: -      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']),
>, <Line: -      'yyyy-MM-ddTHH:mm:ss.sss'),
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[time]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Input with time validation and transformation. In browsers that do not yet support
>, <Line: -   * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: -   * local time format (HH:mm:ss), for example: `14:57:00`. Model must be a Date object. This binding will always output a
>, <Line: -   * Date object to the model of January 1, 1970, or local date `new Date(1970, 0, 1, HH, mm, ss)`.
>, <Line: -   *
>, <Line: -   * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: -   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: -   *
>, <Line: -   * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: -   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: -   * valid ISO time format (HH:mm:ss).
>, <Line: -   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be a
>, <Line: -   * valid ISO time format (HH:mm:ss).
>, <Line: -   * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -   <example name="time-input-directive" module="timeExample">
>, <Line: -   <file name="index.html">
>, <Line: -     <script>
>, <Line: -      angular.module('timeExample', [])
>, <Line: -        .controller('DateController', ['$scope', function($scope) {
>, <Line: -     </script>
>, <Line: -     <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: -        Pick a between 8am and 5pm:
>, <Line: -        <input type="time" id="exampleInput" name="input" ng-model="value"
>, <Line: -            placeholder="HH:mm:ss" min="08:00:00" max="17:00:00" required />
>, <Line: -        <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -            Required!</span>
>, <Line: -        <span class="error" ng-show="myForm.input.$error.time">
>, <Line: -            Not a valid date!</span>
>, <Line: -        <tt>value = {{value | date: "HH:mm:ss"}}</tt><br/>
>, <Line: -        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -     </form>
>, <Line: -   </file>
>, <Line: -   <file name="protractor.js" type="protractor">
>, <Line: -      var value = element(by.binding('value | date: "HH:mm:ss"'));
>, <Line: -      var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -      var input = element(by.model('value'));
>, <Line: -      // currently protractor/webdriver does not support
>, <Line: -      // sending keys to all known HTML5 input controls
>, <Line: -      // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: -      function setInput(val) {
>, <Line: -      it('should initialize to model', function() {
>, <Line: -      it('should be invalid if empty', function() {
>, <Line: -      it('should be invalid if over max', function() {
>, <Line: -   </file>
>, <Line: -   </example>
>, <Line: -   */
>, <Line: -  'time': createDateInputType('time', TIME_REGEXP,
>, <Line: -      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),
>, <Line: -     'HH:mm:ss.sss'),
>, <Line: -   /**
>, <Line: -    * @ngdoc input
>, <Line: -    * @name input[week]
>, <Line: -    *
>, <Line: -    * @description
>, <Line: -    * Input with week-of-the-year validation and transformation to Date. In browsers that do not yet support
>, <Line: -    * the HTML5 week input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: -    * week format (yyyy-W##), for example: `2013-W02`.
>, <Line: -    *
>, <Line: -    * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: -    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: -    *
>, <Line: -    * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: -    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: -    *
>, <Line: -    * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -    * @param {string=} name Property name of the form under which the control is published.
>, <Line: -    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
>, <Line: -    * valid ISO week format (yyyy-W##).
>, <Line: -    * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
>, <Line: -    * a valid ISO week format (yyyy-W##).
>, <Line: -    * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -    *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -    * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -    *    interaction with the input element.
>, <Line: -    *
>, <Line: -    * @example
>, <Line: -    <example name="week-input-directive" module="weekExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <script>
>, <Line: -      angular.module('weekExample', [])
>, <Line: -        .controller('DateController', ['$scope', function($scope) {
>, <Line: -      </script>
>, <Line: -      <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: -        Pick a date between in 2013:
>, <Line: -        <input id="exampleInput" type="week" name="input" ng-model="value"
>, <Line: -            placeholder="YYYY-W##" min="2012-W32" max="2013-W52" required />
>, <Line: -        <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -            Required!</span>
>, <Line: -        <span class="error" ng-show="myForm.input.$error.week">
>, <Line: -            Not a valid date!</span>
>, <Line: -        <tt>value = {{value | date: "yyyy-Www"}}</tt><br/>
>, <Line: -        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -      </form>
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var value = element(by.binding('value | date: "yyyy-Www"'));
>, <Line: -      var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -      var input = element(by.model('value'));
>, <Line: -      // currently protractor/webdriver does not support
>, <Line: -      // sending keys to all known HTML5 input controls
>, <Line: -      // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: -      function setInput(val) {
>, <Line: -      it('should initialize to model', function() {
>, <Line: -      it('should be invalid if empty', function() {
>, <Line: -      it('should be invalid if over max', function() {
>, <Line: -    </file>
>, <Line: -    </example>
>, <Line: -    */
>, <Line: -  'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[month]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Input with month validation and transformation. In browsers that do not yet support
>, <Line: -   * the HTML5 month input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
>, <Line: -   * month format (yyyy-MM), for example: `2009-01`.
>, <Line: -   *
>, <Line: -   * The model must always be a Date object, otherwise Angular will throw an error.
>, <Line: -   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
>, <Line: -   * If the model is not set to the first of the month, the next view to model update will set it
>, <Line: -   * to the first of the month.
>, <Line: -   *
>, <Line: -   * The timezone to be used to read/write the `Date` instance in the model can be defined using
>, <Line: -   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be
>, <Line: -   * a valid ISO month format (yyyy-MM).
>, <Line: -   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must
>, <Line: -   * be a valid ISO month format (yyyy-MM).
>, <Line: -   * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -   <example name="month-input-directive" module="monthExample">
>, <Line: -   <file name="index.html">
>, <Line: -     <script>
>, <Line: -      angular.module('monthExample', [])
>, <Line: -        .controller('DateController', ['$scope', function($scope) {
>, <Line: -     </script>
>, <Line: -     <form name="myForm" ng-controller="DateController as dateCtrl">
>, <Line: -       Pick a month int 2013:
>, <Line: -       <input id="exampleInput" type="month" name="input" ng-model="value"
>, <Line: -          placeholder="yyyy-MM" min="2013-01" max="2013-12" required />
>, <Line: -       <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -          Required!</span>
>, <Line: -       <span class="error" ng-show="myForm.input.$error.month">
>, <Line: -          Not a valid month!</span>
>, <Line: -       <tt>value = {{value | date: "yyyy-MM"}}</tt><br/>
>, <Line: -       <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -       <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -       <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -       <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -     </form>
>, <Line: -   </file>
>, <Line: -   <file name="protractor.js" type="protractor">
>, <Line: -      var value = element(by.binding('value | date: "yyyy-MM"'));
>, <Line: -      var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -      var input = element(by.model('value'));
>, <Line: -      // currently protractor/webdriver does not support
>, <Line: -      // sending keys to all known HTML5 input controls
>, <Line: -      // for various browsers (https://github.com/angular/protractor/issues/562).
>, <Line: -      function setInput(val) {
>, <Line: -      it('should initialize to model', function() {
>, <Line: -      it('should be invalid if empty', function() {
>, <Line: -      it('should be invalid if over max', function() {
>, <Line: -   </file>
>, <Line: -   </example>
>, <Line: -   */
>, <Line: -  'month': createDateInputType('month', MONTH_REGEXP,
>, <Line: -     createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),
>, <Line: -     'yyyy-MM'),
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[number]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Text input with number validation and transformation. Sets the `number` validation
>, <Line: -   * error if not a valid number.
>, <Line: -   *
>, <Line: -   * The model must always be a number, otherwise Angular will throw an error.
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
>, <Line: -   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
>, <Line: -   * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: -   *    minlength.
>, <Line: -   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: -   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: -   *    any length.
>, <Line: -   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: -   *    that contains the regular expression body that will be converted to a regular expression
>, <Line: -   *    as in the ngPattern directive.
>, <Line: -   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: -   *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: -   *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: -   *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: -   *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="number-input-directive" module="numberExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('numberExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -         </script>
>, <Line: -         <form name="myForm" ng-controller="ExampleController">
>, <Line: -           Number: <input type="number" name="input" ng-model="value"
>, <Line: -                          min="0" max="99" required>
>, <Line: -           <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -             Required!</span>
>, <Line: -           <span class="error" ng-show="myForm.input.$error.number">
>, <Line: -             Not valid number!</span>
>, <Line: -           <tt>value = {{value}}</tt><br/>
>, <Line: -           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -          </form>
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          var value = element(by.binding('value'));
>, <Line: -          var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -          var input = element(by.model('value'));
>, <Line: -          it('should initialize to model', function() {
>, <Line: -          it('should be invalid if empty', function() {
>, <Line: -          it('should be invalid if over max', function() {
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'number': numberInputType,
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[url]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Text input with URL validation. Sets the `url` validation error key if the content is not a
>, <Line: -   * valid URL.
>, <Line: -   *
>, <Line: -   * <div class="alert alert-warning">
>, <Line: -   * **Note:** `input[url]` uses a regex to validate urls that is derived from the regex
>, <Line: -   * used in Chromium. If you need stricter validation, you can use `ng-pattern` or modify
>, <Line: -   * the built-in validators (see the {@link guide/forms Forms guide})
>, <Line: -   * </div>
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: -   *    minlength.
>, <Line: -   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: -   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: -   *    any length.
>, <Line: -   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: -   *    that contains the regular expression body that will be converted to a regular expression
>, <Line: -   *    as in the ngPattern directive.
>, <Line: -   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: -   *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: -   *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: -   *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: -   *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="url-input-directive" module="urlExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('urlExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -         </script>
>, <Line: -         <form name="myForm" ng-controller="ExampleController">
>, <Line: -           URL: <input type="url" name="input" ng-model="text" required>
>, <Line: -           <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -             Required!</span>
>, <Line: -           <span class="error" ng-show="myForm.input.$error.url">
>, <Line: -             Not valid url!</span>
>, <Line: -           <tt>text = {{text}}</tt><br/>
>, <Line: -           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
>, <Line: -          </form>
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          var text = element(by.binding('text'));
>, <Line: -          var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -          var input = element(by.model('text'));
>, <Line: -          it('should initialize to model', function() {
>, <Line: -          it('should be invalid if empty', function() {
>, <Line: -          it('should be invalid if not url', function() {
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'url': urlInputType,
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[email]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Text input with email validation. Sets the `email` validation error key if not a valid email
>, <Line: -   * address.
>, <Line: -   *
>, <Line: -   * <div class="alert alert-warning">
>, <Line: -   * **Note:** `input[email]` uses a regex to validate email addresses that is derived from the regex
>, <Line: -   * used in Chromium. If you need stricter validation (e.g. requiring a top-level domain), you can
>, <Line: -   * use `ng-pattern` or modify the built-in validators (see the {@link guide/forms Forms guide})
>, <Line: -   * </div>
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: -   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: -   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: -   *    `required` when you want to data-bind to the `required` attribute.
>, <Line: -   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: -   *    minlength.
>, <Line: -   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: -   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
>, <Line: -   *    any length.
>, <Line: -   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
>, <Line: -   *    that contains the regular expression body that will be converted to a regular expression
>, <Line: -   *    as in the ngPattern directive.
>, <Line: -   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
>, <Line: -   *    a RegExp found by evaluating the Angular expression given in the attribute value.
>, <Line: -   *    If the expression evaluates to a RegExp object then this is used directly.
>, <Line: -   *    If the expression is a string then it will be converted to a RegExp after wrapping it in `^` and `$`
>, <Line: -   *    characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="email-input-directive" module="emailExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('emailExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -         </script>
>, <Line: -           <form name="myForm" ng-controller="ExampleController">
>, <Line: -             Email: <input type="email" name="input" ng-model="text" required>
>, <Line: -             <span class="error" ng-show="myForm.input.$error.required">
>, <Line: -               Required!</span>
>, <Line: -             <span class="error" ng-show="myForm.input.$error.email">
>, <Line: -               Not valid email!</span>
>, <Line: -             <tt>text = {{text}}</tt><br/>
>, <Line: -             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
>, <Line: -             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
>, <Line: -             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: -             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: -             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
>, <Line: -           </form>
>, <Line: -         </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          var text = element(by.binding('text'));
>, <Line: -          var valid = element(by.binding('myForm.input.$valid'));
>, <Line: -          var input = element(by.model('text'));
>, <Line: -          it('should initialize to model', function() {
>, <Line: -          it('should be invalid if empty', function() {
>, <Line: -            expect(text.getText()).toEqual('text =');
>, <Line: -            expect(valid.getText()).toContain('false');
>, <Line: -          });
>, <Line: -          it('should be invalid if not email', function() {
>, <Line: -            input.clear();
>, <Line: -            input.sendKeys('xxx');
>, <Line: -            expect(valid.getText()).toContain('false');
>, <Line: -          });
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'email': emailInputType,
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[radio]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * HTML radio button.
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string} value The value to which the expression should be set when selected.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   * @param {string} ngValue Angular expression which sets the value to which the expression should
>, <Line: -   *    be set when selected.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="radio-input-directive" module="radioExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('radioExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -               $scope.color = 'blue';
>, <Line: -               $scope.specialValue = {
>, <Line: -                 "id": "12345",
>, <Line: -                 "value": "green"
>, <Line: -               };
>, <Line: -             }]);
>, <Line: -         </script>
>, <Line: -         <form name="myForm" ng-controller="ExampleController">
>, <Line: -           <input type="radio" ng-model="color" value="red">  Red <br/>
>, <Line: -           <input type="radio" ng-model="color" ng-value="specialValue"> Green <br/>
>, <Line: -           <input type="radio" ng-model="color" value="blue"> Blue <br/>
>, <Line: -           <tt>color = {{color | json}}</tt><br/>
>, <Line: -          </form>
>, <Line: -          Note that `ng-value="specialValue"` sets radio item's value to be the value of `$scope.specialValue`.
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          it('should change state', function() {
>, <Line: -            var color = element(by.binding('color'));
>, <Line: -            expect(color.getText()).toContain('blue');
>, <Line: -            element.all(by.model('color')).get(0).click();
>, <Line: -            expect(color.getText()).toContain('red');
>, <Line: -          });
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'radio': radioInputType,
>, <Line: -  /**
>, <Line: -   * @ngdoc input
>, <Line: -   * @name input[checkbox]
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * HTML checkbox.
>, <Line: -   *
>, <Line: -   * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: -   * @param {string=} name Property name of the form under which the control is published.
>, <Line: -   * @param {expression=} ngTrueValue The value to which the expression should be set when selected.
>, <Line: -   * @param {expression=} ngFalseValue The value to which the expression should be set when not selected.
>, <Line: -   * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: -   *    interaction with the input element.
>, <Line: -   *
>, <Line: -   * @example
>, <Line: -      <example name="checkbox-input-directive" module="checkboxExample">
>, <Line: -        <file name="index.html">
>, <Line: -         <script>
>, <Line: -           angular.module('checkboxExample', [])
>, <Line: -             .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -               $scope.value1 = true;
>, <Line: -               $scope.value2 = 'YES'
>, <Line: -             }]);
>, <Line: -         </script>
>, <Line: -         <form name="myForm" ng-controller="ExampleController">
>, <Line: -           Value1: <input type="checkbox" ng-model="value1"> <br/>
>, <Line: -           Value2: <input type="checkbox" ng-model="value2"
>, <Line: -                          ng-true-value="'YES'" ng-false-value="'NO'"> <br/>
>, <Line: -           <tt>value1 = {{value1}}</tt><br/>
>, <Line: -           <tt>value2 = {{value2}}</tt><br/>
>, <Line: -          </form>
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          it('should change state', function() {
>, <Line: -            var value1 = element(by.binding('value1'));
>, <Line: -            var value2 = element(by.binding('value2'));
>, <Line: -            expect(value1.getText()).toContain('true');
>, <Line: -            expect(value2.getText()).toContain('YES');
>, <Line: -            element(by.model('value1')).click();
>, <Line: -            element(by.model('value2')).click();
>, <Line: -            expect(value1.getText()).toContain('false');
>, <Line: -            expect(value2.getText()).toContain('NO');
>, <Line: -          });
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -   */
>, <Line: -  'checkbox': checkboxInputType,
>, <Line: -  'hidden': noop,
>, <Line: -  'button': noop,
>, <Line: -  'submit': noop,
>, <Line: -  'reset': noop,
>, <Line: -  'file': noop
>, <Line: -};
>, <Line: -function stringBasedInputType(ctrl) {
>, <Line: -  ctrl.$formatters.push(function(value) {
>, <Line: -    return ctrl.$isEmpty(value) ? value : value.toString();
>, <Line: -  });
>, <Line: -}
>, <Line: -function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: -  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: -  stringBasedInputType(ctrl);
>, <Line: -}
>, <Line: -function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: -  var placeholder = element[0].placeholder, noevent = {};
>, <Line: -  var type = lowercase(element[0].type);
>, <Line: -  // In composition mode, users are still inputing intermediate text buffer,
>, <Line: -  // hold the listener until composition is done.
>, <Line: -  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
>, <Line: -  if (!$sniffer.android) {
>, <Line: -    var composing = false;
>, <Line: -    element.on('compositionstart', function(data) {
>, <Line: -      composing = true;
>, <Line: -    });
>, <Line: -    element.on('compositionend', function() {
>, <Line: -      composing = false;
>, <Line: -      listener();
>, <Line: -    });
>, <Line: -  }
>, <Line: -  var listener = function(ev) {
>, <Line: -    if (composing) return;
>, <Line: -    var value = element.val(),
>, <Line: -        event = ev && ev.type;
>, <Line: -    // IE (11 and under) seem to emit an 'input' event if the placeholder value changes.
>, <Line: -    // We don't want to dirty the value when this happens, so we abort here. Unfortunately,
>, <Line: -    // IE also sends input events for other non-input-related things, (such as focusing on a
>, <Line: -    // form control), so this change is not entirely enough to solve this.
>, <Line: -    if (msie && (ev || noevent).type === 'input' && element[0].placeholder !== placeholder) {
>, <Line: -      placeholder = element[0].placeholder;
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    // By default we will trim the value
>, <Line: -    // If the attribute ng-trim exists we will avoid trimming
>, <Line: -    // If input type is 'password', the value is never trimmed
>, <Line: -    if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
>, <Line: -      value = trim(value);
>, <Line: -    }
>, <Line: -    // If a control is suffering from bad input (due to native validators), browsers discard its
>, <Line: -    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
>, <Line: -    // control's value is the same empty value twice in a row.
>, <Line: -    if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
>, <Line: -      ctrl.$setViewValue(value, event);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
>, <Line: -  // input event on backspace, delete or cut
>, <Line: -  if ($sniffer.hasEvent('input')) {
>, <Line: -    element.on('input', listener);
>, <Line: -  } else {
>, <Line: -    var timeout;
>, <Line: -    var deferListener = function(ev) {
>, <Line: -      if (!timeout) {
>, <Line: -        timeout = $browser.defer(function() {
>, <Line: -          listener(ev);
>, <Line: -          timeout = null;
>, <Line: -        });
>, <Line: -      }
>, <Line: -    };
>, <Line: -    element.on('keydown', function(event) {
>, <Line: -      var key = event.keyCode;
>, <Line: -      // ignore
>, <Line: -      //    command            modifiers                   arrows
>, <Line: -      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;
>, <Line: -      deferListener(event);
>, <Line: -    });
>, <Line: -    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
>, <Line: -    if ($sniffer.hasEvent('paste')) {
>, <Line: -      element.on('paste cut', deferListener);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  // if user paste into input using mouse on older browser
>, <Line: -  // or form autocomplete on newer browser, we need "change" event to catch it
>, <Line: -  element.on('change', listener);
>, <Line: -  ctrl.$render = function() {
>, <Line: -    element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
>, <Line: -  };
>, <Line: -}
>, <Line: -function weekParser(isoWeek, existingDate) {
>, <Line: -  if (isDate(isoWeek)) {
>, <Line: -    return isoWeek;
>, <Line: -  }
>, <Line: -  if (isString(isoWeek)) {
>, <Line: -    WEEK_REGEXP.lastIndex = 0;
>, <Line: -    var parts = WEEK_REGEXP.exec(isoWeek);
>, <Line: -    if (parts) {
>, <Line: -      var year = +parts[1],
>, <Line: -          week = +parts[2],
>, <Line: -          hours = 0,
>, <Line: -          minutes = 0,
>, <Line: -          seconds = 0,
>, <Line: -          milliseconds = 0,
>, <Line: -          firstThurs = getFirstThursdayOfYear(year),
>, <Line: -          addDays = (week - 1) * 7;
>, <Line: -      if (existingDate) {
>, <Line: -        hours = existingDate.getHours();
>, <Line: -        minutes = existingDate.getMinutes();
>, <Line: -        seconds = existingDate.getSeconds();
>, <Line: -        milliseconds = existingDate.getMilliseconds();
>, <Line: -      }
>, <Line: -      return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return NaN;
>, <Line: -}
>, <Line: -function createDateParser(regexp, mapping) {
>, <Line: -  return function(iso, date) {
>, <Line: -    var parts, map;
>, <Line: -    if (isDate(iso)) {
>, <Line: -      return iso;
>, <Line: -    }
>, <Line: -    if (isString(iso)) {
>, <Line: -      // When a date is JSON'ified to wraps itself inside of an extra
>, <Line: -      // set of double quotes. This makes the date parsing code unable
>, <Line: -      // to match the date string and parse it as a date.
>, <Line: -      if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
>, <Line: -        iso = iso.substring(1, iso.length - 1);
>, <Line: -      }
>, <Line: -      if (ISO_DATE_REGEXP.test(iso)) {
>, <Line: -        return new Date(iso);
>, <Line: -      }
>, <Line: -      regexp.lastIndex = 0;
>, <Line: -      parts = regexp.exec(iso);
>, <Line: -      if (parts) {
>, <Line: -        parts.shift();
>, <Line: -        if (date) {
>, <Line: -          map = {
>, <Line: -            yyyy: date.getFullYear(),
>, <Line: -            MM: date.getMonth() + 1,
>, <Line: -            dd: date.getDate(),
>, <Line: -            HH: date.getHours(),
>, <Line: -            mm: date.getMinutes(),
>, <Line: -            ss: date.getSeconds(),
>, <Line: -            sss: date.getMilliseconds() / 1000
>, <Line: -          };
>, <Line: -        } else {
>, <Line: -          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
>, <Line: -        }
>, <Line: -        forEach(parts, function(part, index) {
>, <Line: -          if (index < mapping.length) {
>, <Line: -            map[mapping[index]] = +part;
>, <Line: -          }
>, <Line: -        });
>, <Line: -        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return NaN;
>, <Line: -  };
>, <Line: -}
>, <Line: -function createDateInputType(type, regexp, parseDate, format) {
>, <Line: -  return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
>, <Line: -    badInputChecker(scope, element, attr, ctrl);
>, <Line: -    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: -    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
>, <Line: -    var previousDate;
>, <Line: -    ctrl.$$parserName = type;
>, <Line: -    ctrl.$parsers.push(function(value) {
>, <Line: -      if (ctrl.$isEmpty(value)) return null;
>, <Line: -      if (regexp.test(value)) {
>, <Line: -        // Note: We cannot read ctrl.$modelValue, as there might be a different
>, <Line: -        // parser/formatter in the processing chain so that the model
>, <Line: -        // contains some different data format!
>, <Line: -        var parsedDate = parseDate(value, previousDate);
>, <Line: -        if (timezone === 'UTC') {
>, <Line: -          parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
>, <Line: -        }
>, <Line: -        return parsedDate;
>, <Line: -      }
>, <Line: -      return undefined;
>, <Line: -    });
>, <Line: -    ctrl.$formatters.push(function(value) {
>, <Line: -      if (value && !isDate(value)) {
>, <Line: -        throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
>, <Line: -      }
>, <Line: -      if (isValidDate(value)) {
>, <Line: -        previousDate = value;
>, <Line: -        if (previousDate && timezone === 'UTC') {
>, <Line: -          var timezoneOffset = 60000 * previousDate.getTimezoneOffset();
>, <Line: -          previousDate = new Date(previousDate.getTime() + timezoneOffset);
>, <Line: -        }
>, <Line: -        return $filter('date')(value, format, timezone);
>, <Line: -      } else {
>, <Line: -        previousDate = null;
>, <Line: -        return '';
>, <Line: -      }
>, <Line: -    });
>, <Line: -    if (isDefined(attr.min) || attr.ngMin) {
>, <Line: -      var minVal;
>, <Line: -      ctrl.$validators.min = function(value) {
>, <Line: -        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
>, <Line: -      };
>, <Line: -      attr.$observe('min', function(val) {
>, <Line: -        minVal = parseObservedDateValue(val);
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -    }
>, <Line: -    if (isDefined(attr.max) || attr.ngMax) {
>, <Line: -      var maxVal;
>, <Line: -      ctrl.$validators.max = function(value) {
>, <Line: -        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
>, <Line: -      };
>, <Line: -      attr.$observe('max', function(val) {
>, <Line: -        maxVal = parseObservedDateValue(val);
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -    }
>, <Line: -    function isValidDate(value) {
>, <Line: -      // Invalid Date: getTime() returns NaN
>, <Line: -      return value && !(value.getTime && value.getTime() !== value.getTime());
>, <Line: -    }
>, <Line: -    function parseObservedDateValue(val) {
>, <Line: -      return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
>, <Line: -    }
>, <Line: -  };
>, <Line: -}
>, <Line: -function badInputChecker(scope, element, attr, ctrl) {
>, <Line: -  var node = element[0];
>, <Line: -  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
>, <Line: -  if (nativeValidation) {
>, <Line: -    ctrl.$parsers.push(function(value) {
>, <Line: -      var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
>, <Line: -      // Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):
>, <Line: -      // - also sets validity.badInput (should only be validity.typeMismatch).
>, <Line: -      // - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)
>, <Line: -      // - can ignore this case as we can still read out the erroneous email...
>, <Line: -      return validity.badInput && !validity.typeMismatch ? undefined : value;
>, <Line: -    });
>, <Line: -  }
>, <Line: -}
>, <Line: -function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: -  badInputChecker(scope, element, attr, ctrl);
>, <Line: -  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: -  ctrl.$$parserName = 'number';
>, <Line: -  ctrl.$parsers.push(function(value) {
>, <Line: -    if (ctrl.$isEmpty(value))      return null;
>, <Line: -    if (NUMBER_REGEXP.test(value)) return parseFloat(value);
>, <Line: -    return undefined;
>, <Line: -  });
>, <Line: -  ctrl.$formatters.push(function(value) {
>, <Line: -    if (!ctrl.$isEmpty(value)) {
>, <Line: -      if (!isNumber(value)) {
>, <Line: -        throw $ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
>, <Line: -      }
>, <Line: -      value = value.toString();
>, <Line: -    }
>, <Line: -    return value;
>, <Line: -  });
>, <Line: -  if (attr.min || attr.ngMin) {
>, <Line: -    var minVal;
>, <Line: -    ctrl.$validators.min = function(value) {
>, <Line: -      return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
>, <Line: -    };
>, <Line: -    attr.$observe('min', function(val) {
>, <Line: -      if (isDefined(val) && !isNumber(val)) {
>, <Line: -        val = parseFloat(val, 10);
>, <Line: -      }
>, <Line: -      minVal = isNumber(val) && !isNaN(val) ? val : undefined;
>, <Line: -      // TODO(matsko): implement validateLater to reduce number of validations
>, <Line: -      ctrl.$validate();
>, <Line: -    });
>, <Line: -  }
>, <Line: -  if (attr.max || attr.ngMax) {
>, <Line: -    var maxVal;
>, <Line: -    ctrl.$validators.max = function(value) {
>, <Line: -      return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
>, <Line: -    };
>, <Line: -    attr.$observe('max', function(val) {
>, <Line: -      if (isDefined(val) && !isNumber(val)) {
>, <Line: -        val = parseFloat(val, 10);
>, <Line: -      }
>, <Line: -      maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
>, <Line: -      // TODO(matsko): implement validateLater to reduce number of validations
>, <Line: -      ctrl.$validate();
>, <Line: -    });
>, <Line: -  }
>, <Line: -}
>, <Line: -function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: -  // Note: no badInputChecker here by purpose as `url` is only a validation
>, <Line: -  // in browsers, i.e. we can always read out input.value even if it is not valid!
>, <Line: -  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: -  stringBasedInputType(ctrl);
>, <Line: -  ctrl.$$parserName = 'url';
>, <Line: -  ctrl.$validators.url = function(modelValue, viewValue) {
>, <Line: -    var value = modelValue || viewValue;
>, <Line: -    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
>, <Line: -  };
>, <Line: -}
>, <Line: -function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
>, <Line: -  // Note: no badInputChecker here by purpose as `url` is only a validation
>, <Line: -  // in browsers, i.e. we can always read out input.value even if it is not valid!
>, <Line: -  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
>, <Line: -  stringBasedInputType(ctrl);
>, <Line: -  ctrl.$$parserName = 'email';
>, <Line: -  ctrl.$validators.email = function(modelValue, viewValue) {
>, <Line: -    var value = modelValue || viewValue;
>, <Line: -    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
>, <Line: -  };
>, <Line: -}
>, <Line: -function radioInputType(scope, element, attr, ctrl) {
>, <Line: -  // make the name unique, if not defined
>, <Line: -  if (isUndefined(attr.name)) {
>, <Line: -    element.attr('name', nextUid());
>, <Line: -  }
>, <Line: -  var listener = function(ev) {
>, <Line: -    if (element[0].checked) {
>, <Line: -      ctrl.$setViewValue(attr.value, ev && ev.type);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  element.on('click', listener);
>, <Line: -  ctrl.$render = function() {
>, <Line: -    var value = attr.value;
>, <Line: -    element[0].checked = (value == ctrl.$viewValue);
>, <Line: -  };
>, <Line: -  attr.$observe('value', ctrl.$render);
>, <Line: -}
>, <Line: -function parseConstantExpr($parse, context, name, expression, fallback) {
>, <Line: -  var parseFn;
>, <Line: -  if (isDefined(expression)) {
>, <Line: -    parseFn = $parse(expression);
>, <Line: -    if (!parseFn.constant) {
>, <Line: -      throw minErr('ngModel')('constexpr', 'Expected constant expression for `{0}`, but saw ' +
>, <Line: -                                   '`{1}`.', name, expression);
>, <Line: -    }
>, <Line: -    return parseFn(context);
>, <Line: -  }
>, <Line: -  return fallback;
>, <Line: -}
>, <Line: -function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
>, <Line: -  var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
>, <Line: -  var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
>, <Line: -  var listener = function(ev) {
>, <Line: -    ctrl.$setViewValue(element[0].checked, ev && ev.type);
>, <Line: -  };
>, <Line: -  element.on('click', listener);
>, <Line: -  ctrl.$render = function() {
>, <Line: -    element[0].checked = ctrl.$viewValue;
>, <Line: -  };
>, <Line: -  // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
>, <Line: -  // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
>, <Line: -  // it to a boolean.
>, <Line: -  ctrl.$isEmpty = function(value) {
>, <Line: -    return value === false;
>, <Line: -  };
>, <Line: -  ctrl.$formatters.push(function(value) {
>, <Line: -    return equals(value, trueValue);
>, <Line: -  });
>, <Line: -  ctrl.$parsers.push(function(value) {
>, <Line: -    return value ? trueValue : falseValue;
>, <Line: -  });
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name textarea
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * HTML textarea element control with angular data-binding. The data-binding and validation
>, <Line: - * properties of this element are exactly the same as those of the
>, <Line: - * {@link ng.directive:input input element}.
>, <Line: - *
>, <Line: - * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: - * @param {string=} name Property name of the form under which the control is published.
>, <Line: - * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: - * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: - *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: - *    `required` when you want to data-bind to the `required` attribute.
>, <Line: - * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: - *    minlength.
>, <Line: - * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: - *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
>, <Line: - *    length.
>, <Line: - * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
>, <Line: - *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
>, <Line: - *    patterns defined as scope expressions.
>, <Line: - * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: - *    interaction with the input element.
>, <Line: - * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name input
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * HTML input element control. When used together with {@link ngModel `ngModel`}, it provides data-binding,
>, <Line: - * input state control, and validation.
>, <Line: - * Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** Not every feature offered is available for all input types.
>, <Line: - * Specifically, data binding and event handling via `ng-model` is unsupported for `input[file]`.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: - * @param {string=} name Property name of the form under which the control is published.
>, <Line: - * @param {string=} required Sets `required` validation error key if the value is not entered.
>, <Line: - * @param {boolean=} ngRequired Sets `required` attribute if set to true
>, <Line: - * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
>, <Line: - *    minlength.
>, <Line: - * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
>, <Line: - *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
>, <Line: - *    length.
>, <Line: - * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
>, <Line: - *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
>, <Line: - *    patterns defined as scope expressions.
>, <Line: - * @param {string=} ngChange Angular expression to be executed when input changes due to user
>, <Line: - *    interaction with the input element.
>, <Line: - * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
>, <Line: - *    This parameter is ignored for input[type=password] controls, which will never trim the
>, <Line: - *    input.
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example name="input-directive" module="inputExample">
>, <Line: -      <file name="index.html">
>, <Line: -       <script>
>, <Line: -          angular.module('inputExample', [])
>, <Line: -            .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <form name="myForm">
>, <Line: -           User name: <input type="text" name="userName" ng-model="user.name" required>
>, <Line: -           <span class="error" ng-show="myForm.userName.$error.required">
>, <Line: -             Required!</span><br>
>, <Line: -           Last name: <input type="text" name="lastName" ng-model="user.last"
>, <Line: -             ng-minlength="3" ng-maxlength="10">
>, <Line: -           <span class="error" ng-show="myForm.lastName.$error.minlength">
>, <Line: -             Too short!</span>
>, <Line: -           <span class="error" ng-show="myForm.lastName.$error.maxlength">
>, <Line: -             Too long!</span><br>
>, <Line: -         </form>
>, <Line: -         <hr>
>, <Line: -         <tt>user = {{user}}</tt><br/>
>, <Line: -         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
>, <Line: -         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
>, <Line: -         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
>, <Line: -         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
>, <Line: -         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
>, <Line: -         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
>, <Line: -         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
>, <Line: -         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
>, <Line: -       </div>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        var user = element(by.exactBinding('user'));
>, <Line: -        var userNameValid = element(by.binding('myForm.userName.$valid'));
>, <Line: -        var lastNameValid = element(by.binding('myForm.lastName.$valid'));
>, <Line: -        var lastNameError = element(by.binding('myForm.lastName.$error'));
>, <Line: -        var formValid = element(by.binding('myForm.$valid'));
>, <Line: -        var userNameInput = element(by.model('user.name'));
>, <Line: -        var userLastInput = element(by.model('user.last'));
>, <Line: -        it('should initialize to model', function() {
>, <Line: -        it('should be invalid if empty when required', function() {
>, <Line: -        it('should be valid if empty when min length is set', function() {
>, <Line: -        it('should be invalid if less than required min length', function() {
>, <Line: -        it('should be invalid if longer than max length', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
>, <Line: -    function($browser, $sniffer, $filter, $parse) {
>, <Line: -  return {
>, <Line: -    restrict: 'E',
>, <Line: -    require: ['?ngModel'],
>, <Line: -    link: {
>, <Line: -      pre: function(scope, element, attr, ctrls) {
>, <Line: -        if (ctrls[0]) {
>, <Line: -          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
>, <Line: -                                                              $browser, $filter, $parse);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var VALID_CLASS = 'ng-valid',
>, <Line: -    INVALID_CLASS = 'ng-invalid',
>, <Line: -    PRISTINE_CLASS = 'ng-pristine',
>, <Line: -    DIRTY_CLASS = 'ng-dirty',
>, <Line: -    UNTOUCHED_CLASS = 'ng-untouched',
>, <Line: -    TOUCHED_CLASS = 'ng-touched',
>, <Line: -    PENDING_CLASS = 'ng-pending';
>, <Line: -/**
>, <Line: - * @ngdoc type
>, <Line: - * @name ngModel.NgModelController
>, <Line: - *
>, <Line: - * @property {string} $viewValue Actual string value in the view.
>, <Line: - * @property {*} $modelValue The value in the model that the control is bound to.
>, <Line: - * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
>, <Line: -       the control reads value from the DOM. The functions are called in array order, each passing
>, <Line: -       its return value through to the next. The last return value is forwarded to the
>, <Line: -       {@link ngModel.NgModelController#$validators `$validators`} collection.
>, <Line: -Parsers are used to sanitize / convert the {@link ngModel.NgModelController#$viewValue
>, <Line: -Returning `undefined` from a parser means a parse error occurred. In that case,
>, <Line: -no {@link ngModel.NgModelController#$validators `$validators`} will run and the `ngModel`
>, <Line: -will be set to `undefined` unless {@link ngModelOptions `ngModelOptions.allowInvalid`}
>, <Line: -is set to `true`. The parse error is stored in `ngModel.$error.parse`.
>, <Line: - *
>, <Line: - * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
>, <Line: -       the model value changes. The functions are called in reverse array order, each passing the value through to the
>, <Line: -       next. The last return value is used as the actual DOM value.
>, <Line: -       Used to format / convert values for display in the control.
>, <Line: - * ```js
>, <Line: - * function formatter(value) {
>, <Line: - * ngModel.$formatters.push(formatter);
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @property {Object.<string, function>} $validators A collection of validators that are applied
>, <Line: - *      whenever the model value changes. The key value within the object refers to the name of the
>, <Line: - *      validator while the function refers to the validation operation. The validation operation is
>, <Line: - *      provided with the model value as an argument and must return a true or false value depending
>, <Line: - *      on the response of that validation.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * ngModel.$validators.validCharacters = function(modelValue, viewValue) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @property {Object.<string, function>} $asyncValidators A collection of validations that are expected to
>, <Line: - *      perform an asynchronous validation (e.g. a HTTP request). The validation function that is provided
>, <Line: - *      is expected to return a promise when it is run during the model validation process. Once the promise
>, <Line: - *      is delivered then the validation status will be set to true when fulfilled and false when rejected.
>, <Line: - *      When the asynchronous validators are triggered, each of the validators will run in parallel and the model
>, <Line: - *      value will only be updated once all validators have been fulfilled. As long as an asynchronous validator
>, <Line: - *      is unfulfilled, its key will be added to the controllers `$pending` property. Also, all asynchronous validators
>, <Line: - *      will only run once all synchronous validators have passed.
>, <Line: - *
>, <Line: - * Please note that if $http is used then it is important that the server returns a success HTTP response code
>, <Line: - * in order to fulfill the validation and a status level of `4xx` in order to reject the validation.
>, <Line: - *
>, <Line: - * ```js
>, <Line: - * ngModel.$asyncValidators.uniqueUsername = function(modelValue, viewValue) {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever the
>, <Line: - *     view value has changed. It is called with no arguments, and its return value is ignored.
>, <Line: - *     This can be used in place of additional $watches against the model value.
>, <Line: - *
>, <Line: - * @property {Object} $error An object hash with all failing validator ids as keys.
>, <Line: - * @property {Object} $pending An object hash with all pending validator ids as keys.
>, <Line: - *
>, <Line: - * @property {boolean} $untouched True if control has not lost focus yet.
>, <Line: - * @property {boolean} $touched True if control has lost focus.
>, <Line: - * @property {boolean} $pristine True if user has not interacted with the control yet.
>, <Line: - * @property {boolean} $dirty True if user has already interacted with the control.
>, <Line: - * @property {boolean} $valid True if there is no error.
>, <Line: - * @property {boolean} $invalid True if at least one error on the control.
>, <Line: - * @property {string} $name The name attribute of the control.
>, <Line: - *
>, <Line: - * @description
>, <Line: - *
>, <Line: - * `NgModelController` provides API for the {@link ngModel `ngModel`} directive.
>, <Line: - * The controller contains services for data-binding, validation, CSS updates, and value formatting
>, <Line: - * and parsing. It purposefully does not contain any logic which deals with DOM rendering or
>, <Line: - * listening to DOM events.
>, <Line: - * Such DOM related logic should be provided by other directives which make use of
>, <Line: - * `NgModelController` for data-binding to control elements.
>, <Line: - * Angular provides this DOM logic for most {@link input `input`} elements.
>, <Line: - * At the end of this page you can find a {@link ngModel.NgModelController#custom-control-example
>, <Line: - *
>, <Line: - * @example
>, <Line: - * ### Custom Control Example
>, <Line: - * This example shows how to use `NgModelController` with a custom control to achieve
>, <Line: - * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
>, <Line: - * collaborate together to achieve the desired result.
>, <Line: - *
>, <Line: - * Note that `contenteditable` is an HTML5 attribute, which tells the browser to let the element
>, <Line: - * contents be edited in place by the user.  This will not work on older browsers.
>, <Line: - *
>, <Line: - * We are using the {@link ng.service:$sce $sce} service here and include the {@link ngSanitize $sanitize}
>, <Line: - * module to automatically remove "bad" content like inline event listener (e.g. `<span onclick="...">`).
>, <Line: - * However, as we are using `$sce` the model can still decide to provide unsafe content if it marks
>, <Line: - * that content using the `$sce` service.
>, <Line: - *
>, <Line: - * <example name="NgModelController" module="customControl" deps="angular-sanitize.js">
>, <Line: -    <file name="style.css">
>, <Line: -      [contenteditable] {
>, <Line: -      .ng-invalid {
>, <Line: -    </file>
>, <Line: -    <file name="script.js">
>, <Line: -      angular.module('customControl', ['ngSanitize']).
>, <Line: -        directive('contenteditable', ['$sce', function($sce) {
>, <Line: -    </file>
>, <Line: -    <file name="index.html">
>, <Line: -      <form name="myForm">
>, <Line: -       <div contenteditable
>, <Line: -            name="myWidget" ng-model="userContent"
>, <Line: -            strip-br="true"
>, <Line: -            required>Change me!</div>
>, <Line: -        <span ng-show="myForm.myWidget.$error.required">Required!</span>
>, <Line: -       <hr>
>, <Line: -       <textarea ng-model="userContent"></textarea>
>, <Line: -      </form>
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -    it('should data-bind and become invalid', function() {
>, <Line: -    </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - *
>, <Line: - */
>, <Line: -var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate',
>, <Line: -    function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
>, <Line: -  this.$viewValue = Number.NaN;
>, <Line: -  this.$modelValue = Number.NaN;
>, <Line: -  this.$$rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.
>, <Line: -  this.$validators = {};
>, <Line: -  this.$asyncValidators = {};
>, <Line: -  this.$parsers = [];
>, <Line: -  this.$formatters = [];
>, <Line: -  this.$viewChangeListeners = [];
>, <Line: -  this.$untouched = true;
>, <Line: -  this.$touched = false;
>, <Line: -  this.$pristine = true;
>, <Line: -  this.$dirty = false;
>, <Line: -  this.$valid = true;
>, <Line: -  this.$invalid = false;
>, <Line: -  this.$error = {}; // keep invalid keys here
>, <Line: -  this.$$success = {}; // keep valid keys here
>, <Line: -  this.$pending = undefined; // keep pending keys here
>, <Line: -  this.$name = $interpolate($attr.name || '', false)($scope);
>, <Line: -  var parsedNgModel = $parse($attr.ngModel),
>, <Line: -      parsedNgModelAssign = parsedNgModel.assign,
>, <Line: -      ngModelGet = parsedNgModel,
>, <Line: -      ngModelSet = parsedNgModelAssign,
>, <Line: -      pendingDebounce = null,
>, <Line: -      ctrl = this;
>, <Line: -  this.$$setOptions = function(options) {
>, <Line: -    ctrl.$options = options;
>, <Line: -    if (options && options.getterSetter) {
>, <Line: -      var invokeModelGetter = $parse($attr.ngModel + '()'),
>, <Line: -          invokeModelSetter = $parse($attr.ngModel + '($$$p)');
>, <Line: -      ngModelGet = function($scope) {
>, <Line: -        var modelValue = parsedNgModel($scope);
>, <Line: -        if (isFunction(modelValue)) {
>, <Line: -          modelValue = invokeModelGetter($scope);
>, <Line: -        }
>, <Line: -        return modelValue;
>, <Line: -      };
>, <Line: -      ngModelSet = function($scope, newValue) {
>, <Line: -        if (isFunction(parsedNgModel($scope))) {
>, <Line: -          invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
>, <Line: -        } else {
>, <Line: -          parsedNgModelAssign($scope, ctrl.$modelValue);
>, <Line: -        }
>, <Line: -      };
>, <Line: -    } else if (!parsedNgModel.assign) {
>, <Line: -      throw $ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
>, <Line: -          $attr.ngModel, startingTag($element));
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$render
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Called when the view needs to be updated. It is expected that the user of the ng-model
>, <Line: -   * directive will implement this method.
>, <Line: -   *
>, <Line: -   * The `$render()` method is invoked in the following situations:
>, <Line: -   *
>, <Line: -   * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
>, <Line: -   *   committed value then `$render()` is called to update the input control.
>, <Line: -   * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
>, <Line: -   *   the `$viewValue` are different to last time.
>, <Line: -   *
>, <Line: -   * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
>, <Line: -   * `$modelValue` and `$viewValue` are actually different to their previous value. If `$modelValue`
>, <Line: -   * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
>, <Line: -   * invoked if you only change a property on the objects.
>, <Line: -   */
>, <Line: -  this.$render = noop;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$isEmpty
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * This is called when we need to determine if the value of an input is empty.
>, <Line: -   *
>, <Line: -   * For instance, the required directive does this to work out if the input has data or not.
>, <Line: -   *
>, <Line: -   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
>, <Line: -   *
>, <Line: -   * You can override this for input directives whose concept of being empty is different to the
>, <Line: -   * default. The `checkboxInputType` directive does this because in its case a value of `false`
>, <Line: -   * implies empty.
>, <Line: -   *
>, <Line: -   * @param {*} value The value of the input to check for emptiness.
>, <Line: -   * @returns {boolean} True if `value` is "empty".
>, <Line: -   */
>, <Line: -  this.$isEmpty = function(value) {
>, <Line: -    return isUndefined(value) || value === '' || value === null || value !== value;
>, <Line: -  };
>, <Line: -  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
>, <Line: -      currentValidationRunId = 0;
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setValidity
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Change the validity state, and notify the form.
>, <Line: -   *
>, <Line: -   * This method can be called within $parsers/$formatters or a custom validation implementation.
>, <Line: -   * However, in most cases it should be sufficient to use the `ngModel.$validators` and
>, <Line: -   * `ngModel.$asyncValidators` collections which will call `$setValidity` automatically.
>, <Line: -   *
>, <Line: -   * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be assigned
>, <Line: -   *        to either `$error[validationErrorKey]` or `$pending[validationErrorKey]`
>, <Line: -   *        (for unfulfilled `$asyncValidators`), so that it is available for data-binding.
>, <Line: -   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
>, <Line: -   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
>, <Line: -   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
>, <Line: -   * @param {boolean} isValid Whether the current state is valid (true), invalid (false), pending (undefined),
>, <Line: -   *                          or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
>, <Line: -   *                          Skipped is used by Angular when validators do not run because of parse errors and
>, <Line: -   *                          when `$asyncValidators` do not run because any of the `$validators` failed.
>, <Line: -   */
>, <Line: -  addSetValidityMethod({
>, <Line: -    ctrl: this,
>, <Line: -    $element: $element,
>, <Line: -    set: function(object, property) {
>, <Line: -      object[property] = true;
>, <Line: -    },
>, <Line: -    unset: function(object, property) {
>, <Line: -      delete object[property];
>, <Line: -    },
>, <Line: -    parentForm: parentForm,
>, <Line: -    $animate: $animate
>, <Line: -  });
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setPristine
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the control to its pristine state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the `ng-dirty` class and set the control to its pristine
>, <Line: -   * state (`ng-pristine` class). A model is considered to be pristine when the control
>, <Line: -   * has not been changed from when first compiled.
>, <Line: -   */
>, <Line: -  this.$setPristine = function() {
>, <Line: -    ctrl.$dirty = false;
>, <Line: -    ctrl.$pristine = true;
>, <Line: -    $animate.removeClass($element, DIRTY_CLASS);
>, <Line: -    $animate.addClass($element, PRISTINE_CLASS);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setDirty
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the control to its dirty state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the `ng-pristine` class and set the control to its dirty
>, <Line: -   * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
>, <Line: -   * from when first compiled.
>, <Line: -   */
>, <Line: -  this.$setDirty = function() {
>, <Line: -    ctrl.$dirty = true;
>, <Line: -    ctrl.$pristine = false;
>, <Line: -    $animate.removeClass($element, PRISTINE_CLASS);
>, <Line: -    $animate.addClass($element, DIRTY_CLASS);
>, <Line: -    parentForm.$setDirty();
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setUntouched
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the control to its untouched state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the `ng-touched` class and set the control to its
>, <Line: -   * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
>, <Line: -   * by default, however this function can be used to restore that state if the model has
>, <Line: -   * already been touched by the user.
>, <Line: -   */
>, <Line: -  this.$setUntouched = function() {
>, <Line: -    ctrl.$touched = false;
>, <Line: -    ctrl.$untouched = true;
>, <Line: -    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setTouched
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Sets the control to its touched state.
>, <Line: -   *
>, <Line: -   * This method can be called to remove the `ng-untouched` class and set the control to its
>, <Line: -   * touched state (`ng-touched` class). A model is considered to be touched when the user has
>, <Line: -   * first focused the control element and then shifted focus away from the control (blur event).
>, <Line: -   */
>, <Line: -  this.$setTouched = function() {
>, <Line: -    ctrl.$touched = true;
>, <Line: -    ctrl.$untouched = false;
>, <Line: -    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$rollbackViewValue
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
>, <Line: -   * which may be caused by a pending debounced event or because the input is waiting for a some
>, <Line: -   * future event.
>, <Line: -   *
>, <Line: -   * If you have an input that uses `ng-model-options` to set up debounced events or events such
>, <Line: -   * as blur you can have a situation where there is a period when the `$viewValue`
>, <Line: -   * is out of synch with the ngModel's `$modelValue`.
>, <Line: -   *
>, <Line: -   * In this case, you can run into difficulties if you try to update the ngModel's `$modelValue`
>, <Line: -   * programmatically before these debounced/future events have resolved/occurred, because Angular's
>, <Line: -   * dirty checking mechanism is not able to tell whether the model has actually changed or not.
>, <Line: -   *
>, <Line: -   * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
>, <Line: -   * input which may have such events pending. This is important in order to make sure that the
>, <Line: -   * input field will be updated with the new model value and any pending operations are cancelled.
>, <Line: -   *
>, <Line: -   * <example name="ng-model-cancel-update" module="cancel-update-example">
>, <Line: -   *   <file name="app.js">
>, <Line: -   *     angular.module('cancel-update-example', [])
>, <Line: -   *
>, <Line: -   *     .controller('CancelUpdateController', ['$scope', function($scope) {
>, <Line: -   *   </file>
>, <Line: -   *   <file name="index.html">
>, <Line: -   *     <div ng-controller="CancelUpdateController">
>, <Line: -   *       <p>Try typing something in each input.  See that the model only updates when you
>, <Line: -   *          blur off the input.
>, <Line: -   *        </p>
>, <Line: -   *        <p>Now see what happens if you start typing then press the Escape key</p>
>, <Line: -   *
>, <Line: -   *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
>, <Line: -   *         <p>With $rollbackViewValue()</p>
>, <Line: -   *         <input name="myInput1" ng-model="myValue" ng-keydown="resetWithCancel($event)"><br/>
>, <Line: -   *         myValue: "{{ myValue }}"
>, <Line: -   *
>, <Line: -   *         <p>Without $rollbackViewValue()</p>
>, <Line: -   *         <input name="myInput2" ng-model="myValue" ng-keydown="resetWithoutCancel($event)"><br/>
>, <Line: -   *         myValue: "{{ myValue }}"
>, <Line: -   *       </form>
>, <Line: -   *     </div>
>, <Line: -   *   </file>
>, <Line: -   * </example>
>, <Line: -   */
>, <Line: -  this.$rollbackViewValue = function() {
>, <Line: -    $timeout.cancel(pendingDebounce);
>, <Line: -    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: -    ctrl.$render();
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$validate
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Runs each of the registered validators (first synchronous validators and then
>, <Line: -   * asynchronous validators).
>, <Line: -   * If the validity changes to invalid, the model will be set to `undefined`,
>, <Line: -   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
>, <Line: -   * If the validity changes to valid, it will set the model to the last available valid
>, <Line: -   * modelValue, i.e. either the last parsed value or the last value set from the scope.
>, <Line: -   */
>, <Line: -  this.$validate = function() {
>, <Line: -    // ignore $validate before model is initialized
>, <Line: -    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    var viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: -    // Note: we use the $$rawModelValue as $modelValue might have been
>, <Line: -    // set to undefined during a view -> model update that found validation
>, <Line: -    // errors. We can't parse the view here, since that could change
>, <Line: -    // the model although neither viewValue nor the model on the scope changed
>, <Line: -    var modelValue = ctrl.$$rawModelValue;
>, <Line: -    // Check if the there's a parse error, so we don't unset it accidentially
>, <Line: -    var parserName = ctrl.$$parserName || 'parse';
>, <Line: -    var parserValid = ctrl.$error[parserName] ? false : undefined;
>, <Line: -    var prevValid = ctrl.$valid;
>, <Line: -    var prevModelValue = ctrl.$modelValue;
>, <Line: -    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
>, <Line: -    ctrl.$$runValidators(parserValid, modelValue, viewValue, function(allValid) {
>, <Line: -      // If there was no change in validity, don't update the model
>, <Line: -      // This prevents changing an invalid modelValue to undefined
>, <Line: -      if (!allowInvalid && prevValid !== allValid) {
>, <Line: -        // Note: Don't check ctrl.$valid here, as we could have
>, <Line: -        // external validators (e.g. calculated on the server),
>, <Line: -        // that just call $setValidity and need the model value
>, <Line: -        // to calculate their validity.
>, <Line: -        ctrl.$modelValue = allValid ? modelValue : undefined;
>, <Line: -        if (ctrl.$modelValue !== prevModelValue) {
>, <Line: -          ctrl.$$writeModelToScope();
>, <Line: -        }
>, <Line: -      }
>, <Line: -    });
>, <Line: -  };
>, <Line: -  this.$$runValidators = function(parseValid, modelValue, viewValue, doneCallback) {
>, <Line: -    currentValidationRunId++;
>, <Line: -    var localValidationRunId = currentValidationRunId;
>, <Line: -    // check parser error
>, <Line: -    if (!processParseErrors(parseValid)) {
>, <Line: -      validationDone(false);
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    if (!processSyncValidators()) {
>, <Line: -      validationDone(false);
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    processAsyncValidators();
>, <Line: -    function processParseErrors(parseValid) {
>, <Line: -      var errorKey = ctrl.$$parserName || 'parse';
>, <Line: -      if (parseValid === undefined) {
>, <Line: -        setValidity(errorKey, null);
>, <Line: -      } else {
>, <Line: -        setValidity(errorKey, parseValid);
>, <Line: -        if (!parseValid) {
>, <Line: -          forEach(ctrl.$validators, function(v, name) {
>, <Line: -            setValidity(name, null);
>, <Line: -          });
>, <Line: -          forEach(ctrl.$asyncValidators, function(v, name) {
>, <Line: -            setValidity(name, null);
>, <Line: -          });
>, <Line: -          return false;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    function processSyncValidators() {
>, <Line: -      var syncValidatorsValid = true;
>, <Line: -      forEach(ctrl.$validators, function(validator, name) {
>, <Line: -        var result = validator(modelValue, viewValue);
>, <Line: -        syncValidatorsValid = syncValidatorsValid && result;
>, <Line: -        setValidity(name, result);
>, <Line: -      });
>, <Line: -      if (!syncValidatorsValid) {
>, <Line: -        forEach(ctrl.$asyncValidators, function(v, name) {
>, <Line: -          setValidity(name, null);
>, <Line: -        });
>, <Line: -        return false;
>, <Line: -      }
>, <Line: -      return true;
>, <Line: -    }
>, <Line: -    function processAsyncValidators() {
>, <Line: -      var validatorPromises = [];
>, <Line: -      var allValid = true;
>, <Line: -      forEach(ctrl.$asyncValidators, function(validator, name) {
>, <Line: -        var promise = validator(modelValue, viewValue);
>, <Line: -        if (!isPromiseLike(promise)) {
>, <Line: -          throw $ngModelMinErr("$asyncValidators",
>, <Line: -            "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
>, <Line: -        }
>, <Line: -        setValidity(name, undefined);
>, <Line: -        validatorPromises.push(promise.then(function() {
>, <Line: -          setValidity(name, true);
>, <Line: -        }, function(error) {
>, <Line: -          allValid = false;
>, <Line: -          setValidity(name, false);
>, <Line: -        }));
>, <Line: -      });
>, <Line: -      if (!validatorPromises.length) {
>, <Line: -        validationDone(true);
>, <Line: -      } else {
>, <Line: -        $q.all(validatorPromises).then(function() {
>, <Line: -          validationDone(allValid);
>, <Line: -        }, noop);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function setValidity(name, isValid) {
>, <Line: -      if (localValidationRunId === currentValidationRunId) {
>, <Line: -        ctrl.$setValidity(name, isValid);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    function validationDone(allValid) {
>, <Line: -      if (localValidationRunId === currentValidationRunId) {
>, <Line: -        doneCallback(allValid);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$commitViewValue
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Commit a pending update to the `$modelValue`.
>, <Line: -   *
>, <Line: -   * Updates may be pending by a debounced event or because the input is waiting for a some future
>, <Line: -   * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
>, <Line: -   * usually handles calling this in response to input events.
>, <Line: -   */
>, <Line: -  this.$commitViewValue = function() {
>, <Line: -    var viewValue = ctrl.$viewValue;
>, <Line: -    $timeout.cancel(pendingDebounce);
>, <Line: -    // If the view value has not changed then we should just exit, except in the case where there is
>, <Line: -    // a native validator on the element. In this case the validation state may have changed even though
>, <Line: -    // the viewValue has stayed empty.
>, <Line: -    if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
>, <Line: -      return;
>, <Line: -    }
>, <Line: -    ctrl.$$lastCommittedViewValue = viewValue;
>, <Line: -    // change to dirty
>, <Line: -    if (ctrl.$pristine) {
>, <Line: -      this.$setDirty();
>, <Line: -    }
>, <Line: -    this.$$parseAndValidate();
>, <Line: -  };
>, <Line: -  this.$$parseAndValidate = function() {
>, <Line: -    var viewValue = ctrl.$$lastCommittedViewValue;
>, <Line: -    var modelValue = viewValue;
>, <Line: -    var parserValid = isUndefined(modelValue) ? undefined : true;
>, <Line: -    if (parserValid) {
>, <Line: -      for (var i = 0; i < ctrl.$parsers.length; i++) {
>, <Line: -        modelValue = ctrl.$parsers[i](modelValue);
>, <Line: -        if (isUndefined(modelValue)) {
>, <Line: -          parserValid = false;
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
>, <Line: -      // ctrl.$modelValue has not been touched yet...
>, <Line: -      ctrl.$modelValue = ngModelGet($scope);
>, <Line: -    }
>, <Line: -    var prevModelValue = ctrl.$modelValue;
>, <Line: -    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
>, <Line: -    ctrl.$$rawModelValue = modelValue;
>, <Line: -    if (allowInvalid) {
>, <Line: -      ctrl.$modelValue = modelValue;
>, <Line: -      writeToModelIfNeeded();
>, <Line: -    }
>, <Line: -    ctrl.$$runValidators(parserValid, modelValue, viewValue, function(allValid) {
>, <Line: -      if (!allowInvalid) {
>, <Line: -        // Note: Don't check ctrl.$valid here, as we could have
>, <Line: -        // external validators (e.g. calculated on the server),
>, <Line: -        // that just call $setValidity and need the model value
>, <Line: -        // to calculate their validity.
>, <Line: -        ctrl.$modelValue = allValid ? modelValue : undefined;
>, <Line: -        writeToModelIfNeeded();
>, <Line: -      }
>, <Line: -    });
>, <Line: -    function writeToModelIfNeeded() {
>, <Line: -      if (ctrl.$modelValue !== prevModelValue) {
>, <Line: -        ctrl.$$writeModelToScope();
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$$writeModelToScope = function() {
>, <Line: -    ngModelSet($scope, ctrl.$modelValue);
>, <Line: -    forEach(ctrl.$viewChangeListeners, function(listener) {
>, <Line: -      try {
>, <Line: -        listener();
>, <Line: -      } catch (e) {
>, <Line: -        $exceptionHandler(e);
>, <Line: -      }
>, <Line: -    });
>, <Line: -  };
>, <Line: -  /**
>, <Line: -   * @ngdoc method
>, <Line: -   * @name ngModel.NgModelController#$setViewValue
>, <Line: -   *
>, <Line: -   * @description
>, <Line: -   * Update the view value.
>, <Line: -   *
>, <Line: -   * This method should be called when an input directive want to change the view value; typically,
>, <Line: -   * this is done from within a DOM event handler.
>, <Line: -   *
>, <Line: -   * For example {@link ng.directive:input input} calls it when the value of the input changes and
>, <Line: -   * {@link ng.directive:select select} calls it when an option is selected.
>, <Line: -   *
>, <Line: -   * If the new `value` is an object (rather than a string or a number), we should make a copy of the
>, <Line: -   * object before passing it to `$setViewValue`.  This is because `ngModel` does not perform a deep
>, <Line: -   * watch of objects, it only looks for a change of identity. If you only change the property of
>, <Line: -   * the object then ngModel will not realise that the object has changed and will not invoke the
>, <Line: -   * `$parsers` and `$validators` pipelines.
>, <Line: -   *
>, <Line: -   * For this reason, you should not change properties of the copy once it has been passed to
>, <Line: -   * `$setViewValue`. Otherwise you may cause the model value on the scope to change incorrectly.
>, <Line: -   *
>, <Line: -   * When this method is called, the new `value` will be staged for committing through the `$parsers`
>, <Line: -   * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
>, <Line: -   * value sent directly for processing, finally to be applied to `$modelValue` and then the
>, <Line: -   * **expression** specified in the `ng-model` attribute.
>, <Line: -   *
>, <Line: -   * Lastly, all the registered change listeners, in the `$viewChangeListeners` list, are called.
>, <Line: -   *
>, <Line: -   * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
>, <Line: -   * and the `default` trigger is not listed, all those actions will remain pending until one of the
>, <Line: -   * `updateOn` events is triggered on the DOM element.
>, <Line: -   * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
>, <Line: -   * directive is used with a custom debounce for this particular event.
>, <Line: -   *
>, <Line: -   * Note that calling this function does not trigger a `$digest`.
>, <Line: -   *
>, <Line: -   * @param {string} value Value from the view.
>, <Line: -   * @param {string} trigger Event that triggered the update.
>, <Line: -   */
>, <Line: -  this.$setViewValue = function(value, trigger) {
>, <Line: -    ctrl.$viewValue = value;
>, <Line: -    if (!ctrl.$options || ctrl.$options.updateOnDefault) {
>, <Line: -      ctrl.$$debounceViewValueCommit(trigger);
>, <Line: -    }
>, <Line: -  };
>, <Line: -  this.$$debounceViewValueCommit = function(trigger) {
>, <Line: -    var debounceDelay = 0,
>, <Line: -        options = ctrl.$options,
>, <Line: -        debounce;
>, <Line: -    if (options && isDefined(options.debounce)) {
>, <Line: -      debounce = options.debounce;
>, <Line: -      if (isNumber(debounce)) {
>, <Line: -        debounceDelay = debounce;
>, <Line: -      } else if (isNumber(debounce[trigger])) {
>, <Line: -        debounceDelay = debounce[trigger];
>, <Line: -      } else if (isNumber(debounce['default'])) {
>, <Line: -        debounceDelay = debounce['default'];
>, <Line: -      }
>, <Line: -    }
>, <Line: -    $timeout.cancel(pendingDebounce);
>, <Line: -    if (debounceDelay) {
>, <Line: -      pendingDebounce = $timeout(function() {
>, <Line: -        ctrl.$commitViewValue();
>, <Line: -      }, debounceDelay);
>, <Line: -    } else if ($rootScope.$$phase) {
>, <Line: -      ctrl.$commitViewValue();
>, <Line: -    } else {
>, <Line: -      $scope.$apply(function() {
>, <Line: -        ctrl.$commitViewValue();
>, <Line: -      });
>, <Line: -    }
>, <Line: -  };
>, <Line: -  // model -> value
>, <Line: -  // Note: we cannot use a normal scope.$watch as we want to detect the following:
>, <Line: -  // 1. scope value is 'a'
>, <Line: -  // 2. user enters 'b'
>, <Line: -  // 3. ng-change kicks in and reverts scope value to 'a'
>, <Line: -  //    -> scope value did not change since the last digest as
>, <Line: -  //       ng-change executes in apply phase
>, <Line: -  // 4. view should be changed back to 'a'
>, <Line: -  $scope.$watch(function ngModelWatch() {
>, <Line: -    var modelValue = ngModelGet($scope);
>, <Line: -    // if scope model value and ngModel value are out of sync
>, <Line: -    // TODO(perf): why not move this to the action fn?
>, <Line: -    if (modelValue !== ctrl.$modelValue) {
>, <Line: -      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
>, <Line: -      var formatters = ctrl.$formatters,
>, <Line: -          idx = formatters.length;
>, <Line: -      var viewValue = modelValue;
>, <Line: -      while (idx--) {
>, <Line: -        viewValue = formatters[idx](viewValue);
>, <Line: -      }
>, <Line: -      if (ctrl.$viewValue !== viewValue) {
>, <Line: -        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
>, <Line: -        ctrl.$render();
>, <Line: -        ctrl.$$runValidators(undefined, modelValue, viewValue, noop);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    return modelValue;
>, <Line: -  });
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngModel
>, <Line: - *
>, <Line: - * @element input
>, <Line: - * @priority 1
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a
>, <Line: - * property on the scope using {@link ngModel.NgModelController NgModelController},
>, <Line: - * which is created and exposed by this directive.
>, <Line: - *
>, <Line: - * `ngModel` is responsible for:
>, <Line: - *
>, <Line: - * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`
>, <Line: - *   require.
>, <Line: - * - Providing validation behavior (i.e. required, number, email, url).
>, <Line: - * - Keeping the state of the control (valid/invalid, dirty/pristine, touched/untouched, validation errors).
>, <Line: - * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`, `ng-untouched`) including animations.
>, <Line: - * - Registering the control with its parent {@link ng.directive:form form}.
>, <Line: - *
>, <Line: - * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
>, <Line: - * current scope. If the property doesn't already exist on this scope, it will be created
>, <Line: - * implicitly and added to the scope.
>, <Line: - *
>, <Line: - * For best practices on using `ngModel`, see:
>, <Line: - *
>, <Line: - *  - [Understanding Scopes](https://github.com/angular/angular.js/wiki/Understanding-Scopes)
>, <Line: - *
>, <Line: - * For basic examples, how to use `ngModel`, see:
>, <Line: - *
>, <Line: - *  - {@link ng.directive:input input}
>, <Line: - *    - {@link input[text] text}
>, <Line: - *    - {@link input[checkbox] checkbox}
>, <Line: - *    - {@link input[radio] radio}
>, <Line: - *    - {@link input[number] number}
>, <Line: - *    - {@link input[email] email}
>, <Line: - *    - {@link input[url] url}
>, <Line: - *    - {@link input[date] date}
>, <Line: - *    - {@link input[datetime-local] datetime-local}
>, <Line: - *    - {@link input[time] time}
>, <Line: - *    - {@link input[month] month}
>, <Line: - *    - {@link input[week] week}
>, <Line: - *  - {@link ng.directive:select select}
>, <Line: - *  - {@link ng.directive:textarea textarea}
>, <Line: - *
>, <Line: - * # CSS classes
>, <Line: - * The following CSS classes are added and removed on the associated input/select/textarea element
>, <Line: - * depending on the validity of the model.
>, <Line: - *
>, <Line: - *  - `ng-valid`: the model is valid
>, <Line: - *  - `ng-invalid`: the model is invalid
>, <Line: - *  - `ng-valid-[key]`: for each valid key added by `$setValidity`
>, <Line: - *  - `ng-invalid-[key]`: for each invalid key added by `$setValidity`
>, <Line: - *  - `ng-pristine`: the control hasn't been interacted with yet
>, <Line: - *  - `ng-dirty`: the control has been interacted with
>, <Line: - *  - `ng-touched`: the control has been blurred
>, <Line: - *  - `ng-untouched`: the control hasn't been blurred
>, <Line: - *  - `ng-pending`: any `$asyncValidators` are unfulfilled
>, <Line: - *
>, <Line: - * Keep in mind that ngAnimate can detect each of these classes when added and removed.
>, <Line: - *
>, <Line: - * ## Animation Hooks
>, <Line: - *
>, <Line: - * Animations within models are triggered when any of the associated CSS classes are added and removed
>, <Line: - * on the input element which is attached to the model. These classes are: `.ng-pristine`, `.ng-dirty`,
>, <Line: - * `.ng-invalid` and `.ng-valid` as well as any other validations that are performed on the model itself.
>, <Line: - * The animations that are triggered within ngModel are similar to how they work in ngClass and
>, <Line: - * animations can be hooked into using CSS transitions, keyframes as well as JS animations.
>, <Line: - *
>, <Line: - * The following example shows a simple way to utilize CSS transitions to style an input element
>, <Line: - * that has been rendered as invalid after it has been validated:
>, <Line: - *
>, <Line: - * <pre>
>, <Line: - * //be sure to include ngAnimate as a module to hook into more
>, <Line: - * //advanced animations
>, <Line: - * .my-input {
>, <Line: - * .my-input.ng-invalid {
>, <Line: - * </pre>
>, <Line: - *
>, <Line: - * @example
>, <Line: - * <example deps="angular-animate.js" animations="true" fixBase="true" module="inputExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -        angular.module('inputExample', [])
>, <Line: -          .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <style>
>, <Line: -         .my-input {
>, <Line: -         .my-input.ng-invalid {
>, <Line: -       </style>
>, <Line: -       Update input to see transitions when valid/invalid.
>, <Line: -       Integer is a valid value.
>, <Line: -       <form name="testForm" ng-controller="ExampleController">
>, <Line: -         <input ng-model="val" ng-pattern="/^\d+$/" name="anim" class="my-input" />
>, <Line: -       </form>
>, <Line: -     </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - * ## Binding to a getter/setter
>, <Line: - *
>, <Line: - * Sometimes it's helpful to bind `ngModel` to a getter/setter function.  A getter/setter is a
>, <Line: - * function that returns a representation of the model when called with zero arguments, and sets
>, <Line: - * the internal state of a model when called with an argument. It's sometimes useful to use this
>, <Line: - * for models that have an internal representation that's different than what the model exposes
>, <Line: - * to the view.
>, <Line: - *
>, <Line: - * <div class="alert alert-success">
>, <Line: - * **Best Practice:** It's best to keep getters fast because Angular is likely to call them more
>, <Line: - * frequently than other parts of your code.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * You use this behavior by adding `ng-model-options="{ getterSetter: true }"` to an element that
>, <Line: - * has `ng-model` attached to it. You can also add `ng-model-options="{ getterSetter: true }"` to
>, <Line: - * a `<form>`, which will enable this behavior for all `<input>`s within it. See
>, <Line: - * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.
>, <Line: - *
>, <Line: - * The following example shows how to use `ngModel` with a getter/setter:
>, <Line: - *
>, <Line: - * @example
>, <Line: - * <example name="ngModel-getter-setter" module="getterSetterExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <form name="userForm">
>, <Line: -           Name:
>, <Line: -           <input type="text" name="userName"
>, <Line: -                  ng-model="user.name"
>, <Line: -                  ng-model-options="{ getterSetter: true }" />
>, <Line: -         </form>
>, <Line: -         <pre>user.name = <span ng-bind="user.name()"></span></pre>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="app.js">
>, <Line: -       angular.module('getterSetterExample', [])
>, <Line: -         .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -     </file>
>, <Line: - * </example>
>, <Line: - */
>, <Line: -var ngModelDirective = ['$rootScope', function($rootScope) {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    require: ['ngModel', '^?form', '^?ngModelOptions'],
>, <Line: -    controller: NgModelController,
>, <Line: -    // Prelink needs to run before any input directive
>, <Line: -    // so that we can set the NgModelOptions in NgModelController
>, <Line: -    // before anyone else uses it.
>, <Line: -    priority: 1,
>, <Line: -    compile: function ngModelCompile(element) {
>, <Line: -      // Setup initial state of the control
>, <Line: -      element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
>, <Line: -      return {
>, <Line: -        pre: function ngModelPreLink(scope, element, attr, ctrls) {
>, <Line: -          var modelCtrl = ctrls[0],
>, <Line: -              formCtrl = ctrls[1] || nullFormCtrl;
>, <Line: -          modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
>, <Line: -          // notify others, especially parent forms
>, <Line: -          formCtrl.$addControl(modelCtrl);
>, <Line: -          attr.$observe('name', function(newValue) {
>, <Line: -            if (modelCtrl.$name !== newValue) {
>, <Line: -              formCtrl.$$renameControl(modelCtrl, newValue);
>, <Line: -            }
>, <Line: -          });
>, <Line: -          scope.$on('$destroy', function() {
>, <Line: -            formCtrl.$removeControl(modelCtrl);
>, <Line: -          });
>, <Line: -        },
>, <Line: -        post: function ngModelPostLink(scope, element, attr, ctrls) {
>, <Line: -          var modelCtrl = ctrls[0];
>, <Line: -          if (modelCtrl.$options && modelCtrl.$options.updateOn) {
>, <Line: -            element.on(modelCtrl.$options.updateOn, function(ev) {
>, <Line: -              modelCtrl.$$debounceViewValueCommit(ev && ev.type);
>, <Line: -            });
>, <Line: -          }
>, <Line: -          element.on('blur', function(ev) {
>, <Line: -            if (modelCtrl.$touched) return;
>, <Line: -            if ($rootScope.$$phase) {
>, <Line: -              scope.$evalAsync(modelCtrl.$setTouched);
>, <Line: -            } else {
>, <Line: -              scope.$apply(modelCtrl.$setTouched);
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngChange
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Evaluate the given expression when the user changes the input.
>, <Line: - * The expression is evaluated immediately, unlike the JavaScript onchange event
>, <Line: - * which only triggers at the end of a change (usually, when the user leaves the
>, <Line: - * form element or presses the return key).
>, <Line: - *
>, <Line: - * The `ngChange` expression is only evaluated when a change in the input value causes
>, <Line: - * a new value to be committed to the model.
>, <Line: - *
>, <Line: - * It will not be evaluated:
>, <Line: - * * if the value returned from the `$parsers` transformation pipeline has not changed
>, <Line: - * * if the input has continued to be invalid since the model will stay `null`
>, <Line: - * * if the model is changed programmatically and not by a change to the input value
>, <Line: - *
>, <Line: - *
>, <Line: - * Note, this directive requires `ngModel` to be present.
>, <Line: - *
>, <Line: - * @element input
>, <Line: - * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
>, <Line: - * in input value.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * <example name="ngChange-directive" module="changeExample">
>, <Line: - *   <file name="index.html">
>, <Line: - *     <script>
>, <Line: - *       angular.module('changeExample', [])
>, <Line: - *         .controller('ExampleController', ['$scope', function($scope) {
>, <Line: - *     </script>
>, <Line: - *     <div ng-controller="ExampleController">
>, <Line: - *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
>, <Line: - *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
>, <Line: - *       <label for="ng-change-example2">Confirmed</label><br />
>, <Line: - *       <tt>debug = {{confirmed}}</tt><br/>
>, <Line: - *       <tt>counter = {{counter}}</tt><br/>
>, <Line: - *     </div>
>, <Line: - *   </file>
>, <Line: - *   <file name="protractor.js" type="protractor">
>, <Line: - *     var counter = element(by.binding('counter'));
>, <Line: - *     var debug = element(by.binding('confirmed'));
>, <Line: - *
>, <Line: - *     it('should evaluate the expression if changing from view', function() {
>, <Line: - *
>, <Line: - *     it('should not evaluate the expression if changing from model', function() {
>, <Line: - *   </file>
>, <Line: - * </example>
>, <Line: - */
>, <Line: -var ngChangeDirective = valueFn({
>, <Line: -  restrict: 'A',
>, <Line: -  require: 'ngModel',
>, <Line: -  link: function(scope, element, attr, ctrl) {
>, <Line: -    ctrl.$viewChangeListeners.push(function() {
>, <Line: -      scope.$eval(attr.ngChange);
>, <Line: -    });
>, <Line: -  }
>, <Line: -});
>, <Line: -var requiredDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    require: '?ngModel',
>, <Line: -    link: function(scope, elm, attr, ctrl) {
>, <Line: -      if (!ctrl) return;
>, <Line: -      attr.required = true; // force truthy in case we are on non input element
>, <Line: -      ctrl.$validators.required = function(modelValue, viewValue) {
>, <Line: -        return !attr.required || !ctrl.$isEmpty(viewValue);
>, <Line: -      };
>, <Line: -      attr.$observe('required', function() {
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -var patternDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    require: '?ngModel',
>, <Line: -    link: function(scope, elm, attr, ctrl) {
>, <Line: -      if (!ctrl) return;
>, <Line: -      var regexp, patternExp = attr.ngPattern || attr.pattern;
>, <Line: -      attr.$observe('pattern', function(regex) {
>, <Line: -        if (isString(regex) && regex.length > 0) {
>, <Line: -          regex = new RegExp('^' + regex + '$');
>, <Line: -        }
>, <Line: -        if (regex && !regex.test) {
>, <Line: -          throw minErr('ngPattern')('noregexp',
>, <Line: -            'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp,
>, <Line: -            regex, startingTag(elm));
>, <Line: -        }
>, <Line: -        regexp = regex || undefined;
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -      ctrl.$validators.pattern = function(value) {
>, <Line: -        return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -var maxlengthDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    require: '?ngModel',
>, <Line: -    link: function(scope, elm, attr, ctrl) {
>, <Line: -      if (!ctrl) return;
>, <Line: -      var maxlength = -1;
>, <Line: -      attr.$observe('maxlength', function(value) {
>, <Line: -        var intVal = int(value);
>, <Line: -        maxlength = isNaN(intVal) ? -1 : intVal;
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -      ctrl.$validators.maxlength = function(modelValue, viewValue) {
>, <Line: -        return (maxlength < 0) || ctrl.$isEmpty(modelValue) || (viewValue.length <= maxlength);
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -var minlengthDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    require: '?ngModel',
>, <Line: -    link: function(scope, elm, attr, ctrl) {
>, <Line: -      if (!ctrl) return;
>, <Line: -      var minlength = 0;
>, <Line: -      attr.$observe('minlength', function(value) {
>, <Line: -        minlength = int(value) || 0;
>, <Line: -        ctrl.$validate();
>, <Line: -      });
>, <Line: -      ctrl.$validators.minlength = function(modelValue, viewValue) {
>, <Line: -        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngList
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Text input that converts between a delimited string and an array of strings. The default
>, <Line: - * delimiter is a comma followed by a space - equivalent to `ng-list=", "`. You can specify a custom
>, <Line: - * delimiter as the value of the `ngList` attribute - for example, `ng-list=" | "`.
>, <Line: - *
>, <Line: - * The behaviour of the directive is affected by the use of the `ngTrim` attribute.
>, <Line: - * * If `ngTrim` is set to `"false"` then whitespace around both the separator and each
>, <Line: - *   list item is respected. This implies that the user of the directive is responsible for
>, <Line: - *   dealing with whitespace but also allows you to use whitespace as a delimiter, such as a
>, <Line: - *   tab or newline character.
>, <Line: - * * Otherwise whitespace around the delimiter is ignored when splitting (although it is respected
>, <Line: - *   when joining the list items back together) and whitespace around each list item is stripped
>, <Line: - *   before it is added to the model.
>, <Line: - *
>, <Line: - * ### Example with Validation
>, <Line: - *
>, <Line: - * <example name="ngList-directive" module="listExample">
>, <Line: - *   <file name="app.js">
>, <Line: - *      angular.module('listExample', [])
>, <Line: - *        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: - *   </file>
>, <Line: - *   <file name="index.html">
>, <Line: - *    <form name="myForm" ng-controller="ExampleController">
>, <Line: - *      List: <input name="namesInput" ng-model="names" ng-list required>
>, <Line: - *      <span class="error" ng-show="myForm.namesInput.$error.required">
>, <Line: - *        Required!</span>
>, <Line: - *      <br>
>, <Line: - *      <tt>names = {{names}}</tt><br/>
>, <Line: - *      <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
>, <Line: - *      <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
>, <Line: - *      <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
>, <Line: - *      <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
>, <Line: - *     </form>
>, <Line: - *   </file>
>, <Line: - *   <file name="protractor.js" type="protractor">
>, <Line: - *     var listInput = element(by.model('names'));
>, <Line: - *     var names = element(by.exactBinding('names'));
>, <Line: - *     var valid = element(by.binding('myForm.namesInput.$valid'));
>, <Line: - *     var error = element(by.css('span.error'));
>, <Line: - *
>, <Line: - *     it('should initialize to model', function() {
>, <Line: - *
>, <Line: - *     it('should be invalid if empty', function() {
>, <Line: - *   </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - * ### Example - splitting on whitespace
>, <Line: - * <example name="ngList-directive-newlines">
>, <Line: - *   <file name="index.html">
>, <Line: - *    <textarea ng-model="list" ng-list="&#10;" ng-trim="false"></textarea>
>, <Line: - *    <pre>{{ list | json }}</pre>
>, <Line: - *   </file>
>, <Line: - *   <file name="protractor.js" type="protractor">
>, <Line: - *     it("should split the text by newlines", function() {
>, <Line: - *       listInput.sendKeys('abc\ndef\nghi');
>, <Line: - *       expect(output.getText()).toContain('[\n  "abc",\n  "def",\n  "ghi"\n]');
>, <Line: - *     });
>, <Line: - *   </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - * @element input
>, <Line: - * @param {string=} ngList optional delimiter that should be used to split the value.
>, <Line: - */
>, <Line: -var ngListDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    priority: 100,
>, <Line: -    require: 'ngModel',
>, <Line: -    link: function(scope, element, attr, ctrl) {
>, <Line: -      // We want to control whitespace trimming so we use this convoluted approach
>, <Line: -      // to access the ngList attribute, which doesn't pre-trim the attribute
>, <Line: -      var ngList = element.attr(attr.$attr.ngList) || ', ';
>, <Line: -      var trimValues = attr.ngTrim !== 'false';
>, <Line: -      var separator = trimValues ? trim(ngList) : ngList;
>, <Line: -      var parse = function(viewValue) {
>, <Line: -        // If the viewValue is invalid (say required but empty) it will be `undefined`
>, <Line: -        if (isUndefined(viewValue)) return;
>, <Line: -        var list = [];
>, <Line: -        if (viewValue) {
>, <Line: -          forEach(viewValue.split(separator), function(value) {
>, <Line: -            if (value) list.push(trimValues ? trim(value) : value);
>, <Line: -          });
>, <Line: -        }
>, <Line: -        return list;
>, <Line: -      };
>, <Line: -      ctrl.$parsers.push(parse);
>, <Line: -      ctrl.$formatters.push(function(value) {
>, <Line: -        if (isArray(value)) {
>, <Line: -          return value.join(ngList);
>, <Line: -        }
>, <Line: -        return undefined;
>, <Line: -      });
>, <Line: -      // Override the standard $isEmpty because an empty array means the input is empty.
>, <Line: -      ctrl.$isEmpty = function(value) {
>, <Line: -        return !value || !value.length;
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngValue
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Binds the given expression to the value of `<option>` or {@link input[radio] `input[radio]`},
>, <Line: - * so that when the element is selected, the {@link ngModel `ngModel`} of that element is set to
>, <Line: - * the bound value.
>, <Line: - *
>, <Line: - * `ngValue` is useful when dynamically generating lists of radio buttons using
>, <Line: - * {@link ngRepeat `ngRepeat`}, as shown below.
>, <Line: - *
>, <Line: - * Likewise, `ngValue` can be used to generate `<option>` elements for
>, <Line: - * the {@link select `select`} element. In that case however, only strings are supported
>, <Line: - * for the `value `attribute, so the resulting `ngModel` will always be a string.
>, <Line: - * Support for `select` models with non-string values is available via `ngOptions`.
>, <Line: - *
>, <Line: - * @element input
>, <Line: - * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute
>, <Line: - *   of the `input` element
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example name="ngValue-directive" module="valueExample">
>, <Line: -      <file name="index.html">
>, <Line: -       <script>
>, <Line: -          angular.module('valueExample', [])
>, <Line: -            .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -        <form ng-controller="ExampleController">
>, <Line: -          <h2>Which is your favorite?</h2>
>, <Line: -            <label ng-repeat="name in names" for="{{name}}">
>, <Line: -              {{name}}
>, <Line: -              <input type="radio"
>, <Line: -                     ng-model="my.favorite"
>, <Line: -                     ng-value="name"
>, <Line: -                     id="{{name}}"
>, <Line: -                     name="favorite">
>, <Line: -            </label>
>, <Line: -          <div>You chose {{my.favorite}}</div>
>, <Line: -        </form>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        var favorite = element(by.binding('my.favorite'));
>, <Line: -        it('should initialize to model', function() {
>, <Line: -        it('should bind the values to the inputs', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var ngValueDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    priority: 100,
>, <Line: -    compile: function(tpl, tplAttr) {
>, <Line: -      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
>, <Line: -        return function ngValueConstantLink(scope, elm, attr) {
>, <Line: -          attr.$set('value', scope.$eval(attr.ngValue));
>, <Line: -        };
>, <Line: -      } else {
>, <Line: -        return function ngValueLink(scope, elm, attr) {
>, <Line: -          scope.$watch(attr.ngValue, function valueWatchAction(value) {
>, <Line: -            attr.$set('value', value);
>, <Line: -          });
>, <Line: -        };
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -};
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngModelOptions
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Allows tuning how model updates are done. Using `ngModelOptions` you can specify a custom list of
>, <Line: - * events that will trigger a model update and/or a debouncing delay so that the actual update only
>, <Line: - * takes place when a timer expires; this timer will be reset after another change takes place.
>, <Line: - *
>, <Line: - * Given the nature of `ngModelOptions`, the value displayed inside input fields in the view might
>, <Line: - * be different than the value in the actual model. This means that if you update the model you
>, <Line: - * should also invoke {@link ngModel.NgModelController `$rollbackViewValue`} on the relevant input field in
>, <Line: - * order to make sure it is synchronized with the model and that any debounced action is canceled.
>, <Line: - *
>, <Line: - * The easiest way to reference the control's {@link ngModel.NgModelController `$rollbackViewValue`}
>, <Line: - * method is by making sure the input is placed inside a form that has a `name` attribute. This is
>, <Line: - * important because `form` controllers are published to the related scope under the name in their
>, <Line: - * `name` attribute.
>, <Line: - *
>, <Line: - * Any pending changes will take place immediately when an enclosing form is submitted via the
>, <Line: - * `submit` event. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
>, <Line: - * to have access to the updated model.
>, <Line: - *
>, <Line: - * `ngModelOptions` has an effect on the element it's declared on and its descendants.
>, <Line: - *
>, <Line: - * @param {Object} ngModelOptions options to apply to the current model. Valid keys are:
>, <Line: - *   - `updateOn`: string specifying which event should the input be bound to. You can set several
>, <Line: - *     events using an space delimited list. There is a special event called `default` that
>, <Line: - *     matches the default events belonging of the control.
>, <Line: - *   - `debounce`: integer value which contains the debounce model update value in milliseconds. A
>, <Line: - *     value of 0 triggers an immediate update. If an object is supplied instead, you can specify a
>, <Line: - *     custom value for each event. For example:
>, <Line: - *     `ng-model-options="{ updateOn: 'default blur', debounce: {'default': 500, 'blur': 0} }"`
>, <Line: - *   - `allowInvalid`: boolean value which indicates that the model can be set with values that did
>, <Line: - *     not validate correctly instead of the default behavior of setting the model to undefined.
>, <Line: - *   - `getterSetter`: boolean value which determines whether or not to treat functions bound to
>, <Line: -       `ngModel` as getters/setters.
>, <Line: - *   - `timezone`: Defines the timezone to be used to read/write the `Date` instance in the model for
>, <Line: - *     `<input type="date">`, `<input type="time">`, ... . Right now, the only supported value is `'UTC'`,
>, <Line: - *     otherwise the default timezone of the browser will be used.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  The following example shows how to override immediate updates. Changes on the inputs within the
>, <Line: -  form will update the model only when the control loses focus (blur event). If `escape` key is
>, <Line: -  pressed while the input field is focused, the value is reset to the value in the current model.
>, <Line: -  <example name="ngModelOptions-directive-blur" module="optionsExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-controller="ExampleController">
>, <Line: -        <form name="userForm">
>, <Line: -          Name:
>, <Line: -          <input type="text" name="userName"
>, <Line: -                 ng-model="user.name"
>, <Line: -                 ng-model-options="{ updateOn: 'blur' }"
>, <Line: -                 ng-keyup="cancel($event)" /><br />
>, <Line: -          Other data:
>, <Line: -          <input type="text" ng-model="user.data" /><br />
>, <Line: -        </form>
>, <Line: -        <pre>user.name = <span ng-bind="user.name"></span></pre>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="app.js">
>, <Line: -      angular.module('optionsExample', [])
>, <Line: -        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var model = element(by.binding('user.name'));
>, <Line: -      var input = element(by.model('user.name'));
>, <Line: -      var other = element(by.model('user.data'));
>, <Line: -      it('should allow custom events', function() {
>, <Line: -      it('should $rollbackViewValue when model changes', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: -  This one shows how to debounce model changes. Model will be updated only 1 sec after last change.
>, <Line: -  If the `Clear` button is pressed, any debounced action is canceled and the value becomes empty.
>, <Line: -  <example name="ngModelOptions-directive-debounce" module="optionsExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-controller="ExampleController">
>, <Line: -        <form name="userForm">
>, <Line: -          Name:
>, <Line: -          <input type="text" name="userName"
>, <Line: -                 ng-model="user.name"
>, <Line: -                 ng-model-options="{ debounce: 1000 }" />
>, <Line: -          <button ng-click="userForm.userName.$rollbackViewValue(); user.name=''">Clear</button><br />
>, <Line: -        </form>
>, <Line: -        <pre>user.name = <span ng-bind="user.name"></span></pre>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="app.js">
>, <Line: -      angular.module('optionsExample', [])
>, <Line: -        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: -  This one shows how to bind to getter/setters:
>, <Line: -  <example name="ngModelOptions-directive-getter-setter" module="getterSetterExample">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-controller="ExampleController">
>, <Line: -        <form name="userForm">
>, <Line: -          Name:
>, <Line: -          <input type="text" name="userName"
>, <Line: -                 ng-model="user.name"
>, <Line: -                 ng-model-options="{ getterSetter: true }" />
>, <Line: -        </form>
>, <Line: -        <pre>user.name = <span ng-bind="user.name()"></span></pre>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="app.js">
>, <Line: -      angular.module('getterSetterExample', [])
>, <Line: -        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var ngModelOptionsDirective = function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    controller: ['$scope', '$attrs', function($scope, $attrs) {
>, <Line: -      var that = this;
>, <Line: -      this.$options = $scope.$eval($attrs.ngModelOptions);
>, <Line: -      // Allow adding/overriding bound events
>, <Line: -      if (this.$options.updateOn !== undefined) {
>, <Line: -        this.$options.updateOnDefault = false;
>, <Line: -        // extract "default" pseudo-event from list of events that can trigger a model update
>, <Line: -        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
>, <Line: -          that.$options.updateOnDefault = true;
>, <Line: -          return ' ';
>, <Line: -        }));
>, <Line: -      } else {
>, <Line: -        this.$options.updateOnDefault = true;
>, <Line: -      }
>, <Line: -    }]
>, <Line: -  };
>, <Line: -};
>, <Line: -function addSetValidityMethod(context) {
>, <Line: -  var ctrl = context.ctrl,
>, <Line: -      $element = context.$element,
>, <Line: -      classCache = {},
>, <Line: -      set = context.set,
>, <Line: -      unset = context.unset,
>, <Line: -      parentForm = context.parentForm,
>, <Line: -      $animate = context.$animate;
>, <Line: -  classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
>, <Line: -  ctrl.$setValidity = setValidity;
>, <Line: -  function setValidity(validationErrorKey, state, options) {
>, <Line: -    if (state === undefined) {
>, <Line: -      createAndSet('$pending', validationErrorKey, options);
>, <Line: -    } else {
>, <Line: -      unsetAndCleanup('$pending', validationErrorKey, options);
>, <Line: -    }
>, <Line: -    if (!isBoolean(state)) {
>, <Line: -      unset(ctrl.$error, validationErrorKey, options);
>, <Line: -      unset(ctrl.$$success, validationErrorKey, options);
>, <Line: -    } else {
>, <Line: -      if (state) {
>, <Line: -        unset(ctrl.$error, validationErrorKey, options);
>, <Line: -        set(ctrl.$$success, validationErrorKey, options);
>, <Line: -      } else {
>, <Line: -        set(ctrl.$error, validationErrorKey, options);
>, <Line: -        unset(ctrl.$$success, validationErrorKey, options);
>, <Line: -      }
>, <Line: -    }
>, <Line: -    if (ctrl.$pending) {
>, <Line: -      cachedToggleClass(PENDING_CLASS, true);
>, <Line: -      ctrl.$valid = ctrl.$invalid = undefined;
>, <Line: -      toggleValidationCss('', null);
>, <Line: -    } else {
>, <Line: -      cachedToggleClass(PENDING_CLASS, false);
>, <Line: -      ctrl.$valid = isObjectEmpty(ctrl.$error);
>, <Line: -      ctrl.$invalid = !ctrl.$valid;
>, <Line: -      toggleValidationCss('', ctrl.$valid);
>, <Line: -    }
>, <Line: -    // re-read the state as the set/unset methods could have
>, <Line: -    // combined state in ctrl.$error[validationError] (used for forms),
>, <Line: -    // where setting/unsetting only increments/decrements the value,
>, <Line: -    // and does not replace it.
>, <Line: -    var combinedState;
>, <Line: -    if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
>, <Line: -      combinedState = undefined;
>, <Line: -    } else if (ctrl.$error[validationErrorKey]) {
>, <Line: -      combinedState = false;
>, <Line: -    } else if (ctrl.$$success[validationErrorKey]) {
>, <Line: -      combinedState = true;
>, <Line: -    } else {
>, <Line: -      combinedState = null;
>, <Line: -    }
>, <Line: -    toggleValidationCss(validationErrorKey, combinedState);
>, <Line: -    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
>, <Line: -  }
>, <Line: -  function createAndSet(name, value, options) {
>, <Line: -    if (!ctrl[name]) {
>, <Line: -      ctrl[name] = {};
>, <Line: -    }
>, <Line: -    set(ctrl[name], value, options);
>, <Line: -  }
>, <Line: -  function unsetAndCleanup(name, value, options) {
>, <Line: -    if (ctrl[name]) {
>, <Line: -      unset(ctrl[name], value, options);
>, <Line: -    }
>, <Line: -    if (isObjectEmpty(ctrl[name])) {
>, <Line: -      ctrl[name] = undefined;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  function cachedToggleClass(className, switchValue) {
>, <Line: -    if (switchValue && !classCache[className]) {
>, <Line: -      $animate.addClass($element, className);
>, <Line: -      classCache[className] = true;
>, <Line: -    } else if (!switchValue && classCache[className]) {
>, <Line: -      $animate.removeClass($element, className);
>, <Line: -      classCache[className] = false;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  function toggleValidationCss(validationErrorKey, isValid) {
>, <Line: -    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
>, <Line: -    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
>, <Line: -    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
>, <Line: -  }
>, <Line: -}
>, <Line: -function isObjectEmpty(obj) {
>, <Line: -  if (obj) {
>, <Line: -    for (var prop in obj) {
>, <Line: -      return false;
>, <Line: -    }
>, <Line: -  }
>, <Line: -  return true;
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngBind
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
>, <Line: - * with the value of a given expression, and to update the text content when the value of that
>, <Line: - * expression changes.
>, <Line: - *
>, <Line: - * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
>, <Line: - * `{{ expression }}` which is similar but less verbose.
>, <Line: - *
>, <Line: - * It is preferable to use `ngBind` instead of `{{ expression }}` if a template is momentarily
>, <Line: - * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an
>, <Line: - * element attribute, it makes the bindings invisible to the user while the page is loading.
>, <Line: - *
>, <Line: - * An alternative solution to this problem would be using the
>, <Line: - * {@link ng.directive:ngCloak ngCloak} directive.
>, <Line: - *
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
>, <Line: -   <example module="bindExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('bindExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         Enter name: <input type="text" ng-model="name"><br>
>, <Line: -         Hello <span ng-bind="name"></span>!
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-bind', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngBindDirective = ['$compile', function($compile) {
>, <Line: -  return {
>, <Line: -    restrict: 'AC',
>, <Line: -    compile: function ngBindCompile(templateElement) {
>, <Line: -      $compile.$$addBindingClass(templateElement);
>, <Line: -      return function ngBindLink(scope, element, attr) {
>, <Line: -        $compile.$$addBindingInfo(element, attr.ngBind);
>, <Line: -        element = element[0];
>, <Line: -        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
>, <Line: -          element.textContent = value === undefined ? '' : value;
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngBindTemplate
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngBindTemplate` directive specifies that the element
>, <Line: - * text content should be replaced with the interpolation of the template
>, <Line: - * in the `ngBindTemplate` attribute.
>, <Line: - * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
>, <Line: - * expressions. This directive is needed since some HTML elements
>, <Line: - * (such as TITLE and OPTION) cannot contain SPAN elements.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {string} ngBindTemplate template of form
>, <Line: - *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Try it here: enter text in text box and watch the greeting change.
>, <Line: -   <example module="bindExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('bindExample', [])
>, <Line: -           .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -        Salutation: <input type="text" ng-model="salutation"><br>
>, <Line: -        Name: <input type="text" ng-model="name"><br>
>, <Line: -        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-bind', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
>, <Line: -  return {
>, <Line: -    compile: function ngBindTemplateCompile(templateElement) {
>, <Line: -      $compile.$$addBindingClass(templateElement);
>, <Line: -      return function ngBindTemplateLink(scope, element, attr) {
>, <Line: -        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
>, <Line: -        $compile.$$addBindingInfo(element, interpolateFn.expressions);
>, <Line: -        element = element[0];
>, <Line: -        attr.$observe('ngBindTemplate', function(value) {
>, <Line: -          element.textContent = value === undefined ? '' : value;
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngBindHtml
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default,
>, <Line: - * the resulting HTML content will be sanitized using the {@link ngSanitize.$sanitize $sanitize} service.
>, <Line: - * To utilize this functionality, ensure that `$sanitize` is available, for example, by including {@link
>, <Line: - * ngSanitize} in your module's dependencies (not in core Angular). In order to use {@link ngSanitize}
>, <Line: - * in your module's dependencies, you need to include "angular-sanitize.js" in your application.
>, <Line: - *
>, <Line: - * You may also bypass sanitization for values you know are safe. To do so, bind to
>, <Line: - * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example
>, <Line: - * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual Escaping (SCE)}.
>, <Line: - *
>, <Line: - * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
>, <Line: - * will have an exception (instead of an exploit.)
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="bindHtmlExample" deps="angular-sanitize.js">
>, <Line: -     <file name="index.html">
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -        <p ng-bind-html="myHTML"></p>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="script.js">
>, <Line: -       angular.module('bindHtmlExample', ['ngSanitize'])
>, <Line: -         .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-bind-html', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    compile: function ngBindHtmlCompile(tElement, tAttrs) {
>, <Line: -      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
>, <Line: -      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
>, <Line: -        return (value || '').toString();
>, <Line: -      });
>, <Line: -      $compile.$$addBindingClass(tElement);
>, <Line: -      return function ngBindHtmlLink(scope, element, attr) {
>, <Line: -        $compile.$$addBindingInfo(element, attr.ngBindHtml);
>, <Line: -        scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
>, <Line: -          // we re-evaluate the expr because we want a TrustedValueHolderType
>, <Line: -          // for $sce, not a string
>, <Line: -          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -function classDirective(name, selector) {
>, <Line: -  name = 'ngClass' + name;
>, <Line: -  return ['$animate', function($animate) {
>, <Line: -    return {
>, <Line: -      restrict: 'AC',
>, <Line: -      link: function(scope, element, attr) {
>, <Line: -        var oldVal;
>, <Line: -        scope.$watch(attr[name], ngClassWatchAction, true);
>, <Line: -        attr.$observe('class', function(value) {
>, <Line: -          ngClassWatchAction(scope.$eval(attr[name]));
>, <Line: -        });
>, <Line: -        if (name !== 'ngClass') {
>, <Line: -          scope.$watch('$index', function($index, old$index) {
>, <Line: -            // jshint bitwise: false
>, <Line: -            var mod = $index & 1;
>, <Line: -            if (mod !== (old$index & 1)) {
>, <Line: -              var classes = arrayClasses(scope.$eval(attr[name]));
>, <Line: -              mod === selector ?
>, <Line: -                addClasses(classes) :
>, <Line: -                removeClasses(classes);
>, <Line: -            }
>, <Line: -          });
>, <Line: -        }
>, <Line: -        function addClasses(classes) {
>, <Line: -          var newClasses = digestClassCounts(classes, 1);
>, <Line: -          attr.$addClass(newClasses);
>, <Line: -        }
>, <Line: -        function removeClasses(classes) {
>, <Line: -          var newClasses = digestClassCounts(classes, -1);
>, <Line: -          attr.$removeClass(newClasses);
>, <Line: -        }
>, <Line: -        function digestClassCounts(classes, count) {
>, <Line: -          var classCounts = element.data('$classCounts') || {};
>, <Line: -          var classesToUpdate = [];
>, <Line: -          forEach(classes, function(className) {
>, <Line: -            if (count > 0 || classCounts[className]) {
>, <Line: -              classCounts[className] = (classCounts[className] || 0) + count;
>, <Line: -              if (classCounts[className] === +(count > 0)) {
>, <Line: -                classesToUpdate.push(className);
>, <Line: -              }
>, <Line: -            }
>, <Line: -          });
>, <Line: -          element.data('$classCounts', classCounts);
>, <Line: -          return classesToUpdate.join(' ');
>, <Line: -        }
>, <Line: -        function updateClasses(oldClasses, newClasses) {
>, <Line: -          var toAdd = arrayDifference(newClasses, oldClasses);
>, <Line: -          var toRemove = arrayDifference(oldClasses, newClasses);
>, <Line: -          toAdd = digestClassCounts(toAdd, 1);
>, <Line: -          toRemove = digestClassCounts(toRemove, -1);
>, <Line: -          if (toAdd && toAdd.length) {
>, <Line: -            $animate.addClass(element, toAdd);
>, <Line: -          }
>, <Line: -          if (toRemove && toRemove.length) {
>, <Line: -            $animate.removeClass(element, toRemove);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function ngClassWatchAction(newVal) {
>, <Line: -          if (selector === true || scope.$index % 2 === selector) {
>, <Line: -            var newClasses = arrayClasses(newVal || []);
>, <Line: -            if (!oldVal) {
>, <Line: -              addClasses(newClasses);
>, <Line: -            } else if (!equals(newVal,oldVal)) {
>, <Line: -              var oldClasses = arrayClasses(oldVal);
>, <Line: -              updateClasses(oldClasses, newClasses);
>, <Line: -            }
>, <Line: -          }
>, <Line: -          oldVal = shallowCopy(newVal);
>, <Line: -        }
>, <Line: -      }
>, <Line: -    };
>, <Line: -    function arrayDifference(tokens1, tokens2) {
>, <Line: -      var values = [];
>, <Line: -      outer:
>, <Line: -      for (var i = 0; i < tokens1.length; i++) {
>, <Line: -        var token = tokens1[i];
>, <Line: -        for (var j = 0; j < tokens2.length; j++) {
>, <Line: -          if (token == tokens2[j]) continue outer;
>, <Line: -        }
>, <Line: -        values.push(token);
>, <Line: -      }
>, <Line: -      return values;
>, <Line: -    }
>, <Line: -    function arrayClasses(classVal) {
>, <Line: -      if (isArray(classVal)) {
>, <Line: -        return classVal;
>, <Line: -      } else if (isString(classVal)) {
>, <Line: -        return classVal.split(' ');
>, <Line: -      } else if (isObject(classVal)) {
>, <Line: -        var classes = [];
>, <Line: -        forEach(classVal, function(v, k) {
>, <Line: -          if (v) {
>, <Line: -            classes = classes.concat(k.split(' '));
>, <Line: -          }
>, <Line: -        });
>, <Line: -        return classes;
>, <Line: -      }
>, <Line: -      return classVal;
>, <Line: -    }
>, <Line: -  }];
>, <Line: -}
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngClass
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding
>, <Line: - * an expression that represents all classes to be added.
>, <Line: - *
>, <Line: - * The directive operates in three different ways, depending on which of three types the expression
>, <Line: - * evaluates to:
>, <Line: - *
>, <Line: - * 1. If the expression evaluates to a string, the string should be one or more space-delimited class
>, <Line: - * names.
>, <Line: - *
>, <Line: - * 2. If the expression evaluates to an array, each element of the array should be a string that is
>, <Line: - * one or more space-delimited class names.
>, <Line: - *
>, <Line: - * 3. If the expression evaluates to an object, then for each key-value pair of the
>, <Line: - * object with a truthy value the corresponding key is used as a class name.
>, <Line: - *
>, <Line: - * The directive won't add duplicate classes if a particular class was already set.
>, <Line: - *
>, <Line: - * When the expression changes, the previously added classes are removed and only then the
>, <Line: - * new classes are added.
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * add - happens just before the class is applied to the element
>, <Line: - * remove - happens just before the class is removed from the element
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
>, <Line: - *   of the evaluation can be a string representing space delimited class
>, <Line: - *   names, an array, or a map of class names to boolean values. In the case of a map, the
>, <Line: - *   names of the properties whose values are truthy will be added as css classes to the
>, <Line: - *   element.
>, <Line: - *
>, <Line: - * @example Example that demonstrates basic bindings via ngClass directive.
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -       <p ng-class="{strike: deleted, bold: important, red: error}">Map Syntax Example</p>
>, <Line: -       <input type="checkbox" ng-model="deleted"> deleted (apply "strike" class)<br>
>, <Line: -       <input type="checkbox" ng-model="important"> important (apply "bold" class)<br>
>, <Line: -       <input type="checkbox" ng-model="error"> error (apply "red" class)
>, <Line: -       <hr>
>, <Line: -       <p ng-class="style">Using String Syntax</p>
>, <Line: -       <input type="text" ng-model="style" placeholder="Type: bold strike red">
>, <Line: -       <hr>
>, <Line: -       <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
>, <Line: -       <input ng-model="style1" placeholder="Type: bold, strike or red"><br>
>, <Line: -       <input ng-model="style2" placeholder="Type: bold, strike or red"><br>
>, <Line: -       <input ng-model="style3" placeholder="Type: bold, strike or red"><br>
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       .strike {
>, <Line: -       .bold {
>, <Line: -       .red {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       var ps = element.all(by.css('p'));
>, <Line: -       it('should let you toggle the class', function() {
>, <Line: -       it('should let you toggle string example', function() {
>, <Line: -       it('array example should have 3 classes', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: -   ## Animations
>, <Line: -   The example below demonstrates how to perform animations using ngClass.
>, <Line: -   <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: -     <file name="index.html">
>, <Line: -      <input id="setbtn" type="button" value="set" ng-click="myVar='my-class'">
>, <Line: -      <input id="clearbtn" type="button" value="clear" ng-click="myVar=''">
>, <Line: -      <br>
>, <Line: -      <span class="base-class" ng-class="myVar">Sample Text</span>
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       .base-class {
>, <Line: -       .base-class.my-class {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-class', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: -   ## ngClass and pre-existing CSS3 Transitions/Animations
>, <Line: -   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
>, <Line: -   Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder
>, <Line: -   any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure
>, <Line: -   to view the step by step details of {@link ng.$animate#addClass $animate.addClass} and
>, <Line: -   {@link ng.$animate#removeClass $animate.removeClass}.
>, <Line: - */
>, <Line: -var ngClassDirective = classDirective('', true);
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngClassOdd
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngClassOdd` and `ngClassEven` directives work exactly as
>, <Line: - * {@link ng.directive:ngClass ngClass}, except they work in
>, <Line: - * conjunction with `ngRepeat` and take effect only on odd (even) rows.
>, <Line: - *
>, <Line: - * This directive can be applied only within the scope of an
>, <Line: - * {@link ng.directive:ngRepeat ngRepeat}.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
>, <Line: - *   of the evaluation can be a string representing space delimited class names or an array.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
>, <Line: -          <li ng-repeat="name in names">
>, <Line: -           <span ng-class-odd="'odd'" ng-class-even="'even'">
>, <Line: -             {{name}}
>, <Line: -           </span>
>, <Line: -          </li>
>, <Line: -        </ol>
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       .odd {
>, <Line: -       .even {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-class-odd and ng-class-even', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngClassOddDirective = classDirective('Odd', 0);
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngClassEven
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngClassOdd` and `ngClassEven` directives work exactly as
>, <Line: - * {@link ng.directive:ngClass ngClass}, except they work in
>, <Line: - * conjunction with `ngRepeat` and take effect only on odd (even) rows.
>, <Line: - *
>, <Line: - * This directive can be applied only within the scope of an
>, <Line: - * {@link ng.directive:ngRepeat ngRepeat}.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
>, <Line: - *   result of the evaluation can be a string representing space delimited class names or an array.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
>, <Line: -          <li ng-repeat="name in names">
>, <Line: -           <span ng-class-odd="'odd'" ng-class-even="'even'">
>, <Line: -             {{name}} &nbsp; &nbsp; &nbsp;
>, <Line: -           </span>
>, <Line: -          </li>
>, <Line: -        </ol>
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       .odd {
>, <Line: -       .even {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-class-odd and ng-class-even', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngClassEvenDirective = classDirective('Even', 1);
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngCloak
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngCloak` directive is used to prevent the Angular html template from being briefly
>, <Line: - * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
>, <Line: - * directive to avoid the undesirable flicker effect caused by the html template display.
>, <Line: - *
>, <Line: - * The directive can be applied to the `<body>` element, but the preferred usage is to apply
>, <Line: - * multiple `ngCloak` directives to small portions of the page to permit progressive rendering
>, <Line: - * of the browser view.
>, <Line: - *
>, <Line: - * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and
>, <Line: - * `angular.min.js`.
>, <Line: - * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: - *
>, <Line: - * ```css
>, <Line: - * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * When this css rule is loaded by the browser, all html elements (including their children) that
>, <Line: - * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive
>, <Line: - * during the compilation of the template it deletes the `ngCloak` element attribute, making
>, <Line: - * the compiled element visible.
>, <Line: - *
>, <Line: - * For the best result, the `angular.js` script must be loaded in the head section of the html
>, <Line: - * document; alternatively, the css rule above must be included in the external stylesheet of the
>, <Line: - * application.
>, <Line: - *
>, <Line: - * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
>, <Line: - * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
>, <Line: - * class `ng-cloak` in addition to the `ngCloak` directive as shown in the example below.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -        <div id="template1" ng-cloak>{{ 'hello' }}</div>
>, <Line: -        <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should remove the template directive and css class', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - *
>, <Line: - */
>, <Line: -var ngCloakDirective = ngDirective({
>, <Line: -  compile: function(element, attr) {
>, <Line: -    attr.$set('ngCloak', undefined);
>, <Line: -    element.removeClass('ng-cloak');
>, <Line: -  }
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngController
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
>, <Line: - * supports the principles behind the Model-View-Controller design pattern.
>, <Line: - *
>, <Line: - * MVC components in angular:
>, <Line: - *
>, <Line: - * * Model  Models are the properties of a scope; scopes are attached to the DOM where scope properties
>, <Line: - *   are accessed through bindings.
>, <Line: - * * View  The template (HTML with data bindings) that is rendered into the View.
>, <Line: - * * Controller  The `ngController` directive specifies a Controller class; the class contains business
>, <Line: - *   logic behind the application to decorate the scope with functions and values
>, <Line: - *
>, <Line: - * Note that you can also attach controllers to the DOM by declaring it in a route definition
>, <Line: - * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller
>, <Line: - * again using `ng-controller` in the template itself.  This will cause the controller to be attached
>, <Line: - * and executed twice.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @scope
>, <Line: - * @priority 500
>, <Line: - * @param {expression} ngController Name of a constructor function registered with the current
>, <Line: - * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}
>, <Line: - * that on the current scope evaluates to a constructor function.
>, <Line: - *
>, <Line: - * The controller instance can be published into a scope property by specifying
>, <Line: - * `ng-controller="as propertyName"`.
>, <Line: - *
>, <Line: - * If the current `$controllerProvider` is configured to use globals (via
>, <Line: - * {@link ng.$controllerProvider#allowGlobals `$controllerProvider.allowGlobals()` }), this may
>, <Line: - * also be the name of a globally accessible constructor function (not recommended).
>, <Line: - *
>, <Line: - * @example
>, <Line: - * Here is a simple form for editing user contact information. Adding, removing, clearing, and
>, <Line: - * greeting are methods declared on the controller (see source tab). These methods can
>, <Line: - * easily be called from the angular markup. Any changes to the data are automatically reflected
>, <Line: - * in the View without the need for a manual update.
>, <Line: - *
>, <Line: - * Two different declaration styles are included below:
>, <Line: - *
>, <Line: - * * one binds methods and properties directly onto the controller using `this`:
>, <Line: - * `ng-controller="SettingsController1 as settings"`
>, <Line: - * * one injects `$scope` into the controller:
>, <Line: - * `ng-controller="SettingsController2"`
>, <Line: - *
>, <Line: - * The second option is more common in the Angular community, and is generally used in boilerplates
>, <Line: - * and in this guide. However, there are advantages to binding properties directly to the controller
>, <Line: - * and avoiding scope.
>, <Line: - *
>, <Line: - * * Using `controller as` makes it obvious which controller you are accessing in the template when
>, <Line: - * multiple controllers apply to an element.
>, <Line: - * * If you are writing your controllers as classes you have easier access to the properties and
>, <Line: - * methods, which will appear on the scope, from inside the controller code.
>, <Line: - * * Since there is always a `.` in the bindings, you don't have to worry about prototypal
>, <Line: - * inheritance masking primitives.
>, <Line: - *
>, <Line: - * This example demonstrates the `controller as` syntax.
>, <Line: - *
>, <Line: - * <example name="ngControllerAs" module="controllerAsExample">
>, <Line: - *   <file name="index.html">
>, <Line: - *    <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
>, <Line: - *      Name: <input type="text" ng-model="settings.name"/>
>, <Line: - *      [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
>, <Line: - *      Contact:
>, <Line: - *      <ul>
>, <Line: - *        <li ng-repeat="contact in settings.contacts">
>, <Line: - *          <select ng-model="contact.type">
>, <Line: - *             <option>phone</option>
>, <Line: - *             <option>email</option>
>, <Line: - *          </select>
>, <Line: - *          <input type="text" ng-model="contact.value"/>
>, <Line: - *          [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
>, <Line: - *          | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
>, <Line: - *        </li>
>, <Line: - *        <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
>, <Line: - *     </ul>
>, <Line: - *    </div>
>, <Line: - *   </file>
>, <Line: - *   <file name="app.js">
>, <Line: - *    angular.module('controllerAsExample', [])
>, <Line: - *      .controller('SettingsController1', SettingsController1);
>, <Line: - *
>, <Line: - *    function SettingsController1() {
>, <Line: - *
>, <Line: - *    SettingsController1.prototype.greet = function() {
>, <Line: - *
>, <Line: - *    SettingsController1.prototype.addContact = function() {
>, <Line: - *
>, <Line: - *    SettingsController1.prototype.removeContact = function(contactToRemove) {
>, <Line: - *
>, <Line: - *    SettingsController1.prototype.clearContact = function(contact) {
>, <Line: - *   </file>
>, <Line: - *   <file name="protractor.js" type="protractor">
>, <Line: - *     it('should check controller as', function() {
>, <Line: - *   </file>
>, <Line: - * </example>
>, <Line: - *
>, <Line: - * This example demonstrates the "attach to `$scope`" style of controller.
>, <Line: - *
>, <Line: - * <example name="ngController" module="controllerExample">
>, <Line: - *  <file name="index.html">
>, <Line: - *   <div id="ctrl-exmpl" ng-controller="SettingsController2">
>, <Line: - *     Name: <input type="text" ng-model="name"/>
>, <Line: - *     [ <a href="" ng-click="greet()">greet</a> ]<br/>
>, <Line: - *     Contact:
>, <Line: - *     <ul>
>, <Line: - *       <li ng-repeat="contact in contacts">
>, <Line: - *         <select ng-model="contact.type">
>, <Line: - *            <option>phone</option>
>, <Line: - *            <option>email</option>
>, <Line: - *         </select>
>, <Line: - *         <input type="text" ng-model="contact.value"/>
>, <Line: - *         [ <a href="" ng-click="clearContact(contact)">clear</a>
>, <Line: - *         | <a href="" ng-click="removeContact(contact)">X</a> ]
>, <Line: - *       </li>
>, <Line: - *       <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
>, <Line: - *    </ul>
>, <Line: - *   </div>
>, <Line: - *  </file>
>, <Line: - *  <file name="app.js">
>, <Line: - *   angular.module('controllerExample', [])
>, <Line: - *     .controller('SettingsController2', ['$scope', SettingsController2]);
>, <Line: - *
>, <Line: - *   function SettingsController2($scope) {
>, <Line: - *  </file>
>, <Line: - *  <file name="protractor.js" type="protractor">
>, <Line: - *    it('should check controller', function() {
>, <Line: - *  </file>
>, <Line: - *</example>
>, <Line: - */
>, <Line: -var ngControllerDirective = [function() {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    scope: true,
>, <Line: -    controller: '@',
>, <Line: -    priority: 500
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngCsp
>, <Line: - *
>, <Line: - * @element html
>, <Line: - * @description
>, <Line: - * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
>, <Line: - *
>, <Line: - * This is necessary when developing things like Google Chrome Extensions or Universal Windows Apps.
>, <Line: - *
>, <Line: - * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
>, <Line: - * For Angular to be CSP compatible there are only two things that we need to do differently:
>, <Line: - *
>, <Line: - * - don't use `Function` constructor to generate optimized value getters
>, <Line: - * - don't inject custom stylesheet into the document
>, <Line: - *
>, <Line: - * AngularJS uses `Function(string)` generated functions as a speed optimization. Applying the `ngCsp`
>, <Line: - * directive will cause Angular to use CSP compatibility mode. When this mode is on AngularJS will
>, <Line: - * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
>, <Line: - * be raised.
>, <Line: - *
>, <Line: - * CSP forbids JavaScript to inline stylesheet rules. In non CSP mode Angular automatically
>, <Line: - * includes some CSS rules (e.g. {@link ng.directive:ngCloak ngCloak}).
>, <Line: - * To make those directives work in CSP mode, include the `angular-csp.css` manually.
>, <Line: - *
>, <Line: - * Angular tries to autodetect if CSP is active and automatically turn on the CSP-safe mode. This
>, <Line: - * autodetection however triggers a CSP error to be logged in the console:
>, <Line: - *
>, <Line: - * ```
>, <Line: - * Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of
>, <Line: - * script in the following Content Security Policy directive: "default-src 'self'". Note that
>, <Line: - * 'script-src' was not explicitly set, so 'default-src' is used as a fallback.
>, <Line: - * ```
>, <Line: - *
>, <Line: - * This error is harmless but annoying. To prevent the error from showing up, put the `ngCsp`
>, <Line: - * directive on the root element of the application or on the `angular.js` script tag, whichever
>, <Line: - * appears first in the html document.
>, <Line: - *
>, <Line: - * *Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*
>, <Line: - *
>, <Line: - * @example
>, <Line: - * This example shows how to apply the `ngCsp` directive to the `html` tag.
>, <Line: -   ```html
>, <Line: -     <!doctype html>
>, <Line: -     <html ng-app ng-csp>
>, <Line: -     ...
>, <Line: -     ...
>, <Line: -     </html>
>, <Line: -   ```
>, <Line: -  * @example
>, <Line: -      // Note: the suffix `.csp` in the example name triggers
>, <Line: -      // csp mode in our http server!
>, <Line: -      <example name="example.csp" module="cspExample" ng-csp="true">
>, <Line: -        <file name="index.html">
>, <Line: -          <div ng-controller="MainController as ctrl">
>, <Line: -            <div>
>, <Line: -              <button ng-click="ctrl.inc()" id="inc">Increment</button>
>, <Line: -              <span id="counter">
>, <Line: -                {{ctrl.counter}}
>, <Line: -              </span>
>, <Line: -            </div>
>, <Line: -            <div>
>, <Line: -              <button ng-click="ctrl.evil()" id="evil">Evil</button>
>, <Line: -              <span id="evilError">
>, <Line: -                {{ctrl.evilError}}
>, <Line: -              </span>
>, <Line: -            </div>
>, <Line: -          </div>
>, <Line: -        </file>
>, <Line: -        <file name="script.js">
>, <Line: -           angular.module('cspExample', [])
>, <Line: -             .controller('MainController', function() {
>, <Line: -        </file>
>, <Line: -        <file name="protractor.js" type="protractor">
>, <Line: -          var util, webdriver;
>, <Line: -          var incBtn = element(by.id('inc'));
>, <Line: -          var counter = element(by.id('counter'));
>, <Line: -          var evilBtn = element(by.id('evil'));
>, <Line: -          var evilError = element(by.id('evilError'));
>, <Line: -          function getAndClearSevereErrors() {
>, <Line: -          function clearErrors() {
>, <Line: -          function expectNoErrors() {
>, <Line: -          function expectError(regex) {
>, <Line: -          beforeEach(function() {
>, <Line: -          // For now, we only test on Chrome,
>, <Line: -          // as Safari does not load the page with Protractor's injected scripts,
>, <Line: -          // and Firefox webdriver always disables content security policy (#6358)
>, <Line: -          if (browser.params.browser !== 'chrome') {
>, <Line: -          it('should not report errors when the page is loaded', function() {
>, <Line: -          it('should evaluate expressions', function() {
>, <Line: -          it('should throw and report an error when using "eval"', function() {
>, <Line: -            expectError(/Content Security Policy/);
>, <Line: -          });
>, <Line: -        </file>
>, <Line: -      </example>
>, <Line: -  */
>, <Line: -// ngCsp is not implemented as a proper directive any more, because we need it be processed while we
>, <Line: -// bootstrap the system (before $parse is instantiated), for this reason we just have
>, <Line: -// the csp.isActive() fn that looks for ng-csp attribute anywhere in the current doc
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngClick
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The ngClick directive allows you to specify custom behavior when
>, <Line: - * an element is clicked.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
>, <Line: - * click. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-click="count = count + 1" ng-init="count=0">
>, <Line: -        Increment
>, <Line: -      </button>
>, <Line: -      <span>
>, <Line: -        count: {{count}}
>, <Line: -      </span>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-click', function() {
>, <Line: -         expect(element(by.binding('count')).getText()).toMatch('0');
>, <Line: -         element(by.css('button')).click();
>, <Line: -         expect(element(by.binding('count')).getText()).toMatch('1');
>, <Line: -       });
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/*
>, <Line: - * A collection of directives that allows creation of custom event handlers that are defined as
>, <Line: - * angular expressions and are compiled and executed within the current scope.
>, <Line: - */
>, <Line: -var ngEventDirectives = {};
>, <Line: -// For events that might fire synchronously during DOM manipulation
>, <Line: -// we need to execute their event handlers asynchronously using $evalAsync,
>, <Line: -// so that they are not executed in an inconsistent state.
>, <Line: -var forceAsyncEvents = {
>, <Line: -  'blur': true,
>, <Line: -  'focus': true
>, <Line: -};
>, <Line: -forEach(
>, <Line: -  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
>, <Line: -  function(eventName) {
>, <Line: -    var directiveName = directiveNormalize('ng-' + eventName);
>, <Line: -    ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
>, <Line: -      return {
>, <Line: -        restrict: 'A',
>, <Line: -        compile: function($element, attr) {
>, <Line: -          // We expose the powerful $event object on the scope that provides access to the Window,
>, <Line: -          // etc. that isn't protected by the fast paths in $parse.  We explicitly request better
>, <Line: -          // checks at the cost of speed since event handler expressions are not executed as
>, <Line: -          // frequently as regular change detection.
>, <Line: -          var fn = $parse(attr[directiveName], /* interceptorFn */ null, /* expensiveChecks */ true);
>, <Line: -          return function ngEventHandler(scope, element) {
>, <Line: -            element.on(eventName, function(event) {
>, <Line: -              var callback = function() {
>, <Line: -                fn(scope, {$event:event});
>, <Line: -              };
>, <Line: -              if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
>, <Line: -                scope.$evalAsync(callback);
>, <Line: -              } else {
>, <Line: -                scope.$apply(callback);
>, <Line: -              }
>, <Line: -            });
>, <Line: -          };
>, <Line: -        }
>, <Line: -      };
>, <Line: -    }];
>, <Line: -  }
>, <Line: -);
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngDblclick
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
>, <Line: - * a dblclick. (The Event object is available as `$event`)
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-dblclick="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (on double click)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMousedown
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The ngMousedown directive allows you to specify custom behavior on mousedown event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
>, <Line: - * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mousedown="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (on mouse down)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMouseup
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on mouseup event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
>, <Line: - * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mouseup="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (on mouse up)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMouseover
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on mouseover event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
>, <Line: - * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mouseover="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (when mouse is over)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMouseenter
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on mouseenter event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
>, <Line: - * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mouseenter="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (when mouse enters)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMouseleave
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on mouseleave event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
>, <Line: - * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mouseleave="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (when mouse leaves)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngMousemove
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on mousemove event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
>, <Line: - * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <button ng-mousemove="count = count + 1" ng-init="count=0">
>, <Line: -        Increment (when mouse moves)
>, <Line: -      </button>
>, <Line: -      count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngKeydown
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on keydown event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
>, <Line: - * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <input ng-keydown="count = count + 1" ng-init="count=0">
>, <Line: -      key down count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngKeyup
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on keyup event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
>, <Line: - * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -       <p>Typing in the input box below updates the key count</p>
>, <Line: -       <input ng-keyup="count = count + 1" ng-init="count=0"> key up count: {{count}}
>, <Line: -       <p>Typing in the input box below updates the keycode</p>
>, <Line: -       <input ng-keyup="event=$event">
>, <Line: -       <p>event keyCode: {{ event.keyCode }}</p>
>, <Line: -       <p>event altKey: {{ event.altKey }}</p>
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngKeypress
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on keypress event.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
>, <Line: - * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
>, <Line: - * and can be interrogated for keyCode, altKey, etc.)
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <input ng-keypress="count = count + 1" ng-init="count=0">
>, <Line: -      key press count: {{count}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngSubmit
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Enables binding angular expressions to onsubmit events.
>, <Line: - *
>, <Line: - * Additionally it prevents the default action (which for form means sending the request to the
>, <Line: - * server and reloading the current page), but only if the form does not contain `action`,
>, <Line: - * `data-action`, or `x-action` attributes.
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Warning:** Be careful not to cause "double-submission" by using both the `ngClick` and
>, <Line: - * `ngSubmit` handlers together. See the
>, <Line: - * {@link form#submitting-a-form-and-preventing-the-default-action `form` directive documentation}
>, <Line: - * for a detailed discussion of when `ngSubmit` may be triggered.
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * @element form
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
>, <Line: - * ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="submitExample">
>, <Line: -     <file name="index.html">
>, <Line: -      <script>
>, <Line: -        angular.module('submitExample', [])
>, <Line: -          .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -      </script>
>, <Line: -      <form ng-submit="submit()" ng-controller="ExampleController">
>, <Line: -        Enter text and hit enter:
>, <Line: -        <input type="text" ng-model="text" name="text" />
>, <Line: -        <input type="submit" id="submit" value="Submit" />
>, <Line: -        <pre>list={{list}}</pre>
>, <Line: -      </form>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-submit', function() {
>, <Line: -       it('should ignore empty strings', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngFocus
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on focus event.
>, <Line: - *
>, <Line: - * Note: As the `focus` event is executed synchronously when calling `input.focus()`
>, <Line: - * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
>, <Line: - * during an `$apply` to ensure a consistent state.
>, <Line: - *
>, <Line: - * @element window, input, select, textarea, a
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
>, <Line: - * focus. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: - * See {@link ng.directive:ngClick ngClick}
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngBlur
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on blur event.
>, <Line: - *
>, <Line: - * A [blur event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires when
>, <Line: - * an element has lost focus.
>, <Line: - *
>, <Line: - * Note: As the `blur` event is executed synchronously also during DOM manipulations
>, <Line: - * (e.g. removing a focussed input),
>, <Line: - * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
>, <Line: - * during an `$apply` to ensure a consistent state.
>, <Line: - *
>, <Line: - * @element window, input, select, textarea, a
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
>, <Line: - * blur. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: - * See {@link ng.directive:ngClick ngClick}
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngCopy
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on copy event.
>, <Line: - *
>, <Line: - * @element window, input, select, textarea, a
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
>, <Line: - * copy. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
>, <Line: -      copied: {{copied}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngCut
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on cut event.
>, <Line: - *
>, <Line: - * @element window, input, select, textarea, a
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
>, <Line: - * cut. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
>, <Line: -      cut: {{cut}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngPaste
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Specify custom behavior on paste event.
>, <Line: - *
>, <Line: - * @element window, input, select, textarea, a
>, <Line: - * @priority 0
>, <Line: - * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
>, <Line: - * paste. ({@link guide/expression#-event- Event object is available as `$event`})
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -      <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
>, <Line: -      pasted: {{paste}}
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngIf
>, <Line: - * @restrict A
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
>, <Line: - * {expression}. If the expression assigned to `ngIf` evaluates to a false
>, <Line: - * value then the element is removed from the DOM, otherwise a clone of the
>, <Line: - * element is reinserted into the DOM.
>, <Line: - *
>, <Line: - * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
>, <Line: - * element in the DOM rather than changing its visibility via the `display` css property.  A common
>, <Line: - * case when this difference is significant is when using css selectors that rely on an element's
>, <Line: - * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.
>, <Line: - *
>, <Line: - * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope
>, <Line: - * is created when the element is restored.  The scope created within `ngIf` inherits from
>, <Line: - * its parent scope using
>, <Line: - * [prototypal inheritance](https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance).
>, <Line: - * An important implication of this is if `ngModel` is used within `ngIf` to bind to
>, <Line: - * a javascript primitive defined in the parent scope. In this case any modifications made to the
>, <Line: - * variable within the child scope will override (hide) the value in the parent scope.
>, <Line: - *
>, <Line: - * Also, `ngIf` recreates elements using their compiled state. An example of this behavior
>, <Line: - * is if an element's class attribute is directly modified after it's compiled, using something like
>, <Line: - * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
>, <Line: - * the added class will be lost because the original compiled state is used to regenerate the element.
>, <Line: - *
>, <Line: - * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
>, <Line: - * and `leave` effects.
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * enter - happens just after the `ngIf` contents change and a new DOM element is created and injected into the `ngIf` container
>, <Line: - * leave - happens just before the `ngIf` contents are removed from the DOM
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @scope
>, <Line: - * @priority 600
>, <Line: - * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
>, <Line: - *     the element is removed from the DOM tree. If it is truthy a copy of the compiled
>, <Line: - *     element is added to the DOM tree.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -      Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
>, <Line: -      Show when checked:
>, <Line: -      <span ng-if="checked" class="animate-if">
>, <Line: -        This is removed when the checkbox is unchecked.
>, <Line: -      </span>
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .animate-if {
>, <Line: -      .animate-if.ng-enter, .animate-if.ng-leave {
>, <Line: -      .animate-if.ng-enter,
>, <Line: -      .animate-if.ng-leave.ng-leave-active {
>, <Line: -      .animate-if.ng-leave,
>, <Line: -      .animate-if.ng-enter.ng-enter-active {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var ngIfDirective = ['$animate', function($animate) {
>, <Line: -  return {
>, <Line: -    multiElement: true,
>, <Line: -    transclude: 'element',
>, <Line: -    priority: 600,
>, <Line: -    terminal: true,
>, <Line: -    restrict: 'A',
>, <Line: -    $$tlb: true,
>, <Line: -    link: function($scope, $element, $attr, ctrl, $transclude) {
>, <Line: -        var block, childScope, previousElements;
>, <Line: -        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
>, <Line: -          if (value) {
>, <Line: -            if (!childScope) {
>, <Line: -              $transclude(function(clone, newScope) {
>, <Line: -                childScope = newScope;
>, <Line: -                clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
>, <Line: -                // Note: We only need the first/last node of the cloned nodes.
>, <Line: -                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
>, <Line: -                // by a directive with templateUrl when its template arrives.
>, <Line: -                block = {
>, <Line: -                  clone: clone
>, <Line: -                };
>, <Line: -                $animate.enter(clone, $element.parent(), $element);
>, <Line: -              });
>, <Line: -            }
>, <Line: -          } else {
>, <Line: -            if (previousElements) {
>, <Line: -              previousElements.remove();
>, <Line: -              previousElements = null;
>, <Line: -            }
>, <Line: -            if (childScope) {
>, <Line: -              childScope.$destroy();
>, <Line: -              childScope = null;
>, <Line: -            }
>, <Line: -            if (block) {
>, <Line: -              previousElements = getBlockNodes(block.clone);
>, <Line: -              $animate.leave(previousElements).then(function() {
>, <Line: -                previousElements = null;
>, <Line: -              });
>, <Line: -              block = null;
>, <Line: -            }
>, <Line: -          }
>, <Line: -        });
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngInclude
>, <Line: - * @restrict ECA
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Fetches, compiles and includes an external HTML fragment.
>, <Line: - *
>, <Line: - * By default, the template URL is restricted to the same domain and protocol as the
>, <Line: - * application document. This is done by calling {@link $sce#getTrustedResourceUrl
>, <Line: - * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
>, <Line: - * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link
>, <Line: - * ng.$sce Strict Contextual Escaping}.
>, <Line: - *
>, <Line: - * In addition, the browser's
>, <Line: - * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
>, <Line: - * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
>, <Line: - * policy may further restrict whether the template is successfully loaded.
>, <Line: - * For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`
>, <Line: - * access on some browsers.
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * enter - animation is used to bring new content into the browser.
>, <Line: - * leave - animation is used to animate existing content away.
>, <Line: - *
>, <Line: - * The enter and leave animation occur concurrently.
>, <Line: - *
>, <Line: - * @scope
>, <Line: - * @priority 400
>, <Line: - *
>, <Line: - * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
>, <Line: - *                 make sure you wrap it in **single** quotes, e.g. `src="'myPartialTemplate.html'"`.
>, <Line: - * @param {string=} onload Expression to evaluate when a new partial is loaded.
>, <Line: - *
>, <Line: - * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
>, <Line: - *
>, <Line: - *                  - If the attribute is not set, disable scrolling.
>, <Line: - *                  - If the attribute is set without value, enable scrolling.
>, <Line: - *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="includeExample" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -     <div ng-controller="ExampleController">
>, <Line: -       <select ng-model="template" ng-options="t.name for t in templates">
>, <Line: -        <option value="">(blank)</option>
>, <Line: -       </select>
>, <Line: -       url of the template: <tt>{{template.url}}</tt>
>, <Line: -       <hr/>
>, <Line: -       <div class="slide-animate-container">
>, <Line: -         <div class="slide-animate" ng-include="template.url"></div>
>, <Line: -       </div>
>, <Line: -     </div>
>, <Line: -    </file>
>, <Line: -    <file name="script.js">
>, <Line: -      angular.module('includeExample', ['ngAnimate'])
>, <Line: -        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -     </file>
>, <Line: -    <file name="template1.html">
>, <Line: -      Content of template1.html
>, <Line: -    </file>
>, <Line: -    <file name="template2.html">
>, <Line: -      Content of template2.html
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .slide-animate-container {
>, <Line: -      .slide-animate {
>, <Line: -      .slide-animate.ng-enter, .slide-animate.ng-leave {
>, <Line: -      .slide-animate.ng-enter {
>, <Line: -      .slide-animate.ng-enter.ng-enter-active {
>, <Line: -      .slide-animate.ng-leave {
>, <Line: -      .slide-animate.ng-leave.ng-leave-active {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var templateSelect = element(by.model('template'));
>, <Line: -      var includeElem = element(by.css('[ng-include]'));
>, <Line: -      it('should load template1.html', function() {
>, <Line: -      it('should load template2.html', function() {
>, <Line: -      it('should change to blank', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc event
>, <Line: - * @name ngInclude#$includeContentRequested
>, <Line: - * @eventType emit on the scope ngInclude was declared in
>, <Line: - * @description
>, <Line: - * Emitted every time the ngInclude content is requested.
>, <Line: - *
>, <Line: - * @param {Object} angularEvent Synthetic event object.
>, <Line: - * @param {String} src URL of content to load.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc event
>, <Line: - * @name ngInclude#$includeContentLoaded
>, <Line: - * @eventType emit on the current ngInclude scope
>, <Line: - * @description
>, <Line: - * Emitted every time the ngInclude content is reloaded.
>, <Line: - *
>, <Line: - * @param {Object} angularEvent Synthetic event object.
>, <Line: - * @param {String} src URL of content to load.
>, <Line: - */
>, <Line: -/**
>, <Line: - * @ngdoc event
>, <Line: - * @name ngInclude#$includeContentError
>, <Line: - * @eventType emit on the scope ngInclude was declared in
>, <Line: - * @description
>, <Line: - * Emitted when a template HTTP request yields an erronous response (status < 200 || status > 299)
>, <Line: - *
>, <Line: - * @param {Object} angularEvent Synthetic event object.
>, <Line: - * @param {String} src URL of content to load.
>, <Line: - */
>, <Line: -var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', '$sce',
>, <Line: -                  function($templateRequest,   $anchorScroll,   $animate,   $sce) {
>, <Line: -  return {
>, <Line: -    restrict: 'ECA',
>, <Line: -    priority: 400,
>, <Line: -    terminal: true,
>, <Line: -    transclude: 'element',
>, <Line: -    controller: angular.noop,
>, <Line: -    compile: function(element, attr) {
>, <Line: -      var srcExp = attr.ngInclude || attr.src,
>, <Line: -          onloadExp = attr.onload || '',
>, <Line: -          autoScrollExp = attr.autoscroll;
>, <Line: -      return function(scope, $element, $attr, ctrl, $transclude) {
>, <Line: -        var changeCounter = 0,
>, <Line: -            currentScope,
>, <Line: -            previousElement,
>, <Line: -            currentElement;
>, <Line: -        var cleanupLastIncludeContent = function() {
>, <Line: -          if (previousElement) {
>, <Line: -            previousElement.remove();
>, <Line: -            previousElement = null;
>, <Line: -          }
>, <Line: -          if (currentScope) {
>, <Line: -            currentScope.$destroy();
>, <Line: -            currentScope = null;
>, <Line: -          }
>, <Line: -          if (currentElement) {
>, <Line: -            $animate.leave(currentElement).then(function() {
>, <Line: -              previousElement = null;
>, <Line: -            });
>, <Line: -            previousElement = currentElement;
>, <Line: -            currentElement = null;
>, <Line: -          }
>, <Line: -        };
>, <Line: -        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
>, <Line: -          var afterAnimation = function() {
>, <Line: -            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
>, <Line: -              $anchorScroll();
>, <Line: -            }
>, <Line: -          };
>, <Line: -          var thisChangeId = ++changeCounter;
>, <Line: -          if (src) {
>, <Line: -            //set the 2nd param to true to ignore the template request error so that the inner
>, <Line: -            //contents and scope can be cleaned up.
>, <Line: -            $templateRequest(src, true).then(function(response) {
>, <Line: -              if (thisChangeId !== changeCounter) return;
>, <Line: -              var newScope = scope.$new();
>, <Line: -              ctrl.template = response;
>, <Line: -              // Note: This will also link all children of ng-include that were contained in the original
>, <Line: -              // html. If that content contains controllers, ... they could pollute/change the scope.
>, <Line: -              // However, using ng-include on an element with additional content does not make sense...
>, <Line: -              // Note: We can't remove them in the cloneAttchFn of $transclude as that
>, <Line: -              // function is called before linking the content, which would apply child
>, <Line: -              // directives to non existing elements.
>, <Line: -              var clone = $transclude(newScope, function(clone) {
>, <Line: -                cleanupLastIncludeContent();
>, <Line: -                $animate.enter(clone, null, $element).then(afterAnimation);
>, <Line: -              });
>, <Line: -              currentScope = newScope;
>, <Line: -              currentElement = clone;
>, <Line: -              currentScope.$emit('$includeContentLoaded', src);
>, <Line: -              scope.$eval(onloadExp);
>, <Line: -            }, function() {
>, <Line: -              if (thisChangeId === changeCounter) {
>, <Line: -                cleanupLastIncludeContent();
>, <Line: -                scope.$emit('$includeContentError', src);
>, <Line: -              }
>, <Line: -            });
>, <Line: -            scope.$emit('$includeContentRequested', src);
>, <Line: -          } else {
>, <Line: -            cleanupLastIncludeContent();
>, <Line: -            ctrl.template = null;
>, <Line: -          }
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var ngIncludeFillContentDirective = ['$compile',
>, <Line: -  function($compile) {
>, <Line: -    return {
>, <Line: -      restrict: 'ECA',
>, <Line: -      priority: -400,
>, <Line: -      require: 'ngInclude',
>, <Line: -      link: function(scope, $element, $attr, ctrl) {
>, <Line: -        if (/SVG/.test($element[0].toString())) {
>, <Line: -          // WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not
>, <Line: -          // support innerHTML, so detect this here and try to generate the contents
>, <Line: -          // specially.
>, <Line: -          $element.empty();
>, <Line: -          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
>, <Line: -              function namespaceAdaptedClone(clone) {
>, <Line: -            $element.append(clone);
>, <Line: -          }, {futureParentElement: $element});
>, <Line: -          return;
>, <Line: -        }
>, <Line: -        $element.html(ctrl.template);
>, <Line: -        $compile($element.contents())(scope);
>, <Line: -      }
>, <Line: -    };
>, <Line: -  }];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngInit
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngInit` directive allows you to evaluate an expression in the
>, <Line: - * current scope.
>, <Line: - *
>, <Line: - * <div class="alert alert-error">
>, <Line: - * The only appropriate use of `ngInit` is for aliasing special properties of
>, <Line: - * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you
>, <Line: - * should use {@link guide/controller controllers} rather than `ngInit`
>, <Line: - * to initialize values on a scope.
>, <Line: - * </div>
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note**: If you have assignment in `ngInit` along with {@link ng.$filter `$filter`}, make
>, <Line: - * sure you have parenthesis for correct precedence:
>, <Line: - * <pre class="prettyprint">
>, <Line: - *   <div ng-init="test1 = (data | orderBy:'name')"></div>
>, <Line: - * </pre>
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * @priority 450
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngInit {@link guide/expression Expression} to eval.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="initExample">
>, <Line: -     <file name="index.html">
>, <Line: -   <script>
>, <Line: -     angular.module('initExample', [])
>, <Line: -       .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -   </script>
>, <Line: -   <div ng-controller="ExampleController">
>, <Line: -     <div ng-repeat="innerList in list" ng-init="outerIndex = $index">
>, <Line: -       <div ng-repeat="value in innerList" ng-init="innerIndex = $index">
>, <Line: -          <span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};</span>
>, <Line: -       </div>
>, <Line: -     </div>
>, <Line: -   </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       it('should alias index positions', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngInitDirective = ngDirective({
>, <Line: -  priority: 450,
>, <Line: -  compile: function() {
>, <Line: -    return {
>, <Line: -      pre: function(scope, element, attrs) {
>, <Line: -        scope.$eval(attrs.ngInit);
>, <Line: -      }
>, <Line: -    };
>, <Line: -  }
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngNonBindable
>, <Line: - * @restrict AC
>, <Line: - * @priority 1000
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current
>, <Line: - * DOM element. This is useful if the element contains what appears to be Angular directives and
>, <Line: - * bindings but which should be ignored by Angular. This could be the case if you have a site that
>, <Line: - * displays snippets of code, for instance.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - *
>, <Line: - * @example
>, <Line: - * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,
>, <Line: - * but the one wrapped in `ngNonBindable` is left alone.
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example>
>, <Line: -      <file name="index.html">
>, <Line: -        <div>Normal: {{1 + 2}}</div>
>, <Line: -        <div ng-non-bindable>Ignored: {{1 + 2}}</div>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -       it('should check ng-non-bindable', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngPluralize
>, <Line: - * @restrict EA
>, <Line: - *
>, <Line: - * @description
>, <Line: - * `ngPluralize` is a directive that displays messages according to en-US localization rules.
>, <Line: - * These rules are bundled with angular.js, but can be overridden
>, <Line: - * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
>, <Line: - * by specifying the mappings between
>, <Line: - * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
>, <Line: - * and the strings to be displayed.
>, <Line: - *
>, <Line: - * # Plural categories and explicit number rules
>, <Line: - * There are two
>, <Line: - * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
>, <Line: - * in Angular's default en-US locale: "one" and "other".
>, <Line: - *
>, <Line: - * While a plural category may match many numbers (for example, in en-US locale, "other" can match
>, <Line: - * any number that is not 1), an explicit number rule can only match one number. For example, the
>, <Line: - * explicit number rule for "3" matches the number 3. There are examples of plural categories
>, <Line: - * and explicit number rules throughout the rest of this documentation.
>, <Line: - *
>, <Line: - * # Configuring ngPluralize
>, <Line: - * You configure ngPluralize by providing 2 attributes: `count` and `when`.
>, <Line: - * You can also provide an optional attribute, `offset`.
>, <Line: - *
>, <Line: - * The value of the `count` attribute can be either a string or an {@link guide/expression
>, <Line: - *
>, <Line: - * The `when` attribute specifies the mappings between plural categories and the actual
>, <Line: - * string to be displayed. The value of the attribute should be a JSON object.
>, <Line: - *
>, <Line: - * The following example shows how to configure ngPluralize:
>, <Line: - *
>, <Line: - * ```html
>, <Line: - * <ng-pluralize count="personCount"
>, <Line: -                 when="{'0': 'Nobody is viewing.',
>, <Line: - * </ng-pluralize>
>, <Line: - *```
>, <Line: - *
>, <Line: - * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
>, <Line: - * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
>, <Line: - * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
>, <Line: - * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
>, <Line: - * show "a dozen people are viewing".
>, <Line: - *
>, <Line: - * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted
>, <Line: - * into pluralized strings. In the previous example, Angular will replace `{}` with
>, <Line: - * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
>, <Line: - * for <span ng-non-bindable>{{numberExpression}}</span>.
>, <Line: - *
>, <Line: - * # Configuring ngPluralize with offset
>, <Line: - * The `offset` attribute allows further customization of pluralized text, which can result in
>, <Line: - * a better user experience. For example, instead of the message "4 people are viewing this document",
>, <Line: - * you might display "John, Kate and 2 others are viewing this document".
>, <Line: - * The offset attribute allows you to offset a number by any desired value.
>, <Line: - * Let's take a look at an example:
>, <Line: - *
>, <Line: - * ```html
>, <Line: - * <ng-pluralize count="personCount" offset=2
>, <Line: - *               when="{'0': 'Nobody is viewing.',
>, <Line: - * </ng-pluralize>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Notice that we are still using two plural categories(one, other), but we added
>, <Line: - * three explicit number rules 0, 1 and 2.
>, <Line: - * When one person, perhaps John, views the document, "John is viewing" will be shown.
>, <Line: - * When three people view the document, no explicit number rule is found, so
>, <Line: - * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
>, <Line: - * In this case, plural category 'one' is matched and "John, Mary and one other person are viewing"
>, <Line: - * is shown.
>, <Line: - *
>, <Line: - * Note that when you specify offsets, you must provide explicit number rules for
>, <Line: - * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
>, <Line: - * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
>, <Line: - * plural categories "one" and "other".
>, <Line: - *
>, <Line: - * @param {string|expression} count The variable to be bound to.
>, <Line: - * @param {string} when The mapping between plural category to its corresponding strings.
>, <Line: - * @param {number=} offset Offset to deduct from the total number.
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example module="pluralizeExample">
>, <Line: -      <file name="index.html">
>, <Line: -        <script>
>, <Line: -          angular.module('pluralizeExample', [])
>, <Line: -            .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -        </script>
>, <Line: -        <div ng-controller="ExampleController">
>, <Line: -          Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
>, <Line: -          Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
>, <Line: -          Number of People:<input type="text" ng-model="personCount" value="1" /><br/>
>, <Line: -          <!--- Example with simple pluralization rules for en locale --->
>, <Line: -          Without Offset:
>, <Line: -          <ng-pluralize count="personCount"
>, <Line: -                        when="{'0': 'Nobody is viewing.',
>, <Line: -          </ng-pluralize><br>
>, <Line: -          <!--- Example with offset --->
>, <Line: -          With Offset(2):
>, <Line: -          <ng-pluralize count="personCount" offset=2
>, <Line: -                        when="{'0': 'Nobody is viewing.',
>, <Line: -          </ng-pluralize>
>, <Line: -        </div>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -        it('should show correct pluralized string', function() {
>, <Line: -        it('should show data-bound names', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
>, <Line: -  var BRACE = /{}/g,
>, <Line: -      IS_WHEN = /^when(Minus)?(.+)$/;
>, <Line: -  return {
>, <Line: -    restrict: 'EA',
>, <Line: -    link: function(scope, element, attr) {
>, <Line: -      var numberExp = attr.count,
>, <Line: -          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
>, <Line: -          offset = attr.offset || 0,
>, <Line: -          whens = scope.$eval(whenExp) || {},
>, <Line: -          whensExpFns = {},
>, <Line: -          startSymbol = $interpolate.startSymbol(),
>, <Line: -          endSymbol = $interpolate.endSymbol(),
>, <Line: -          braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
>, <Line: -          watchRemover = angular.noop,
>, <Line: -          lastCount;
>, <Line: -      forEach(attr, function(expression, attributeName) {
>, <Line: -        var tmpMatch = IS_WHEN.exec(attributeName);
>, <Line: -        if (tmpMatch) {
>, <Line: -          var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
>, <Line: -          whens[whenKey] = element.attr(attr.$attr[attributeName]);
>, <Line: -        }
>, <Line: -      });
>, <Line: -      forEach(whens, function(expression, key) {
>, <Line: -        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
>, <Line: -      });
>, <Line: -      scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
>, <Line: -        var count = parseFloat(newVal);
>, <Line: -        var countIsNaN = isNaN(count);
>, <Line: -        if (!countIsNaN && !(count in whens)) {
>, <Line: -          // If an explicit number rule such as 1, 2, 3... is defined, just use it.
>, <Line: -          // Otherwise, check it against pluralization rules in $locale service.
>, <Line: -          count = $locale.pluralCat(count - offset);
>, <Line: -        }
>, <Line: -        // If both `count` and `lastCount` are NaN, we don't need to re-register a watch.
>, <Line: -        // In JS `NaN !== NaN`, so we have to exlicitly check.
>, <Line: -        if ((count !== lastCount) && !(countIsNaN && isNaN(lastCount))) {
>, <Line: -          watchRemover();
>, <Line: -          watchRemover = scope.$watch(whensExpFns[count], updateElementText);
>, <Line: -          lastCount = count;
>, <Line: -        }
>, <Line: -      });
>, <Line: -      function updateElementText(newText) {
>, <Line: -        element.text(newText || '');
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngRepeat
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
>, <Line: - * instance gets its own scope, where the given loop variable is set to the current collection item,
>, <Line: - * and `$index` is set to the item index or key.
>, <Line: - *
>, <Line: - * Special properties are exposed on the local scope of each template instance, including:
>, <Line: - *
>, <Line: - * | Variable  | Type            | Details                                                                     |
>, <Line: - * |-----------|-----------------|-----------------------------------------------------------------------------|
>, <Line: - * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
>, <Line: - * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
>, <Line: - * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
>, <Line: - * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
>, <Line: - * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
>, <Line: - * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
>, <Line: - *
>, <Line: - * Creating aliases for these properties is possible with {@link ng.directive:ngInit `ngInit`}.
>, <Line: - * This may be useful when, for instance, nesting ngRepeats.
>, <Line: - *
>, <Line: - * # Special repeat start and end points
>, <Line: - * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
>, <Line: - * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
>, <Line: - * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
>, <Line: - * up to and including the ending HTML tag where **ng-repeat-end** is placed.
>, <Line: - *
>, <Line: - * The example below makes use of this feature:
>, <Line: - * ```html
>, <Line: - *   <header ng-repeat-start="item in items">
>, <Line: - *     Header {{ item }}
>, <Line: - *   </header>
>, <Line: - *   <div class="body">
>, <Line: - *     Body {{ item }}
>, <Line: - *   </div>
>, <Line: - *   <footer ng-repeat-end>
>, <Line: - *     Footer {{ item }}
>, <Line: - *   </footer>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
>, <Line: - * ```html
>, <Line: - *   <header>
>, <Line: - *     Header A
>, <Line: - *   </header>
>, <Line: - *   <div class="body">
>, <Line: - *     Body A
>, <Line: - *   </div>
>, <Line: - *   <footer>
>, <Line: - *     Footer A
>, <Line: - *   </footer>
>, <Line: - *   <header>
>, <Line: - *     Header B
>, <Line: - *   </header>
>, <Line: - *   <div class="body">
>, <Line: - *     Body B
>, <Line: - *   </div>
>, <Line: - *   <footer>
>, <Line: - *     Footer B
>, <Line: - *   </footer>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
>, <Line: - * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * **.enter** - when a new item is added to the list or when an item is revealed after a filter
>, <Line: - *
>, <Line: - * **.leave** - when an item is removed from the list or when an item is filtered out
>, <Line: - *
>, <Line: - * **.move** - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @scope
>, <Line: - * @priority 1000
>, <Line: - * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
>, <Line: - *   formats are currently supported:
>, <Line: - *
>, <Line: - *   * `variable in expression`  where variable is the user defined loop variable and `expression`
>, <Line: - *     is a scope expression giving the collection to enumerate.
>, <Line: - *
>, <Line: - *     For example: `album in artist.albums`.
>, <Line: - *
>, <Line: - *   * `(key, value) in expression`  where `key` and `value` can be any user defined identifiers,
>, <Line: - *     and `expression` is the scope expression giving the collection to enumerate.
>, <Line: - *
>, <Line: - *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
>, <Line: - *
>, <Line: - *   * `variable in expression track by tracking_expression`  You can also provide an optional tracking function
>, <Line: - *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function
>, <Line: - *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
>, <Line: - *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are
>, <Line: - *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,
>, <Line: - *     before specifying a tracking expression.
>, <Line: - *
>, <Line: - *     For example: `item in items` is equivalent to `item in items track by $id(item)`. This implies that the DOM elements
>, <Line: - *     will be associated by item identity in the array.
>, <Line: - *
>, <Line: - *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
>, <Line: - *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
>, <Line: - *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
>, <Line: - *     element in the same way in the DOM.
>, <Line: - *
>, <Line: - *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
>, <Line: - *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
>, <Line: - *     property is same.
>, <Line: - *
>, <Line: - *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
>, <Line: - *     to items in conjunction with a tracking expression.
>, <Line: - *
>, <Line: - *   * `variable in expression as alias_expression`  You can also provide an optional alias expression which will then store the
>, <Line: - *     intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message
>, <Line: - *     when a filter is active on the repeater, but the filtered result set is empty.
>, <Line: - *
>, <Line: - *     For example: `item in items | filter:x as results` will store the fragment of the repeated items as `results`, but only after
>, <Line: - *     the items have been processed through the filter.
>, <Line: - *
>, <Line: - * @example
>, <Line: - * This example initializes the scope to a list of names and
>, <Line: - * then uses `ngRepeat` to display every person:
>, <Line: -  <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-init="friends = [
>, <Line: -        {name:'John', age:25, gender:'boy'},
>, <Line: -        {name:'Jessie', age:30, gender:'girl'},
>, <Line: -        {name:'Johanna', age:28, gender:'girl'},
>, <Line: -        {name:'Joy', age:15, gender:'girl'},
>, <Line: -        {name:'Mary', age:28, gender:'girl'},
>, <Line: -        {name:'Peter', age:95, gender:'boy'},
>, <Line: -        {name:'Sebastian', age:50, gender:'boy'},
>, <Line: -        {name:'Erika', age:27, gender:'girl'},
>, <Line: -        {name:'Patrick', age:40, gender:'boy'},
>, <Line: -        {name:'Samantha', age:60, gender:'girl'}
>, <Line: -      ]">
>, <Line: -        I have {{friends.length}} friends. They are:
>, <Line: -        <input type="search" ng-model="q" placeholder="filter friends..." />
>, <Line: -        <ul class="example-animate-container">
>, <Line: -          <li class="animate-repeat" ng-repeat="friend in friends | filter:q as results">
>, <Line: -            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
>, <Line: -          </li>
>, <Line: -          <li class="animate-repeat" ng-if="results.length == 0">
>, <Line: -            <strong>No results found...</strong>
>, <Line: -          </li>
>, <Line: -        </ul>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .example-animate-container {
>, <Line: -      .animate-repeat {
>, <Line: -      .animate-repeat.ng-move,
>, <Line: -      .animate-repeat.ng-enter,
>, <Line: -      .animate-repeat.ng-leave {
>, <Line: -      .animate-repeat.ng-leave.ng-leave-active,
>, <Line: -      .animate-repeat.ng-move,
>, <Line: -      .animate-repeat.ng-enter {
>, <Line: -      .animate-repeat.ng-leave,
>, <Line: -      .animate-repeat.ng-move.ng-move-active,
>, <Line: -      .animate-repeat.ng-enter.ng-enter-active {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var friends = element.all(by.repeater('friend in friends'));
>, <Line: -      it('should render initial data set', function() {
>, <Line: -       it('should update repeater when filter predicate changes', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
>, <Line: -  var NG_REMOVED = '$$NG_REMOVED';
>, <Line: -  var ngRepeatMinErr = minErr('ngRepeat');
>, <Line: -  var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
>, <Line: -    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
>, <Line: -    scope[valueIdentifier] = value;
>, <Line: -    if (keyIdentifier) scope[keyIdentifier] = key;
>, <Line: -    scope.$index = index;
>, <Line: -    scope.$first = (index === 0);
>, <Line: -    scope.$last = (index === (arrayLength - 1));
>, <Line: -    scope.$middle = !(scope.$first || scope.$last);
>, <Line: -    // jshint bitwise: false
>, <Line: -    scope.$odd = !(scope.$even = (index&1) === 0);
>, <Line: -    // jshint bitwise: true
>, <Line: -  };
>, <Line: -  var getBlockStart = function(block) {
>, <Line: -    return block.clone[0];
>, <Line: -  };
>, <Line: -  var getBlockEnd = function(block) {
>, <Line: -    return block.clone[block.clone.length - 1];
>, <Line: -  };
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    multiElement: true,
>, <Line: -    transclude: 'element',
>, <Line: -    priority: 1000,
>, <Line: -    terminal: true,
>, <Line: -    $$tlb: true,
>, <Line: -    compile: function ngRepeatCompile($element, $attr) {
>, <Line: -      var expression = $attr.ngRepeat;
>, <Line: -      var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
>, <Line: -      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
>, <Line: -      if (!match) {
>, <Line: -        throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
>, <Line: -            expression);
>, <Line: -      }
>, <Line: -      var lhs = match[1];
>, <Line: -      var rhs = match[2];
>, <Line: -      var aliasAs = match[3];
>, <Line: -      var trackByExp = match[4];
>, <Line: -      match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
>, <Line: -      if (!match) {
>, <Line: -        throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
>, <Line: -            lhs);
>, <Line: -      }
>, <Line: -      var valueIdentifier = match[3] || match[1];
>, <Line: -      var keyIdentifier = match[2];
>, <Line: -      if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
>, <Line: -          /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent)$/.test(aliasAs))) {
>, <Line: -        throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
>, <Line: -          aliasAs);
>, <Line: -      }
>, <Line: -      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
>, <Line: -      var hashFnLocals = {$id: hashKey};
>, <Line: -      if (trackByExp) {
>, <Line: -        trackByExpGetter = $parse(trackByExp);
>, <Line: -      } else {
>, <Line: -        trackByIdArrayFn = function(key, value) {
>, <Line: -          return hashKey(value);
>, <Line: -        };
>, <Line: -        trackByIdObjFn = function(key) {
>, <Line: -          return key;
>, <Line: -        };
>, <Line: -      }
>, <Line: -      return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
>, <Line: -        if (trackByExpGetter) {
>, <Line: -          trackByIdExpFn = function(key, value, index) {
>, <Line: -            // assign key, value, and $index to the locals so that they can be used in hash functions
>, <Line: -            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
>, <Line: -            hashFnLocals[valueIdentifier] = value;
>, <Line: -            hashFnLocals.$index = index;
>, <Line: -            return trackByExpGetter($scope, hashFnLocals);
>, <Line: -          };
>, <Line: -        }
>, <Line: -        // Store a list of elements from previous run. This is a hash where key is the item from the
>, <Line: -        // iterator, and the value is objects with following properties.
>, <Line: -        //   - scope: bound scope
>, <Line: -        //   - element: previous element.
>, <Line: -        //   - index: position
>, <Line: -        //
>, <Line: -        // We are using no-proto object so that we don't need to guard against inherited props via
>, <Line: -        // hasOwnProperty.
>, <Line: -        var lastBlockMap = createMap();
>, <Line: -        //watch props
>, <Line: -        $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
>, <Line: -          var index, length,
>, <Line: -              previousNode = $element[0],     // node that cloned nodes should be inserted after
>, <Line: -                                              // initialized to the comment node anchor
>, <Line: -              nextNode,
>, <Line: -              // Same as lastBlockMap but it has the current state. It will become the
>, <Line: -              // lastBlockMap on the next iteration.
>, <Line: -              nextBlockMap = createMap(),
>, <Line: -              collectionLength,
>, <Line: -              key, value, // key/value of iteration
>, <Line: -              trackById,
>, <Line: -              trackByIdFn,
>, <Line: -              collectionKeys,
>, <Line: -              block,       // last object information {scope, element, id}
>, <Line: -              nextBlockOrder,
>, <Line: -              elementsToRemove;
>, <Line: -          if (aliasAs) {
>, <Line: -            $scope[aliasAs] = collection;
>, <Line: -          }
>, <Line: -          if (isArrayLike(collection)) {
>, <Line: -            collectionKeys = collection;
>, <Line: -            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
>, <Line: -          } else {
>, <Line: -            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
>, <Line: -            // if object, extract keys, sort them and use to determine order of iteration over obj props
>, <Line: -            collectionKeys = [];
>, <Line: -            for (var itemKey in collection) {
>, <Line: -              if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
>, <Line: -                collectionKeys.push(itemKey);
>, <Line: -              }
>, <Line: -            }
>, <Line: -            collectionKeys.sort();
>, <Line: -          }
>, <Line: -          collectionLength = collectionKeys.length;
>, <Line: -          nextBlockOrder = new Array(collectionLength);
>, <Line: -          // locate existing items
>, <Line: -          for (index = 0; index < collectionLength; index++) {
>, <Line: -            key = (collection === collectionKeys) ? index : collectionKeys[index];
>, <Line: -            value = collection[key];
>, <Line: -            trackById = trackByIdFn(key, value, index);
>, <Line: -            if (lastBlockMap[trackById]) {
>, <Line: -              // found previously seen block
>, <Line: -              block = lastBlockMap[trackById];
>, <Line: -              delete lastBlockMap[trackById];
>, <Line: -              nextBlockMap[trackById] = block;
>, <Line: -              nextBlockOrder[index] = block;
>, <Line: -            } else if (nextBlockMap[trackById]) {
>, <Line: -              // if collision detected. restore lastBlockMap and throw an error
>, <Line: -              forEach(nextBlockOrder, function(block) {
>, <Line: -                if (block && block.scope) lastBlockMap[block.id] = block;
>, <Line: -              });
>, <Line: -              throw ngRepeatMinErr('dupes',
>, <Line: -                  "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
>, <Line: -                  expression, trackById, value);
>, <Line: -            } else {
>, <Line: -              // new never before seen block
>, <Line: -              nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined};
>, <Line: -              nextBlockMap[trackById] = true;
>, <Line: -            }
>, <Line: -          }
>, <Line: -          // remove leftover items
>, <Line: -          for (var blockKey in lastBlockMap) {
>, <Line: -            block = lastBlockMap[blockKey];
>, <Line: -            elementsToRemove = getBlockNodes(block.clone);
>, <Line: -            $animate.leave(elementsToRemove);
>, <Line: -            if (elementsToRemove[0].parentNode) {
>, <Line: -              // if the element was not removed yet because of pending animation, mark it as deleted
>, <Line: -              // so that we can ignore it later
>, <Line: -              for (index = 0, length = elementsToRemove.length; index < length; index++) {
>, <Line: -                elementsToRemove[index][NG_REMOVED] = true;
>, <Line: -              }
>, <Line: -            }
>, <Line: -            block.scope.$destroy();
>, <Line: -          }
>, <Line: -          // we are not using forEach for perf reasons (trying to avoid #call)
>, <Line: -          for (index = 0; index < collectionLength; index++) {
>, <Line: -            key = (collection === collectionKeys) ? index : collectionKeys[index];
>, <Line: -            value = collection[key];
>, <Line: -            block = nextBlockOrder[index];
>, <Line: -            if (block.scope) {
>, <Line: -              // if we have already seen this object, then we need to reuse the
>, <Line: -              // associated scope/element
>, <Line: -              nextNode = previousNode;
>, <Line: -              // skip nodes that are already pending removal via leave animation
>, <Line: -              do {
>, <Line: -                nextNode = nextNode.nextSibling;
>, <Line: -              } while (nextNode && nextNode[NG_REMOVED]);
>, <Line: -              if (getBlockStart(block) != nextNode) {
>, <Line: -                // existing item which got moved
>, <Line: -                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
>, <Line: -              }
>, <Line: -              previousNode = getBlockEnd(block);
>, <Line: -              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
>, <Line: -            } else {
>, <Line: -              // new item which we don't know about
>, <Line: -              $transclude(function ngRepeatTransclude(clone, scope) {
>, <Line: -                block.scope = scope;
>, <Line: -                // http://jsperf.com/clone-vs-createcomment
>, <Line: -                var endNode = ngRepeatEndComment.cloneNode(false);
>, <Line: -                clone[clone.length++] = endNode;
>, <Line: -                // TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?
>, <Line: -                $animate.enter(clone, null, jqLite(previousNode));
>, <Line: -                previousNode = endNode;
>, <Line: -                // Note: We only need the first/last node of the cloned nodes.
>, <Line: -                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
>, <Line: -                // by a directive with templateUrl when its template arrives.
>, <Line: -                block.clone = clone;
>, <Line: -                nextBlockMap[block.id] = block;
>, <Line: -                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
>, <Line: -              });
>, <Line: -            }
>, <Line: -          }
>, <Line: -          lastBlockMap = nextBlockMap;
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var NG_HIDE_CLASS = 'ng-hide';
>, <Line: -var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngShow
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngShow` directive shows or hides the given HTML element based on the expression
>, <Line: - * provided to the `ngShow` attribute. The element is shown or hidden by removing or adding
>, <Line: - * the `.ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
>, <Line: - * in AngularJS and sets the display style to none (using an !important flag).
>, <Line: - * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: - *
>, <Line: - * ```html
>, <Line: - * <!-- when $scope.myValue is truthy (element is visible) -->
>, <Line: - * <div ng-show="myValue"></div>
>, <Line: - *
>, <Line: - * <!-- when $scope.myValue is falsy (element is hidden) -->
>, <Line: - * <div ng-show="myValue" class="ng-hide"></div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added to the class
>, <Line: - * attribute on the element causing it to become hidden. When truthy, the `.ng-hide` CSS class is removed
>, <Line: - * from the element causing the element not to appear hidden.
>, <Line: - *
>, <Line: - * ## Why is !important used?
>, <Line: - *
>, <Line: - * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
>, <Line: - * can be easily overridden by heavier selectors. For example, something as simple
>, <Line: - * as changing the display style on a HTML list item would make hidden elements appear visible.
>, <Line: - * This also becomes a bigger issue when dealing with CSS frameworks.
>, <Line: - *
>, <Line: - * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
>, <Line: - * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
>, <Line: - * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
>, <Line: - *
>, <Line: - * ### Overriding `.ng-hide`
>, <Line: - *
>, <Line: - * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
>, <Line: - * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
>, <Line: - * class in CSS:
>, <Line: - *
>, <Line: - * ```css
>, <Line: - * .ng-hide {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * By default you don't need to override in CSS anything and the animations will work around the display style.
>, <Line: - *
>, <Line: - * ## A note about animations with `ngShow`
>, <Line: - *
>, <Line: - * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
>, <Line: - * is true and false. This system works like the animation system present with ngClass except that
>, <Line: - * you must also include the !important flag to override the display property
>, <Line: - * so that you can perform an animation when the element is hidden during the time of the animation.
>, <Line: - *
>, <Line: - * ```css
>, <Line: - * //
>, <Line: - * //a working example can be found at the bottom of this page
>, <Line: - * //
>, <Line: - * .my-element.ng-hide-add, .my-element.ng-hide-remove {
>, <Line: - *
>, <Line: - * .my-element.ng-hide-add-active,
>, <Line: - * .my-element.ng-hide-remove-active {
>, <Line: - *
>, <Line: - * .my-element.ng-hide-add { ... }
>, <Line: - * .my-element.ng-hide-add.ng-hide-add-active { ... }
>, <Line: - * .my-element.ng-hide-remove { ... }
>, <Line: - * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
>, <Line: - * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * addClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a truthy value and the just before contents are set to visible
>, <Line: - * removeClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngShow If the {@link guide/expression expression} is truthy
>, <Line: - *     then the element is shown or hidden respectively.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -      Click me: <input type="checkbox" ng-model="checked"><br/>
>, <Line: -      <div>
>, <Line: -        Show:
>, <Line: -        <div class="check-element animate-show" ng-show="checked">
>, <Line: -          <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
>, <Line: -        </div>
>, <Line: -      </div>
>, <Line: -      <div>
>, <Line: -        Hide:
>, <Line: -        <div class="check-element animate-show" ng-hide="checked">
>, <Line: -          <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
>, <Line: -        </div>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="glyphicons.css">
>, <Line: -      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .animate-show {
>, <Line: -      .animate-show.ng-hide-add.ng-hide-add-active,
>, <Line: -      .animate-show.ng-hide-remove.ng-hide-remove-active {
>, <Line: -      .animate-show.ng-hide {
>, <Line: -      .check-element {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
>, <Line: -      var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
>, <Line: -      it('should check ng-show / ng-hide', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var ngShowDirective = ['$animate', function($animate) {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    multiElement: true,
>, <Line: -    link: function(scope, element, attr) {
>, <Line: -      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
>, <Line: -        // we're adding a temporary, animation-specific class for ng-hide since this way
>, <Line: -        // we can control when the element is actually displayed on screen without having
>, <Line: -        // to have a global/greedy CSS selector that breaks when other animations are run.
>, <Line: -        // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
>, <Line: -        $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
>, <Line: -          tempClasses: NG_HIDE_IN_PROGRESS_CLASS
>, <Line: -        });
>, <Line: -      });
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngHide
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngHide` directive shows or hides the given HTML element based on the expression
>, <Line: - * provided to the `ngHide` attribute. The element is shown or hidden by removing or adding
>, <Line: - * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
>, <Line: - * in AngularJS and sets the display style to none (using an !important flag).
>, <Line: - * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
>, <Line: - *
>, <Line: - * ```html
>, <Line: - * <!-- when $scope.myValue is truthy (element is hidden) -->
>, <Line: - * <div ng-hide="myValue" class="ng-hide"></div>
>, <Line: - *
>, <Line: - * <!-- when $scope.myValue is falsy (element is visible) -->
>, <Line: - * <div ng-hide="myValue"></div>
>, <Line: - * ```
>, <Line: - *
>, <Line: - * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class
>, <Line: - * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed
>, <Line: - * from the element causing the element not to appear hidden.
>, <Line: - *
>, <Line: - * ## Why is !important used?
>, <Line: - *
>, <Line: - * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
>, <Line: - * can be easily overridden by heavier selectors. For example, something as simple
>, <Line: - * as changing the display style on a HTML list item would make hidden elements appear visible.
>, <Line: - * This also becomes a bigger issue when dealing with CSS frameworks.
>, <Line: - *
>, <Line: - * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
>, <Line: - * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
>, <Line: - * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
>, <Line: - *
>, <Line: - * ### Overriding `.ng-hide`
>, <Line: - *
>, <Line: - * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
>, <Line: - * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
>, <Line: - * class in CSS:
>, <Line: - *
>, <Line: - * ```css
>, <Line: - * .ng-hide {
>, <Line: - * ```
>, <Line: - *
>, <Line: - * By default you don't need to override in CSS anything and the animations will work around the display style.
>, <Line: - *
>, <Line: - * ## A note about animations with `ngHide`
>, <Line: - *
>, <Line: - * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
>, <Line: - * is true and false. This system works like the animation system present with ngClass, except that the `.ng-hide`
>, <Line: - * CSS class is added and removed for you instead of your own CSS class.
>, <Line: - *
>, <Line: - * ```css
>, <Line: - * //
>, <Line: - * //a working example can be found at the bottom of this page
>, <Line: - * //
>, <Line: - * .my-element.ng-hide-add, .my-element.ng-hide-remove {
>, <Line: - *
>, <Line: - * .my-element.ng-hide-add { ... }
>, <Line: - * .my-element.ng-hide-add.ng-hide-add-active { ... }
>, <Line: - * .my-element.ng-hide-remove { ... }
>, <Line: - * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
>, <Line: - * ```
>, <Line: - *
>, <Line: - * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
>, <Line: - * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
>, <Line: - *
>, <Line: - * @animations
>, <Line: - * removeClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden
>, <Line: - * addClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a non truthy value and just before the contents are set to visible
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
>, <Line: - *     the element is shown or hidden respectively.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="ngAnimate" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -      Click me: <input type="checkbox" ng-model="checked"><br/>
>, <Line: -      <div>
>, <Line: -        Show:
>, <Line: -        <div class="check-element animate-hide" ng-show="checked">
>, <Line: -          <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
>, <Line: -        </div>
>, <Line: -      </div>
>, <Line: -      <div>
>, <Line: -        Hide:
>, <Line: -        <div class="check-element animate-hide" ng-hide="checked">
>, <Line: -          <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
>, <Line: -        </div>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="glyphicons.css">
>, <Line: -      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .animate-hide {
>, <Line: -      .animate-hide.ng-hide {
>, <Line: -      .check-element {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
>, <Line: -      var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
>, <Line: -      it('should check ng-show / ng-hide', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var ngHideDirective = ['$animate', function($animate) {
>, <Line: -  return {
>, <Line: -    restrict: 'A',
>, <Line: -    multiElement: true,
>, <Line: -    link: function(scope, element, attr) {
>, <Line: -      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
>, <Line: -        // The comment inside of the ngShowDirective explains why we add and
>, <Line: -        // remove a temporary class for the show/hide animation
>, <Line: -        $animate[value ? 'addClass' : 'removeClass'](element,NG_HIDE_CLASS, {
>, <Line: -          tempClasses: NG_HIDE_IN_PROGRESS_CLASS
>, <Line: -        });
>, <Line: -      });
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngStyle
>, <Line: - * @restrict AC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - * @param {expression} ngStyle
>, <Line: - *
>, <Line: - * {@link guide/expression Expression} which evals to an
>, <Line: - * object whose keys are CSS style names and values are corresponding values for those CSS
>, <Line: - * keys.
>, <Line: - *
>, <Line: - * Since some CSS style names are not valid keys for an object, they must be quoted.
>, <Line: - * See the 'background-color' style in the example below.
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example>
>, <Line: -     <file name="index.html">
>, <Line: -        <input type="button" value="set color" ng-click="myStyle={color:'red'}">
>, <Line: -        <input type="button" value="set background" ng-click="myStyle={'background-color':'blue'}">
>, <Line: -        <input type="button" value="clear" ng-click="myStyle={}">
>, <Line: -        <br/>
>, <Line: -        <span ng-style="myStyle">Sample Text</span>
>, <Line: -        <pre>myStyle={{myStyle}}</pre>
>, <Line: -     </file>
>, <Line: -     <file name="style.css">
>, <Line: -       span {
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -       var colorSpan = element(by.css('span'));
>, <Line: -       it('should check ng-style', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - */
>, <Line: -var ngStyleDirective = ngDirective(function(scope, element, attr) {
>, <Line: -  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
>, <Line: -    if (oldStyles && (newStyles !== oldStyles)) {
>, <Line: -      forEach(oldStyles, function(val, style) { element.css(style, '');});
>, <Line: -    }
>, <Line: -    if (newStyles) element.css(newStyles);
>, <Line: -  }, true);
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngSwitch
>, <Line: - * @restrict EA
>, <Line: - *
>, <Line: - * @description
>, <Line: - * The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.
>, <Line: - * Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location
>, <Line: - * as specified in the template.
>, <Line: - *
>, <Line: - * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
>, <Line: - * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
>, <Line: - * matches the value obtained from the evaluated expression. In other words, you define a container element
>, <Line: - * (where you place the directive), place an expression on the **`on="..."` attribute**
>, <Line: - * (or the **`ng-switch="..."` attribute**), define any inner elements inside of the directive and place
>, <Line: - * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
>, <Line: - * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
>, <Line: - * attribute is displayed.
>, <Line: - *
>, <Line: - * <div class="alert alert-info">
>, <Line: - * Be aware that the attribute values to match against cannot be expressions. They are interpreted
>, <Line: - * as literal string values to match against.
>, <Line: - * For example, **`ng-switch-when="someVal"`** will match against the string `"someVal"` not against the
>, <Line: - * value of the expression `$scope.someVal`.
>, <Line: - * </div>
>, <Line: - * @animations
>, <Line: - * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container
>, <Line: - * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
>, <Line: - *
>, <Line: - * @usage
>, <Line: - *
>, <Line: - * ```
>, <Line: - * <ANY ng-switch="expression">
>, <Line: - *   <ANY ng-switch-when="matchValue1">...</ANY>
>, <Line: - *   <ANY ng-switch-when="matchValue2">...</ANY>
>, <Line: - *   <ANY ng-switch-default>...</ANY>
>, <Line: - * </ANY>
>, <Line: - * ```
>, <Line: - *
>, <Line: - *
>, <Line: - * @scope
>, <Line: - * @priority 1200
>, <Line: - * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
>, <Line: - * On child elements add:
>, <Line: - *
>, <Line: - * * `ngSwitchWhen`: the case statement to match against. If match then this
>, <Line: - *   case will be displayed. If the same match appears multiple times, all the
>, <Line: - *   elements will be displayed.
>, <Line: - * * `ngSwitchDefault`: the default case when no other case match. If there
>, <Line: - *   are multiple default cases, all of them will be displayed when no other
>, <Line: - *   case match.
>, <Line: - *
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example module="switchExample" deps="angular-animate.js" animations="true">
>, <Line: -    <file name="index.html">
>, <Line: -      <div ng-controller="ExampleController">
>, <Line: -        <select ng-model="selection" ng-options="item for item in items">
>, <Line: -        </select>
>, <Line: -        <tt>selection={{selection}}</tt>
>, <Line: -        <hr/>
>, <Line: -        <div class="animate-switch-container"
>, <Line: -          ng-switch on="selection">
>, <Line: -            <div class="animate-switch" ng-switch-when="settings">Settings Div</div>
>, <Line: -            <div class="animate-switch" ng-switch-when="home">Home Span</div>
>, <Line: -            <div class="animate-switch" ng-switch-default>default</div>
>, <Line: -        </div>
>, <Line: -      </div>
>, <Line: -    </file>
>, <Line: -    <file name="script.js">
>, <Line: -      angular.module('switchExample', ['ngAnimate'])
>, <Line: -        .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -    </file>
>, <Line: -    <file name="animations.css">
>, <Line: -      .animate-switch-container {
>, <Line: -      .animate-switch {
>, <Line: -      .animate-switch.ng-animate {
>, <Line: -      .animate-switch.ng-leave.ng-leave-active,
>, <Line: -      .animate-switch.ng-enter {
>, <Line: -      .animate-switch.ng-leave,
>, <Line: -      .animate-switch.ng-enter.ng-enter-active {
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      var switchElem = element(by.css('[ng-switch]'));
>, <Line: -      var select = element(by.model('selection'));
>, <Line: -      it('should start in settings', function() {
>, <Line: -      it('should change to home', function() {
>, <Line: -      it('should select default', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var ngSwitchDirective = ['$animate', function($animate) {
>, <Line: -  return {
>, <Line: -    restrict: 'EA',
>, <Line: -    require: 'ngSwitch',
>, <Line: -    // asks for $scope to fool the BC controller module
>, <Line: -    controller: ['$scope', function ngSwitchController() {
>, <Line: -     this.cases = {};
>, <Line: -    }],
>, <Line: -    link: function(scope, element, attr, ngSwitchController) {
>, <Line: -      var watchExpr = attr.ngSwitch || attr.on,
>, <Line: -          selectedTranscludes = [],
>, <Line: -          selectedElements = [],
>, <Line: -          previousLeaveAnimations = [],
>, <Line: -          selectedScopes = [];
>, <Line: -      var spliceFactory = function(array, index) {
>, <Line: -          return function() { array.splice(index, 1); };
>, <Line: -      };
>, <Line: -      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
>, <Line: -        var i, ii;
>, <Line: -        for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
>, <Line: -          $animate.cancel(previousLeaveAnimations[i]);
>, <Line: -        }
>, <Line: -        previousLeaveAnimations.length = 0;
>, <Line: -        for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
>, <Line: -          var selected = getBlockNodes(selectedElements[i].clone);
>, <Line: -          selectedScopes[i].$destroy();
>, <Line: -          var promise = previousLeaveAnimations[i] = $animate.leave(selected);
>, <Line: -          promise.then(spliceFactory(previousLeaveAnimations, i));
>, <Line: -        }
>, <Line: -        selectedElements.length = 0;
>, <Line: -        selectedScopes.length = 0;
>, <Line: -        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
>, <Line: -          forEach(selectedTranscludes, function(selectedTransclude) {
>, <Line: -            selectedTransclude.transclude(function(caseElement, selectedScope) {
>, <Line: -              selectedScopes.push(selectedScope);
>, <Line: -              var anchor = selectedTransclude.element;
>, <Line: -              caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
>, <Line: -              var block = { clone: caseElement };
>, <Line: -              selectedElements.push(block);
>, <Line: -              $animate.enter(caseElement, anchor.parent(), anchor);
>, <Line: -            });
>, <Line: -          });
>, <Line: -        }
>, <Line: -      });
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var ngSwitchWhenDirective = ngDirective({
>, <Line: -  transclude: 'element',
>, <Line: -  priority: 1200,
>, <Line: -  require: '^ngSwitch',
>, <Line: -  multiElement: true,
>, <Line: -  link: function(scope, element, attrs, ctrl, $transclude) {
>, <Line: -    ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
>, <Line: -    ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });
>, <Line: -  }
>, <Line: -});
>, <Line: -var ngSwitchDefaultDirective = ngDirective({
>, <Line: -  transclude: 'element',
>, <Line: -  priority: 1200,
>, <Line: -  require: '^ngSwitch',
>, <Line: -  multiElement: true,
>, <Line: -  link: function(scope, element, attr, ctrl, $transclude) {
>, <Line: -    ctrl.cases['?'] = (ctrl.cases['?'] || []);
>, <Line: -    ctrl.cases['?'].push({ transclude: $transclude, element: element });
>, <Line: -   }
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name ngTransclude
>, <Line: - * @restrict EAC
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
>, <Line: - *
>, <Line: - * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
>, <Line: - *
>, <Line: - * @element ANY
>, <Line: - *
>, <Line: - * @example
>, <Line: -   <example module="transcludeExample">
>, <Line: -     <file name="index.html">
>, <Line: -       <script>
>, <Line: -         angular.module('transcludeExample', [])
>, <Line: -          .directive('pane', function(){
>, <Line: -         .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -       </script>
>, <Line: -       <div ng-controller="ExampleController">
>, <Line: -         <input ng-model="title"><br>
>, <Line: -         <textarea ng-model="text"></textarea> <br/>
>, <Line: -         <pane title="{{title}}">{{text}}</pane>
>, <Line: -       </div>
>, <Line: -     </file>
>, <Line: -     <file name="protractor.js" type="protractor">
>, <Line: -        it('should have transcluded', function() {
>, <Line: -     </file>
>, <Line: -   </example>
>, <Line: - *
>, <Line: - */
>, <Line: -var ngTranscludeDirective = ngDirective({
>, <Line: -  restrict: 'EAC',
>, <Line: -  link: function($scope, $element, $attrs, controller, $transclude) {
>, <Line: -    if (!$transclude) {
>, <Line: -      throw minErr('ngTransclude')('orphan',
>, <Line: -       'Illegal use of ngTransclude directive in the template! ' +
>, <Line: -       'No parent directive that requires a transclusion found. ' +
>, <Line: -       'Element: {0}',
>, <Line: -       startingTag($element));
>, <Line: -    }
>, <Line: -    $transclude(function(clone) {
>, <Line: -      $element.empty();
>, <Line: -      $element.append(clone);
>, <Line: -    });
>, <Line: -  }
>, <Line: -});
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name script
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * Load the content of a `<script>` element into {@link ng.$templateCache `$templateCache`}, so that the
>, <Line: - * template can be used by {@link ng.directive:ngInclude `ngInclude`},
>, <Line: - * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive directives}. The type of the
>, <Line: - * `<script>` element must be specified as `text/ng-template`, and a cache name for the template must be
>, <Line: - * assigned through the element's `id`, which can then be used as a directive's `templateUrl`.
>, <Line: - *
>, <Line: - * @param {string} type Must be set to `'text/ng-template'`.
>, <Line: - * @param {string} id Cache name of the template.
>, <Line: - *
>, <Line: - * @example
>, <Line: -  <example>
>, <Line: -    <file name="index.html">
>, <Line: -      <script type="text/ng-template" id="/tpl.html">
>, <Line: -        Content of the template.
>, <Line: -      </script>
>, <Line: -      <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
>, <Line: -      <div id="tpl-content" ng-include src="currentTpl"></div>
>, <Line: -    </file>
>, <Line: -    <file name="protractor.js" type="protractor">
>, <Line: -      it('should load template defined inside script tag', function() {
>, <Line: -    </file>
>, <Line: -  </example>
>, <Line: - */
>, <Line: -var scriptDirective = ['$templateCache', function($templateCache) {
>, <Line: -  return {
>, <Line: -    restrict: 'E',
>, <Line: -    terminal: true,
>, <Line: -    compile: function(element, attr) {
>, <Line: -      if (attr.type == 'text/ng-template') {
>, <Line: -        var templateUrl = attr.id,
>, <Line: -            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
>, <Line: -            text = element[0].text;
>, <Line: -        $templateCache.put(templateUrl, text);
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var ngOptionsMinErr = minErr('ngOptions');
>, <Line: -/**
>, <Line: - * @ngdoc directive
>, <Line: - * @name select
>, <Line: - * @restrict E
>, <Line: - *
>, <Line: - * @description
>, <Line: - * HTML `SELECT` element with angular data-binding.
>, <Line: - *
>, <Line: - * # `ngOptions`
>, <Line: - *
>, <Line: - * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
>, <Line: - * elements for the `<select>` element using the array or object obtained by evaluating the
>, <Line: - * `ngOptions` comprehension_expression.
>, <Line: - *
>, <Line: - * In many cases, `ngRepeat` can be used on `<option>` elements instead of `ngOptions` to achieve a
>, <Line: - * similar result. However, the `ngOptions` provides some benefits such as reducing memory and
>, <Line: - * increasing speed by not creating a new scope for each repeated instance, as well as providing
>, <Line: - * more flexibility in how the `select`'s model is assigned via `select as`. `ngOptions` should be
>, <Line: - * used when the `select` model needs to be bound to a non-string value. This is because an option
>, <Line: - * element can only be bound to string values at present.
>, <Line: - *
>, <Line: - * When an item in the `<select>` menu is selected, the array element or object property
>, <Line: - * represented by the selected option will be bound to the model identified by the `ngModel`
>, <Line: - * directive.
>, <Line: - *
>, <Line: - * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
>, <Line: - * be nested into the `<select>` element. This element will then represent the `null` or "not selected"
>, <Line: - * option. See example below for demonstration.
>, <Line: - *
>, <Line: - * <div class="alert alert-warning">
>, <Line: - * **Note:** `ngModel` compares by reference, not value. This is important when binding to an
>, <Line: - * array of objects. See an example [in this jsfiddle](http://jsfiddle.net/qWzTb/).
>, <Line: - * </div>
>, <Line: - *
>, <Line: - * ## `select as`
>, <Line: - *
>, <Line: - * Using `select as` will bind the result of the `select as` expression to the model, but
>, <Line: - * the value of the `<select>` and `<option>` html elements will be either the index (for array data sources)
>, <Line: - * or property name (for object data sources) of the value within the collection. If a `track by` expression
>, <Line: - * is used, the result of that expression will be set as the value of the `option` and `select` elements.
>, <Line: - *
>, <Line: - * ### `select as` with `trackexpr`
>, <Line: - *
>, <Line: - * Using `select as` together with `trackexpr` is not recommended. Reasoning:
>, <Line: - *
>, <Line: - * - Example: &lt;select ng-options="item.subItem as item.label for item in values track by item.id" ng-model="selected"&gt;
>, <Line: - *   values: [{id: 1, label: 'aLabel', subItem: {name: 'aSubItem'}}, {id: 2, label: 'bLabel', subItem: {name: 'bSubItem'}}],
>, <Line: - *   $scope.selected = {name: 'aSubItem'};
>, <Line: - * - track by is always applied to `value`, with the purpose of preserving the selection,
>, <Line: - *   (to `item` in this case)
>, <Line: - * - to calculate whether an item is selected we do the following:
>, <Line: - *   1. apply `track by` to the values in the array, e.g.
>, <Line: - *      In the example: [1,2]
>, <Line: - *   2. apply `track by` to the already selected value in `ngModel`:
>, <Line: - *      In the example: this is not possible, as `track by` refers to `item.id`, but the selected
>, <Line: - *      value from `ngModel` is `{name: aSubItem}`.
>, <Line: - *
>, <Line: - * @param {string} ngModel Assignable angular expression to data-bind to.
>, <Line: - * @param {string=} name Property name of the form under which the control is published.
>, <Line: - * @param {string=} required The control is considered valid only if value is entered.
>, <Line: - * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
>, <Line: - *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
>, <Line: - *    `required` when you want to data-bind to the `required` attribute.
>, <Line: - * @param {comprehension_expression=} ngOptions in one of the following forms:
>, <Line: - *
>, <Line: - *   * for array data sources:
>, <Line: - *     * `label` **`for`** `value` **`in`** `array`
>, <Line: - *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
>, <Line: - *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
>, <Line: - *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
>, <Line: - *   * for object data sources:
>, <Line: - *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
>, <Line: - *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
>, <Line: - *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
>, <Line: - *     * `select` **`as`** `label` **`group by`** `group`
>, <Line: - *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
>, <Line: - *
>, <Line: - * Where:
>, <Line: - *
>, <Line: - *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
>, <Line: - *   * `value`: local variable which will refer to each item in the `array` or each property value
>, <Line: - *      of `object` during iteration.
>, <Line: - *   * `key`: local variable which will refer to a property name in `object` during iteration.
>, <Line: - *   * `label`: The result of this expression will be the label for `<option>` element. The
>, <Line: - *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
>, <Line: - *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
>, <Line: - *      element. If not specified, `select` expression will default to `value`.
>, <Line: - *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
>, <Line: - *      DOM element.
>, <Line: - *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
>, <Line: - *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
>, <Line: - *     `value` variable (e.g. `value.propertyName`). With this the selection is preserved
>, <Line: - *      even when the options are recreated (e.g. reloaded from the server).
>, <Line: - *
>, <Line: - * @example
>, <Line: -    <example module="selectExample">
>, <Line: -      <file name="index.html">
>, <Line: -        <script>
>, <Line: -        angular.module('selectExample', [])
>, <Line: -          .controller('ExampleController', ['$scope', function($scope) {
>, <Line: -        </script>
>, <Line: -        <div ng-controller="ExampleController">
>, <Line: -          <ul>
>, <Line: -            <li ng-repeat="color in colors">
>, <Line: -              Name: <input ng-model="color.name">
>, <Line: -              [<a href ng-click="colors.splice($index, 1)">X</a>]
>, <Line: -            </li>
>, <Line: -            <li>
>, <Line: -              [<a href ng-click="colors.push({})">add</a>]
>, <Line: -            </li>
>, <Line: -          </ul>
>, <Line: -          <hr/>
>, <Line: -          Color (null not allowed):
>, <Line: -          <select ng-model="myColor" ng-options="color.name for color in colors"></select><br>
>, <Line: -          Color (null allowed):
>, <Line: -          <span  class="nullable">
>, <Line: -            <select ng-model="myColor" ng-options="color.name for color in colors">
>, <Line: -              <option value="">-- choose color --</option>
>, <Line: -            </select>
>, <Line: -          </span><br/>
>, <Line: -          Color grouped by shade:
>, <Line: -          <select ng-model="myColor" ng-options="color.name group by color.shade for color in colors">
>, <Line: -          </select><br/>
>, <Line: -          Select <a href ng-click="myColor = { name:'not in list', shade: 'other' }">bogus</a>.<br>
>, <Line: -          <hr/>
>, <Line: -          Currently selected: {{ {selected_color:myColor} }}
>, <Line: -          <div style="border:solid 1px black; height:20px"
>, <Line: -               ng-style="{'background-color':myColor.name}">
>, <Line: -          </div>
>, <Line: -        </div>
>, <Line: -      </file>
>, <Line: -      <file name="protractor.js" type="protractor">
>, <Line: -         it('should check ng-options', function() {
>, <Line: -      </file>
>, <Line: -    </example>
>, <Line: - */
>, <Line: -var ngOptionsDirective = valueFn({
>, <Line: -  restrict: 'A',
>, <Line: -  terminal: true
>, <Line: -});
>, <Line: -var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
>, <Line: -                         //000011111111110000000000022222222220000000000000000000003333333333000000000000004444444444444440000000005555555555555550000000666666666666666000000000000000777777777700000000000000000008888888888
>, <Line: -  var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
>, <Line: -      nullModelCtrl = {$setViewValue: noop};
>, <Line: -  return {
>, <Line: -    restrict: 'E',
>, <Line: -    require: ['select', '?ngModel'],
>, <Line: -    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
>, <Line: -      var self = this,
>, <Line: -          optionsMap = {},
>, <Line: -          ngModelCtrl = nullModelCtrl,
>, <Line: -          nullOption,
>, <Line: -          unknownOption;
>, <Line: -      self.databound = $attrs.ngModel;
>, <Line: -      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
>, <Line: -        ngModelCtrl = ngModelCtrl_;
>, <Line: -        nullOption = nullOption_;
>, <Line: -        unknownOption = unknownOption_;
>, <Line: -      };
>, <Line: -      self.addOption = function(value, element) {
>, <Line: -        assertNotHasOwnProperty(value, '"option value"');
>, <Line: -        optionsMap[value] = true;
>, <Line: -        if (ngModelCtrl.$viewValue == value) {
>, <Line: -          $element.val(value);
>, <Line: -          if (unknownOption.parent()) unknownOption.remove();
>, <Line: -        }
>, <Line: -        // Workaround for https://code.google.com/p/chromium/issues/detail?id=381459
>, <Line: -        // Adding an <option selected="selected"> element to a <select required="required"> should
>, <Line: -        // automatically select the new element
>, <Line: -        if (element && element[0].hasAttribute('selected')) {
>, <Line: -          element[0].selected = true;
>, <Line: -        }
>, <Line: -      };
>, <Line: -      self.removeOption = function(value) {
>, <Line: -        if (this.hasOption(value)) {
>, <Line: -          delete optionsMap[value];
>, <Line: -          if (ngModelCtrl.$viewValue == value) {
>, <Line: -            this.renderUnknownOption(value);
>, <Line: -          }
>, <Line: -        }
>, <Line: -      };
>, <Line: -      self.renderUnknownOption = function(val) {
>, <Line: -        var unknownVal = '? ' + hashKey(val) + ' ?';
>, <Line: -        unknownOption.val(unknownVal);
>, <Line: -        $element.prepend(unknownOption);
>, <Line: -        $element.val(unknownVal);
>, <Line: -        unknownOption.prop('selected', true); // needed for IE
>, <Line: -      };
>, <Line: -      self.hasOption = function(value) {
>, <Line: -        return optionsMap.hasOwnProperty(value);
>, <Line: -      };
>, <Line: -      $scope.$on('$destroy', function() {
>, <Line: -        // disable unknown option so that we don't do work when the whole select is being destroyed
>, <Line: -        self.renderUnknownOption = noop;
>, <Line: -      });
>, <Line: -    }],
>, <Line: -    link: function(scope, element, attr, ctrls) {
>, <Line: -      // if ngModel is not defined, we don't need to do anything
>, <Line: -      if (!ctrls[1]) return;
>, <Line: -      var selectCtrl = ctrls[0],
>, <Line: -          ngModelCtrl = ctrls[1],
>, <Line: -          multiple = attr.multiple,
>, <Line: -          optionsExp = attr.ngOptions,
>, <Line: -          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
>, <Line: -          emptyOption,
>, <Line: -          renderScheduled = false,
>, <Line: -          // we can't just jqLite('<option>') since jqLite is not smart enough
>, <Line: -          // to create it in <select> and IE barfs otherwise.
>, <Line: -          optionTemplate = jqLite(document.createElement('option')),
>, <Line: -          optGroupTemplate =jqLite(document.createElement('optgroup')),
>, <Line: -          unknownOption = optionTemplate.clone();
>, <Line: -      // find "null" option
>, <Line: -      for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
>, <Line: -        if (children[i].value === '') {
>, <Line: -          emptyOption = nullOption = children.eq(i);
>, <Line: -          break;
>, <Line: -        }
>, <Line: -      }
>, <Line: -      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
>, <Line: -      // required validator
>, <Line: -      if (multiple) {
>, <Line: -        ngModelCtrl.$isEmpty = function(value) {
>, <Line: -          return !value || value.length === 0;
>, <Line: -        };
>, <Line: -      }
>, <Line: -      if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
>, <Line: -      else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);
>, <Line: -      else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
>, <Line: -      ////////////////////////////
>, <Line: -      function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
>, <Line: -        ngModelCtrl.$render = function() {
>, <Line: -          var viewValue = ngModelCtrl.$viewValue;
>, <Line: -          if (selectCtrl.hasOption(viewValue)) {
>, <Line: -            if (unknownOption.parent()) unknownOption.remove();
>, <Line: -            selectElement.val(viewValue);
>, <Line: -            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
>, <Line: -          } else {
>, <Line: -            if (isUndefined(viewValue) && emptyOption) {
>, <Line: -              selectElement.val('');
>, <Line: -            } else {
>, <Line: -              selectCtrl.renderUnknownOption(viewValue);
>, <Line: -            }
>, <Line: -          }
>, <Line: -        };
>, <Line: -        selectElement.on('change', function() {
>, <Line: -          scope.$apply(function() {
>, <Line: -            if (unknownOption.parent()) unknownOption.remove();
>, <Line: -            ngModelCtrl.$setViewValue(selectElement.val());
>, <Line: -          });
>, <Line: -        });
>, <Line: -      }
>, <Line: -      function setupAsMultiple(scope, selectElement, ctrl) {
>, <Line: -        var lastView;
>, <Line: -        ctrl.$render = function() {
>, <Line: -          var items = new HashMap(ctrl.$viewValue);
>, <Line: -          forEach(selectElement.find('option'), function(option) {
>, <Line: -            option.selected = isDefined(items.get(option.value));
>, <Line: -          });
>, <Line: -        };
>, <Line: -        // we have to do it on each watch since ngModel watches reference, but
>, <Line: -        // we need to work of an array, so we need to see if anything was inserted/removed
>, <Line: -        scope.$watch(function selectMultipleWatch() {
>, <Line: -          if (!equals(lastView, ctrl.$viewValue)) {
>, <Line: -            lastView = shallowCopy(ctrl.$viewValue);
>, <Line: -            ctrl.$render();
>, <Line: -          }
>, <Line: -        });
>, <Line: -        selectElement.on('change', function() {
>, <Line: -          scope.$apply(function() {
>, <Line: -            var array = [];
>, <Line: -            forEach(selectElement.find('option'), function(option) {
>, <Line: -              if (option.selected) {
>, <Line: -                array.push(option.value);
>, <Line: -              }
>, <Line: -            });
>, <Line: -            ctrl.$setViewValue(array);
>, <Line: -          });
>, <Line: -        });
>, <Line: -      }
>, <Line: -      function setupAsOptions(scope, selectElement, ctrl) {
>, <Line: -        var match;
>, <Line: -        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
>, <Line: -          throw ngOptionsMinErr('iexp',
>, <Line: -            "Expected expression in form of " +
>, <Line: -            "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
>, <Line: -            " but got '{0}'. Element: {1}",
>, <Line: -            optionsExp, startingTag(selectElement));
>, <Line: -        }
>, <Line: -        var displayFn = $parse(match[2] || match[1]),
>, <Line: -            valueName = match[4] || match[6],
>, <Line: -            selectAs = / as /.test(match[0]) && match[1],
>, <Line: -            selectAsFn = selectAs ? $parse(selectAs) : null,
>, <Line: -            keyName = match[5],
>, <Line: -            groupByFn = $parse(match[3] || ''),
>, <Line: -            valueFn = $parse(match[2] ? match[1] : valueName),
>, <Line: -            valuesFn = $parse(match[7]),
>, <Line: -            track = match[8],
>, <Line: -            trackFn = track ? $parse(match[8]) : null,
>, <Line: -            trackKeysCache = {},
>, <Line: -            // This is an array of array of existing option groups in DOM.
>, <Line: -            // We try to reuse these if possible
>, <Line: -            // - optionGroupsCache[0] is the options with no option group
>, <Line: -            // - optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
>, <Line: -            optionGroupsCache = [[{element: selectElement, label:''}]],
>, <Line: -            //re-usable object to represent option's locals
>, <Line: -            locals = {};
>, <Line: -        if (nullOption) {
>, <Line: -          // compile the element since there might be bindings in it
>, <Line: -          $compile(nullOption)(scope);
>, <Line: -          // remove the class, which is added automatically because we recompile the element and it
>, <Line: -          // becomes the compilation root
>, <Line: -          nullOption.removeClass('ng-scope');
>, <Line: -          // we need to remove it before calling selectElement.empty() because otherwise IE will
>, <Line: -          // remove the label from the element. wtf?
>, <Line: -          nullOption.remove();
>, <Line: -        }
>, <Line: -        // clear contents, we'll add what's needed based on the model
>, <Line: -        selectElement.empty();
>, <Line: -        selectElement.on('change', selectionChanged);
>, <Line: -        ctrl.$render = render;
>, <Line: -        scope.$watchCollection(valuesFn, scheduleRendering);
>, <Line: -        scope.$watchCollection(getLabels, scheduleRendering);
>, <Line: -        if (multiple) {
>, <Line: -          scope.$watchCollection(function() { return ctrl.$modelValue; }, scheduleRendering);
>, <Line: -        }
>, <Line: -        // ------------------------------------------------------------------ //
>, <Line: -        function callExpression(exprFn, key, value) {
>, <Line: -          locals[valueName] = value;
>, <Line: -          if (keyName) locals[keyName] = key;
>, <Line: -          return exprFn(scope, locals);
>, <Line: -        }
>, <Line: -        function selectionChanged() {
>, <Line: -          scope.$apply(function() {
>, <Line: -            var collection = valuesFn(scope) || [];
>, <Line: -            var viewValue;
>, <Line: -            if (multiple) {
>, <Line: -              viewValue = [];
>, <Line: -              forEach(selectElement.val(), function(selectedKey) {
>, <Line: -                  selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey;
>, <Line: -                viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
>, <Line: -              });
>, <Line: -            } else {
>, <Line: -              var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
>, <Line: -              viewValue = getViewValue(selectedKey, collection[selectedKey]);
>, <Line: -            }
>, <Line: -            ctrl.$setViewValue(viewValue);
>, <Line: -            render();
>, <Line: -          });
>, <Line: -        }
>, <Line: -        function getViewValue(key, value) {
>, <Line: -          if (key === '?') {
>, <Line: -            return undefined;
>, <Line: -          } else if (key === '') {
>, <Line: -            return null;
>, <Line: -          } else {
>, <Line: -            var viewValueFn = selectAsFn ? selectAsFn : valueFn;
>, <Line: -            return callExpression(viewValueFn, key, value);
>, <Line: -          }
>, <Line: -        }
>, <Line: -        function getLabels() {
>, <Line: -          var values = valuesFn(scope);
>, <Line: -          var toDisplay;
>, <Line: -          if (values && isArray(values)) {
>, <Line: -            toDisplay = new Array(values.length);
>, <Line: -            for (var i = 0, ii = values.length; i < ii; i++) {
>, <Line: -              toDisplay[i] = callExpression(displayFn, i, values[i]);
>, <Line: -            }
>, <Line: -            return toDisplay;
>, <Line: -          } else if (values) {
>, <Line: -            // TODO: Add a test for this case
>, <Line: -            toDisplay = {};
>, <Line: -            for (var prop in values) {
>, <Line: -              if (values.hasOwnProperty(prop)) {
>, <Line: -                toDisplay[prop] = callExpression(displayFn, prop, values[prop]);
>, <Line: -              }
>, <Line: -            }
>, <Line: -          }
>, <Line: -          return toDisplay;
>, <Line: -        }
>, <Line: -        function createIsSelectedFn(viewValue) {
>, <Line: -          var selectedSet;
>, <Line: -          if (multiple) {
>, <Line: -            if (trackFn && isArray(viewValue)) {
>, <Line: -              selectedSet = new HashMap([]);
>, <Line: -              for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) {
>, <Line: -                // tracking by key
>, <Line: -                selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), true);
>, <Line: -              }
>, <Line: -            } else {
>, <Line: -              selectedSet = new HashMap(viewValue);
>, <Line: -            }
>, <Line: -          } else if (trackFn) {
>, <Line: -            viewValue = callExpression(trackFn, null, viewValue);
>, <Line: -          }
>, <Line: -          return function isSelected(key, value) {
>, <Line: -            var compareValueFn;
>, <Line: -            if (trackFn) {
>, <Line: -              compareValueFn = trackFn;
>, <Line: -            } else if (selectAsFn) {
>, <Line: -              compareValueFn = selectAsFn;
>, <Line: -            } else {
>, <Line: -              compareValueFn = valueFn;
>, <Line: -            }
>, <Line: -            if (multiple) {
>, <Line: -              return isDefined(selectedSet.remove(callExpression(compareValueFn, key, value)));
>, <Line: -            } else {
>, <Line: -              return viewValue === callExpression(compareValueFn, key, value);
>, <Line: -            }
>, <Line: -          };
>, <Line: -        }
>, <Line: -        function scheduleRendering() {
>, <Line: -          if (!renderScheduled) {
>, <Line: -            scope.$$postDigest(render);
>, <Line: -            renderScheduled = true;
>, <Line: -          }
>, <Line: -        }
>, <Line: -        /**
>, <Line: -         * A new labelMap is created with each render.
>, <Line: -         * This function is called for each existing option with added=false,
>, <Line: -         * and each new option with added=true.
>, <Line: -         * - Labels that are passed to this method twice,
>, <Line: -         * (once with added=true and once with added=false) will end up with a value of 0, and
>, <Line: -         * will cause no change to happen to the corresponding option.
>, <Line: -         * - Labels that are passed to this method only once with added=false will end up with a
>, <Line: -         * value of -1 and will eventually be passed to selectCtrl.removeOption()
>, <Line: -         * - Labels that are passed to this method only once with added=true will end up with a
>, <Line: -         * value of 1 and will eventually be passed to selectCtrl.addOption()
>, <Line: -        */
>, <Line: -        function updateLabelMap(labelMap, label, added) {
>, <Line: -          labelMap[label] = labelMap[label] || 0;
>, <Line: -          labelMap[label] += (added ? 1 : -1);
>, <Line: -        }
>, <Line: -        function render() {
>, <Line: -          renderScheduled = false;
>, <Line: -          // Temporary location for the option groups before we render them
>, <Line: -          var optionGroups = {'':[]},
>, <Line: -              optionGroupNames = [''],
>, <Line: -              optionGroupName,
>, <Line: -              optionGroup,
>, <Line: -              option,
>, <Line: -              existingParent, existingOptions, existingOption,
>, <Line: -              viewValue = ctrl.$viewValue,
>, <Line: -              values = valuesFn(scope) || [],
>, <Line: -              keys = keyName ? sortedKeys(values) : values,
>, <Line: -              key,
>, <Line: -              value,
>, <Line: -              groupLength, length,
>, <Line: -              groupIndex, index,
>, <Line: -              labelMap = {},
>, <Line: -              selected,
>, <Line: -              isSelected = createIsSelectedFn(viewValue),
>, <Line: -              anySelected = false,
>, <Line: -              lastElement,
>, <Line: -              element,
>, <Line: -              label,
>, <Line: -              optionId;
>, <Line: -          trackKeysCache = {};
>, <Line: -          // We now build up the list of options we need (we merge later)
>, <Line: -          for (index = 0; length = keys.length, index < length; index++) {
>, <Line: -            key = index;
>, <Line: -            if (keyName) {
>, <Line: -              key = keys[index];
>, <Line: -              if (key.charAt(0) === '$') continue;
>, <Line: -            }
>, <Line: -            value = values[key];
>, <Line: -            optionGroupName = callExpression(groupByFn, key, value) || '';
>, <Line: -            if (!(optionGroup = optionGroups[optionGroupName])) {
>, <Line: -              optionGroup = optionGroups[optionGroupName] = [];
>, <Line: -              optionGroupNames.push(optionGroupName);
>, <Line: -            }
>, <Line: -            selected = isSelected(key, value);
>, <Line: -            anySelected = anySelected || selected;
>, <Line: -            label = callExpression(displayFn, key, value); // what will be seen by the user
>, <Line: -            // doing displayFn(scope, locals) || '' overwrites zero values
>, <Line: -            label = isDefined(label) ? label : '';
>, <Line: -            optionId = trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index);
>, <Line: -            if (trackFn) {
>, <Line: -              trackKeysCache[optionId] = key;
>, <Line: -            }
>, <Line: -            optionGroup.push({
>, <Line: -              // either the index into array or key from object
>, <Line: -              id: optionId,
>, <Line: -              label: label,
>, <Line: -              selected: selected                   // determine if we should be selected
>, <Line: -            });
>, <Line: -          }
>, <Line: -          if (!multiple) {
>, <Line: -            if (nullOption || viewValue === null) {
>, <Line: -              // insert null option if we have a placeholder, or the model is null
>, <Line: -              optionGroups[''].unshift({id:'', label:'', selected:!anySelected});
>, <Line: -            } else if (!anySelected) {
>, <Line: -              // option could not be found, we have to insert the undefined item
>, <Line: -              optionGroups[''].unshift({id:'?', label:'', selected:true});
>, <Line: -            }
>, <Line: -          }
>, <Line: -          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
>, <Line: -          for (groupIndex = 0, groupLength = optionGroupNames.length;
>, <Line: -               groupIndex < groupLength;
>, <Line: -               groupIndex++) {
>, <Line: -            // current option group name or '' if no group
>, <Line: -            optionGroupName = optionGroupNames[groupIndex];
>, <Line: -            // list of options for that group. (first item has the parent)
>, <Line: -            optionGroup = optionGroups[optionGroupName];
>, <Line: -            if (optionGroupsCache.length <= groupIndex) {
>, <Line: -              // we need to grow the optionGroups
>, <Line: -              existingParent = {
>, <Line: -                element: optGroupTemplate.clone().attr('label', optionGroupName),
>, <Line: -                label: optionGroup.label
>, <Line: -              };
>, <Line: -              existingOptions = [existingParent];
>, <Line: -              optionGroupsCache.push(existingOptions);
>, <Line: -              selectElement.append(existingParent.element);
>, <Line: -            } else {
>, <Line: -              existingOptions = optionGroupsCache[groupIndex];
>, <Line: -              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element
>, <Line: -              // update the OPTGROUP label if not the same.
>, <Line: -              if (existingParent.label != optionGroupName) {
>, <Line: -                existingParent.element.attr('label', existingParent.label = optionGroupName);
>, <Line: -              }
>, <Line: -            }
>, <Line: -            lastElement = null;  // start at the beginning
>, <Line: -            for (index = 0, length = optionGroup.length; index < length; index++) {
>, <Line: -              option = optionGroup[index];
>, <Line: -              if ((existingOption = existingOptions[index + 1])) {
>, <Line: -                // reuse elements
>, <Line: -                lastElement = existingOption.element;
>, <Line: -                if (existingOption.label !== option.label) {
>, <Line: -                  updateLabelMap(labelMap, existingOption.label, false);
>, <Line: -                  updateLabelMap(labelMap, option.label, true);
>, <Line: -                  lastElement.text(existingOption.label = option.label);
>, <Line: -                  lastElement.prop('label', existingOption.label);
>, <Line: -                }
>, <Line: -                if (existingOption.id !== option.id) {
>, <Line: -                  lastElement.val(existingOption.id = option.id);
>, <Line: -                }
>, <Line: -                // lastElement.prop('selected') provided by jQuery has side-effects
>, <Line: -                if (lastElement[0].selected !== option.selected) {
>, <Line: -                  lastElement.prop('selected', (existingOption.selected = option.selected));
>, <Line: -                  if (msie) {
>, <Line: -                    // See #7692
>, <Line: -                    // The selected item wouldn't visually update on IE without this.
>, <Line: -                    // Tested on Win7: IE9, IE10 and IE11. Future IEs should be tested as well
>, <Line: -                    lastElement.prop('selected', existingOption.selected);
>, <Line: -                  }
>, <Line: -                }
>, <Line: -              } else {
>, <Line: -                // grow elements
>, <Line: -                // if it's a null option
>, <Line: -                if (option.id === '' && nullOption) {
>, <Line: -                  // put back the pre-compiled element
>, <Line: -                  element = nullOption;
>, <Line: -                } else {
>, <Line: -                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
>, <Line: -                  // in this version of jQuery on some browser the .text() returns a string
>, <Line: -                  // rather then the element.
>, <Line: -                  (element = optionTemplate.clone())
>, <Line: -                      .val(option.id)
>, <Line: -                      .prop('selected', option.selected)
>, <Line: -                      .attr('selected', option.selected)
>, <Line: -                      .prop('label', option.label)
>, <Line: -                      .text(option.label);
>, <Line: -                }
>, <Line: -                existingOptions.push(existingOption = {
>, <Line: -                    element: element,
>, <Line: -                    label: option.label,
>, <Line: -                    id: option.id,
>, <Line: -                    selected: option.selected
>, <Line: -                });
>, <Line: -                updateLabelMap(labelMap, option.label, true);
>, <Line: -                if (lastElement) {
>, <Line: -                  lastElement.after(element);
>, <Line: -                } else {
>, <Line: -                  existingParent.element.append(element);
>, <Line: -                }
>, <Line: -                lastElement = element;
>, <Line: -              }
>, <Line: -            }
>, <Line: -            // remove any excessive OPTIONs in a group
>, <Line: -            index++; // increment since the existingOptions[0] is parent element not OPTION
>, <Line: -            while (existingOptions.length > index) {
>, <Line: -              option = existingOptions.pop();
>, <Line: -              updateLabelMap(labelMap, option.label, false);
>, <Line: -              option.element.remove();
>, <Line: -            }
>, <Line: -            forEach(labelMap, function(count, label) {
>, <Line: -              if (count > 0) {
>, <Line: -                selectCtrl.addOption(label);
>, <Line: -              } else if (count < 0) {
>, <Line: -                selectCtrl.removeOption(label);
>, <Line: -              }
>, <Line: -            });
>, <Line: -          }
>, <Line: -          // remove any excessive OPTGROUPs from select
>, <Line: -          while (optionGroupsCache.length > groupIndex) {
>, <Line: -            optionGroupsCache.pop()[0].element.remove();
>, <Line: -          }
>, <Line: -        }
>, <Line: -      }
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var optionDirective = ['$interpolate', function($interpolate) {
>, <Line: -  var nullSelectCtrl = {
>, <Line: -    addOption: noop,
>, <Line: -    removeOption: noop
>, <Line: -  };
>, <Line: -  return {
>, <Line: -    restrict: 'E',
>, <Line: -    priority: 100,
>, <Line: -    compile: function(element, attr) {
>, <Line: -      if (isUndefined(attr.value)) {
>, <Line: -        var interpolateFn = $interpolate(element.text(), true);
>, <Line: -        if (!interpolateFn) {
>, <Line: -          attr.$set('value', element.text());
>, <Line: -        }
>, <Line: -      }
>, <Line: -      return function(scope, element, attr) {
>, <Line: -        var selectCtrlName = '$selectController',
>, <Line: -            parent = element.parent(),
>, <Line: -            selectCtrl = parent.data(selectCtrlName) ||
>, <Line: -              parent.parent().data(selectCtrlName); // in case we are in optgroup
>, <Line: -        if (!selectCtrl || !selectCtrl.databound) {
>, <Line: -          selectCtrl = nullSelectCtrl;
>, <Line: -        }
>, <Line: -        if (interpolateFn) {
>, <Line: -          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
>, <Line: -            attr.$set('value', newVal);
>, <Line: -            if (oldVal !== newVal) {
>, <Line: -              selectCtrl.removeOption(oldVal);
>, <Line: -            }
>, <Line: -            selectCtrl.addOption(newVal, element);
>, <Line: -          });
>, <Line: -        } else {
>, <Line: -          selectCtrl.addOption(attr.value, element);
>, <Line: -        }
>, <Line: -        element.on('$destroy', function() {
>, <Line: -          selectCtrl.removeOption(attr.value);
>, <Line: -        });
>, <Line: -      };
>, <Line: -    }
>, <Line: -  };
>, <Line: -}];
>, <Line: -var styleDirective = valueFn({
>, <Line: -  restrict: 'E',
>, <Line: -  terminal: false
>, <Line: -});
>, <Line: -  if (window.angular.bootstrap) {
>, <Line: -    //AngularJS is already loaded, so we can return here...
>, <Line: -    console.log('WARNING: Tried to load angular more than once.');
>, <Line: -    return;
>, <Line: -  }
>, <Line: -  //try to bind to jquery now so that one can write jqLite(document).ready()
>, <Line: -  //but we will rebind on bootstrap again.
>, <Line: -  bindJQuery();
>, <Line: -  publishExternalAPI(angular);
>, <Line: -  jqLite(document).ready(function() {
>, <Line: -    angularInit(document, bootstrap);
>, <Line: -  });
>]